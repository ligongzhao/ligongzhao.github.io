<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>07使用包、Crate和模块 |  听潮亭</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="听潮亭" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-学习笔记/Rust/07使用包、Crate和模块"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  07使用包、Crate和模块
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/07%E4%BD%BF%E7%94%A8%E5%8C%85%E3%80%81Crate%E5%92%8C%E6%A8%A1%E5%9D%97.html" class="article-date">
  <time datetime="2022-05-10T03:12:06.000Z" itemprop="datePublished">2022-05-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Rust/">Rust</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">3.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">14 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>模块系统（the module system）</p>
<ul>
<li>包（packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate；</li>
<li>Crates：一个模块的树形结构，它形成了库或二进制项目；</li>
<li>模块（modules）和 use ：允许你控制作用域和路径的私有性；</li>
<li>路径（path）：一个命名例如结构体、函数或模块等项的方式；</li>
</ul>
<h1 id="包和crate"><a href="#包和crate" class="headerlink" title="包和crate"></a>包和crate</h1><p>包（package）：我们通过 <code>cargo new &lt;my-project&gt;</code> 命令创建出来的 my-project 项目中，my-project 就是我们的包名。</p>
<p>crate 是一个二进制项或者库。</p>
<p><code>crate root</code> 是一个源文件，Rust 编译器以它为起点，并构建你的 crate 的根模块。</p>
<p>包（package）是提供一系列功能的一个或多个 crate。</p>
<ul>
<li>一个包会包含一个 Cargo.toml 文件，阐述如何取构建这些 crate。</li>
</ul>
<p>包中包含的内容由以下几条规则来确立：</p>
<ol>
<li>一个包中至多只能包含一个库 crate（library crate）；</li>
<li>包中可以包含任意多个二进制 crate（binary crate）；</li>
<li>包中至少包含一个 crate（库 crate &#x2F; 二进制 crate）;</li>
</ol>
<p>当我们使用 <code>cargo new my-project</code> 的方式创建新项目<code>my-project</code>的时候，Cargo 会自动创建<code>src/main.rs</code> 的文件</p>
<ul>
<li><p>my-project 就是我们当前项目的包（package）;</p>
</li>
<li><p>Cargo 遵守了一个约定，</p>
<ul>
<li><code>src/main.rs</code> 就是一个与包同名的二进制 crate 的 crate 根；</li>
<li><code>src/lib.rs</code> ，则是一个与包同名的 库 crate，且 <code>src/lib.rs</code> 是 crate 根;</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cargo 命令创建项目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的是默认包含 src/main.rs 的二进制 crate</span></span><br><span class="line">cargo new &lt;my-project&gt;  </span><br><span class="line"><span class="comment">// 创建的是默认包含 src/lib.rs 的库 crate</span></span><br><span class="line">cargo new --lib &lt;my-project&gt;  </span><br></pre></td></tr></table></figure>



<p><strong>crate 根文件</strong>的作用：</p>
<ul>
<li>Cargo 会将 crate 根文件传递给 rustc 来实际构建库或者二进制项目。</li>
</ul>
<p>一个包如何拥有多个二进制 crate ？</p>
<ul>
<li>通过将文件放在 <code>src/bin</code> 目录下；</li>
<li>每个 <code>src/bin</code> 下的文件都会被编译成为一个独立的二进制 crate；</li>
</ul>
<p>一个 crate 的功能是在自身作用域中进行命名的，例如，当我们将 <code>rand</code> 作为一个依赖，编译器不会混淆 <code>Rng</code> 这个名字的指向。我们可以通过<code>rand::Rng</code> 的方式来访问 rand crate 中的 Rng trait，而我们也可以在我们的 crate 中，创建自己的 Rng struct，指向不一样。</p>
<h1 id="定义模块来控制作用域与私有性"><a href="#定义模块来控制作用域与私有性" class="headerlink" title="定义模块来控制作用域与私有性"></a>定义模块来控制作用域与私有性</h1><p><code>模块</code> 的作用：</p>
<ul>
<li>将一个 crate 中的代码分组。提高可读性与重用性。</li>
<li>控制项的私有性，<ul>
<li>即可以被外部代码访问的 public；</li>
<li>作为内部实现的，不能被外部代码使用的 private；<ul>
<li>Rust 默认所有项（函数、方法、结构体、枚举、模块和常量）都是 private 的；</li>
<li>父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项。</li>
<li>可以使用 [<code>pub</code> ](# 使用 pub 关键字暴露路径)关键字创建公共项，使子模块的内部部分暴露给上级模块。</li>
<li>模块（mod）上的 <code>pub</code> 关键字只允许其父模块引用它。样例参考 [<code>pub</code>](# 使用 pub 关键字暴露路径)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>定义模块</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> &lt;模块名&gt; &#123;  <span class="comment">// 花括号内的是模块的主体；</span></span><br><span class="line">    <span class="comment">// 模块主体；</span></span><br><span class="line">    <span class="comment">// 可以定义其他模块；</span></span><br><span class="line">    <span class="comment">// 可以定义例如结构体、枚举、常量、trait、函数等其他项；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>模块树（module tree）</p>
<ul>
<li><p>从 crate 根文件开始向下展示模块嵌套的树结构；</p>
</li>
<li><p>如果一些模块定义在同一模块中，则它们是互为兄弟（siblings）的；</p>
</li>
<li><p>如果模块A包含模块B，则A是B的父（parent）,B是A的子（child）;</p>
</li>
</ul>
<blockquote>
<p>注意：整个模块树都在名为 crate 的隐式模块下，即 crate 根文件下；</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">crate</span>  <span class="comment">// 这里是隐式的，Rust 中使用 crate 表示根，就像路径中的 / 根路径一样。</span></span><br><span class="line"> └── front_of_house  <span class="comment">// 定义在crate 根文件中的顶层 mod</span></span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         └── take_order</span><br></pre></td></tr></table></figure>

<p>这些类似与文件系统</p>
<h1 id="路径用于引用模块树中的项"><a href="#路径用于引用模块树中的项" class="headerlink" title="路径用于引用模块树中的项"></a>路径用于引用模块树中的项</h1><p>Rust 中使用路径的方式在模块中找到一个项的位置</p>
<ul>
<li>就像文件系统使用路径一样。</li>
</ul>
<p>如果想要调用一个函数，我们需要知道它的路径。</p>
<p>路径的两种形式：</p>
<ul>
<li><strong>绝对路径</strong>（absolute path），从 crate 根开始，以 crate 名或者字面值 crate（<code>crate</code>） 开头。</li>
<li><strong>相对路径</strong>（relative path），从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li>
</ul>
<p>路径分割使用 <code>::</code> 双冒号。</p>
<p>如何使用绝对路径和相对路径？</p>
<ul>
<li>取决于如何管理模块；</li>
<li>我们更倾向使用<strong>绝对路径</strong>，因为它更适合移动代码定义和项调用的相对独立；</li>
</ul>
<h2 id="使用-pub-关键字暴露路径"><a href="#使用-pub-关键字暴露路径" class="headerlink" title="使用 pub 关键字暴露路径"></a>使用 pub 关键字暴露路径</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;  <span class="comment">// 因为同级，是兄弟，所以mod这里不需要添加 pub；</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;   <span class="comment">// 没有pub 关键字 下面hosting和add_to_waitlist会报错;</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// Absolute path</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-super-起始的相对路径"><a href="#使用-super-起始的相对路径" class="headerlink" title="使用 super 起始的相对路径"></a>使用 <code>super</code> 起始的相对路径</h2><p>可以使用 <code>super</code> 开头来构建从父模块开始的相对路径。</p>
<ul>
<li>这类似于文件系统中以 <code>..</code> 来头的语法</li>
</ul>
<p>使用场景：</p>
<ul>
<li>也属于相对路径，所以适用于重新组织 crate 的模块树时，一起移动提供者与调用者的场景中。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();   <span class="comment">// 这里的 super 就是fix_incorrect_order 的上一层 .. ,即代指 back_of_house 这一层</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong><code>super</code> 和 <code>self</code> 在模块路径中使用的作用主要有两个：</p>
<ol>
<li>消除访问项的歧义；</li>
<li>防止不需要的路径硬编码；</li>
</ol>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里self 1. 起消除歧义的作用，与下面的function区分开；</span></span><br><span class="line"><span class="comment">// 2. 代替模块名的硬编码，例如my_mod:function();</span></span><br><span class="line">self::<span class="title function_ invoke__">function</span>();</span><br><span class="line"><span class="title function_ invoke__">function</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里self 和 super，有代替模块名硬编码的作用</span></span><br><span class="line">self::cool::<span class="title function_ invoke__">function</span>();</span><br><span class="line">super::<span class="title function_ invoke__">function</span>();</span><br></pre></td></tr></table></figure>





<h2 id="创建共有的结构体和枚举"><a href="#创建共有的结构体和枚举" class="headerlink" title="创建共有的结构体和枚举"></a>创建共有的结构体和枚举</h2><p>额外注意事项：</p>
<p>结构体：</p>
<ol>
<li>结构体定义前添加 <code>pub</code> 关键字，这个结构体会变成公有的，但是结构体中的字段仍然是私有的，需要根据情况<strong>单独为字段添加</strong> <code>pub</code> 关键字。</li>
<li>如果结构体具<strong>有私有字段</strong>，这个结构体需要提供一个<strong>公共的关联函数</strong>来创建实例，否则我们无法在外部调用时创建结构体的实例。<ul>
<li>因为我们不能在外部设置私有字段的值；</li>
<li>结构体通常使用时，不必将它们的字段公有化；</li>
</ul>
</li>
</ol>
<p>枚举：</p>
<ol>
<li>如果枚举设为公有，则它的所有成员都将变成公有的。我们只需要在 <code>enum</code> 关键字前添加 <code>pub</code> 关键字。<ul>
<li>如果枚举成员不是公有的，那么枚举会显得用处不大；</li>
</ul>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="使用-use-关键字将名称引入作用域"><a href="#使用-use-关键字将名称引入作用域" class="headerlink" title="使用 use 关键字将名称引入作用域"></a>使用 use 关键字将名称引入作用域</h1><p>使用 <code>use</code> 关键字，可以一次性将路径引入作用域，方便我们调用该路径中的项。</p>
<ul>
<li>与 Java 和 python 中的 import 类似；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();  <span class="comment">// 这里调用函数时指定父模块，可以清晰地表明函数不是在本地定义的；</span></span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：use 引入时，use + path 的方式，我们通常引入到调用项所在模块即可，使用时 <code>模块名+调用项</code>。</p>
<ol>
<li>这样在调用函数时，通过指定父模块，可以清晰地表明函数<strong>不是在本地定义的</strong>；</li>
<li>同时使完整路径的重复度最小化；</li>
<li>使用 use 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。</li>
<li>如果两个模块具有相同的名字，但是父模块名字不同时，我们通常引入到它们的父模块；（Rust 不允许直接引入具有相同名字模块的完整路径，因为直接使用该模块时，不容易分清是哪个模块的。）</li>
</ol>
</blockquote>
<p>第1，2，3点的样例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 HashMap 结构体引入作用域的习惯用法；</span></span><br><span class="line"><span class="comment">// 指定到该结构体的完整路径即可。</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4点的样例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="comment">// 这样的引入路径，我们就可以比较容易分清两个Result分别是哪个模块中的了。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-as-关键字提供新的名称"><a href="#使用-as-关键字提供新的名称" class="headerlink" title="使用 as 关键字提供新的名称"></a>使用 <code>as</code> 关键字提供新的名称</h2><p>针对使用 <code>use</code> 将两个同名类型引入同一作用域这个问题，还有另一个解决办法：</p>
<ul>
<li>使用 <code>as</code> 关键字，即 在这个类型的路径后面，使用 <code>as</code> 指定一个新的本地名称或者别名。<ul>
<li>这点与 python 很像；</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-pub-use-重导出名称"><a href="#使用-pub-use-重导出名称" class="headerlink" title="使用 pub use 重导出名称"></a>使用 <code>pub use</code> 重导出名称</h2><p>使用 <code>use</code> 将路径（名称）导入到作用域内后，该名称在此作用域内是<strong>私有</strong>的。</p>
<p><code>pub use</code>作用：（这个组合更多用在将 crate 对外发布使用的场景。）</p>
<ul>
<li>将条目引入作用域；<ul>
<li>（在当前作用域与使用 <code>use</code> 效果一样）</li>
</ul>
</li>
<li>该条目可以被外部代码引入到它们的作用域；<ul>
<li>（通常我们自己的模块代码要作为 库 crate 对外发布的情况下，最好使用 <code>pub use</code> 的形式，这样外部调用者就可以根据我们 <code>pub use</code> 的路径引入模块和项了，而不用关心我们真正实现时的路径）</li>
</ul>
</li>
</ul>
<p>样例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以参考 <a href="#">在文档</a> 中的样例效果。</p>
<h2 id="使用外部包"><a href="#使用外部包" class="headerlink" title="使用外部包"></a>使用外部包</h2><p>当我们的项目需要引入外部包时，</p>
<ol>
<li>首先在项目的 Cargo.toml 文件的 <code>dependencies</code>段落中加入依赖的包名；<ul>
<li>要从<code>crates.io</code> 中下载，可以修改源地址加快下载速度；</li>
</ul>
</li>
<li>使用 <code>use</code> 将模块引入项目作用域；</li>
</ol>
<blockquote>
<p>注意：标准库（std）对于我们的包来说也是外部 crate。因为标准库随 Rust 语言一同发布，无需修改 Cargo.toml 来引入 std，不过依然需要使用 use 将标准库中定义的项引入项目包的作用域中。例如 HashMap。</p>
</blockquote>
<h2 id="嵌套路径来消除大量的-use-行"><a href="#嵌套路径来消除大量的-use-行" class="headerlink" title="嵌套路径来消除大量的 use 行"></a>嵌套路径来消除大量的 <code>use</code> 行</h2><p>语法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定路径的相同部分::&#123;[<span class="keyword">self</span>,]子路径各自不同的部分<span class="number">1</span>,不同<span class="number">2</span>...&#125;</span><br></pre></td></tr></table></figure>

<p>样例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line">=&gt;</span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在夫模块路径和子模块路径时，父模块使用 self 关键字</span></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line">=&gt;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以在路径的任何层级使用嵌套路径。</p>
<h2 id="通过-glob-和-运算符将所有的公有定义引入作用域"><a href="#通过-glob-和-运算符将所有的公有定义引入作用域" class="headerlink" title="通过 glob 和 * 运算符将所有的公有定义引入作用域"></a>通过 glob 和 <code>*</code> 运算符将所有的公有定义引入作用域</h2><p>如果希望将一个路径下 <strong>所有</strong> 公有项引入作用域，可以指定路径后跟 * ，glob 运算符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里指将 collections 中定义的所有公有项引入当前作用域。</span></span><br><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用 glob 运算符时需要小心，glob 会使得我们难以推导作用域中有什么名字和它们是在何处定义的。</p>
<p>glob 运算符经常用于测试模块 <code>tests</code> 中，将所有内容引入作用域。</p>
</blockquote>
<h1 id="将模块分割进不同文件"><a href="#将模块分割进不同文件" class="headerlink" title="将模块分割进不同文件"></a>将模块分割进不同文件</h1><p>对于 二进制 crate 或 库 crate 来说，我们可以将该文件中的多个 <code>mod</code> 拆分到不同的子文件或者子目录中。</p>
<p>模块定义时，如果模块名后边是 “;” ，而不是代码块：</p>
<ul>
<li>Rust 会从与模块同名的文件中加载内容；</li>
<li>模块树的结构不会变化；</li>
</ul>
<p>随着模块逐渐变大，该技术可以把模块的内容移动到其他文件中。</p>
<p>如果拆分到子文件，</p>
<ol>
<li><p>新建一个以 <em>需要移除的 mod 名</em> 命名的 rs 文件；</p>
</li>
<li><p>将该 mod 中的内容复制到 新 rs 文件中；</p>
</li>
<li><p>在原文件中添加 mod 声明语句（带<code>;</code>号），这将告诉 Rust 在另一个与模块同名的文件中加载模块的内容；</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// 也可以使用相对路径</span></span><br><span class="line"><span class="comment">// pub use front_of_house::hosting;</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二，如果该 mod 还包含子 mod，可以创建 <code>目录+子文件</code> 的多层结构；</p>
<ol>
<li>创建一个以 <em>需要移动的父 mod 模块名</em> 命名的 rs 文件；在文件中添加子 mod 的声明；</li>
<li>在步骤1中的同级目录下，创建一个以 <em>需要移动的父 mod 模块名</em> 命名的目录，和一个子 mod 名命名的 rs 文件；</li>
<li>移动子 mod 的内容到同名文件中；</li>
<li>原始文件中依然需要声明父 mod ；</li>
<li>在原始文件中，使用子 mod 的方式与方式一中一样。</li>
</ol>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">|-- front_of_house</span><br><span class="line">|   `-- hosting.rs</span><br><span class="line">|-- front_of_house.rs</span><br><span class="line">`-- main.rs</span><br><span class="line"></span><br><span class="line">文件名: src/front_of_house.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"></span><br><span class="line">目录名：src/front_of_house</span><br><span class="line">文件名: src/front_of_house/hosting.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">此时原文件中的使用 <span class="title function_ invoke__">add_to_waitlist</span>() 的方式不变；</span><br></pre></td></tr></table></figure>



<p>在拆分模块到文件的过程中，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-- my</span><br><span class="line">|   |-- inaccessible.rs</span><br><span class="line">|   |-- <span class="keyword">mod</span>.rs</span><br><span class="line">|   `-- nested.rs</span><br><span class="line">`-- split.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下两种方式效果相同</span></span><br><span class="line"></span><br><span class="line">|-- my</span><br><span class="line">|   |-- inaccessible.rs</span><br><span class="line">|   `-- nested.rs</span><br><span class="line">|-- my.rs</span><br><span class="line">`-- split.rs</span><br></pre></td></tr></table></figure>



<p><code>my.rs</code> &#x3D;&#x3D; <code>my/mod.rs</code> ，即效果是相同的，在其他模块中使用时，都是作如下声明 ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pub 是可选的，根据访问需求添加；</span></span><br><span class="line">[<span class="keyword">pub</span>] <span class="keyword">mod</span> my;</span><br></pre></td></tr></table></figure>

<p>如上所示，Rust 会将该文件内容放进名为 <code>my</code> 的模块中，然后插入到当前声明的作用域中。</p>
<h2 id="多个二进制文件如何处理"><a href="#多个二进制文件如何处理" class="headerlink" title="多个二进制文件如何处理"></a>多个二进制文件如何处理</h2><p>常规单个二进制文件的结构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>main.rs 是默认的二进制 crate</p>
</blockquote>
<p>多个二进制文件的结构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── main.rs</span><br><span class="line">    └── bin</span><br><span class="line">        └── my_other_bin.rs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果希望有除默认 main.rs 之外的二进制 crate，就在 main.rs 同级目录下创建 bin 目录，然后添加二进制 crate。</p>
</blockquote>
<h1 id="二进制文件中如何引入上级模块"><a href="#二进制文件中如何引入上级模块" class="headerlink" title="二进制文件中如何引入上级模块"></a>二进制文件中如何引入上级模块</h1><p>通过 mod 上添加路径属性，指定 mod 所在 rs 文件路径。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[path =<span class="string">&quot;../dbaccess/mod.rs&quot;</span>]</span></span><br><span class="line"><span class="keyword">mod</span> db_access;</span><br><span class="line"><span class="meta">#[path =<span class="string">&quot;../errors.rs&quot;</span>]</span></span><br><span class="line"><span class="keyword">mod</span> errors;</span><br></pre></td></tr></table></figure>





<h1 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h1><p>如果直接 <code>use</code> 导入，而没有依赖进来，那么会有类似如下报错：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unresolved import `animal_test`</span><br><span class="line"><span class="keyword">use</span> of undeclared <span class="keyword">crate</span> or module `animal_test`</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ol>
<li>上述错误，是本地mod，则在使用的rs文件中 使用 <code>pub mod animal_test;</code></li>
<li>如果不是外部crate，那么需要在 <code>Cargo.toml</code> 文件中依赖此 crate；</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://ligongzhao.github.io/07%E4%BD%BF%E7%94%A8%E5%8C%85%E3%80%81Crate%E5%92%8C%E6%A8%A1%E5%9D%97.html" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust/" rel="tag">Rust</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/21%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97.html" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            21知识拾遗
          
        </div>
      </a>
    
    
      <a href="/http_server.html" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">http_server</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> ligongzhao
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="听潮亭"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>