<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于我</title>
    <url>//about.html</url>
    <content><![CDATA[<h1 id="Who-Am-I"><a href="#Who-Am-I" class="headerlink" title="Who Am I?"></a>Who Am I?</h1><p><img src="/about/food-dog.jpg"> </p>
]]></content>
  </entry>
  <entry>
    <title>运动注意事项</title>
    <url>//%E8%BF%90%E5%8A%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html</url>
    <content><![CDATA[<h1 id="硬拉的注意事项："><a href="#硬拉的注意事项：" class="headerlink" title="硬拉的注意事项："></a>硬拉的注意事项：</h1><p>背面的肌肉群</p>
<ol start="0">
<li>鞋底平硬薄<ul>
<li>平底鞋或者摔跤鞋，或者光脚</li>
</ul>
</li>
<li>穿长腿袜或者紧身裤保护小腿<ul>
<li>因为需要与杠铃接触，容易刮伤</li>
</ul>
</li>
<li>握距（双手的位置）：<ul>
<li>手臂垂直向下的距离</li>
<li>站距，一般比肩略窄，需要保证在手臂内侧</li>
<li>脚尖的指向，可以笔直向前，也可以稍微打开（大约15度左右即可），选择发力舒适的角度即可</li>
</ul>
</li>
<li>确定自己的最佳臀位（需要同时做到一下4点）：<ul>
<li>下背保持挺直，胸椎保持自然的生理曲度</li>
<li>肩在杠铃正上方</li>
<li>膝盖不要超过手臂，应该与手臂对齐（这里指与手臂的前后位置），，超过手臂会导致臀位过低，相反则会导致臀位过高</li>
<li>小腿贴住杠铃</li>
</ul>
</li>
<li>握杠铃的方式（以下任意）：<ul>
<li>双手正握 （但是随着重量的提升，可能导致杠铃滑落，握力不够）</li>
<li>正反握（一只手正握，一只手反握），可以提高握力</li>
<li>锁握（用其余四指包着大拇指）</li>
<li>助理带的缺点是可能不能正确把握握力，建议在训练的最后几组，小臂力量不足支撑训练次数时使用</li>
</ul>
</li>
</ol>
<p>流程：</p>
<ol>
<li>视线看向斜前方</li>
<li>将气吸至腹部，并保持核心收紧，同时伸膝伸髋（大约屁股的位置）将杠铃拉至身体直立</li>
<li>杠铃时刻贴近身体，拉起后呼气<ul>
<li>启动时不要先伸膝再伸髋，臀位不存在上下移动（即臀位不需要先下再上），而是直接从原位置伸展开</li>
</ul>
</li>
<li>当杠铃拉过膝盖后，髋应该主动向前贴杠<ul>
<li>杠铃的轨迹应该成直线，不要将杠铃向身体方向拉，造成过度后仰，存在受伤的风险</li>
</ul>
</li>
<li>杠铃下放，也是垂直向下，保持小腿垂直地面，将杠铃屈髋至膝盖后，顺势下放<ul>
<li>下放时，不要屈膝下蹲，避免杠铃磕到膝盖</li>
</ul>
</li>
</ol>
<p>次数</p>
<ol>
<li>硬拉的训练，不建议高次数，保持10次以内的范围，<ul>
<li>硬拉时三大项中对神经系统压力最大的一个</li>
</ul>
</li>
<li>对于新手而言，每周硬拉训练不要超过一次</li>
</ol>
<h1 id="跳绳"><a href="#跳绳" class="headerlink" title="跳绳"></a>跳绳</h1><p>双腿着力不均<br>    重心会无意识的偏向一侧膝盖，长期会导致一侧膝盖比另一侧膝盖疼<br>    - 可以采用交替跳的方式</p>
<p>膝盖微屈</p>
<p>不要驼背探头</p>
<p>一周四次，每次不超过1500个</p>
<p>如果感觉膝盖疼，立刻停止，恢复到不疼后再开始，避免造成不可逆损伤</p>
<p>减少碳水摄入，可以增加脂肪和蛋白质</p>
]]></content>
      <categories>
        <category>运动</category>
      </categories>
      <tags>
        <tag>运动</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>//Git%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="几个不太懂的命令"><a href="#几个不太懂的命令" class="headerlink" title="几个不太懂的命令"></a>几个不太懂的命令</h2><ol>
<li><p>创建新仓库  –这个命令什么时候使用？？</p>
<p><code>git init</code></p>
</li>
<li><p>创建一个本地仓库的克隆版  –检出远程仓库可以理解，为什么还要check out本地仓库？？</p>
<p><code>git clone /path/to/repository</code></p>
</li>
<li><p>原话是：“如果你还没有克隆现有仓库，并欲将你的仓库连接某个远程服务器，使用如下命令，可以将你的改动推送到所添加的服务器上：”  –这里也不太命令什么时候使用？？？</p>
<p><code>git remote add origin &lt;server&gt;</code></p>
</li>
</ol>
<h2 id="Git常用命令和流程"><a href="#Git常用命令和流程" class="headerlink" title="Git常用命令和流程"></a>Git常用命令和流程</h2><ol>
<li>刚开始要在本地**创建目录 <strong>，然后</strong>初始化仓库 **</li>
<li>将指定服务器中的代码，检出到本地，**检出仓库&#x2F;克隆仓库 **</li>
<li>有了修改，<strong>添加和提交</strong>  —这里只是提交到本地缓存中</li>
<li>真正的提交本地修改到远程服务器，<strong>推送修改</strong></li>
</ol>
<h2 id="Git、版本控制常用概念"><a href="#Git、版本控制常用概念" class="headerlink" title="Git、版本控制常用概念"></a>Git、版本控制常用概念</h2><ol>
<li>分支branch<ol>
<li>创建分支</li>
<li>切换分支，<em>master与新分支之间切换</em></li>
<li>分支合并</li>
<li>分支删除，提交</li>
</ol>
</li>
<li>更新与合并<ol>
<li>冲突conflicts，合并或更新本地仓库代码时常遇到的问题，需要解决conflicts</li>
</ol>
</li>
<li>替换本地改动，当本地操作发生错误后</li>
<li>标签，tag，不同版本之间做tag</li>
<li>日志，log，关于本地git的所有操作</li>
<li>​</li>
</ol>
<h2 id="问题：git-clone到本地的文件，没有绿色和红色等状态图标"><a href="#问题：git-clone到本地的文件，没有绿色和红色等状态图标" class="headerlink" title="问题：git clone到本地的文件，没有绿色和红色等状态图标"></a>问题：git clone到本地的文件，没有绿色和红色等状态图标</h2><p>处理方式：</p>
<ol>
<li><p><code>Win + r</code> 打开运行窗口，输入 <code>regedit.exe</code> 查看注册表<br>按照注册表文件层级依次找到下面的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers</span><br></pre></td></tr></table></figure></li>
<li><p>打开<code>ShellIconOverlayIdentifiers</code>的层级，可以看到很多子项，确认Tortoise相关的9个子项排在前11位置（一般默认应该是，因为前面Tortoise相关的子项前面都有空格，会排的比较靠前，这种情况下就什么都不需要修改直接操作后面步骤）。</p>
<ul>
<li>如果有子项的顺序超过了前11的位置，通过修改子项名称，例如前面添加一个<code>.</code>前缀或数组的形式，让其排在前11的顺序；</li>
<li><blockquote>
<p>Windows Explorer Shell 支持的 Overlay Icon 最多 15 个，Windows 自身使用了 4 个，只剩 11 个可扩展使用。排在后面会影响Tortoise的展示。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>打开任务管理器（Ctrl+Alt+Delete选择<code>启动任务管理器</code>或者Ctrl+Shift+Esc直接打开任务管理器）</p>
<ul>
<li>重启windows的资源管理器。点击<code>进程</code>（win7）或者<code>详细信息</code>（win10），找到<code>explorer.exe</code>（资源管理器），选择结束任务，然后点击<code>文件</code>，选择<code>新建任务</code>，输入<code>exloroer.exe</code>即可。<ul>
<li>（win10可以在进程页找到<code>Windows 资源管理器</code>右键选择<code>重新启动</code>）</li>
</ul>
</li>
</ul>
</li>
<li><p>再次打开clone下来的项目，此时git状态应该正常了。</p>
</li>
</ol>
<h2 id="问题：TortoiseGit-在Git-clone时一直要输入密码问题"><a href="#问题：TortoiseGit-在Git-clone时一直要输入密码问题" class="headerlink" title="问题：TortoiseGit 在Git clone时一直要输入密码问题"></a>问题：TortoiseGit 在Git clone时一直要输入密码问题</h2><p>这个问题有两种可能</p>
<ol>
<li>Git clone时，要输入用户名和密码，输入后，结果报了Access denied的错误，而实际上信息是正确的。</li>
<li>Git clone时，要输入用户名密码，输入后就可以正常下载。</li>
</ol>
<h3 id="可能1-输入用户名密码后，信息正确，但是却报了Access-denied"><a href="#可能1-输入用户名密码后，信息正确，但是却报了Access-denied" class="headerlink" title="可能1. 输入用户名密码后，信息正确，但是却报了Access denied"></a>可能1. 输入用户名密码后，信息正确，但是却报了Access denied</h3><p>原因：</p>
<p>没有将本地公钥上传到git托管服务器上（github或者gitee上），或者本地没有启动Pageant并且没有将对应的私钥添加到Pageant中。</p>
<p>处理方式：</p>
<blockquote>
<p>下面步骤的内容如果确认做过了，就跳过，把没有做过的做了。</p>
</blockquote>
<ol>
<li>本地生成rsa公私钥；</li>
<li>将本地公钥添加到github&#x2F;gitee的SSH Key中；</li>
<li>本地将之前生成的私钥文件添加到Pageant中</li>
</ol>
<h3 id="可能2-输入用户名密码后，就可以正常clone拉取代码"><a href="#可能2-输入用户名密码后，就可以正常clone拉取代码" class="headerlink" title="可能2. 输入用户名密码后，就可以正常clone拉取代码"></a>可能2. 输入用户名密码后，就可以正常clone拉取代码</h3><p>原因：</p>
<p>Git clone时的url，使用了<code>http/https的url</code>的方式拉取代码才出现的，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://gitee.com/ligongzhao/logback.git</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<h4 id="推荐-方法一，通用的解决方法"><a href="#推荐-方法一，通用的解决方法" class="headerlink" title="(推荐)方法一，通用的解决方法"></a>(推荐)方法一，通用的解决方法</h4><p>切换git的拉取方式，将 <code>http/https</code> 换为 <code>ssh</code> 的方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git@gitee.com:ligongzhao/logback.git</span><br></pre></td></tr></table></figure>

<h4 id="方法二，适用于windows-（-git-credentials（存储git账号和密码的文件）文件）"><a href="#方法二，适用于windows-（-git-credentials（存储git账号和密码的文件）文件）" class="headerlink" title="方法二，适用于windows （.git-credentials（存储git账号和密码的文件）文件）"></a>方法二，适用于windows （.git-credentials（存储git账号和密码的文件）文件）</h4><ol>
<li>出现上面这种情况 先<code>按提示输入用户名和密码</code>，</li>
<li>接着执行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure></li>
<li>检查C:\Users\你的电脑名（本地用户目录下）; 这个文件夹(如下)下面是否能找到.git-credentials文件。<blockquote>
<p>如果文件的内容是有关你的gitlab的设置，格式为：http:&#x2F;&#x2F;{用户名}:{密码}@{git 网址}</p>
</blockquote>
</li>
<li>再次执行<code>git pull之类</code>的操作就不需要再输入用户名和密码了</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习遇到过的问题</title>
    <url>//Git%E5%AD%A6%E4%B9%A0%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="Git学习遇到过的问题"><a href="#Git学习遇到过的问题" class="headerlink" title="Git学习遇到过的问题"></a>Git学习遇到过的问题</h1><h2 id="1-修改目录报错permission-denied"><a href="#1-修改目录报错permission-denied" class="headerlink" title="1. 修改目录报错permission denied"></a>1. 修改目录报错permission denied</h2><p>要通过TortoiseGti的rename修改git项目中的一个目录<code>springboot学习</code> -&gt; <code>SpringBoot学习</code>，但是报错如下：</p>
<p><img src="/images/solved_rename_failed_permission_denied.png" alt="solved_rename_failed_permission_denied"></p>
<h4 id="解决过程："><a href="#解决过程：" class="headerlink" title="解决过程："></a>解决过程：</h4><p>一般情况是要修改的目录被 lock 了，可以通过第三方工具，例如 OpenArk64.exe 来查找占用相关目录的进程，然后结束该进程。</p>
<p>如果找不到相应的进程，最简单的方法把有关联的进程全部关掉，或者重启 Windows。</p>
<p>然后再重新 rename 。</p>
<blockquote>
<p>为什么会被 lock ？准备重命名的目录或者里面的文件，可能被编辑器正在打开使用，或者目录被占用。</p>
</blockquote>
<h2 id="2-多账号配置"><a href="#2-多账号配置" class="headerlink" title="2. 多账号配置"></a>2. 多账号配置</h2><p>配置 Github 和 Gitee 两种平台的账号</p>
<blockquote>
<p>我理解，最主要是项目单独配置权限。</p>
</blockquote>
<p>在 <code>.ssh/config</code> 配置文件中分别配置不同平台的账号信息</p>
<blockquote>
<p>如果没有改文件，就在用户目录下的.ssh目录下手动创建一个config文件。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host gitee.com</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    User ligongzhao</span><br><span class="line">    IdentityFile C:\\Users\\spoon\\.ssh\\id_rsa</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User dirtyair</span><br><span class="line">    IdentityFile C:\\Users\\spoon\\.ssh\\id_rsa</span><br><span class="line">    PreferredAuthentications publickey</span><br></pre></td></tr></table></figure>

<p>可以使用相同的私钥</p>
<p>测试github是否联通</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spoon@LAPTOP-SPOON MINGW64 ~/.ssh</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span></span><br><span class="line">The authenticity of host &#x27;github.com (20.205.243.166)&#x27; can&#x27;t be established.</span><br><span class="line">ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.</span><br><span class="line">This key is not known by any other names</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line">Warning: Permanently added &#x27;github.com&#x27; (ED25519) to the list of known hosts.</span><br><span class="line">Hi dirtyair! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>



<p>如果使用的是小乌龟（TortoiseGit），可以通过 <code>puttygen.exe</code> 程序导入 id_rsa 私钥文件然后生成一个 ppk 后缀文件来使用。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 反射</title>
    <url>//Java%20%E5%8F%8D%E5%B0%84.html</url>
    <content><![CDATA[<h1 id="Java-反射和动态代理"><a href="#Java-反射和动态代理" class="headerlink" title="Java 反射和动态代理"></a>Java 反射和动态代理</h1><p>反射与动态代理原理</p>
<p>1 关于反射<br>反射最大的作用之一就在于我们可以不在编译时知道某个对象的类型，而在运行时通过提供完整的”包名+类名.class”得到。注意：不是在编译时，而是在运行时。</p>
<p>功能：<br>•在运行时能判断任意一个对象所属的类。<br>•在运行时能构造任意一个类的对象。<br>•在运行时判断任意一个类所具有的成员变量和方法。<br>•在运行时调用任意一个对象的方法。<br>说大白话就是，利用Java反射机制我们可以加载一个运行时才得知名称的class，获悉其构造方法，并生成其对象实体，能对其fields设值并唤起其methods。</p>
<p>应用场景：<br>反射技术常用在各类通用框架开发中。因为为了保证框架的通用性，需要根据配置文件加载不同的对象或类，并调用不同的方法，这个时候就会用到反射——运行时动态加载需要加载的对象。</p>
<p>特点：<br>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>
<p>2 动态代理<br>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在两者之间起到中介的作用（可类比房屋中介，房东委托中介销售房屋、签订合同等）。<br>所谓动态代理，就是实现阶段不用关心代理谁，而是在运行阶段才指定代理哪个一个对象（不确定性）。如果是自己写代理类的方式就是静态代理（确定性）。</p>
<p>组成要素：<br>(动态)代理模式主要涉及三个要素：<br>其一：抽象类接口<br>其二：被代理类（具体实现抽象接口的类）<br>其三：动态代理类：实际调用被代理类的方法和属性的类</p>
<p>实现方式:<br>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了反射机制。还有其他的实现方式，比如利用字节码操作机制，类似 ASM、CGLIB（基于 ASM）、Javassist 等。<br>举例，常可采用的JDK提供的动态代理接口InvocationHandler来实现动态代理类。其中invoke方法是该接口定义必须实现的，它完成对真实方法的调用。通过InvocationHandler接口，所有方法都由该Handler来进行处理，即所有被代理的方法都由InvocationHandler接管实际的处理任务。此外，我们常可以在invoke方法实现中增加自定义的逻辑实现，实现对被代理类的业务逻辑无侵入。</p>
<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>利用反射的优点：</p>
<p>在编写程序时，如果知道想要查看的field（类的域成员）名和类型，查看指定的域是一件简单的事情</p>
<p>而利用反射机制可以查看在编译时还不清楚的对象域。</p>
<p>Class类的</p>
<ol>
<li>getFields()</li>
<li>getMethods()</li>
<li>getConstructors()</li>
</ol>
<p>方法，分别返回类提供的public的域，方法和构造器 -&gt; 数组,(包括超类的公有成员)</p>
<p>Class类的</p>
<ol>
<li>getDeclareFields()</li>
<li>getDeclareMethods()</li>
<li>getDeclareConstructors()</li>
</ol>
<p>方法，分别返回类中声明的全部域，方法和构造器，包括私有和受保护的，（不包括超类的成员）</p>
<p>modifier -&gt; 有修饰词的意思，如：public,private,static…都是修饰词</p>
<p>java.lang.reflect包中有Field,Method,Constructor三个类，用于描述类的域，方法，构造器</p>
<p>三个类都有一个getModifiers()的方法，返回一个整型，描述修饰词的，如public的</p>
<p>反射机制的默认行为，受限于Java的访问控制</p>
<p>如果一个Java程序没有收到安全管理器的控制，就可以覆盖访问控制</p>
<p>Field,Method,Constructor对象的setAccessible()，例如：</p>
<p><code>f.setAccessible(true);</code>&#x2F;&#x2F; 修改f(Field对象)的访问权限</p>
<p>写一个利用反射分析类中fields,methods,constructor的小程序&#x2F;脚本</p>
<ul>
<li>即查看对象的数据域名称和类型</li>
<li>获得对应Class对象</li>
</ul>
<p>写一个利用反射分析对象的脚本</p>
<h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><p>问题：动态代理是解决什么问题的？</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java使用笔记</title>
    <url>//Java%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><p>任何语言，都需要有其开发运行环境</p>
<p>jre： java runtime environment java运行环境<br>    包括jvm和java程序所需的核心类库等，<br>    如果想要运行一个开发好的java程序，只需要安装jre即可</p>
<p>jdk：java development kit java开发工具包<br>    jdk提供给java开发人员使用，包含了jre<br>    也包含了一些开发工具：编译工具java.exec，打包工具jar.exe</p>
<p>总结：使用jdk开发完的java程序，交给jre运行</p>
<h1 id="Java-文件"><a href="#Java-文件" class="headerlink" title="Java 文件"></a>Java 文件</h1><p>java 的可以执行文件”.class”</p>
<p>【windows】<br>命令行中设置临时环境变量</p>
<p><code>set Path=E:\jdk\bin\;%path%</code></p>
<p>【linux】<br><code>$path=$PATH:xxxx</code></p>
<p>java中无论从jar包加载还是从.class文件加载，都有一个classpath的概念，类似于PATH。<br>    系统会从当前路径下寻找，然后在PATH中寻找，都没有则会报错<br>    classpath也一样<br>不同的是，PATH只能包含目录，classpath可以包含jar包</p>
<p>java.lang.NoClassDefFoundError错误：</p>
<ul>
<li>没有在classpath中忘掉了需要的jar包</li>
</ul>
<p>classpah 的作用就是告诉系统java运行环境，告诉java虚拟机到哪里去寻找需要的jar包或文件</p>
<p>classpath 中需要注意的：</p>
<ol>
<li>classpath告诉jvm到指定目录下寻找需要的jar文件，</li>
<li>jvm默认只会寻找classpath中的路径</li>
<li>如果classpath路径后加了”;”，则jvm在寻找完指定路径后，会搜索当前路径；</li>
<li>如果不想让jvm自动去寻找当前路径，则不需要在最后的路径后添加”;”，</li>
<li>如果需要jvm在当前路径寻找，又在指定的其他路径寻找，classpath&#x3D;.;xxxx<br>这样，就会现在当前路径寻找，再到指定路径寻找</li>
<li>添加以后的classpath,</li>
</ol>
<p>windows下想已有的classpath中添加临时的路径，<br>    <code>set classpath=.;%classpath%</code></p>
<p>每个.java文件中，可以包含多个class ，但是每个class后面的名称都不能相同；</p>
<ul>
<li>一个.java文件中，只能有一个public修饰的class</li>
<li>为方便，每个.java文件的名称都必须与public的类名称完全一致</li>
</ul>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>如果java原文件中包含了package信息，例如com.data.data,则这个原文件要放在相应的目录下，</p>
<ul>
<li>如：person.java使用了package com.data.data,</li>
<li>那么，person.java应该放在src&#x2F;com&#x2F;data&#x2F;data目录下</li>
</ul>
<p>java生成的.class文件也会遵循类似的目录结构和命名方式</p>
<p>Java程序中源代码文件那么多，编译之后生成那么多.class文件，怎么方便管理呢？</p>
<p>jar工具，用来给我们的程序打包，</p>
<ul>
<li>打包之后会生成一个.jar文件，</li>
<li>这个文件跟zip文件的结构是一样的，可以用解压工具打开，方便管理。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jar -cfv test.jar  Test.class</span><br></pre></td></tr></table></figure>
java 包</li>
</ul>
<p>包 </p>
<ul>
<li>有层次关系</li>
<li>包嵌套的层次可以保证包名的唯一性，</li>
<li>建议用Internet域名的倒序作为包的前缀<ul>
<li>lzy.com –&gt; com.lzy.mypackage,</li>
</ul>
</li>
<li>包名用小写字母表示</li>
<li>包名与文件系统的目录结构一一对应</li>
<li>要使java知道包在文件系统中的地址，需要修改classpath（类路径）</li>
</ul>
<p>在包中添加类</p>
<ul>
<li>只需在程序的最前端加上<br> <code>package PACKAGE_NAME</code></li>
</ul>
<h1 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/**/多行注释</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/** 文档注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注：文档注释可以通过javadoc程序自动提取生成相关说明文档<br>类似于python中<br>“””<br>“”” 三引号中的紧跟在函数或类下面的说明文档</p>
<p>注释很重要，<br>与人方便，于己方便</p>
<p>代码仅仅是思想的一种体现形式</p>
<p>想好了可以先用中文或更容易表现的形式展示出来。</p>
<p>类的形式就是一个字节码，给计算机看的</p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>整数常量<br>小数常量<br>布尔(boolean)常量：<br>字符常量 –&gt; 用’’单引号标识的,单个&#x2F;一个[数字(0-9)和字母，符号]<br>字符串常量 –&gt; 用””双引号标识的<br>null常量</p>
<p>整数：有四种表现形式<br>二进制：0,1，满2进1<br>八进制：0-7，满8进1，用0开头表示<br>十进制：0-9，满10进1<br>十六进制：0-9，A-F，满16进1，用0x表示</p>
<p>进制“一种计数的形式”</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>内存中的一个存储区域</p>
<ul>
<li>该区域有自己的名称(变量名)和类型(数据类型)<ul>
<li>（名字用来寻找，类型用来约束存放的内容）</li>
</ul>
</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
</ul>
<p>用来不断的存放同一类型的常量，并可以重复使用</p>
<p>注意：<br>变量的作用范围(一对{}之间有效，作用域，超出作用域之后，变量在内存中会被释放)</p>
<ul>
<li>{} 局部代码块，可以定义局部变量的生命周期。<br>初始化值</li>
</ul>
<p>定义变量的格式：<br>    数据类型 变量名 &#x3D; 初始化值；<br>(格式固定)</p>
<p>Java强类型 –&gt; 每种数据都定义了明确的数据类型，</p>
<pre><code>每种数据类型在内存中分配的内存空间大小不相同
</code></pre>
<p>基本数据类型 –&gt; 数值型 :–&gt; 整数 byte,short, int ,long<br>                         –&gt; 浮点数 float, double<br>                 字符型 char<br>                 布尔型 boolean</p>
<p>引用数据类型</p>
<ul>
<li>类class</li>
<li>接口interface</li>
<li>数组[]</li>
</ul>
<p>注：整数默认为：int ,小数默认为：double</p>
<p>String 不是基本数据类型，是Java库的预定义类，任何Java类，都为引用类型</p>
<p>数据类型的设置，应该以需要赋值的类型来判定</p>
<p>类型转换：</p>
<p>自动类型转换<br>强制类型转换（显示类型转换）<br>什么时候使用强制类型转换？？？<br>如：(int)(a + b)强制转换为int</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>只要是运算符，计算之后都会有结果</li>
</ul>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ : Java中两个整数相除，商为整数，<span class="number">5</span> / <span class="number">9</span> == <span class="number">0</span>，</span><br><span class="line">所以，要想得到小数，--&gt; <span class="number">5.0</span> / <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>结果true；false</p>
<h2 id="逻辑运算符（关系运算符）"><a href="#逻辑运算符（关系运算符）" class="headerlink" title="逻辑运算符（关系运算符）"></a>逻辑运算符（关系运算符）</h2><p>逻辑运算符，用于连接两个boolean类型的表达式</p>
<ul>
<li>&amp;	(单)与运算：两边都参与运算</li>
<li>|	(单)或运算：同上</li>
<li>！	非</li>
<li>^	异或	</li>
<li>&amp;&amp;	(短路)与运算：当前面一个运算不满足时，后面的不需要运算</li>
<li>||	(短路)或运算：同上</li>
</ul>
<h2 id="位运算符："><a href="#位运算符：" class="headerlink" title="位运算符："></a>位运算符：</h2><p>用于二进制位运算<br>（算法运算时用）<br>^ 异或运算时，</p>
<ul>
<li>一个数异或同一个数两次，结果还是这个数</li>
<li>（异或的小应用：对一个数据异或一次，相当于加密，在异或一次相同于解密（USBKey））</li>
</ul>
<h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p><code>A?B:C</code><br>与下面代码效果相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (A)&#123;</span><br><span class="line">	B</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只要是运算符，计算之后都会有结果</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol>
<li><p>最有效的方法计算2*8</p>
<ul>
<li>凡是涉及到2进制运算，位运算是最高效的方式<br><code>2&lt;&lt;3 == 2*8 =16</code></li>
</ul>
</li>
<li><p>对两个整数变量的值进行互换（不用第三方变量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b; 计算的结果a、b实现互换  </span><br></pre></td></tr></table></figure>
<p>这里的利用^ 的规律，一个数^同一个数两次，值不变</p>
</li>
</ol>
<p>if条件判断</p>
<h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p>格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 取值<span class="number">1</span>:</span><br><span class="line">		执行语句;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 取值<span class="number">2</span>:</span><br><span class="line">		执行语句<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		执行语句n;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：靠近结尾大括号的语句的break可以省略；</p>
<p>多个选项对应一个内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		System.out.println(month + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（switch语句不常用）</p>
<h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式; 循环条件表达式; 循环后的操作表达式)&#123;</span><br><span class="line">    执行语句; (注意: 循环体)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个表达式之间用 <code>,</code> 逗号隔开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;&#125;	 <span class="comment">//无限循环</span></span><br></pre></td></tr></table></figure>


<p>循环通常需要变量的变化来控制</p>
<p>for与while的特点：</p>
<ol>
<li>for和while可以互换；</li>
<li>区别<ul>
<li>如果需要通过变量来对循环控制，且该变量只作为循环增量(变量)存在时，用for更好,循环结束后，这个变量就被回收了。</li>
</ul>
</li>
</ol>
<p>当对一个条件进行一次判断时，可以使用if语句；<br>当对一个条件进行多次判断时，可以使用while语句；</p>
<p>注意：</p>
<ol>
<li>在使用循环时，一定要明确哪些语句需要参与循环，哪些不需要；</li>
<li>循环通常情况下，需要定义条件，需要控制次数；</li>
</ol>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>存储结构</p>
<ul>
<li>简单的说，HashMap的存储结构是由<code>数组和链表</code>共同完成的。</li>
</ul>
<p>数组：</p>
<ol>
<li>在内存中的地址是连续的，大小固定，一旦分配，不能被其他引用占用</li>
<li>查询快，时间复杂度是O(1), 插入和删除的操作比较慢，时间复杂度是O(n),</li>
</ol>
<p>链表：</p>
<ol>
<li>存储方式是非连续的，大小不固定，特点与数组相反，</li>
<li>插入和删除快，查询慢。</li>
</ol>
<p>HashMap是一种折中方案</p>
<ul>
<li>HashMap, Y轴方向是数组，X轴方向是链表，的存储方式</li>
</ul>
<h2 id="HashMap基本原理："><a href="#HashMap基本原理：" class="headerlink" title="HashMap基本原理："></a>HashMap基本原理：</h2><p>2、根据Hash值，要找到对应的数组，所以对Entry[]的长度length求余，得到的就是Entry数组的index<br>3、找到对应的数组，就找到了所在的链表，然后按照链表的操作对Value进行插入、删除和查询操作</p>
<p><code>h%length</code>求余，一般什么情况下利用该算法？</p>
<ul>
<li>典型应用：分组</li>
</ul>
<h1 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h1><p>用最简单的方法来说，hashcode就是一个签名。当两个对象的hashcode一样时，两个对象就有可能一样。如果不一样的话两个对象就肯定不一样。<br>一般用hashcode来进行比较两个东西是不是一样的，可以很容易的排除许多不一样的东西。<br>最常用的地方就是在一堆东西里找一个东西。先用你要找的东西的hashcode和所有东西的hashcode比较，如果不一样的话就肯定不是你要找的东西。如果一样的话就很可能是你要找的东西。然后再进行仔细的比较两个东西是不是真的一模一样。</p>
<p>两个不同的东西的hashcode可以是一样的，不过这样会减慢运行速度，所以尽量避免（也就是所谓的碰撞）。</p>
<ol>
<li>一个对象的散列码，什么是散列码呢，简单的说就是通过哈希算法算出来的一大窜数字之类的东西，和内存有关.<br>如果对象1和对象2相等，说明他们的散列码相等！反过来就不一样了！</li>
<li>另外hashcode可以减少equals比较的次数，提高运算效率。</li>
</ol>
<p>网上，<br>hashcode 常常和 equal 一起提到</p>
<p>Java</p>
<p>垃圾回收器只释放那些经由new分配的内存</p>
<p>只有当垃圾回收发生时，才会释放那些不用的内存空间，当时垃圾回收不一定什么时候发生</p>
<p>Java中的垃圾回收与C++的析构函数的不同：</p>
<ul>
<li>垃圾回收不一定会发生，所以在程序执行过程中，对象不一定会被回收，</li>
<li>析构一定会发生，</li>
</ul>
<p>垃圾回收只与内存有关，</p>
<ul>
<li>使用垃圾回收器的唯一原因是为了回收程序不在使用的内存</li>
</ul>
<h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><p>继承，也是一种代码复用</p>
<p>关键字：extends，</p>
<p>可以得到基类中所有的成员变量(域)和方法</p>
<h1 id="Java-初始化的顺序"><a href="#Java-初始化的顺序" class="headerlink" title="Java 初始化的顺序"></a>Java 初始化的顺序</h1><ol>
<li>在类的内部，变量定义的先后顺序决定了初始化的顺序。</li>
<li>即使变量定义散布于方法定义之间（这里是指变量没有放在一起定义，而是散布在方法定义的前后），他们仍旧会在任何方法（包括构造器）被调用之前得到初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demoTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitSeq</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">House</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">		h.f();  <span class="comment">// show that construction is done</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">	Window(<span class="type">int</span> marker)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Window(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">	<span class="type">Window</span> <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">1</span>);  <span class="comment">// before constructor</span></span><br><span class="line">	House() &#123;</span><br><span class="line">		<span class="comment">//show that we&#x27;re in the constructor</span></span><br><span class="line">		System.out.println(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">		w3 = <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">33</span>);  <span class="comment">// reinitialize the w3</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Window</span> <span class="variable">w2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">2</span>);  <span class="comment">// after the constructor</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Window</span> <span class="variable">w3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">3</span>);  <span class="comment">// at end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的代码中，House中，故意把几个Window对象的定义散布在各处，以证明他们会在构造函数及其他函数调用之前得到初始化</li>
</ol>
<p>static的对象，会优先于非static对象初始化</p>
<ul>
<li>即先静态，后非静态</li>
</ul>
<p>构造器可以看做是static方法</p>
<p>非静态实例初始化</p>
<ul>
<li>java 中有一种称为“实例初始化”，用来初始化每一个对象的非静态变量</li>
</ul>
<p>数组初始化：</p>
<ul>
<li>java 中可以将一个数组赋值给另一个数组，即： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a2 = a1; (<span class="type">int</span>[] a2; <span class="type">int</span>[] a1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure>
 这中间真正做的是复制了一个引用，即a2和a1其实都是相同数组([1,2,3,4])的别名，即对a2的修改其实就是对相同数组的修改，a1也能看到修改后的内容；</li>
</ul>
<p>在编写程序时，并不能确定在数组中需要多少个元素，该怎么办？</p>
<p>可变参数：<br>有可变参数的好处是，<br>    就不用再显示地编写数组语法了<br>        String[] args<br>        String… args 	可变参数仍旧可以是一个数组，	可以用于“具有可选的尾随参数”时</p>
<p>Integer是int的包装类型<br>    自动包装机制可以将int提升为Integer</p>
<h1 id="Java的-if…else-与switch-结构总结"><a href="#Java的-if…else-与switch-结构总结" class="headerlink" title="Java的 if…else 与switch 结构总结"></a>Java的 if…else 与switch 结构总结</h1><p>swtich 从字节码上看是优于 if，<br>但是从测试结果来看在分支很多的情况下能显示出优势，一般情况下还是打不过 if</p>
<p><strong>额外知识点：</strong></p>
<p>现代 CPU 都支持分支预测 (branch prediction) 和指令流水线 (instruction pipeline)，这两个结合可以极大提高 CPU 效率。对于像简单的 if 跳转，CPU 是可以比较好地做分支预测的。但是对于 switch 跳转，CPU 则没有太多的办法。 switch 本质上是根​据索引，从地址数组里取地址再跳转。</p>
<p>if 是跳转指令，如果是简单的跳转指令的话 CPU 可以利用分支预测来预执行指令，而 switch 是要先根据值去一个类似数组结构找到对应的地址，然后再进行跳转，这样的话 CPU 预测就帮不上忙了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java现场技巧汇总</title>
    <url>//Java%E7%8E%B0%E5%9C%BA%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<ol>
<li><p>现场linux环境下，编译项目的java文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">编译后台文件：</span><br><span class="line">jarpath=/opt/kangaroo-module-center/kangaroo-earlywarn-process/lib/</span><br><span class="line">CP=&quot;&quot; ; for jar in `find $&#123;jarpath&#125; -name &#x27;*.jar&#x27;`; do CP=&quot;$jar:$CP&quot; ; done</span><br><span class="line">javac -cp $CP KangarooFlowModuleBase.java</span><br><span class="line">javac -cp $CP SourceObjectMapManage.java</span><br></pre></td></tr></table></figure>

</li>
<li><p>现场排查jar包冲突问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: com.google.common.util.concurrent.MoreExecutors.sameThreadExecutor()Lcom/google/common/util/concurrent/ListeningExecutorService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in `ls`;do unzip -l $i | grep com/google/common/util/concurrent/ListeningExecutorService;done</span><br><span class="line"></span><br><span class="line">hive-exec-2.0.0.jar</span><br><span class="line">     1386  02-09-2016 18:36   com/google/common/util/concurrent/ListeningExecutorService.class</span><br><span class="line">guava-23.0.jar</span><br><span class="line">     2071  08-04-2017 17:23   com/google/common/util/concurrent/ListeningExecutorService.class</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>处理jar冲突，两种方式：</p>
<ol>
<li>显示的在classpath中指定jar –优先选择显示指定</li>
<li>删除冲突jar</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>//Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="Java设计模式"><a href="#Java设计模式" class="headerlink" title="Java设计模式"></a>Java设计模式</h1><h2 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h2><p>对于设计模式，要做到，</p>
<ol>
<li>明白不同的设计用来解决什么场景问题，</li>
<li>对于常用的设计模式能够灵活运用</li>
</ol>
<h1 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ol>
<li>代理模式分为<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
</li>
<li>代理模式通常与反射联系到一起</li>
<li>动态代理的方法<ul>
<li>jdk动态代理</li>
<li>cglib</li>
<li>javassist</li>
</ul>
</li>
</ol>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><ol>
<li>像是工厂的流水线，链上的每一个节点都仅完成对象的某一种处理</li>
<li>Pipeline就是一种责任链模式</li>
</ol>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ol>
<li>就像我们生活中的转接头</li>
<li>起到适配和解耦的功能</li>
<li>通过适配器将不同的对象进行适配，完成功能的使用</li>
</ol>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ol>
<li>也成为了发布订阅模式</li>
<li>适用于一个对象的某种行为需要触发一系列事件的场景</li>
</ol>
<h2 id="构造者模式"><a href="#构造者模式" class="headerlink" title="构造者模式"></a>构造者模式</h2><ol>
<li>适用于一个对象有很多复杂的属性，需要根据不同的情况创建不同的对象</li>
<li>例如创建一个PB对象时使用的builder方式</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java代码片段</title>
    <url>//java%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5.html</url>
    <content><![CDATA[<ol>
<li><p>简单处理5位自增序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">  <span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自增数据超过5位的处理</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">autoIncrementSeq</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">incrementNum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (atomicInt.get() &gt; <span class="number">99999</span>) &#123;</span><br><span class="line">      atomicInt = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    incrementNum = atomicInt.getAndIncrement();</span><br><span class="line">    <span class="comment">// 数字长度为5位,长度不够前面补0</span></span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%05d&quot;</span>, incrementNum);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过更新监控文件时间，来处理心跳，是一个简单巧妙的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 片段来自titan-runner的MonitorClinet.java，runner与taskmanager程序约定的监控程序心跳的方式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heartbeat</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    com.google.common.io.Files.touch(<span class="built_in">this</span>.monitorFile);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">使用场景，可以sleep一段时间，更新一下文件时间，来表示程序还存活，然后另外一个程序通过计算该文件的更新时间来判断监控的程序是否正常</span><br><span class="line">    <span class="type">int</span> <span class="variable">idleSleepMs</span> <span class="operator">=</span> <span class="built_in">this</span>.configuration.getInt(<span class="string">&quot;task.idle_sleep.ms&quot;</span>, <span class="number">500</span>);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">this</span>.stoped) &#123;</span><br><span class="line">      <span class="built_in">this</span>.monitorClient.checkParentAlive();</span><br><span class="line">      <span class="built_in">this</span>.monitorClient.heartbeat();</span><br><span class="line">      ...</span><br><span class="line">      Thread.sleep((<span class="type">long</span>)idleSleepMs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java单元测试库</title>
    <url>//java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BA%93.html</url>
    <content><![CDATA[<h1 id="java单元测试库"><a href="#java单元测试库" class="headerlink" title="java单元测试库"></a>java单元测试库</h1><h2 id="jupiter-与-junit的异同？"><a href="#jupiter-与-junit的异同？" class="headerlink" title="jupiter 与 junit的异同？"></a>jupiter 与 junit的异同？</h2><h3 id="junit-jupiter"><a href="#junit-jupiter" class="headerlink" title="junit-jupiter"></a>junit-jupiter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.7</span><span class="number">.0</span>-M1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br></pre></td></tr></table></figure>

<h3 id="junit"><a href="#junit" class="headerlink" title="junit"></a>junit</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br></pre></td></tr></table></figure>

<h2 id="补充一些使用样例"><a href="#补充一些使用样例" class="headerlink" title="补充一些使用样例"></a>补充一些使用样例</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单元测试</tag>
        <tag>Junit</tag>
        <tag>Jupiter</tag>
      </tags>
  </entry>
  <entry>
    <title>java序列化</title>
    <url>//java%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
    <content><![CDATA[<h1 id="java序列化"><a href="#java序列化" class="headerlink" title="java序列化"></a>java序列化</h1><p>Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。</p>
<p>实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream &#x2F; ObjectOutputStream 类、完全保真的元数据以及程序员愿意用 Serializable 标识接口标记他们的类，从而 “参与” 这个过程。</p>
<ol>
<li>序列化允许重构</li>
</ol>
<p>序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。</p>
<p>为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver 命令计算出的。</p>
<p>一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是”null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person ，这毫不奇怪。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>序列化</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Java的一点建议</title>
    <url>//%E5%AD%A6%E4%B9%A0Java%E7%9A%84%E4%B8%80%E7%82%B9%E5%BB%BA%E8%AE%AE.html</url>
    <content><![CDATA[<h1 id="学习Java的一点建议"><a href="#学习Java的一点建议" class="headerlink" title="学习Java的一点建议"></a>学习Java的一点建议</h1><p>一、语法初识阶段，<br>操作对象，<br>操作if，for循环<br>操作list,set,map,<br>线程，IO，<br>jdbc</p>
<p>二、web学习的初级阶段，<br>弄清楚一个用户的点击产生的请求，是从哪里发起的，哪里接收的，哪里处理的，哪里返回的，<br>理解浏览器和服务器的关系和分工，<br>cookie,session,和response,<br>这些可以通过，html，jsp，servlet，等写出一个动态网站，也许只有登录功能，只能显示个人资料</p>
<p>三，<br>把一些常用的琐碎技术学会，<br>xml的作用的实际运用，<br>操作文件，<br>运用日志，<br>简化封装常用的工具类，？<br>    日期凑走，<br>    编码处理，<br>    分页模块<br>    等等。。。。。。</p>
<p>四，<br>数据库用好，<br>crud，增，查，改，删，<br>事物设置，</p>
<p>五，<br>多线程和异步，并发的概念，<br>队列</p>
<p>六，<br>nosql,memcached,redis,mongodb,眼花缭乱，但可以试着去用用</p>
<p>七，<br>设计模式，合理地改造自己的代码习惯</p>
<p>这样的原因，之前写的代码很乱，重复的，难以服用的代码堆积如山，</p>
<p>八，<br>google，和各种资料</p>
<p>九，<br>阅读优秀的开源项目的源代码，<br>搞懂一些当前不懂的基础知识</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>日志框架为什么会冲突</title>
    <url>//%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%86%B2%E7%AA%81.html</url>
    <content><![CDATA[<h1 id="日志框架为什么会冲突"><a href="#日志框架为什么会冲突" class="headerlink" title="日志框架为什么会冲突"></a>日志框架为什么会冲突</h1><p>现场遇到过好几次，放在tomcat的web项目启动后没有logs日志，最终发现都是因为引入的日志框架的jar包冲突导致的，排除不需要的日志框架jar包后log打印正常。</p>
<p>那么为什么同时存在多个日志框架的时候就会出现冲突呢？深入研究了日志框架的历史和设计后，发现原来这跟日志框架的实现机制有关系。</p>
<p>本文主要参考<a href="https://www.javazhiyin.com/58596.html">为什么日志框架会冲突</a>。</p>
<h2 id="日志框架的历史"><a href="#日志框架的历史" class="headerlink" title="日志框架的历史"></a>日志框架的历史</h2><p>首先要从日志框架的发展历史开始说起。</p>
<ol>
<li><p>Java Util Log<br>首先登场的是Java Util Log，简称JUL，是JDK中自带的log功能。虽然是官方自带的，JUL的使用却不广泛，主要是因为功能比较简单，不好用。</p>
</li>
<li><p>Log4j 1.x<br>然后Log4j 1.x就登场了，它是Gülcü 设计实现的日志框架，设计非常优秀，是使用非常广泛的框架。</p>
</li>
<li><p>Commons Logging<br>Commons Logging，简称JCL，是Apache的项目，JCL是一个Log Facade，只提供Log API,不提供实现，用Adapter来使用Log4j或者JUL作为Log Implementation。目的是统一日志接口规范，适配多种日志实现。</p>
</li>
<li><p>SLF4J&#x2F;Logback<br>SLF4J(The Simple Logging Facade for Java) 和 Logback 也是 Gülcü 创立的项目，其创立主要是为了提供更高性能的实现。其中，SLF4J是类似于JCL的Log Facade，Logback是类似于Log4j的Log Implementation。这老哥觉得JCL的接口设计不好，所以重新设计了一套。</p>
</li>
<li><p>Log4J2<br>维护Log4j的人为了不让Log4j的用户被SLF4J&#x2F;Logback抢走，所以搞了新的日志框架。Log4j2和Log4j1.x并不兼容，设计上很大程度上模仿了SLF4J&#x2F;Logback，性能上也获得了很大的提升。Log4j2也做了Facade&#x2F;Implementation分离设计，分成了Log4j-api和Log4j-core。</p>
</li>
</ol>
<p>至此，我们已经有了3个Log接口和4个Log实现，果然程序员真的是爱造轮子。出现这么多框架之后，有人开始搞各个框架之间的桥接，你兼容我，我兼容你，如下图所示<br><a href="resources/pics/log%E6%A1%86%E6%9E%B6%E5%86%B2%E7%AA%81%E5%8E%9F%E5%9B%A0/log_framework_compatible.jpg">日志框架兼容图片</a></p>
<p>因为很多jar使用的日志框架不同，所以经常会出现引入jar包之后导致日志类冲突。</p>
<h2 id="动态加载日志实现"><a href="#动态加载日志实现" class="headerlink" title="动态加载日志实现"></a>动态加载日志实现</h2><p>前面我们提到，日志框架分为日志接口和日志实现，只要我们的代码中使用的是日志接口（JCL，SLF4J，Log4j-api），我们可以随时替换日志实现。</p>
<h4 id="SLF4J加载日志实现的方式"><a href="#SLF4J加载日志实现的方式" class="headerlink" title="SLF4J加载日志实现的方式"></a>SLF4J加载日志实现的方式</h4><p>SLF4J加载日志实现分为两个步骤：</p>
<ol>
<li>获取ILoggerFactory日志工厂，</li>
<li>根据ILoggerFactory获取Logger。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>项目构建</title>
    <url>//%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA.html</url>
    <content><![CDATA[<h1 id="在maven或gradle项目中指定java版本号"><a href="#在maven或gradle项目中指定java版本号" class="headerlink" title="在maven或gradle项目中指定java版本号"></a>在maven或gradle项目中指定java版本号</h1><p>To use a different Java version for your projects, please specify it in build scripts.<br>For example, if you want to use Java 8, add below lines<br>In <code>pom.xml</code> of a Maven project:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
<p>In <code>build.gradle</code> of a Gradle project:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sourceCompatibility = 1.8</span><br><span class="line">targetCompatibility = 1.8</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>项目构建</tag>
        <tag>maven</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS-OpenSSH升级过程</title>
    <url>//CentOS-OpenSSH%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>升级背景</li>
<li>升级前注意事项</li>
<li>手动升级流程</li>
<li>rpm包升级流程</li>
<li>遇到问题及解决</li>
</ul>
<h1 id="升级背景"><a href="#升级背景" class="headerlink" title="升级背景"></a>升级背景</h1><p>搜扫发现主机的 OpenSSH 相关高危漏洞，通过升级解决。</p>
<p>服务器版本</p>
<ul>
<li><code>centos7.6-1811-2nic</code></li>
<li><code>centos7.4-1708-2nic</code></li>
</ul>
<h1 id="升级前注意事项"><a href="#升级前注意事项" class="headerlink" title="升级前注意事项"></a>升级前注意事项</h1><p>CentOS7.4和7.6的 OpenSSH 的自带版本</p>
<p>OpenSSH 的版本</p>
<ul>
<li><code>ssh -V</code><ul>
<li><code>OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017</code></li>
</ul>
</li>
<li><code>rpm -qa zlib</code><ul>
<li><code>zlib-1.2.7-17.el7.x86_64</code></li>
</ul>
</li>
</ul>
<p>OpenSSH 官方网站</p>
<ul>
<li><a href="https://www.openssh.com/">https://www.openssh.com</a></li>
</ul>
<p>openssl官方网站</p>
<ul>
<li><a href="https://www.openssl.org/">https://www.openssl.org/</a></li>
</ul>
<p>zlib官方网站</p>
<ul>
<li><a href="http://www.zlib.net/">http://www.zlib.net/</a></li>
</ul>
<p>到 OpenSSH 官网下载最新版本源码，然后解压后，通过<code>INSTALL</code>文件可以知道其依赖组件的版本要求，然后查看系统组件决定是否升级（没有问题就不升级）</p>
<ul>
<li>OpenSSL 1.0.x &gt;&#x3D; 1.0.1 or 1.1.0 &gt;&#x3D; 1.1.0g or any 1.1.1(条件满足，无需升级)</li>
<li>Zlib 1.1.4或1.2.1.2或更高版本（早期1.2.x版本有问题）(条件满足，无需升级)</li>
</ul>
<p>普通服务器操作前注意安装 <code>telnet</code> 和 <code>xinetd</code> 工具，通过 telnet 连接，防止升级过中 ssh 远程中断导致无法远程连接。</p>
<h1 id="rpm包升级流程"><a href="#rpm包升级流程" class="headerlink" title="rpm包升级流程"></a>rpm包升级流程</h1><h2 id="1-制作-rpm-升级包"><a href="#1-制作-rpm-升级包" class="headerlink" title="1. 制作 rpm 升级包"></a>1. 制作 rpm 升级包</h2><ol>
<li><p>分别下载 <code>openssh-8.8p1</code>的源码包，和 <code>x11-ssh-askpass-1.2.4.1</code> 的源码包（手动下载，或者 <code>wget</code> 到打包的服务器上）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/pub/OpenBSD/OpenSSH/portable/openssh-8.8p1.tar.gz</span><br><span class="line"></span><br><span class="line">wget https://src.fedoraproject.org/repo/pkgs/openssh/x11-ssh-askpass-1.2.4.1.tar.gz/8f2e41f3f7eaa8543a2440454637f3c3/x11-ssh-askpass-1.2.4.1.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装打包和编译 <code>openssh-8.8p1</code> 源码的依赖（）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install rpm-build zlib-devel openssl-devel gcc perl-devel pam-devel</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">（TODO，perl-devel 依赖是否需要安装，这块找一个新机器重新安装测试一下，没有这个试一试能否编译并打包成功，编译openssh是不需要这个包的，是否制作rpm需要？测试一下）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建本地打包目录，并将 <code>openssh</code> 和 <code>x11-ssh-askpass</code> 源码 copy 到指定位置</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/rpmbuild/&#123;SOURCES,SPECS&#125;</span><br><span class="line">cp /root/dev_ops/openssh-8.8p1.tar.gz /root/rpmbuild/SOURCES</span><br><span class="line">cp /root/dev_ops/x11-ssh-askpass-1.2.4.1.tar.gz /root/rpmbuild/SOURCES/</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压 <code>openssh</code> 源码包到其他目录，然后 copy 其构建目录下的 <code>openssh.spec</code> 文件到打包目录中的<code>SPECS</code> 子目录下，并修改文件权限</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxf openssh-8.8p1.tar.gz -C /opt/</span><br><span class="line">cp /opt/openssh-8.8p1/contrib/redhat/openssh.spec /root/rpmbuild/SPECS/</span><br><span class="line">chown sshd:sshd /root/rpmbuild/SPECS/openssh.spec</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>openssh.spec</code> 文件内容并进行打包</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i -e &quot;s/%global no_x11_askpass 0/%global no_x11_askpass 1/g&quot; openssh.spec</span><br><span class="line"></span><br><span class="line">sed -i -e &quot;s/%global no_gnome_askpass 0/%global no_gnome_askpass 1/g&quot; openssh.spec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">并注释掉 `BuildRequires: openssl-devel &lt; 1.1` 这行内容</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为openssl安装的版本低于1.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这时就可以rpmbuild打包了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成源码和rpm文件</span></span><br><span class="line">rpmbuild -ba openssh.spec</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩并下载生成的 rpm 包，以备后面使用</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/rpmbuild/RPMS/x86_64</span><br><span class="line">tar -zcvf openssh-8.8p1_rpm_package.tar.gz *.rpm</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-升级步骤"><a href="#2-升级步骤" class="headerlink" title="2. 升级步骤"></a>2. 升级步骤</h2><ol>
<li><p>备份配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/ssh_bak/</span><br><span class="line">cp /etc/ssh/sshd_config /opt/ssh_bak/</span><br><span class="line">cp /etc/pam.d/sshd /opt/ssh_bak/</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 telnet</p>
<blockquote>
<p>避免 openssh 升级识别无法登陆，安装telnet（同时开启两个窗口）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没有repo源就提前下载然后手动安装</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum localinstall xxx 或 rpm -ivh xxx</span></span><br><span class="line">yum install telnet-server xinetd -y</span><br><span class="line"></span><br><span class="line">systemctl enable --now xinetd.service</span><br><span class="line"></span><br><span class="line">systemctl enable --now telnet.socket</span><br></pre></td></tr></table></figure>


</li>
<li><p>配置 telnet 登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/^auth [user_unknown=/#&amp;/&#x27; /etc/pam.d/login</span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /etc/securetty &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">pts/0</span><br><span class="line">pts/1</span><br><span class="line">pts/2</span><br><span class="line">pts/3</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>


</li>
<li><p>安装升级 <code>openssh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf openssh-8.8p1_rpm_package.tar.gz</span><br><span class="line">yum localinstall ./*.rpm</span><br></pre></td></tr></table></figure>


</li>
<li><p>启动 ssh 服务，恢复备份文件，并重启 <code>sshd</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /opt/ssh_bak/sshd_config /etc/ssh/sshd_config</span><br><span class="line">cp /opt/ssh_bak/sshd /etc/pam.d/sshd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加或修改：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PermitRootLogin <span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PasswordAuthentication <span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">UseDNS no</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里主要修改PermitRootLogin <span class="built_in">yes</span>允许root用户登录，其他两个原有配置都是开启的</span></span><br><span class="line">sed -i &quot;s/#PermitRootLogin yes/PermitRootLogin yes/g&quot; /etc/ssh/sshd_config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改/etc/ssh/ 目录下key文件的权限</span></span><br><span class="line">chmod 600 /etc/ssh/*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启并添加开机自启</span></span><br><span class="line">systemctl restart sshd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为rpm默认没有systemctl <span class="built_in">enable</span> sshd 命令需要的文件，所以centos7也需要使用 centos6配置开机自启的命令</span></span><br><span class="line">chkconfig sshd on</span><br></pre></td></tr></table></figure>


</li>
<li><p>验证登录，和升级后 ssh 版本</p>
<blockquote>
<p>新开窗口连接登陆测试，没有问题后再进行下面的关闭telnet步骤。<br>注意：<strong>请勿关闭当前窗口，另外新开窗口连接没问题，再关闭。</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -V</span><br></pre></td></tr></table></figure>


</li>
<li><p>关闭 telnet</p>
<blockquote>
<p>注意：开启telnet的root远程登录极度不安全，账号密码都是明文传输，尤其在公网，所以一般只限于在某些情况下内网中ssh无法使用时，临时调测，使用完后，将相关配置复原，彻底关闭telnet服务！</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop telnet.socket &amp;&amp; systemctl disable telnet.socket</span><br><span class="line"></span><br><span class="line">systemctl stop xinetd.service &amp;&amp; systemctl disable xinetd.service</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="手动升级流程"><a href="#手动升级流程" class="headerlink" title="手动升级流程"></a>手动升级流程</h1><p>与 rpm 包升级流程的区别仅在于第4步骤，安装升级 <code>openssh</code></p>
<p>手动安装时，需要下载 <code>openssh-8.8p1.tar.gz</code> 源码到需要升级的机器上，编译然后安装</p>
<blockquote>
<p>参考其他博客内容，暂时不写，验证后再写。</p>
</blockquote>
<p>所谓羁绊，</p>
<ul>
<li>君以志诚待我，我必以志诚报之。</li>
</ul>
<h1 id="遇到问题及解决"><a href="#遇到问题及解决" class="headerlink" title="遇到问题及解决"></a>遇到问题及解决</h1><h2 id="1-制作-rpm-包遇到的问题"><a href="#1-制作-rpm-包遇到的问题" class="headerlink" title="1. 制作 rpm 包遇到的问题"></a>1. 制作 rpm 包遇到的问题</h2><p>制作时，参考其他博客或文章时，发现所有人默认都添加了 <code>x11-ssh-askpass</code> 这个包，但是查看该包作用时发现是 x11 可视化有关，考虑到我使用的是服务器模式，应该不需要，所以开始的时候，并没有添加这个包，结果制作过程中报错如下，缺少该包。</p>
<ul>
<li>应该是在specs文件中没有正确去掉，但是也没有深入研究，添加后就解决了。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没有添加 x11-ssh-askpass-1.2.4.1.tar.gz 包</span></span><br><span class="line">error: Bad file: /root/rpmbuild/SOURCES/x11-ssh-askpass-1.2.4.1.tar.gz: No such file or directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RPM build errors:</span><br><span class="line">    Bad file: /root/rpmbuild/SOURCES/x11-ssh-askpass-1.2.4.1.tar.gz: No such file or directory</span><br></pre></td></tr></table></figure>

<p>解决：下载并添加到报错指定的位置即可。</p>
<h2 id="2-x2F-etc-x2F-ssh-x2F-目录下的文件权限不对"><a href="#2-x2F-etc-x2F-ssh-x2F-目录下的文件权限不对" class="headerlink" title="2. &#x2F;etc&#x2F;ssh&#x2F; 目录下的文件权限不对"></a>2. &#x2F;etc&#x2F;ssh&#x2F; 目录下的文件权限不对</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test-for-qianxin-linshi1 dev_ops]# systemctl restart sshd</span><br><span class="line">Job for sshd.service failed because the control process exited with error code. See &quot;systemctl status sshd.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line">[root@test-for-qianxin-linshi1 dev_ops]#</span><br><span class="line"></span><br><span class="line">[root@test-for-qianxin-linshi1 dev_ops]# systemctl status sshd.service</span><br><span class="line">● sshd.service - SYSV: OpenSSH server daemon</span><br><span class="line">   Loaded: loaded (/etc/rc.d/init.d/sshd; bad; vendor preset: enabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Thu 2022-01-20 15:04:01 UTC; 51s ago</span><br><span class="line">     Docs: man:systemd-sysv-generator(8)</span><br><span class="line">  Process: 21036 ExecStop=/etc/rc.d/init.d/sshd stop (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 21077 ExecStart=/etc/rc.d/init.d/sshd start (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 1232 (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 sshd[21077]: It is required that your private key files are NOT accessible by others.</span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 sshd[21077]: This private key will be ignored.</span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 sshd[21077]: Unable to load host key &quot;/etc/ssh/ssh_host_ed25519_key&quot;: bad permissions</span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 sshd[21077]: Unable to load host key: /etc/ssh/ssh_host_ed25519_key</span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 systemd[1]: sshd.service: control process exited, code=exited status=1</span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 sshd[21077]: sshd: no hostkeys available -- exiting.</span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 systemd[1]: Failed to start SYSV: OpenSSH server daemon.</span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 sshd[21077]: [FAILED]</span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 systemd[1]: Unit sshd.service entered failed state.</span><br><span class="line">Jan 20 15:04:01 test-for-qianxin-linshi1 systemd[1]: sshd.service failed.</span><br></pre></td></tr></table></figure>

<p>问题：升级后重启sshd服务时报错，通过上面报错可知，&#x2F;etc&#x2F;ssh目录下的几个ssh key有问题。</p>
<p>解决：查看该目录有这些文件，那就是权限不对，修改权限为600即可。</p>
<h1 id="批量升级操作"><a href="#批量升级操作" class="headerlink" title="批量升级操作"></a>批量升级操作</h1><p>通过 ansible 脚本进行批量升级，</p>
<p>ansible脚本放在该文档的同级目录下，供参考。</p>
<h1 id="可能需要注意的"><a href="#可能需要注意的" class="headerlink" title="可能需要注意的"></a>可能需要注意的</h1><p>参考<a href="https://www.openssh.com/releasenotes.html">openssh_8.8p1的release</a></p>
<p>关于启用加密算法的问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">For most users, this change should be invisible and there is</span><br><span class="line">no need to replace ssh-rsa keys. OpenSSH has supported RFC8332</span><br><span class="line">RSA/SHA-256/512 signatures since release 7.2 and existing ssh-rsa keys</span><br><span class="line">will automatically use the stronger algorithm where possible.</span><br><span class="line"></span><br><span class="line">Incompatibility is more likely when connecting to older SSH</span><br><span class="line">implementations that have not been upgraded or have not closely tracked</span><br><span class="line">improvements in the SSH protocol. For these cases, it may be necessary</span><br><span class="line">to selectively re-enable RSA/SHA1 to allow connection and/or user</span><br><span class="line">authentication via the HostkeyAlgorithms and PubkeyAcceptedAlgorithms</span><br><span class="line">options. For example, the following stanza in ~/.ssh/config will enable</span><br><span class="line">RSA/SHA1 for host and user authentication for a single destination host:</span><br><span class="line"></span><br><span class="line">    Host old-host</span><br><span class="line">        HostkeyAlgorithms +ssh-rsa</span><br><span class="line">	PubkeyAcceptedAlgorithms +ssh-rsa</span><br><span class="line"></span><br><span class="line">We recommend enabling RSA/SHA1 only as a stopgap measure until legacy</span><br><span class="line">implementations can be upgraded or reconfigured with another key type</span><br><span class="line">(such as ECDSA or Ed25519).</span><br></pre></td></tr></table></figure>

<p>可能值老的远程客户端无法连接到升级后的远端机器上。</p>
<p>xshell6之前可能会遇到报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">找不到匹配的 host key 算法</span><br></pre></td></tr></table></figure>

<p>服务器端日志如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Apr  7 19:51:34 fgfc-web-1 sshd[4355]: Unable to negotiate with 10.2.10.17 port 65226: no matching host key type found. Their offer: ssh-rsa,ssh-dss [preauth]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就是上面默认不支持 <code>ssh-rsa</code> 算法导致</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>要么服务器端启用 <code>ssh-rsa</code> 算法，要么换一个客户端，例如 putty，或者 xhell6，或者xshell5中ssh-&gt; 安全性-&gt;密钥交换，有其他加密算法的也可以。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>OpenSSH</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OpenSSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux目录说明</title>
    <url>//Linux%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E.html</url>
    <content><![CDATA[<p><strong>&#x2F;etc&#x2F;passwd 存放账户信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">jianing:x:1011:100::/home/jianing:/bin/bash</span><br><span class="line"></span><br><span class="line">username:password:uid:gid:allname:homedir:shell</span><br><span class="line"></span><br><span class="line">用户名:密码:用户ID:组ID:用户全名:主目录:登录shell</span><br><span class="line"></span><br><span class="line">字段说明：</span><br><span class="line">用户名：登录用户</span><br><span class="line"></span><br><span class="line">密码：存在/etc/shadow中，存入后者的就用x表示,如果是“!”说明此用户不能用密码登录</span><br><span class="line"></span><br><span class="line">UID：就是用户识别码（ID），当UID为0时说明其账号是管理员身份，1-499是保留给系统使用的主要是一些系统服务,500-65535是给一般用户的。</span><br><span class="line"></span><br><span class="line">GID：与/etc/group文件有关，就是用户初始化组的ID。</span><br><span class="line"></span><br><span class="line">用户全名：用户全名</span><br><span class="line"></span><br><span class="line">家目录：就是该用户的主目录</span><br><span class="line"></span><br><span class="line">Shell：用户登录时的默认shell，在centos中，通常是 /bin/bash</span><br></pre></td></tr></table></figure>



<p><strong>&#x2F;etc&#x2F;shadow  存放用户密码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root:$2a$32$3lnW8AXwIZy.Ibh0T2k3huMil/ZGEOQwe3EvJJzfnIcnPzxTamjke:14916::::::</span><br><span class="line"></span><br><span class="line">jianing:$2a$10$AmxqDaxMITQoEr4HGcM/zO6JzJWMVcHpxmXdWKVOX5Tb/WWQ/m8wK:14853:0:99999:7:::</span><br><span class="line"></span><br><span class="line">aj:!:15006:0:99999:7:::</span><br><span class="line"></span><br><span class="line">username:password:last_change:min_change:max_change:warm:failed_expire:expiration:reserved</span><br><span class="line"></span><br><span class="line">账号名称:密码:最近更改密码的日期(from 1974-1-1):密码不可更改的天数:密码需要重新更改的天数:密码更改期限前的警告日期:密码过期的宽限时间:账号失效时间:保留</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>&#x2F;etc&#x2F;group 用户组信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> root:x:0:</span><br><span class="line"></span><br><span class="line">test:!:1005:u01,u02,u03,cvsroot</span><br><span class="line"></span><br><span class="line">groupname:password:gid:members</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">组名：密码：组ID：成员</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSH使用遇到的问题</title>
    <url>//OpenSSH%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="参数写错配置文件"><a href="#参数写错配置文件" class="headerlink" title="参数写错配置文件"></a>参数写错配置文件</h1><p>sshd 服务报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/ssh/sshd_config: line 43: Bad configuration option: StrictHostKeyChecking</span><br><span class="line">/etc/ssh/sshd_config: line 44: Bad configuration option: UserKnownHostsFile</span><br></pre></td></tr></table></figure>

<p>原因如下：</p>
<p>在 <code>/etc/ssh/sshd_config</code> 配置文件中添加了如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">StrictHostKeyChecking no</span><br><span class="line">UserKnownHostsFile /dev/null</span><br></pre></td></tr></table></figure>



<p><strong>说明解释：</strong></p>
<p>上面两个选项是 <code>ssh_config</code> 客户端配置中的，并不是 <code>sshd_config</code> 服务端的配置。因为配置在了错误的配置文件中导致 <code>sshd</code> 服务停止。</p>
<p>可以通过下面命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man ssh_config</span><br></pre></td></tr></table></figure>

<blockquote>
<p>StrictHostKeyChecking</p>
<p>​	If this flag is set to no or off, ssh will automatically add new host keys to the user known hosts files and allow connections to hosts with changed hostkeys to proceed, subject to some restrictions.</p>
<p> UserKnownHostsFile<br>         Specifies one or more files to use for the user host key database, separated by whitespace.</p>
</blockquote>
<p>通常这两个 ssh 客户端参数组合使用，用来完成 ssh 无口令登录（即通过客户端公钥认证，就可以直接连接到远程主机）。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>OpenSSH</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OpenSSH</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH使用记录</title>
    <url>//SSH%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="REMOTE-HOST-IDENTIFICATION-HAS-CHANGED"><a href="#REMOTE-HOST-IDENTIFICATION-HAS-CHANGED" class="headerlink" title="REMOTE HOST IDENTIFICATION HAS CHANGED"></a>REMOTE HOST IDENTIFICATION HAS CHANGED</h1><p>ssh远程登录云主机报错如下，远程主机认证key变了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[user@hostname ~]$ ssh root@pong</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line">6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending RSA key in /var/lib/sss/pubconf/known_hosts:4</span><br><span class="line">RSA host key for pong has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R &lt;host&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-R hostname  从known_hosts文件中删除属于主机名的所有键。</p>
</blockquote>
<h1 id="no-matching-host-key-type-found-Their-offer-ssh-dss"><a href="#no-matching-host-key-type-found-Their-offer-ssh-dss" class="headerlink" title="no matching host key type found. Their offer: ssh-dss"></a>no matching host key type found. Their offer: ssh-dss</h1><p>ssh 登录时报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.8.109</span><br><span class="line"></span><br><span class="line">Unable to negotiate with 192.168.8.109 port 22: no matching host key type found. Their offer: ssh-rsa</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -oHostKeyAlgorithms=+ssh-rsa root@192.168.8.109</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因，OpenSSH 升级后，默认删除了 ssh-rsa 算法，在访问时临时指定，或者可以在 <code>~/.ssh/config</code> 或者 <code>/etc/ssh/ssh_config</code> 文件中添加如下内容。</p>
<p>详细内容可以参考 <a href="http://www.openssh.com/legacy.html">http://www.openssh.com/legacy.html</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host bitbucket.org</span><br><span class="line">    HostKeyAlgorithms +ssh-rsa</span><br><span class="line">    PubkeyAcceptedKeyTypes +ssh-rsa</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim使用帮助</title>
    <url>//Vim%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9.html</url>
    <content><![CDATA[<h1 id="常遇到的问题"><a href="#常遇到的问题" class="headerlink" title="常遇到的问题"></a>常遇到的问题</h1><h2 id="Vim-中复制粘贴缩进错乱问题解决"><a href="#Vim-中复制粘贴缩进错乱问题解决" class="headerlink" title="Vim 中复制粘贴缩进错乱问题解决"></a>Vim 中复制粘贴缩进错乱问题解决</h2><p>通常直接在插入模式中粘贴外面复制的代码，会出现缩进错乱的情况。</p>
<p><strong>解决方法</strong></p>
<p>vim 进入 paste 模式，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:set paste</span><br></pre></td></tr></table></figure>

<p>进入 paste 模式后，再按<code>i</code> 进入插入模式，此时进行复制粘贴格式就正常了。</p>
<p>解除 paste 模式，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:set nopaste</span><br></pre></td></tr></table></figure>



<p>paste 模式主要帮我们做了如下事情：</p>
<blockquote>
<ul>
<li>textwidth设置为0</li>
<li>wrapmargin设置为0</li>
<li>set noai</li>
<li>set nosi</li>
<li>softtabstop设置为0</li>
<li>revins重置</li>
<li>ruler重置</li>
<li>showmatch重置</li>
<li>formatoptions使用空值</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>yum包管理工具使用</title>
    <url>//yum%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="仅下载不安装"><a href="#仅下载不安装" class="headerlink" title="仅下载不安装"></a>仅下载不安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install --downloadonly --downloaddir=tmp vsftpd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要指定两个参数，</p>
<p>–downloadonly   ，表明仅下载</p>
<p>–downloaddir&#x3D;&lt;存储的位置&gt;</p>
</blockquote>
<h1 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h1><h3 id="方法1-yum-C-install"><a href="#方法1-yum-C-install" class="headerlink" title="方法1. yum -C install"></a>方法1. yum -C install</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">把下载的包，copy 到缓存包的默认目录中，</span><br><span class="line">/var/cache/yum/x86_64/7/base/packages/</span><br><span class="line"></span><br><span class="line">yum -C install  [packageName]</span><br></pre></td></tr></table></figure>



<h3 id="方法2-yum-localinstall"><a href="#方法2-yum-localinstall" class="headerlink" title="方法2. yum localinstall"></a>方法2. yum localinstall</h3><p>直接指定本地包的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall xxx.rpm</span><br></pre></td></tr></table></figure>



<h3 id="方法3-rpm-ivh"><a href="#方法3-rpm-ivh" class="headerlink" title="方法3. rpm -ivh"></a>方法3. rpm -ivh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh xxx.rpm</span><br></pre></td></tr></table></figure>



<h1 id="查看RPM包内容"><a href="#查看RPM包内容" class="headerlink" title="查看RPM包内容"></a>查看RPM包内容</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qpl zabbix-agent-5.0.21-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看 zabbix-agent-5.0.21-1.el7.x86_64.rpm 包的内容</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">效果如下：会列出包中文件</span><br><span class="line">/etc/logrotate.d/zabbix-agent</span><br><span class="line">/etc/zabbix/zabbix_agentd.conf</span><br><span class="line">/etc/zabbix/zabbix_agentd.d</span><br><span class="line">/usr/lib/systemd/system/zabbix-agent.service</span><br><span class="line">/usr/lib/tmpfiles.d/zabbix-agent.conf</span><br><span class="line">/usr/sbin/zabbix_agentd</span><br><span class="line">/usr/share/doc/zabbix-agent-5.0.21</span><br><span class="line">/usr/share/doc/zabbix-agent-5.0.21/AUTHORS</span><br><span class="line">/usr/share/doc/zabbix-agent-5.0.21/COPYING</span><br><span class="line">/usr/share/doc/zabbix-agent-5.0.21/ChangeLog</span><br><span class="line">/usr/share/doc/zabbix-agent-5.0.21/NEWS</span><br><span class="line">/usr/share/doc/zabbix-agent-5.0.21/README</span><br><span class="line">/usr/share/doc/zabbix-agent-5.0.21/userparameter_mysql.conf</span><br><span class="line">/usr/share/man/man8/zabbix_agentd.8.gz</span><br><span class="line">/var/log/zabbix</span><br><span class="line">/var/run/zabbix</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
        <category>包管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Yum</tag>
        <tag>包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>现场Keepalived配置测试</title>
    <url>//%E7%8E%B0%E5%9C%BAKeepalived%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95.html</url>
    <content><![CDATA[<h1 id="keepalived配置"><a href="#keepalived配置" class="headerlink" title="keepalived配置"></a>keepalived配置</h1><p>配置主备，抢占和非抢占模式下的HA（高可用）</p>
<ol>
<li>yum 安装 keepalived</li>
<li>为了通过web来测试，安装nginx，（nginx使用tengine的包）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install keepalived</span><br><span class="line">yum -y install tengine</span><br></pre></td></tr></table></figure></li>
<li>分别配置主副节点的keepalived.conf 配置， 目前仅做简单配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id LVS_DEVEL  # 删除了email通知</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置一个vrrp_instacne 名字随便</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    # 分别是主备</span><br><span class="line">    state MASTER/BACKUP</span><br><span class="line">    # 选择绑定那张网卡，需要是在用的</span><br><span class="line">    interface eth1</span><br><span class="line">    # 主备id要一样</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    # 主备优先级值一般设置不一样，但是应该遵循master_priority - backup_priority &lt; weight (如果有设置vrrp_script，且设置了weight的情况下)</span><br><span class="line">    priority 100</span><br><span class="line">    # 通信时间</span><br><span class="line">    advert_int 1</span><br><span class="line">    # 认证方式，密码一样，方便主备通信</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    # 绑定的VIP(虚拟IP，即对外用的IP地址)，可以是多个，每行一个。</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.10.193</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分别启动服务，然后通过浏览器访问192.168.10.193:15003（我设置nginx监控15003端口，没有使用80），来确定keepalive生效</li>
</ol>
<p>当master节点挂掉重启后，会自动抢占成为master</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主节点关掉后，主节点日志：</span><br><span class="line">Apr 14 00:02:12 ora12c Keepalived[1944]: Stopping Keepalived v1.2.13 (03/19,2015)</span><br><span class="line">Apr 14 00:02:12 ora12c Keepalived_vrrp[1946]: VRRP_Instance(VI_1) sending 0 priority</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">备节点的状态：</span><br><span class="line">Apr 13 16:14:00 interface16 Keepalived_vrrp[14033]: VRRP_Instance(VI_1) Transition to MASTER STATE</span><br><span class="line">Apr 13 16:14:01 interface16 kernel: ACPI: No handler for Region [POWR] (ffff881821ff72b8) [IPMI]</span><br><span class="line">Apr 13 16:14:01 interface16 Keepalived_vrrp[14033]: VRRP_Instance(VI_1) Entering MASTER STATE</span><br><span class="line">Apr 13 16:14:01 interface16 Keepalived_vrrp[14033]: VRRP_Instance(VI_1) setting protocol VIPs.</span><br><span class="line">Apr 13 16:14:01 interface16 Keepalived_vrrp[14033]: VRRP_Instance(VI_1) Sending gratuitous ARPs on em1 for 192.168.10.193</span><br><span class="line">Apr 13 16:14:01 interface16 Keepalived_healthcheckers[14032]: Netlink reflector reports IP 192.168.10.193 added</span><br><span class="line">Apr 13 16:14:06 interface16 Keepalived_vrrp[14033]: VRRP_Instance(VI_1) Sending gratuitous ARPs on em1 for 192.168.10.193</span><br><span class="line"></span><br><span class="line">备用节点ip情况：</span><br><span class="line">2: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether b8:2a:72:de:40:c3 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.10.170/24 brd 192.168.10.255 scope global em1</span><br><span class="line">    inet 192.168.10.193/32 scope global em1</span><br><span class="line">    inet6 fe80::ba2a:72ff:fede:40c3/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">此时VIP已经漂移到170这台机器上了</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">主节点：重启后，messages的日志</span><br><span class="line">Apr 13 23:47:43 ora12c Keepalived_healthcheckers[1945]: Using LinkWatch kernel netlink reflector...</span><br><span class="line">Apr 13 23:47:43 ora12c Keepalived_vrrp[1946]: VRRP_Instance(VI_1) Transition to MASTER STATE</span><br><span class="line">Apr 13 23:47:43 ora12c Keepalived_vrrp[1946]: VRRP_Instance(VI_1) Received lower prio advert, forcing new election</span><br><span class="line">Apr 13 23:47:44 ora12c Keepalived_vrrp[1946]: VRRP_Instance(VI_1) Entering MASTER STATE</span><br><span class="line"></span><br><span class="line">此时主节点ip情况</span><br><span class="line">2: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:10:4f:bc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.10.191/24 brd 192.168.10.255 scope global eth1</span><br><span class="line">    inet 192.168.10.193/32 scope global eth1</span><br><span class="line">设置的对外IP（即VIP）绑定到 191这台机器上了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">备节点此时状态：</span><br><span class="line">Apr 13 16:15:22 interface16 Keepalived_vrrp[14033]: VRRP_Instance(VI_1) Received higher prio advert</span><br><span class="line">Apr 13 16:15:22 interface16 Keepalived_vrrp[14033]: VRRP_Instance(VI_1) Entering BACKUP STATE</span><br><span class="line">Apr 13 16:15:22 interface16 Keepalived_vrrp[14033]: VRRP_Instance(VI_1) removing protocol VIPs.</span><br><span class="line">Apr 13 16:15:22 interface16 Keepalived_healthcheckers[14032]: Netlink reflector reports IP 192.168.10.193 removed</span><br><span class="line">Apr 13 16:15:24 interface16 ntpd[2105]: Deleting interface #7 em1, 192.168.10.193#123, interface stats: received=0, sent=0, dropped=0, active_time=81 secs</span><br><span class="line"></span><br><span class="line">此时备节点ip情况：</span><br><span class="line">2: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether b8:2a:72:de:40:c3 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.10.170/24 brd 192.168.10.255 scope global em1</span><br><span class="line">    inet6 fe80::ba2a:72ff:fede:40c3/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非抢占模式</p>
<p>非抢占模式配置：</p>
<ol>
<li>主备文件中都在vrrp_instance中添加参数<code>nopreempt</code>，表示不争抢</li>
<li>在vrrp_instance中将state都改为BACKUP<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">修改完成后先停用主节点，重启备用节点的keepalived进程，</span><br><span class="line">目的是，让备用节点先拿到VIP，验证启动主节点进程后，VIP不会漂移到主节点  --ok，因为配置了nopreempt参数，所以主节点不会抢占，</span><br><span class="line"></span><br><span class="line">此时备用节点ip情况：</span><br><span class="line">2: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether b8:2a:72:de:40:c3 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.10.170/24 brd 192.168.10.255 scope global em1</span><br><span class="line">    inet 192.168.10.193/32 scope global em1</span><br><span class="line"></span><br><span class="line">杀掉备用节点进程</span><br><span class="line">[root@interface16 ~]# killall keepalived</span><br><span class="line"></span><br><span class="line">此时主节点会变成MASTER主节点，日志：</span><br><span class="line">Apr 14 00:20:16 ora12c Keepalived_vrrp[2213]: VRRP_Instance(VI_1) Transition to MASTER STATE</span><br><span class="line">Apr 14 00:20:17 ora12c Keepalived_vrrp[2213]: VRRP_Instance(VI_1) Entering MASTER STATE</span><br><span class="line">Apr 14 00:20:17 ora12c Keepalived_vrrp[2213]: VRRP_Instance(VI_1) setting protocol VIPs.</span><br><span class="line">Apr 14 00:20:17 ora12c Keepalived_vrrp[2213]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth1 for 192.168.10.193</span><br><span class="line">Apr 14 00:20:17 ora12c Keepalived_healthcheckers[2212]: Netlink reflector reports IP 192.168.10.193 added</span><br><span class="line">Apr 14 00:20:22 ora12c Keepalived_vrrp[2213]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth1 for 192.168.10.193</span><br><span class="line"></span><br><span class="line">主节点ip情况：</span><br><span class="line">2: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 00:0c:29:10:4f:bc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.10.191/24 brd 192.168.10.255 scope global eth1</span><br><span class="line">    inet 192.168.10.193/32 scope global eth1</span><br><span class="line">    inet6 fe80::20c:29ff:fe10:4fbc/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft foreve</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">综上，当设置nopreempt非抢占模式时，会根据priority大小选举一个MASTER节点，但是当MASTER节点的keepalived进程出现问题，即使恢复后，就不会再主动抢占MASTER，</span><br><span class="line">但是如果其他备用节点的keepalived进程都出现问题时，该节点会自动接管成为MASTER。</span><br><span class="line">--所以，这也是网上教程中都在提的双主模式下，通过杀掉keepalived进程，实现出现问题时完成主备切换。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Keepalived</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel使用学习</title>
    <url>//Excel%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="将Unix-10位的时间戳转换为指定日期格式"><a href="#将Unix-10位的时间戳转换为指定日期格式" class="headerlink" title="将Unix 10位的时间戳转换为指定日期格式"></a>将Unix 10位的时间戳转换为指定日期格式</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=TEXT((P2+8*3600)/86400+70*365+19,&quot;yyyy-mm-dd hh:mm:ss&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Excel 的时期实际上是序列值，它以1900-01-01为1，每过一天序列值+1；</p>
<p>Unix时间戳是从<code>1970-01-01 00:00:00 UTC</code> 开始到现在经过的秒杀；</p>
<p>所以在Excel中转换Unix的时间戳时需要+70年的时间；</p>
</blockquote>
<ul>
<li><p><code>TEXT()</code>，是Excel公式；</p>
</li>
<li><p>P2，是时间戳所在单元格；</p>
</li>
<li><p><code>8*3600</code>，为中国所在东八区时区，所以<code>+8*3600</code> ；</p>
</li>
<li><p><code>P2 + 8*3600</code>，计算当前时区的时间（秒）；</p>
</li>
<li><p><code>(P2+8*3600)/86400</code>，转换单位为天；</p>
</li>
<li><p><code>(P2+8*3600)/86400+70*365</code>，加上1900到1970这70年；</p>
</li>
<li><p><code>(P2+8*3600)/86400+70*365+19</code>，闰年多出来的天数；</p>
<blockquote>
<p>1900年到1970年共17个闰年，考虑到Excel将1900-01-01作为1，那么公式应该+18，为什么要加19？</p>
<p>答：这是Excel的一个BUG，1900年也被当做闰年了，因此需要多+1。</p>
</blockquote>
</li>
</ul>
<p><strong>注意1</strong>：另外，在Excel的工具-&gt; 选项-&gt;重新计算中，有个1904年日期系统，如果勾选这个选项，上面的公式应当将70改为66，即<code>(P2+8*3600)/86400+66*365+19</code></p>
<p><strong>注意2</strong>： 如果需要转换的Unix时间戳为13位的ms格式，那么公式P2部分需要先除1000，即<code>(P2/1000 + 8*3600)/86400 + 66*365 + 19</code></p>
<p>转换效果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1658746074	-&gt;	2022-07-25 18:47:54</span><br></pre></td></tr></table></figure>



<h1 id="Excel-删除筛选的内容"><a href="#Excel-删除筛选的内容" class="headerlink" title="Excel 删除筛选的内容"></a>Excel 删除筛选的内容</h1><ol>
<li>通过<strong>筛选</strong>功能，在名字列筛选选择张三李四。 </li>
<li>选择将要删除的数据整行。 </li>
<li>通过快捷键Ctrl+G调出定位窗口→“<strong>定位</strong>”→选择“<strong>可见单元格</strong>”→“确定”。</li>
<li>在所定位的行范围内右键选择删除。</li>
</ol>
<p>这样就解决了删除excel中筛选的内容的问题了。</p>
<h1 id="查询函数VLOOKUP"><a href="#查询函数VLOOKUP" class="headerlink" title="查询函数VLOOKUP"></a>查询函数VLOOKUP</h1><p>vlookup</p>
<ul>
<li><p>公式基础使用 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vlookup(用哪一列查询,在哪个表中的什么范围使用,取第几列[需要多列，可以使用&#123;&#125;括号，用逗号分隔],精确匹配/模糊匹配)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vlookup(A2,Sheet1!A:E,&#123;2,5,3&#125;,0)  表示用A来查询，在Sheet1!A:E范围查询，取2,5,3三列，精确匹配。 该函数会自动扩展三列。</span><br></pre></td></tr></table></figure>


</li>
<li><p>iferror(正确的值,出错后给出的默认值（例如：””）)</p>
</li>
<li><p>下拉填充，选择不带格式填充（这个可以解决填充后覆盖原有行的颜色或者其他格式）</p>
</li>
<li><p>常量数组，</p>
<ul>
<li>常规写函数后，按住F9，这样会将依赖的表，自动转化为常量数组。</li>
<li>好处：此时可以删除依赖的辅助表中的数据，结果也不会出错。</li>
</ul>
</li>
</ul>
<p>if，可以嵌套</p>
]]></content>
      <categories>
        <category>Office</category>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Office</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>MAVEN使用学习</title>
    <url>//MAVEN%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="MAVEN"><a href="#MAVEN" class="headerlink" title="MAVEN"></a>MAVEN</h1><h3 id="maven编译过程"><a href="#maven编译过程" class="headerlink" title="maven编译过程"></a>maven编译过程</h3><h4 id="编译主代码"><a href="#编译主代码" class="headerlink" title="编译主代码"></a>编译主代码</h4><ul>
<li><p>mvn clean compile</p>
<p>clean 告诉maven清理输出目录target（target目录为maven默认构建的所有输出都在target目录中）</p>
<p>comile 告诉maven编译项目主代码</p>
</li>
</ul>
<p>依次执行的过程为</p>
<p>clean，</p>
<p>resources项目主资源处理（如果没有定义项目资源，会跳过）</p>
<p>compile编译主代码，将项目主代码编译到targe&#x2F;classes目录</p>
<h4 id="执行测试代码"><a href="#执行测试代码" class="headerlink" title="执行测试代码"></a>执行测试代码</h4><ul>
<li>mvn clean test<ol>
<li>clean</li>
<li>resources</li>
<li>compile</li>
<li>testResources</li>
<li>testCompile</li>
<li>test</li>
</ol>
</li>
</ul>
<h4 id="打包和运行"><a href="#打包和运行" class="headerlink" title="打包和运行"></a>打包和运行</h4><ul>
<li><p>mvn clean package</p>
<ol>
<li>clean</li>
<li>resources</li>
<li>compile</li>
<li>testResources</li>
<li>testCompile</li>
<li>test</li>
<li>jar,打包插件</li>
</ol>
</li>
<li><p>mvn clean install</p>
<p>如果是maven项目要想直接在pom.xml文件中引入该jar包，则需要把该jar包安装在本地仓库中</p>
<ul>
<li>在执行打包之前，依次执行了编译，测试，打包</li>
</ul>
<p>这条命令会将jar包打包并安装在本地的mvn仓库中</p>
</li>
</ul>
<h3 id="maven构成–坐标"><a href="#maven构成–坐标" class="headerlink" title="maven构成–坐标"></a>maven构成–坐标</h3><ul>
<li>基础坐标<ol>
<li>groupId</li>
<li>artifactId</li>
<li>version</li>
</ol>
</li>
</ul>
<h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>maven项目中需要使用其他依赖时，需要在pom.xml中配置<code>&lt;dependency&gt;</code> 元素，作为依赖声明。</p>
<p>这样在编写项目时就可以使用依赖了，并且会在打包时自动将依赖的jar包打包到项目中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>...<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">optional</span>&gt;</span>...<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>依赖范围</p>
<ol>
<li>编译classpath:编译主代码有效</li>
<li>测试classpath：编译、运行测试代码有效</li>
<li>运行classpath：项目运行时有效</li>
</ol>
</li>
<li><p>maven的依赖范围：</p>
<ol>
<li>compile</li>
<li>test</li>
<li>provided</li>
<li>runtime</li>
<li>system</li>
</ol>
</li>
<li><p>依赖传递</p>
</li>
<li><p>依赖优先</p>
</li>
<li><p>可选依赖</p>
</li>
<li><p>排除依赖</p>
</li>
<li><p>归类依赖</p>
<p>当依赖的多个模块版本相同时，为了方便统一，所以用<code>properties</code> 元素定义maven属性，</p>
<p>通过使用${xxx}替换掉实际值，将所有依赖的版本值都使用这一引用值表示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">....</span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>4.3.2.RELEASE<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看已解析依赖</p>
<p><code>mvn dependency:list</code></p>
</li>
<li><p>查看依赖树</p>
<p><code>mvn dependency:tree</code></p>
</li>
<li><p>分析依赖书</p>
<p><code>mvn dependency:analyze</code></p>
<p>分析结果有两部分：</p>
<ul>
<li>Used undeclared dependencies found：表示为项目中使用到的，但是没有显示声明的依赖(可能为传递依赖)</li>
<li>Unused declared dependencies found：表示项目中未使用的，但显示声明的依赖，没有使用是指没有在编译主代码和测试代码中使用的依赖，也有可能在项目运行中会使用</li>
</ul>
</li>
</ul>
<h3 id="maven仓库-–从仓库解析依赖的机制"><a href="#maven仓库-–从仓库解析依赖的机制" class="headerlink" title="maven仓库 –从仓库解析依赖的机制"></a>maven仓库 –从仓库解析依赖的机制</h3><p>仓库分类：</p>
<ol>
<li>本地仓库</li>
<li>远程仓库<ol>
<li>中央仓库</li>
<li>私服</li>
</ol>
</li>
</ol>
<h4 id="远程仓库配置"><a href="#远程仓库配置" class="headerlink" title="远程仓库配置"></a>远程仓库配置</h4><ol>
<li><p>配置</p>
<p>默认的中央仓库如果无法满足项目需求，可能需要的构件在其他的远程仓库，如JBoss Maven仓库，可以在pom中配置该仓库。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">....</span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.jboss.com/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"> ....</span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解释</p>
<ul>
<li><p>id要唯一</p>
</li>
<li><p>release的enabled 为true，表示开始JBoss仓库的发布版本下载支持，从上面的配置来看，maven只从JBoss仓库中下载发布版的构件而不会下载snapshot快照版本。</p>
</li>
<li><p>对于releases和snapshots来说，除了enabled还包含两个子元素updataPolicy和checksumPolicy</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updataPolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updataPolicy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>updataPolicy:配置maven从远程仓库检查更新的频率，对<strong>同一个版本（如：log4j.1.2.15.jar）</strong>的构件如果发现有更新（如：对log4j.1.2.15.jar进行了内容修复但是版本都不变）会下载最新的。默认daily-maven每天检查一次</li>
</ul>
<p> never-从不检查；always-每次构件都要检查更新；interval:X -每隔X分钟检查一次更新（X为整数）</p>
<ul>
<li><strong>当然：用户可以使用参数-U,强制检查更新，使用参数后，maven就会忽略updatePolicy的配置。</strong></li>
<li>checksumPolicy:用来配置Maven检查校验和文件失败后的策略。构件被部署到maven仓库中时会同时部署对应的校验和文件，maven会验证校验和文件以确定下载的构件是否完整，如果校验失败，怎么办？策略有3中：(默认值)warn-maven会执行构建时输出警告信息；fail-maven遇到校验和错处就让构建失败；ignore-使maven完全忽略校验和错误。</li>
</ul>
</li>
</ul>
<h4 id="部署当前maven项目到远程仓库"><a href="#部署当前maven项目到远程仓库" class="headerlink" title="部署当前maven项目到远程仓库"></a>部署当前maven项目到远程仓库</h4><ol>
<li><p>需求</p>
<ul>
<li>私服的一个作用是部署公司内部生成的构件以及一些无法从外部仓库获取的构件。那么如何把maven项目部署到私服上或者其他的远程服务器上呢？</li>
</ul>
</li>
<li><p>操作步骤</p>
<p><strong>步骤-1配置pom.xml</strong><br>需要编写pom.xml文件，配置distributionManagement元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>proj-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Proj Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.100/content/repositories/proj-releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>proj-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>Proj Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.100/content/repositories/proj-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>distributionManagement包含repository和snapshotRepository子元素，前者表示发布版本构件的仓库，后者表示快照版本的仓库。</li>
<li>id为远程仓库的唯一标识，name是为了方便人阅读，url表示该仓库的地址。</li>
</ul>
<p><strong>步骤-2配置settings.xml</strong></p>
<ul>
<li><p>往仓库部署构件往往<em>需要认证</em>，配置方式如上面所讲，只需要配置<code>settings.xml</code>中的server元素。同时其id要与仓库id匹配。不论部署还是下载构件，当需要认证时配置方式一样。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"> <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">server</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-proj<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>repo-user<span class="tag">&lt;/<span class="name">username</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>repo-pwd<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;/<span class="name">server</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的id&#x3D;my-proj一定要和pom.xml中仓库的id一致，这是它们之间唯一的联系。</p>
<p>settings.xml的servers中就是用来配服务器授权信息的，当然不仅可以配置仓库服务器认证信息，还可以配置其它的比如tomcat服务器授权信息也可以在这里配置。</p>
</li>
</ul>
<p><strong>步骤-3使用部署命令</strong></p>
<ul>
<li>在命令行运行 mvn clean deploy。Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目版本是快照版本就部署到快照版本仓库地址，同理发布版本仓库地址。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="从仓库解析依赖的机制（重要）"><a href="#从仓库解析依赖的机制（重要）" class="headerlink" title="从仓库解析依赖的机制（重要）"></a>从仓库解析依赖的机制（重要）</h4><p>maven是根据怎样的规则从仓库解析并使用依赖的构件的呢？</p>
<ul>
<li><p>1.解析构件步骤（插件、依赖的解析）</p>
<ol>
<li><p>当依赖范围是system时候，Maven直接从本地文件解析构件。</p>
</li>
<li><p>根据依赖坐标计算仓库路径后，先从本地仓库寻找构件，如果发现则解析成功。</p>
</li>
<li><p>本地仓库没找到，如果依赖版本(version)是发布版构件，即1.2,2.3等，则遍历远程仓库，发现后下载并解析使用。</p>
</li>
<li><p>如果version是SNAPSHOT版，如：2.1-SNAPSHOT，则基于更新策略（updatepolicy）读取所有远程仓库的元数据groupId&#x2F;artifactId&#x2F;<strong>version&#x2F;maven-metadata.xml</strong>，将其与本地仓库的对应元数据合并后，得到最新快照版本的值，然后基于该值检查本地仓库，或者从远程仓库下载。（如果最新版还是之前的值就不需要去远程仓库下载了）。</p>
<p><strong>注意：这一步因为updatepolicy的原因，可能要求本机能连接到远程仓库（远程仓库可以是私服或者中央仓库，一般只有自己的项目会使用SNAPSHOT，所以大多数是私服</strong></p>
</li>
<li><p>如果最后解析得到构件版本是时间戳格式的快照，如1.4.1-20161121.121432-121则复制其时间戳格式的文件至非时间戳格式，如SNAPSHOT，并使用该时间戳格式的构件。</p>
</li>
<li><p>当依赖的version值为RELEASE时（不建议），Maven会基于updatepolicy策略读取远程仓库的元数据groupId&#x2F;artifactId&#x2F;<strong>maven-metadata.xml</strong>，将其与本地仓库相对应元数据合并后，计算出最新版本的RELEASE值（稳定版），然后基于这个值检查本地和远程仓库，步骤如2和3。</p>
<p><strong>注意：存在潜在问题，如某个依赖的1.1版本与1.2版本可能发生一些接口变化，从而导致当前Maven项目构建失败，所以依赖的版本最好确定</strong></p>
<p><strong>注：第4步骤在6.2、6.3节有详解</strong></p>
</li>
</ol>
</li>
<li><p>2.解析进一步说明</p>
</li>
</ul>
<h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><ul>
<li><p>什么是<strong>镜像</strong> ？</p>
<p>如果仓库x可以提供仓库y存储的所有内容，那么就可以认为x是y的一个镜像mirror</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven.net.cn<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>one of the central mirrors in China<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.net.cn/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的配置中，mirrorOf为central,表示该配置为中央仓库的镜像，任何对于中央仓库的请求都会转到该镜像。用户也可以使用该方式，配置其他仓库的镜像。</li>
<li>镜像一般用在私服上，因为私服代理了任何外部的公共仓库，对于组织内容的maven用户来说，使用一个私服地址等于使用所有外部仓库。</li>
</ul>
</li>
</ul>
<h3 id="maven-生命周期和插件"><a href="#maven-生命周期和插件" class="headerlink" title="maven 生命周期和插件"></a>maven 生命周期和插件</h3><p>maven的设计中，实际的任务(如编译源代码)都交给插件来完成，这种设计思想类似于设计模式中的<strong>模板方法</strong></p>
<p><strong>模板方法模式</strong>：在父类中定义算法的整体结构，子类可以通过实现或者重写父类的方法来控制实际的行为。这样既保证了算法足够的可扩展性，又严格控制算法的整体结构</p>
<ul>
<li><p>**maven生命周期 **</p>
<ol>
<li><p>maven的生命周期抽象类构建的各个步骤，定义了次序，但是么有提供具体实现，由<em>插件</em> 来实现。</p>
</li>
<li><p>maven的生命周期的每个阶段都可以绑定一个或多个插件行为，并且maven的大多数构建步骤绑定了默认的插件</p>
</li>
<li><p>maven生命周期与插件机制的优点：</p>
<p>一方面，保证了所有maven项目都有一致的构建标准(步骤)，</p>
<p>另一方面，通过默认插件，简化和稳定了实际项目构建</p>
<p>此外，这个机制还提供了足够的扩展空间，用户可以通过配置现有插件或者自行编写插件来完成自定义构建行为。</p>
</li>
</ol>
</li>
<li><p>**三套生命周期 **</p>
<p>项目构建的生命周期一般包括：项目清理，初始化，编译，测试，打包，集成测试，验证，部署，站点生成等阶段</p>
<ul>
<li>maven简化了构建过程，三套独立的生命周期：<code>clean</code> ,<code>default</code> , <code>site</code> .</li>
</ul>
<p>每个生命周期内都有各个阶段，每个阶段都是由次序关系的</p>
<ul>
<li><strong>clean</strong>： 清理项目</li>
<li><strong>default：</strong> 构建项目（核心生命周期）</li>
<li>**site: ** 建立项目站点</li>
</ul>
</li>
<li><p><strong>命令行与生命周期</strong></p>
<ul>
<li>从命令行执行maven任务，最主要的方式是<em>调用maven生命周期</em></li>
<li>$ mvn clean : 该命令，调用clean生命周期的clean阶段，实际执行的阶段为clean生命周期的pre-clean 和clean阶段</li>
<li>$ mvn clean deploy site-deploy：该命令调用clean生命周期的clean阶段、default周期的deploy阶段、site生命周期的site-deploy阶段。实际执行clean生命周期pre-clean,clean<br> 阶段，default生命周期所有阶段，site生命周期所有阶段。</li>
<li>$ mvn clean install所执行的任务</li>
</ul>
</li>
<li><p><strong>插件目标</strong></p>
<ul>
<li>Maven的核心仅仅定义了抽象生命周期，具体工作由插件完成，对于插件本身，为了能够实现代码复用，它往往能完成多个任务，也就具有多个功能，这些功能聚集在一个插件中，每个功能就叫做一个插件目标。</li>
<li>maven-dependency-plugin插件有十多个目标，每个目标对应一个功能，目标有：<code>dependency:analyze、dependency:tree、dependency:list</code>。<strong>这是一种通用写法，冒号前面是插件前缀，后面是插件目标</strong></li>
</ul>
</li>
<li><p><strong>插件绑定</strong></p>
<p>把插件的目标goal，绑定到maven生命周期的某个阶段用于完成实际任务，叫做插件绑定</p>
</li>
<li><p>内置绑定</p>
</li>
<li><p>自定义绑定</p>
<ol>
<li>确定插件目标，首先通过查看插件，找到合适的插件目标，（基本上所有的插件都来源于Apache和Codehaus）</li>
<li>确定生命周期，查看生命周期的各个阶段，找到合适的位置，</li>
<li>在pom.xml文件中配置，将插件和其目标与 生命周期的阶段相绑定</li>
</ol>
</li>
<li><p>插件配置</p>
<p>插件和生命周期绑定后，可以配置插件和插件目标的参数，</p>
<p>可以在命令行配置，也可以在pom.xml中配置</p>
</li>
<li><p>获取插件信息</p>
<ol>
<li><p>在线获取</p>
</li>
<li><p>使用maven-help-plugin描述插件获取</p>
<p>例：<code>mvn help:describe -Dplugin=xxx(想获取信息的插件)</code></p>
</li>
</ol>
</li>
<li><p>插件解析机制</p>
<p>与依赖构件一样，插件构件也基于坐标存在与maven仓库中</p>
<ul>
<li>插件前缀</li>
<li>插件解析版本</li>
<li>插件的groupId</li>
</ul>
</li>
</ul>
<h3 id="遇到过得问题"><a href="#遇到过得问题" class="headerlink" title="遇到过得问题"></a>遇到过得问题</h3><p>mvn com.coveo:fmt-maven-plugin:format -Dmaven.wagon.http.ssl.insecure&#x3D;true -Dmaven.wagon.http.ssl.allowall&#x3D;true </p>
<p>mvn com.coveo:fmt-maven-plugin:format 报错，无法获取指定依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to execute goal com.coveo:fmt-maven-plugin:2.9:format (default-cli) on project dataflow_preprocess_topic_rest: Execution default-cli of goal com.coveo:fmt-maven-plugin:2.9:format failed: Plugin com.coveo:fmt-maven-plugin:2.9 or one of its dependencies could not be resolved: Failed to collect dependencies at com.coveo:fmt-maven-plugin:jar:2.9 -&gt; com.google.googlejavaformat:google-java-format:jar:1.7 -&gt; com.google.errorprone:javac-shaded:jar:9+181-r4173-1: Failed to read artifact descriptor for com.google.errorprone:javac-shaded:jar:9+181-r4173-1: Could not transfer artifact com.google.errorprone:javac-shaded:pom:9+181-r4173-1 from/to aliyunmaven (https://maven.aliyun.com/repository/public): Authorization failed for https://maven.aliyun.com/repository/public/com/google/errorprone/javac-shaded/9+181-r4173-1/javac-shaded-9+181-r4173-1.pom 403 Forbidden -&gt; [Help 1]</span><br></pre></td></tr></table></figure>
<p>解决：手动下载指定pom后，重新执行<br>过程： 更换maven源地址等操作并不生效，最终手动下载有错误的pom后，顺利解决</p>
<h1 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pom.xml中配置了fmt插件后，手动format代码的命令</span><br><span class="line">mvn com.coveo:fmt-maven-plugin:format</span><br><span class="line"></span><br><span class="line">maven打包时跳过单元测试的命令</span><br><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Python知识点小结</title>
    <url>//Python%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.html</url>
    <content><![CDATA[<p>﻿Python知识点：</p>
<p>1、<br>python的函数</p>
<p>所有的对象都是通过引用来出传递的，函数也不例外。</p>
<p>函数参数传递，<br>直接给出数据时，参数按照预定义的顺序传递给相关形参，<br>当以关键字输入时，顺序就不重要了，解释器会自动匹配对应的形参关键字</p>
<p>函数中，关键字参数总是出现在形参之后，如int(x,base &#x3D; 2)</p>
<p>任何能通过函数操作符“()”来调用的对象，都是“可调用的”</p>
<p>2、<br>lambda表达式<br>lambda [arg1[,arg2,…argN]]:expression</p>
<p>lambda可以生成函数对象，同时注意，lambda的函数体只能为单句表达式，甚至print语句都不行</p>
<p>例1：<br>def true():<br>    return True<br>&lt;&#x3D;&#x3D;&#x3D;&gt; lambda :True<br>例2：<br>def add(x, y):return x + y &lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt; lambda x,y:x+y</p>
<p>通过lambda来创建函数的对象，除了没有命名之外，享有和用户自定义函数相同的属性。<br>lambda的__name__属性被定义为字符串”<lambda>“</p>
<p>3、<br>内建函数<br>apply()</p>
<p>filter()</p>
<p>map()</p>
<p>reduce()</p>
<p>函数句点属性标识对于两个模块意味了不同的命名空间<br>foo.x ,bar.x</p>
<p>python有四种可调用对象：<br>函数，方法，类，以及一些类的实例</p>
<p>【注意】：可调用对象的任何引用或者别名都是可调用的。</p>
<p>只有内建类型（built-in type,BIT）有内建方法<br>内建方法和内建函数享有相同的属性，<br>不同之处在于BIM的__self__属性指向一个Python对象，而BIF指向None</p>
<p>4、<br>实例化，与类的调用<br>类,我们可以利用类的可调用性来创建实例。“调用”类的结果是创建了实例，也就是“实例化”</p>
<p>一般情况下，类的实例是不可被调用的，只有在类中实现了__call__()方法，类的实例才能成为可调用的。</p>
<p>5、exec()和eval()<br>一个很重要观点，exec和eval()都可以执行字符串格式的Python代码。<br>当执行字符串形式的代码时，每次都必须对这些代码进行字节编译处理</p>
<p>eval()对表达式求值，表达式可以为字符串或内建函数complie()创建的预编译代码对象。<br>eval()在执行时，可以理解为对字符串两边的引号视而不见<br>利用eval()可以将字符串转换为真正的Python对象<br>例如：eval(“2*3”)  –&gt; 6</p>
<p>exec与eval()相似，exec语句执行代码对象或字符串形式的Python代码（单一语句或多个语句组成的语句组）。<br>exec obj<br>注：多个语句作为一个字符串发给exec时，一般用”””引号。<br>exec还可以接受有效的Python文件对象。<br>例：<br>exec(“print ‘hello world.’”)   —&gt; hello world.<br>f &#x3D; open(filename,’r’)<br>exec f     #[注意]exec执行f之后，文件指针会移动到文件末尾EOF，再次执行时不会有任何效果，可以通过f.seek(0)移动文件指针至文件开始<br>f.close()</p>
<p>用compile()预编译重复代码有助于改善性能，因为调用时不必经过字节编译处理。</p>
<p>内建函数input()是eval()和raw_input()的组合，&lt;&#x3D;&#x3D;&gt; eval(raw_input())</p>
<p>6、<br>执行其他（Python）程序</p>
<p>可以利用os模块调用外部程序</p>
<p>关于模块的导入，<br>注意：当导入模块时，解释器会执行模块中所有最高级别的（即没有缩进的）Python代码</p>
<p>如果有些代码不想被导入，那么就写在if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘语句中，<br>导入的副作用：导致最高级别代码运行。</p>
<p>将模块作为脚本执行<br>命令行中，Python -m 标准库中的模块</p>
<p>**14.5.3章节，与进程有关的一些说明。<br>**14.5.5章节，subprocess模块的常用方法用法介绍</p>
<p>shelve模块</p>
<p>shelve.open()方法<br>open(filename, flag&#x3D;’c’, protocol&#x3D;None, writeback&#x3D;False)<br>    Open a persistent dictionary for reading and writing.<br>    filename文件名参数是一个数据库相关的基础文件名（不能是一个txt文件）<br>    The filename parameter is the base filename for the underlying<br>    database. </p>
<hr>
<p>python文件操作</p>
<p>几个不太懂的词汇：</p>
<p>“钩子”</p>
<p>“句柄”</p>
<p>“文件描述符”</p>
<p>永久性存储<br>大部分永久性存储模块是用来存储字符串数据的<br>数据的序列化，扁平化，顺序化</p>
<p>“文件描述符”<br>形式：文件描述符是非负整数。<br>作用：内核（kernel）利用文件描述符（file descriptor）来访问文件,用于指代被打开的文件,所有执行I&#x2F;O操作的系统调用都通过文件描述符。</p>
<p>文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。<br>在UNIX、Linux的系统调用中，大量的系统调用都是依赖于文件描述符。<br>由于Linux的设计思想便是把一切设备都视作文件。</p>
<p>在Windows操作系统上，’文件描述符’被称作’文件句柄’。</p>
<hr>
<p>1、相当于打开收音机<br>2、定于指定频道<br>3、接收信息（有两个方法，一个阻塞型的，另一个非阻塞型（新版本中才有，2.x版本没有））<br>4、发送方，指定频道并发送信息（数据）</p>
<p>注，接收一次后会断掉，如果想要不断地监听，最好写成一个循环，如：while True:后面是接收信息。</p>
<p>return True  –&gt; 可以用作条件判断时使用，return true时，if等条件语句为true</p>
<p>base64 模块的作用</p>
<p>command模块的作用</p>
<hr>
<p>Python面试中常提到的内容：</p>
<p>一、爬虫<br>爬虫必要的几个基本需求：<br>1、抓取；<br>html看不懂（w3cschool学习，看懂各种标签的含义，要求能看懂html文件里的内容），http原理不懂（需要能看懂http请求头）<br>2、存储；<br>3、分析；<br>提取信息，<br>4、展示；</p>
<p>二、一般问题：<br>1、函数中设置全局变量<br>global<br>2、匿名函数<br>lambda x:xx</p>
<p>RE<br>3、Python中match()和search()区别<br>match()，只匹配开始位置<br>search()，扫描整个字符串并返回第一个成功的匹配<br>4、怎样查询并替换一个文本字符串？<br>sub()</p>
<p>异常；<br>try:<br>except</p>
<p>raise手动触发</p>
<p>pass语句<br>占位符</p>
<p>range()函数，</p>
<p>随机生成器<br>random</p>
<p>Python内存管理，是由Python解释器负责，不需要程序员关心</p>
<p>如何用Python来发送邮件<br>使用smtplib标准库</p>
<p>如何设置很多项目，不同版本<br>virtualenv</p>
<p>装饰器，<br>使用@decorator_name</p>
<p>你知道列表和元组之间的区别么？举个例子？<br>列表时可变对象<br>元组是不可变对象</p>
<p>with…as..<br>用于处理打开关闭文件</p>
<p>hasattr(a,b) –&gt; a有b属性</p>
<p>if语句<br>if xxx:<br>    if-statement<br>[else:xxx]</p>
<p>if条件表达式<br>result1 if xxx else result2<br>如果xxx为true,则result1，否则result2</p>
<hr>
<p>符号的另外含义使用：</p>
<p>1、”+” : 连接操作符<br>除了用在数字加减，<br>还可以用于”序列+序列” ，–&gt; 把两个序列组合成新的序列</p>
<p>2、”<em>“ : 重复操作符<br>-序列</em>整数， —&gt; 重复序列整数次</p>
<hr>
<p>yield<br>生成器，</p>
<p>每次生成一个值的特殊函数</p>
<p>遇到yield，会返回yield生产出来的值，</p>
<p>可以调用yield生成器对象的next()方法</p>
<p>可以在for循环中使用生成器， 	for循环会创建一个生成器对象，并连续滴啊用其next()方法，获得值赋予for变量</p>
<p>python 的文件处理方法，<br>open()&#x2F;file() 本身也是一个生成器<br>默认f &#x3D; open(‘’,’r’) 	f本身也是一个生成器，默认一次读取一行</p>
<hr>
<p>【linux】【expect】</p>
<p>expect是linux中一个，用于实现自动和交互式程序进行通讯，不需人工干预的工具</p>
<p>【pexpect】Python</p>
<p>expect的python封装，同样实现命令行进行自动交互，达到无需人工干涉自动化的目的</p>
<p>注：pexpect无法解析shell命令行中的 “&gt;”,”|”和”*”(通配符),这三个特殊的元字符</p>
<pre><code>解决：
    将有这三个特殊元字符的命令作为/bin/bash的参数进行调用：
例：
    child = pexpect.spawn(&quot;/bin/bash -c &#39;ls -l | grep LOG &gt; log.txt&#39;&quot;)
    child.expect(pexpect.EOF)
  或
    用python列表作为参数项
    shell_cmd = &#39;ls -l | grep LOG &gt; log.txt&#39;
    child = pexpect.spawn(&#39;/bin/bash&#39;, [&#39;-c&#39;, shell_cmd])  # 对我的启发，当直接写不容易的时候，多用变量进行传值
    child.expect(pexpect.EOF)
</code></pre>
<p>pexpect的几个核心组件 ：spawn类，run函数, pxssh派生类</p>
<p>spawn 类 ， # 作用，启动和控制子应用程序</p>
<p>【获取pexpect的输入和输出信息】<br>1、写到日志文件</p>
<pre><code>child = pexpect.spawn(&#39;some_command&#39;)
fout = open(&#39;mylog.txt&#39;, &#39;w&#39;)
child.logfile = fout  # 
</code></pre>
<p>2、输出到标准输出STDOUT</p>
<pre><code>child = pexpect.spawn(&#39;some_command&#39;)
child.logfile = sys.stdout
</code></pre>
<p>expect(pattern, timeout&#x3D;-1, searchwindowsize&#x3D;-1)</p>
<p>pattern 可以为一个list<br>    若为list，则返回的结果是<br>              子程序输出最先出现的那个元素，<br>              或者是列表最左边的元素（索引最小的）</p>
<p>如果pexpect.EOF,pexpect.TIMEOUT作为expect的列表参数时，匹配时将返回所处列表中的索引ID</p>
<p>before;<br>after;</p>
<p>向子程序发送响应命令的方法s：<br>send(self, s)	# 发送命令，不回车<br>sendline(self, s&#x3D;””)	# 发送命令， 回车<br>sendcontrol(self, char)  # 发送控制字符，如child.sendcontrol(‘c’) 等价于”ctrl + c”<br>sendof()  # 发送eof</p>
<hr>
<h2 id="判断是文件还是文件夹"><a href="#判断是文件还是文件夹" class="headerlink" title="判断是文件还是文件夹"></a>判断是文件还是文件夹</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;it&#x27;s a directory&quot;</span></span><br><span class="line"><span class="keyword">elif</span> os.path.isfile(path):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;it&#x27;s a normal file&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;it&#x27;s a special file(socket,FIFO,device file)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用os模块可以获取指定文件夹下所有文件名，有两个方法os-walk-和os-listdir"><a href="#使用os模块可以获取指定文件夹下所有文件名，有两个方法os-walk-和os-listdir" class="headerlink" title="使用os模块可以获取指定文件夹下所有文件名，有两个方法os.walk()和os.listdir()"></a>使用os模块可以获取指定文件夹下所有文件名，有两个方法os.walk()和os.listdir()</h2><ol>
<li><p>os.listdir()</p>
<p>注意：该方法会将目录下的一层文件和目录全部列出来，需要再结合上级路径判断哪些是文件，哪些是目录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">excel_files = os.listdir(files)</span><br><span class="line"><span class="keyword">for</span> excel_f <span class="keyword">in</span> excel_files:</span><br><span class="line">    input_excel = os.path.join(files, excel_f)</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(input_excel):</span><br><span class="line">        <span class="built_in">print</span> input_excel + <span class="string">&#x27;is a dir&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> input_excel + <span class="string">&#x27;is a file&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Python获取文件路径、文件名和扩展名"><a href="#Python获取文件路径、文件名和扩展名" class="headerlink" title="Python获取文件路径、文件名和扩展名"></a>Python获取文件路径、文件名和扩展名</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>os.path.realpath(__file__)</code></td>
<td>获取当前文件绝对路径</td>
<td>字符串</td>
</tr>
<tr>
<td><code>os.path.dirname(__file__)</code></td>
<td><strong>注意</strong>，这个函数仅能获取当前文件的上一级目录名，并不是所在父级路径</td>
<td>字符串</td>
</tr>
<tr>
<td>os.path.splitext()</td>
<td>分割文件名和扩展名</td>
<td>元组</td>
</tr>
<tr>
<td>os.path.split()</td>
<td>分割路径和文件名</td>
<td>元组</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://images/logo.png&quot;</span></span><br><span class="line"></span><br><span class="line">(file, ext) = os.path.splitext(url)</span><br><span class="line"><span class="built_in">print</span>(file)  <span class="comment"># http://images/logo</span></span><br><span class="line"><span class="built_in">print</span>(ext)   <span class="comment"># .png</span></span><br><span class="line"></span><br><span class="line">(path, filename) = os.path.split(url)</span><br><span class="line"><span class="built_in">print</span>(path)      <span class="comment"># http://images</span></span><br><span class="line"><span class="built_in">print</span>(filename)  <span class="comment"># logo.png</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># /root/devops/export-zabbix/zabbix-export.py</span></span><br><span class="line"><span class="comment"># 上一级目录</span></span><br><span class="line">file_path = os.path.dirname(__file__) <span class="comment"># export-zabbix</span></span><br><span class="line"><span class="comment"># 文件路径</span></span><br><span class="line">file_path = os.path.split(os.path.realpath(__file__))[<span class="number">0</span>]  <span class="comment"># /root/devops/export-zabbix</span></span><br></pre></td></tr></table></figure>



<h2 id="python-创建目录"><a href="#python-创建目录" class="headerlink" title="python 创建目录"></a>python 创建目录</h2><p><code>os.mkdir</code> 创建单层目录</p>
<ul>
<li>类似于 Linux 命令： <code>mkdir xxx</code></li>
</ul>
<p><code>os.makedirs</code> 递归创建目录</p>
<ul>
<li>类似于 Linux 命令：<code>mkdir -p xxx</code></li>
</ul>
<h2 id="处理Python的编码问题"><a href="#处理Python的编码问题" class="headerlink" title="处理Python的编码问题"></a>处理Python的编码问题</h2><ol>
<li><p>python 文件包含中文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character <span class="string">&#x27;\xe4\xe5&#x27;</span> <span class="keyword">in</span> file xxxxx</span><br></pre></td></tr></table></figure>

<p>解决：在 python 文件开头添加文件编码注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>报错如下：<code>typeerror decoding unicode is not supported</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode(<span class="string">u&#x27;foo&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#1&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    unicode(<span class="string">u&#x27;foo&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">TypeError: decoding Unicode <span class="keyword">is</span> <span class="keyword">not</span> supported</span><br><span class="line">    </span><br><span class="line">从上面内容可知，已经是unicode的对象是无法用unicode()方法再编码的，</span><br><span class="line"></span><br><span class="line">可以利用下面方法将<span class="string">u&#x27;foo&#x27;</span>编码为<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">u&#x27;foo&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">同时，在python程序中，通过方法返回的结果编码是unicode，那么不能再次调用unicode()方法</span><br><span class="line"></span><br><span class="line">样例<span class="number">1</span>：</span><br><span class="line">workbook = xlrd.open_workbook(excel_file)</span><br><span class="line">sheet_names = workbook.sheet_names()</span><br><span class="line"><span class="keyword">for</span> worksheet_name <span class="keyword">in</span> sheet_names:</span><br><span class="line">    <span class="built_in">print</span> worksheet_name   √</span><br><span class="line">    <span class="built_in">print</span> unicode(worksheet_name,<span class="string">&#x27;utf-8&#x27;</span>)  x</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span>：</span><br><span class="line">(pre_file, suffix_file) = os.path.splitext(base_naem)</span><br><span class="line"><span class="built_in">print</span> unicode(pre_file, <span class="string">&#x27;utf-8&#x27;</span>)  √</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>&#96;&#96;&#96;python<br>unicodedecodeerror ‘ascii’ codec can’t decode byte 0xe6 in position 25:ordinal not in range(128)</p>
<p>isinstance(aa, unicode)  # 判断是否为unicode编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &gt;  在解决错误之前，首先要了解unicode和utf-8的区别。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; ​     unicode指的是万国码，是一种“字码表”。而utf-8是这种字码表储存的编码方法。unicode不一定要由utf-8这种方式编成bytecode储存，也可以使用utf-16,utf-7等其他方式。目前大多都以utf-8的方式来变成bytecode。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; ​     其次，[**Python**](http://lib.csdn.net/base/11)中字符串类型分为byte string 和 unicode string两种。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; ​     如果在python文件中指定编码方式为utf-8(#coding=utf-8)，那么所有带中文的字符串都会被认为是utf-8编码的byte  string（例如：mystr=&quot;你好&quot;），但是在函数中所产生的字符串则被认为是unicode string。</span><br><span class="line">   &gt; ​     问题就出在这边，unicode string 和 byte string 是不可以混合使用的，一旦混合使用了，就会产生这样的错误。例如：</span><br><span class="line">   &gt; ​     self.response.out.write(&quot;你好&quot;+self.request.get(&quot;argu&quot;))</span><br><span class="line">   &gt; ​     其中，&quot;你好&quot;被认为是byte string，而self.request.get(&quot;argu&quot;)的返回值被认为是unicode string。由于预设的解码器是ascii，所以就不能识别中文byte string。然后就报错了。</span><br><span class="line"></span><br><span class="line">   &gt; 以下有两个解决方法：</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 1.将字符串全都转成byte string。</span><br><span class="line">   &gt;        self.response.out.write(&quot;你好&quot;+self.request.get(&quot;argu&quot;).encode(&quot;utf-8&quot;))</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 2.将字符串全都转成unicode string。</span><br><span class="line">   &gt;        self.response.out.write(u&quot;你好&quot;+self.request.get(&quot;argu&quot;))</span><br><span class="line">   &gt;        byte string转换成unicode string可以这样转unicode(unicodestring, &quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">   更详细的内容查看 [stackoverflow上的这个回答](https://stackoverflow.com/questions/21129020/how-to-fix-unicodedecodeerror-ascii-codec-cant-decode-byte)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 处理Pandas遇到的问题</span><br><span class="line"></span><br><span class="line">1. pandas从excel读取数据数字类型过长出现科学计数法的问题</span><br><span class="line"></span><br><span class="line">   - 原因：excel显示数字时，如果数字大于12位就会自动转化为科学计数法。如果数字大于15位，它不仅用于科学技术费表示，还会只保留高15位，其他位都变0。所以本场景就是因为超过15位了，导致读取有问题，需要将数字类型转换位文本类型(str类型)</span><br><span class="line"></span><br><span class="line">   - 解决：在excel读取的时候，添加`dtype=object`的参数 （也有人说添加dtype=str，可能由于版本问题，我没有成功）</span><br><span class="line"></span><br><span class="line">     ```python</span><br><span class="line">     pd.read_excel(excel_file, worksheet_name,index_col=None,dtype=object)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Python-计算百分比保留多位小数"><a href="#Python-计算百分比保留多位小数" class="headerlink" title="Python 计算百分比保留多位小数"></a>Python 计算百分比保留多位小数</h1><p>两种方式，</p>
<ol>
<li><p>格式化</p>
<ol>
<li><code>&#39;%.2f&#39; % x</code> ，这里以保留两位小数为例</li>
<li><code>&#39;&#123;:.2f&#125;&#39;.format(x)</code></li>
</ol>
</li>
<li><p>round函数</p>
<ul>
<li><p>round(x, 2)</p>
<blockquote>
<p>注意，该函数会省略为0的数字，比如 round(10.00, 2)  –&gt; 10.0</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="计算百分比"><a href="#计算百分比" class="headerlink" title="计算百分比"></a>计算百分比</h2><p>同样是采用格式化，两种方法</p>
<ul>
<li>方法1，格式化为 float，然后处理 <code>%</code> 格式，需要计算 <code>分子 / 分母 * 100</code>，</li>
<li>方法2，直接使用参数格式化： <code>&#123;:.2%&#125;</code>，这里为显示小数点后2位，</li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#123;:.2f&#125;%&#x27;</span>.<span class="built_in">format</span>(<span class="number">42</span> / <span class="number">50</span> * <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#123;:.2%&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">42</span> / <span class="number">50</span> * <span class="number">100</span>)<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="元组列表转为字典"><a href="#元组列表转为字典" class="headerlink" title="元组列表转为字典"></a>元组列表转为字典</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tups = [(<span class="string">&quot;akash&quot;</span>, <span class="number">10</span>), (<span class="string">&quot;gaurav&quot;</span>, <span class="number">12</span>), (<span class="string">&quot;anand&quot;</span>, <span class="number">14</span>), </span><br><span class="line">    (<span class="string">&quot;suraj&quot;</span>, <span class="number">20</span>), (<span class="string">&quot;akhil&quot;</span>, <span class="number">25</span>), (<span class="string">&quot;ashish&quot;</span>, <span class="number">30</span>)]</span><br><span class="line">di = <span class="built_in">dict</span>(tups)</span><br><span class="line"><span class="built_in">print</span> di</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">&#123;<span class="string">&#x27;anand&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;akash&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;akhil&#x27;</span>: <span class="number">25</span>, </span><br><span class="line"> <span class="string">&#x27;suraj&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;ashish&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;gaurav&#x27;</span>: <span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>pip使用问题</title>
    <url>//pip%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="pip-安装包时-ValueError-check-hostname-requires-server-hostname-错误"><a href="#pip-安装包时-ValueError-check-hostname-requires-server-hostname-错误" class="headerlink" title="pip 安装包时 ValueError: check_hostname requires server_hostname 错误"></a>pip 安装包时 <code>ValueError: check_hostname requires server_hostname</code> 错误</h2><p><strong>解决方法</strong>：关闭本地代理即可。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Pip</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pip</tag>
      </tags>
  </entry>
  <entry>
    <title>python启动http服务</title>
    <url>//python%E5%90%AF%E5%8A%A8http%E6%9C%8D%E5%8A%A1.html</url>
    <content><![CDATA[<p>Python 2.x版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>



<p>Python 3.x版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></table></figure>

<blockquote>
<p>省略端口号，即默认 80 。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>python处理excel文件</title>
    <url>//python%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6.html</url>
    <content><![CDATA[<p>使用两个库</p>
<p>读取使用 <code>xlrd</code></p>
<p><strong>openpyxl</strong></p>
<p>根据官方文档，<a href="https://so.csdn.net/so/search?q=openpyxl&spm=1001.2101.3001.7020">openpyxl</a> 是一个第三方库, 它可以可以处理 <strong>xlsx&#x2F;xlsm</strong> 格式的 Excel 文件(A Python library to read&#x2F;write Excel 2010 xlsx&#x2F;xlsm files)</p>
<blockquote>
<p>注：不能处理 <strong>xls</strong> 格式的 excel 文件。</p>
</blockquote>
<p>安装：</p>
<ul>
<li>pip 安装，<code>pip install openpyxl</code></li>
<li>源码文件安装，下载安装文件后， <code>python setup.py install</code></li>
</ul>
<p><a href="Python%E4%BD%BF%E7%94%A8openpyxl%E8%AF%BB%E5%86%99excel%E6%96%87%E4%BB%B6">Python使用openpyxl读写excel文件</a></p>
<h2 id="处理单元格"><a href="#处理单元格" class="headerlink" title="处理单元格"></a>处理单元格</h2><p><a href="https://www.cnblogs.com/SunboyL/p/14738690.html">python使用openpyxl获取合并单元格的值</a></p>
<h1 id="xlrd-最新-2-0-1-版本无法读取-xlsx-格式"><a href="#xlrd-最新-2-0-1-版本无法读取-xlsx-格式" class="headerlink" title="xlrd 最新 2.0.1 版本无法读取 .xlsx  格式"></a>xlrd 最新 2.0.1 版本无法读取 <code>.xlsx</code>  格式</h1><p>报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xlrd.biffh.XLRDError: Excel xlsx file； not supported</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：</p>
<p>安装旧版本的 xlrd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip uninstall xlrd</span><br><span class="line">pip install xlrd==1.2.0</span><br></pre></td></tr></table></figure>

<p>或者使用 <code>openpyxl</code>  代替 <code>xlrd</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>02猜数游戏</title>
    <url>//02%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F.html</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>程序将会随机生成一个 1 到 100 之间的随机整数。接着它会请玩家猜一个数并输入，然后提示猜测是大了还是小了。如果猜对了，它会打印祝贺信息并退出。</p>
<h1 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h1><p>let,match,方法,关联函数，外部crate</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo new guessing_game</span><br><span class="line">cd guessing_game</span><br></pre></td></tr></table></figure>



<h3 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h3><p>默认情况下，Rust 将 <code>prelude</code> 模块中少量的类型引入到每个程序的作用域（scope）中。如果需要的类型不在 <code>prelude</code>中，就必须使用<code>use</code> 语句显示地将其引入作用域（scope）中。</p>
<h3 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h3><p><code>String::new()</code>,中<code>::</code> 语法表明，<code>new</code>是<code>String</code>类型的一个<strong>关联函数</strong>。关联函数是针对类型实现的。<code>new</code> 是创建类型实例的惯用函数名。</p>
<ul>
<li>关联函数有点类似于Java中的静态方法，与类关联，不与实例关联。</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><code>&amp;mut guess</code>，这里的<code>&amp;</code>表示这个参数是一个<strong>引用</strong>（reference）,它允许多处代码访问同一处数据，而无需在内存中多次拷贝。</p>
<ul>
<li>Rust 的一个主要优势就是安全而简单的操作引用。</li>
</ul>
<h3 id="使用Result-类型来处理潜在的错误"><a href="#使用Result-类型来处理潜在的错误" class="headerlink" title="使用Result 类型来处理潜在的错误"></a>使用Result 类型来处理潜在的错误</h3><p><code>Result</code> 是<code>枚举类型</code>（enumerations），通常也写作 enums。枚举类型持有固定集合的值，这些值被称为<strong>成员</strong>（variants）。</p>
<p>Rust 标准库中有很多<code>Result</code>的类型，一个通用的 <code>Result</code>以及在子模块中的特化版本，比如<code>io::Result</code>。</p>
<p>通常消除警告的正确做法是，编写错误处理代码。</p>
<h3 id="crate"><a href="#crate" class="headerlink" title="crate"></a>crate</h3><p>crate 是一个 Rust 代码包</p>
<ul>
<li>二进制crate<ul>
<li>会有一个可执行文件</li>
</ul>
</li>
<li>库crate<ul>
<li>可以包含任意能被其他程序使用的代码。</li>
</ul>
</li>
</ul>
<p>Cargo可以引用外部的crate。需要修改 Cargo.toml 文件，引入依赖。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">rand = &#x27;<span class="number">0.8</span>.<span class="number">3</span>&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">为什么这里这么慢？修改第三方镜像源</span><br><span class="line"></span><br><span class="line">PS C:\Tableware\codes\rust\guessing_game&gt; cargo build</span><br><span class="line">    Blocking waiting <span class="keyword">for</span> <span class="title class_">file</span> lock on package cache</span><br></pre></td></tr></table></figure>

<p>解决方法，更新国内源</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = <span class="string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span></span><br><span class="line"># 指定镜像</span><br><span class="line">replace-with = <span class="symbol">&#x27;tuna</span>&#x27;</span><br><span class="line"></span><br><span class="line"># 清华大学</span><br><span class="line">[source.tuna]</span><br><span class="line">registry = <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br></pre></td></tr></table></figure>

<p>Rng 是一个 trait，它定义了随机数生成器应该实现的方法，想使用这些方法，此 trait 必须在作用域中，所以需要使用 <code>use</code> 引入。</p>
<h3 id="rand-中的范围表达式"><a href="#rand-中的范围表达式" class="headerlink" title="rand 中的范围表达式"></a>rand 中的范围表达式</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..<span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<p>上面 gen_range() 方法接受一个范围表达式作为参数，这里的范围表达式，使用<code>start..end</code> 的形式，[start,end)，包括start，但是不包括 end。</p>
<ul>
<li>也可以使用 1..&#x3D;100 与 1..101 作用等价。</li>
</ul>
<h3 id="如何查看-crate-本地文档"><a href="#如何查看-crate-本地文档" class="headerlink" title="如何查看 crate 本地文档"></a>如何查看 crate 本地文档</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo doc --open</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们不可能凭空就知道应该 <code>use</code> 哪个 trait 以及应该从 crate中调用哪个方法。crate 的使用说明位于其中档中。 可以在本地运行上面命令，来查看所有本地依赖提供的文档，并在浏览器中打开。</p>
</blockquote>
<h3 id="match-分支表达式"><a href="#match-分支表达式" class="headerlink" title="match 分支表达式"></a>match 分支表达式</h3><p>一个 <code>match</code> 表达式由<strong>分支</strong>（arms）构成。一个分支包含一个<strong>模式</strong>（pattern）和表达式开头的值与分支匹配时应该执行的代码。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> 表达式 &#123;</span><br><span class="line">    分支一 =&gt; 表达式,</span><br><span class="line">    分支二 =&gt; &#123;多行表达式时，使用代码块&#125;,</span><br><span class="line">    分支三 =&gt; (),  <span class="comment">// 没有内容时可以使用 () 圆括号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>03常见编程概念</title>
    <url>//03%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5.html</url>
    <content><![CDATA[<h1 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h1><p>Rust 中，变量<strong>默认</strong>是不可变的（immutable）</p>
<ul>
<li><p>不能对不可变（immutable）变量二次赋值；</p>
</li>
<li><p>在变量名之前加 <code>mut</code> 关键字，使其可变；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;  <span class="comment">// x 为不可变变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;  <span class="comment">// x 为可变变量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="变量与常量的区别"><a href="#变量与常量的区别" class="headerlink" title="变量与常量的区别"></a>变量与常量的区别</h2><p>常量（constants）： 常量是不能修改的，</p>
<ol>
<li><p>不允许对常量使用 <code>mut</code> 关键字；</p>
</li>
<li><p>声明常量使用 <code>const</code> 关键字，不用 <code>let</code>，且必须<strong>标明</strong>值的<strong>类型</strong>；</p>
</li>
<li><p>命名方式：</p>
<ul>
<li><p>全大写字母，多个字母使用下划线分隔；</p>
</li>
<li><p>值为数字时，可以在数字间加下划线提升可读性；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="type">u32</span> = <span class="number">100_000</span>;  <span class="comment">// 数字中的下划线仅起到增加可读性的作用；</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>常量在整个程序生命周期中都有效；</p>
<ul>
<li>将程序中的硬编码值，声明为常量，有助于代码维护人了解值的意图，同时便于后面修改时仅修改一处值；</li>
</ul>
</li>
<li></li>
</ol>
<h2 id="隐藏（Shadowing）"><a href="#隐藏（Shadowing）" class="headerlink" title="隐藏（Shadowing）"></a>隐藏（Shadowing）</h2><p>定义一个与之前变量同名的变量，当使用该变量时，仅能获取第二个变量的值，即第一个变量被第二个同名变量<strong>隐藏</strong>了。</p>
<ul>
<li>可以使用<code>let</code>关键字进行多次隐藏；</li>
</ul>
<p>使用场景：</p>
<ul>
<li><p>变量类型转换的场景；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;  <span class="comment">// 先获取输入；</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();  <span class="comment">// 再获取上面变量的长度;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样就可以复用同一个变量名，而不是必须创建两个不同变量</p>
</blockquote>
</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>每个值都属于一个 <code>数据类型（data type）</code></p>
<p>Rust 是静态类型语言，即在编译时就必须知道所有变量的类型。</p>
<p>两类数据类型：</p>
<ul>
<li><p>标量（scalar）类型，代表一个单独的值。有4中基本的标量类型。</p>
<ul>
<li><p>整型</p>
<ul>
<li><p>没有小数部分的数字</p>
</li>
<li><p>分为，有符号（i，数字可以为负值）和无符号（u，数字不能为负值）</p>
</li>
<li><p>有符号最高位为符号位，可以参考 Java；</p>
</li>
<li><p>有符号数以<code>补码形式</code>存储？</p>
</li>
<li><p>有符号可以存储的数字范围，-(2^n-1) 到 2^(n-1) -1</p>
</li>
<li><p>无符号，0 到 2^n - 1</p>
</li>
<li><p><code>isize</code> 和 <code>usize</code> 依赖运行程序的计算机架构，64位则是i64&#x2F;u64，32位的机器则是i32&#x2F;u32</p>
<blockquote>
<p>主要作为某些集合的索引；</p>
</blockquote>
</li>
<li><p>注：除了 <code>byte</code>以外的所有<strong>数字字面值</strong>，允许使用类型后缀，同时也允许使用<code>_</code>做为分隔符以方便读数；</p>
<ul>
<li>例如：57u8，1_000；</li>
<li><a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch03-02-data-types.html">数据类型 · Rust 程序设计语言（第二版） 简体中文版 (gitbooks.io)</a></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>浮点型</p>
<ul>
<li>带小数点的数字</li>
<li>f32 （单精度浮点数）</li>
<li>f64 （默认类型，因为在现在CPU中，它与<code>f32</code>速度几乎一样，不过精度更高）（双精度浮点数）</li>
<li>采用 IEEE-754 标准来表示，</li>
</ul>
</li>
<li><p>布尔型</p>
<ul>
<li><p><code>bool</code>，值：true ，false</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">false</span>;  <span class="comment">// 自动推断</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">true</span>; <span class="comment">// 显示指定</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主要使用场景是，条件表达式，例如，if 表达式中</p>
</li>
</ul>
</li>
<li><p>字符类型</p>
<ul>
<li><code>char</code>，单引号，</li>
<li>4 个字节，32bit，代表了一个 <code>Unicode</code> 标量值（范围包含了，U+0000 ~ U+D7FF 和 U+E000 ~ U+10FFFF 在内的值）</li>
<li>只要是<code>Unicode</code>范围内的值都是有效的<code>char</code>值<ul>
<li>例如，拼音字母，中文，日文，emoji(绘文字)…</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>复合（compound），包含多个值的类型</p>
<ul>
<li><p>两个原生的复合类型</p>
</li>
<li><p>元组（tuple）</p>
<ul>
<li><p>长度固定，一旦声明，其长度不会增加或减少</p>
</li>
<li><p><code>(a,b,c)</code>，圆括号定义，多个值的类型可以不同</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>,<span class="type">f64</span>,<span class="type">u8</span>) = (<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>逗号（<code>,</code>）分隔</p>
</li>
<li><p>使用方式：</p>
</li>
<li><p>方式1，模式匹配来解构（destructure）</p>
</li>
<li><p>方式2，使用 <code>.</code> 点符号访问索引</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x,y,z) = tup;  <span class="comment">// 通过模式将 tup 元组分成了 x,y,z 三个不同的变量，这里与python有些类似</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y); <span class="comment">// 解构后，可以单独使用变量</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">2</span>：</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>:(<span class="type">i32</span>,<span class="type">f64</span>,<span class="type">u8</span>) = (<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p>数组（array）</p>
<ul>
<li><p>与元组不同，数组中每个元素的类型必须相同</p>
</li>
<li><p>固定长度</p>
</li>
<li><p><code>[类型; 长度]</code>方括号定义，逗号分隔（<code>,</code>）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; <span class="comment">// 显示标注类型时，需要指明类型和数组长度；</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = [<span class="number">3</span>; <span class="number">5</span>];  <span class="comment">// 这样写，表示c有5个元素，都是数字3；</span></span><br><span class="line">即 <span class="keyword">let</span> <span class="variable">c</span> = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据分配在栈（stack）上，一整块在栈上的内存</p>
<blockquote>
<p>当需要的元素固定时，使用数组；</p>
<p>当不定长时，使用 vector；（标准库提供的与数组类似的，可变的集合类型）；</p>
<p>当不确定应该使用array 还是 vector 时，使用 vector；</p>
</blockquote>
</li>
<li><p>访问方式： 使用索引访问，（与Java一样）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];  <span class="comment">// first 的值是1；</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>]; <span class="comment">// second 的值是2；</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组越界时，Rust会发生 <code>panic</code>，然后立刻推出，不允许继续访问。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用时，</p>
<ul>
<li>省略类型（自动推断），即默认 Rust 编译器会自动根据值和其使用方式，推断我们使用的类型。</li>
<li>显示标注类型，当结果可能为多种类型时，即 Rust 编译器无法准确推断值的类型时。</li>
</ul>
<h1 id="函数如何工作"><a href="#函数如何工作" class="headerlink" title="函数如何工作"></a>函数如何工作</h1><p>函数定义的关键字</p>
<ul>
<li><code>fn</code></li>
<li>函数和变量名命名风格，<code>snake case</code>风格<ul>
<li>所有字母都是<strong>小写</strong>，并使用**下划线(_)**分隔单词；</li>
</ul>
</li>
<li>函数签名中，<strong>必须</strong>声明每个<strong>参数的类型</strong>。多个参数用逗号（<code>,</code>分隔）</li>
</ul>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>如果有返回值，则需要在<strong>箭头（<code>-&gt;</code>）</strong>后声明它的类型 。</p>
<p><strong>重要</strong>：</p>
<ol>
<li><p>在 Rust 中，函数的返回值等同于函数体<strong>最后一个表达式的值</strong>。</p>
</li>
<li><p>使用 <code>return</code> 关键字和指定值，可以从函数中提前返回。</p>
</li>
<li><p>大部分函数隐式的返回最后一个表达式的值。</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">five</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注：</strong></p>
<p>代码块的值是其最后一个表达式的值，而数字本身就是一个表达式</p>
<h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><p>语句（statement），不返回值</p>
<ul>
<li>执行一些操作但不返回值的指令</li>
<li>使用 <code>let</code> 关键字创建变量并绑定一个值是一个语句</li>
<li>函数定义也是一个语句；</li>
</ul>
<p>表达式（expressions）</p>
<ul>
<li>计算并产生一个值</li>
<li>表达式的结尾没有分号；如果加上分号就变成语句了，语句不能返回值。<ul>
<li>函数体内最后一行作为返回值的是表达式，不能加分号</li>
</ul>
</li>
</ul>
<p>语句块（block）也是表达式</p>
<ul>
<li><p>block 是多个语句或表达式的集合；</p>
</li>
<li><p>所以它可以被当做值（value）使用在赋值语句中；</p>
<blockquote>
<p>注意，当做值在赋值语句中使用时，要以<code>;</code>结尾。</p>
</blockquote>
</li>
<li><p>如果block中的最后一句是表达式，则当block处在赋值语句中时，最后一个表达式的值将作为返回值并赋值给变量；</p>
</li>
<li><p>如果block中的最一句是语句（以<code>;</code>结尾），则返回值为<code>()</code> ;</p>
</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>在 Rust 中，使用 <code>//</code> 来进行注释</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello,world</span></span><br></pre></td></tr></table></figure>



<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a><code>if</code> 表达式</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式 &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 条件表达式 &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Rust 中 if 的条件表达式直接跟在 if 关键字后面，不需要圆括号()</p>
</blockquote>
<h3 id="在-let-语句中使用-if"><a href="#在-let-语句中使用-if" class="headerlink" title="在 let 语句中使用 if"></a>在 <code>let</code> 语句中使用 <code>if</code></h3><p>因为<code>if</code> 是一个表达式，所以可以将 if 表达式赋值给 let 定义的变量。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="使用循环重复执行"><a href="#使用循环重复执行" class="headerlink" title="使用循环重复执行"></a>使用循环重复执行</h2><p>Rust 提供三种循环：</p>
<ul>
<li>[loop](# loop)</li>
<li>[while](# while-条件循环)</li>
<li>[for](# for-循环)</li>
</ul>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>在 Rust 中，通常使用在希望<strong>无限循环</strong>的场景中（代替 while ture 的写法）。</p>
<p>与 <code>for</code>循环一样，使用 <code>break</code> 停止当前循环，使用 <code>continue</code> 跳过本次循环内容，进入下一次循环。</p>
<p>如果存在嵌套<code>loop</code>循环，<code>break</code>和<code>continue</code>仅作用于当前层循环。</p>
<p>不同点：</p>
<ul>
<li><p>停止多层循环，使用<strong>循环标签（loop label）</strong>，这样<code>break</code>关键字就可以作用在指定的循环层。</p>
<ul>
<li><p><code>break/continue 循环标签</code></p>
</li>
<li><p>循环标签定义： <code>&#39;标签名</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;  <span class="comment">// 外层循环指定一个标签 &lt;&#x27;标签名&gt;</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;&#125;&quot;</span>, count);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;&#125;&quot;</span>, remaining);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;  <span class="comment">// 停止外层循环则</span></span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;&#125;&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>从循环返回值，</p>
<ul>
<li><p><code>break  需要返回的内容</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;  <span class="comment">// 当执行到这里时，会将 counter * 2 的结果20 返回并赋值给 result;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="while-条件循环"><a href="#while-条件循环" class="headerlink" title="while 条件循环"></a>while 条件循环</h3><p>与 Java 一样，不同的点在于 <strong>条件语句没有圆括号</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;  <span class="comment">// 与 if 语句的条件表达式一样</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">        number = number - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>for loops</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合 &#123;</span><br><span class="line">	<span class="comment">//something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式与 python 和 shell 的一种有些像</span></span><br></pre></td></tr></table></figure>

<p><code>for in</code> 结构体通常使用 <code>Iterator</code> 迭代器来迭代。</p>
<p>有两种方式创建 iterator，</p>
<p>方法一，使用range，即范围表示法<code>a..b</code> 表示范围<code>[a,b)</code>，使用<code>a..=b</code>表示范围 <code>[a,b]</code></p>
<h4 id="for-and-range"><a href="#for-and-range" class="headerlink" title="for and range"></a>for and range</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// `n` will take the values: 1, 2, ..., 100 in each iteration</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">101</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">15</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;fizzbuzz&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `n` will take the values: 1, 2, ..., 100 in each iteration</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">100</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="for-and-iterators"><a href="#for-and-iterators" class="headerlink" title="for and iterators"></a>for and iterators</h4><p><code>for in</code> 结构体与 <code>Iterator</code> 有几种交互方式</p>
<ul>
<li><p><code>into_iter</code></p>
<ul>
<li>获取所有权，每次循环都会消费值，即将迭代的值 moved 到循环中。循环结束后该集合就不可重用。</li>
</ul>
</li>
<li><p><code>iter</code></p>
<ul>
<li>借用（不可变借用），循环结束后该集合可重用。</li>
</ul>
</li>
<li><p><code>iter_mut</code></p>
<ul>
<li>可变借用，允许修改集合中的值。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">names</span> = <span class="built_in">vec!</span>[<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Frank&quot;</span>, <span class="string">&quot;Ferris&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">name</span> <span class="keyword">in</span> names.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">        *name = <span class="keyword">match</span> name &#123;</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="string">&quot;Ferris&quot;</span> =&gt; <span class="string">&quot;There is a rustacean among us!&quot;</span>,</span><br><span class="line">            _ =&gt; <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;names: &#123;:?&#125;&quot;</span>, names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>04认识所有权</title>
    <url>//04%E8%AE%A4%E8%AF%86%E6%89%80%E6%9C%89%E6%9D%83.html</url>
    <content><![CDATA[<p>背景： 所有运行的程序都必须管理其使用的计算机内存的方式。</p>
<p>目前主要三种方式：</p>
<ul>
<li>垃圾回收机制<ul>
<li>程序运行时不断地寻找不再使用的内存</li>
</ul>
</li>
<li>程序员自己分配和释放内存</li>
<li>所有权系统管理内存</li>
</ul>
<p>栈和堆</p>
<p>栈：后进先出（last in first out）</p>
<p>增加数据 称为，进栈</p>
<p>移出数据 称为，出栈</p>
<p>栈中的所有数据都必须占用已知且固定的大小。</p>
<p>在编译时，大小未知或大小可能变化的数据，要存储在堆上。</p>
<p><strong>在堆上分配内存</strong>*（allocating on the heap）：当向堆中放入数据时，要请求一定大小的空间。内存分配器在堆的某处找到一块足够大的空间，把它标记为已使用，并返回一个表示该位置地址的指针（pointer）。</p>
<p>因为<strong>指针的大小是已知且固定的</strong>，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针所指数据。</p>
<p>入栈比在堆上分配内存要快，因为入栈时分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。</p>
<p>访问堆上数据比访问栈上数据慢，因为必须通过指针来访问。</p>
<p>现代处理器在内存中跳转越少就越快。</p>
<p>当调用一个函数时，传递给函数的参数和函数的局部变量会被压入栈中。</p>
<p>当函数调用结束时，这些值被移出栈。</p>
<p>存储在栈上的数据，当离开作用域时被移出栈。</p>
<h1 id="什么是所有权？"><a href="#什么是所有权？" class="headerlink" title="什么是所有权？"></a>什么是所有权？</h1><h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><p>要谨记这些规则：</p>
<blockquote>
<ol>
<li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li>
<li>值<strong>有且只有</strong>一个所有者。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃。</li>
</ol>
</blockquote>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>从变量被声明的点开始直到所在花括号结束。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure>



<p>存储在栈上的数据，当离开作用域时被移出栈。</p>
<p>在没有GC的语言中，内存的分配和释放都必须我们来处理。Rust 为我们调用了一个特殊的函数 <code>drop</code>，在作用域结束处<code>&#125;</code> 自动调用 <code>drop</code>函数。</p>
<h2 id="内存与分配"><a href="#内存与分配" class="headerlink" title="内存与分配"></a>内存与分配</h2><p>在堆上分配内存，意味着：</p>
<ul>
<li>必须在运行时像操作系统申请内存；</li>
<li>需要一个当我们处理完时将内存返回给操作系统的方法。</li>
</ul>
<h2 id="变量与数据交互的方式（一）：移动"><a href="#变量与数据交互的方式（一）：移动" class="headerlink" title="变量与数据交互的方式（一）：移动"></a>变量与数据交互的方式（一）：移动</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 在堆上为数据 hello 分配了内存，在栈上创建了s1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1; <span class="comment">// 在栈上创建s2，指向 hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure>

<p>例如上面代码，s2&#x3D;s1 时，并没有像Java语言那样发生浅拷贝，而是发生了<strong>移动</strong>（move），Rust 为了防止<strong>二次释放</strong>（double free）,Rust 认为 s1 不再有效，将数据的所有权移交给了 s2，这样s1 离开作用域的时候不会清理任何内容，而s2 离开作用域时会清理绑定的数据。</p>
<h2 id="变量与数据交互的方式（二）：克隆"><a href="#变量与数据交互的方式（二）：克隆" class="headerlink" title="变量与数据交互的方式（二）：克隆"></a>变量与数据交互的方式（二）：克隆</h2><p>当将<strong>堆上</strong>的数据复制时，需要使类型实现 <code>clone</code>的通用函数。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2); <span class="comment">// 因为s1.clone() 在堆上复制了一份数据，所以s1，也可以使用。</span></span><br></pre></td></tr></table></figure>



<h2 id="只在栈上的数据：拷贝"><a href="#只在栈上的数据：拷贝" class="headerlink" title="只在栈上的数据：拷贝"></a>只在栈上的数据：拷贝</h2><p>Rust 中有一个 <code>Copy</code> 的trait，如果一个类型拥有 <code>Copy</code> trait，则一个旧的变量在将其赋值给其他变量后，仍然可用。</p>
<p>发生在栈上（stack）。</p>
<blockquote>
<p>注：Rust 不允许自身或其任何部分实现了<code>Drop</code> trait 的类型使用 <code>Copy</code> trait。</p>
</blockquote>
<p>以下数据类型实现了 <code>Copy</code> 类型：</p>
<blockquote>
<p>即，赋值给第二个变量后，旧的变量依然可用。所有权没有发生移动。</p>
</blockquote>
<ul>
<li>所有整数类型，比如，<code>u32</code>.</li>
<li>布尔类型，<code>bool</code>。</li>
<li>所有浮点数据类型，比如<code>f64</code>.</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都是<code>Copy</code> 的时候，比如，<code>(i32,i32) </code> 是<code>Copy</code> 的，但<code>(i32, String)</code> 就不是。</li>
</ul>
<h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数，在语义上与给变量赋值相似。即像函数传递值可能会移动或者复制。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 所以不会有特殊操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。不会有特殊操作</span></span><br></pre></td></tr></table></figure>



<h2 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h2><p>返回值也可以转移所有权。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中, </span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership 将返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>变量的所有权总是遵循相同的模式：</p>
<ul>
<li><p>将值赋值给另一个变量时移动它。</p>
<ul>
<li><p>如果值的类型实现了<code>clone</code>这个函数，可以通过复制该值给新变量。此时在堆上是有两个值。</p>
<blockquote>
<p>也就是使用时，如果方法需要的是获取所有权，而传参是引用时，可以通过调用 clone() 复制该值，然后传递。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">pre_block</span>: &amp;Block = xxx;</span><br><span class="line">Block::<span class="title function_ invoke__">new</span>(<span class="string">&quot;&quot;</span>, pre_block.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"><span class="comment">// Block::new() 的定义如下</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: &amp;<span class="type">str</span>, pre_block: Block)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当持有堆中数据值的变量离开作用域时，其值将通过<code>drop</code> 被清理掉，除非数据所有权移动给了另一个变量所有。</p>
</li>
<li><p>实现了<code>Copy</code> trait 的数据类型，赋值后所有权并不会移动。</p>
<ul>
<li>例如，常用的标量类型，分配到栈中。</li>
</ul>
</li>
</ul>
<h1 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h1><p><code>&amp;</code> 符号就是<strong>引用</strong>， 它允许你使用值但不获取其所有权。</p>
<blockquote>
<p>注意：与使用<code>&amp;</code> 引用相反的操作是<strong>解引用</strong>（dereferencing），它使用解引用运算符<code>*</code>。我们将会在第八章遇到一些解引用运算符，并在第十五章详细讨论解引用。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，<code>&amp;s1</code> 创建了一个<strong>指向</strong><code>s1</code>的引用，但是并不拥有它。所以当引用离开作用域时，其指向的值也不会被丢弃。</p>
<p>同理，函数签名使用<code>&amp;</code>也是一样。</p>
<p>我们将获取<strong>引用</strong>作为<strong>函数参数</strong>称为<strong>借用</strong>（borrowing）。</p>
<h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><p><code>&amp;mut &lt;变量名&gt;</code> 在<code>&amp;</code>符号后面添加<code>mut</code> 可变关键字，表示该引用为可变引用。</p>
<p>Rust 为了避免数据竞争，对可变引用做了限制。</p>
<ul>
<li>在<strong>特定作用域</strong>中的特定数据有且只有一个可变引用。<ul>
<li>在不同的作用域中可以有多个可变引用</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure>



<p>引用的作用域：</p>
<ul>
<li>一个引用的作用域从声明的地方开始一直到最后一次使用为止。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line"><span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br></pre></td></tr></table></figure>



<h2 id="悬垂引用（Dangling-References）"><a href="#悬垂引用（Dangling-References）" class="headerlink" title="悬垂引用（Dangling References）"></a>悬垂引用（Dangling References）</h2><p>悬垂指针（dangling pointer），其指向的内存可能已经被分配给其他持有者。</p>
<p>在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<h2 id="引用规则总结："><a href="#引用规则总结：" class="headerlink" title="引用规则总结："></a>引用规则总结：</h2><ul>
<li>在<strong>特定作用域</strong>中的特定数据<ul>
<li><strong>要么</strong>只能有一个可变引用；</li>
<li><strong>要么</strong>只能有多个不可变引用；</li>
<li>引用必须总是有效的。</li>
</ul>
</li>
<li>在作用域不重合的情况下，才有可能有多个。<ul>
<li>参考[可变引用](# 可变引用) 中的样例。</li>
</ul>
</li>
</ul>
<h1 id="Slices（切片）"><a href="#Slices（切片）" class="headerlink" title="Slices（切片）"></a>Slices（切片）</h1><p><code>slice</code>，是一个没有所有权的数据类型。</p>
<ul>
<li>针对集合的引用；</li>
</ul>
<p>允许你引用集合中一段连续的元素序列，而不用引用整个集合。</p>
<ul>
<li>语法：<code>&amp;变量名[starting_index..ending_index]</code></li>
<li>当作参数类型声明时：<ul>
<li>数组：<code>&amp;[T]</code>，例如：<code>&amp;[i32]</code></li>
<li>字符串：<code>&amp;str</code></li>
</ul>
</li>
<li>如果从索引0开始，那么可以省略start_index部分，例如： <code>&amp;s[..5]</code>，&#x3D;&#x3D; <code>&amp;s[0..5]</code></li>
<li>如果取到结束，那么可以省略ending_index 部分，例如：<code>&amp;s[6..]</code> &#x3D;&#x3D; <code>&amp;s[6..11]</code>，这里整个字符串结尾索引为11。</li>
<li>如果表示取整个范围，可以前后都省略，即，<code>&amp;s[..]</code></li>
</ul>
<blockquote>
<p>注： <code>starting_index..ending_index</code> 这样的语法是Rust 中的 range语法，表示一个范围。</p>
</blockquote>
<ul>
<li>数据结构：<ul>
<li>slice 中存储了<ul>
<li>开始位置的引用；</li>
<li>长度；</li>
</ul>
</li>
<li>长度对应于<code>ending_index - starting_index</code> 的值；</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];  <span class="comment">// 这里表示引用 he 这两个字符</span></span><br></pre></td></tr></table></figure>



<h2 id="字符串-slice"><a href="#字符串-slice" class="headerlink" title="字符串 slice"></a>字符串 slice</h2><p>类声明： <code>&amp;str</code></p>
<h2 id="字符串字面值就是-slice"><a href="#字符串字面值就是-slice" class="headerlink" title="字符串字面值就是 slice"></a>字符串字面值就是 slice</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 这里的 s 就是 &amp;str 类型</span></span><br></pre></td></tr></table></figure>

<p>字符串字面值是不可变的，因为 <code>&amp;str</code> 是一个不可变引用。</p>
<h2 id="字符串-slice-作为参数"><a href="#字符串-slice-作为参数" class="headerlink" title="字符串 slice 作为参数"></a>字符串 slice 作为参数</h2><p>通常如果函数参数需要传递一个 <code>String</code> 类型操作参数，我们使用字符串slice 而不是<code>String</code>引用作为参数，可以使我么的函数更加通用并且不会丢失任何功能。</p>
<ul>
<li>当传递的实参为 <code>String</code> 类型时，我们传递整个<code>String</code> 的slice</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word 中传入 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word 中传入字符串字面值的 slice</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值 就是 字符串 slice，</span></span><br><span class="line">    <span class="comment">// 这样写也可以，即不使用 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="其他类型的-slice"><a href="#其他类型的-slice" class="headerlink" title="其他类型的 slice"></a>其他类型的 slice</h2><p>字符串 slice 是针对字符串的，</p>
<p>其他集合类型也有slice。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a_slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>]; <span class="comment">// 这个 slice 是 &amp;[i32] 类型的</span></span><br></pre></td></tr></table></figure>

<p>它跟字符串slice的工作方式一样。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>05结构体</title>
    <url>//05%E7%BB%93%E6%9E%84%E4%BD%93.html</url>
    <content><![CDATA[<p>struct 是一个自定义数据类型</p>
<p>在Rust 中通过 struct 来定义类型，就组织数据属性这点，有点类似于 Java 中的 Class，但又有很大不同。</p>
<p>struct 可以通过定义方法和关联函数的方式来指定与结构体数据相关的行为。</p>
<p>在Rust中可以通过在程序中基于结构体和枚举（enum）创建新类型。这样可以充分利用 Rust 的编译时类型检查。</p>
<h1 id="定义并实例化结构体"><a href="#定义并实例化结构体" class="headerlink" title="定义并实例化结构体"></a>定义并实例化结构体</h1><p>定义结构体，需要使用<code>struct</code> 关键字并为整个结构体提供一个名字。</p>
<p>在大括号中，需要定义每一部分数据的名字和类型，即<strong>字段</strong>（field）。</p>
<p><code>struct</code> 中仅定义字段，方法在外面创建。</p>
<p>struct 结构体命名规范，使用驼峰格式。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实例化结构体"><a href="#实例化结构体" class="headerlink" title="实例化结构体"></a>实例化结构体</h2><ol>
<li><p>实例化需要结构体的名字开头，</p>
</li>
<li><p>在大括号中使用<code>key:value</code> 的形式提供字段值，<code>key</code> 为字段名字，<code>value</code>为存储在字段中的数据值。</p>
<blockquote>
<p>实例中字段的顺序不需要和它们在结构体中声明的顺序一致。</p>
</blockquote>
</li>
<li><p>注意：如果结构体中有字段为私有的，如果推外提供访问，那么需要提供一个关联函数，否则外部无法通过直接实例化的方式创建结构体实例。参考<a href="7%E4%BD%BF%E7%94%A8%E5%8C%85%E3%80%81Crate%E5%92%8C%E6%A8%A1%E5%9D%97.md">第7章包、crate和模块</a></p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="使用结构体"><a href="#使用结构体" class="headerlink" title="使用结构体"></a>使用结构体</h2><p>访问结构体中的字段</p>
<ul>
<li>使用<code>.</code>点号，例如，<code>user1.email</code>。</li>
</ul>
<p>如果结构体实例是可变的，那么我们就可以修改实例中的字段值</p>
<ul>
<li>注意，Rust 中并不允许某个字段标记为可变，必须<strong>整个实例</strong>是可变的；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);  <span class="comment">// user1 实例是可变的，所以可以通过.来访问并修改email字段的值。</span></span><br></pre></td></tr></table></figure>



<p>在函数中，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式的返回整个实例。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email: email,</span><br><span class="line">        username: username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="变量与字段同名时的字段初始化简写语法"><a href="#变量与字段同名时的字段初始化简写语法" class="headerlink" title="变量与字段同名时的字段初始化简写语法"></a>变量与字段同名时的字段初始化简写语法</h2><p>当参数名与结构体字段名完全相同时，实例化时，可以使用省略<code>value</code>的写法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,   <span class="comment">// 参数名 email 与字段名相同 </span></span><br><span class="line">        username,  <span class="comment">// 一样</span></span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="用结构体更新语法从其他实例创建实例"><a href="#用结构体更新语法从其他实例创建实例" class="headerlink" title="用结构体更新语法从其他实例创建实例"></a>用结构体更新语法从其他实例创建实例</h2><p>如果一个实例从另一个实例中创建，可以仅设置不同的新值，相同的旧值字段不变。</p>
<p>这种结构体更新语法（struct update syntax），有两种：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user2 使用 user1 的部分字段</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    active: user1.active,</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user3 使用 .. 更新 user1 的部分字段</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user3</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h2><p>普通元组没有名称，</p>
<p>元组结构体：有名字，本质还是元组</p>
<ul>
<li>有着结构体的名称（这样整个元组有更明确的含义），</li>
<li>只有字段的类型，但是没有具体的字段名，</li>
</ul>
<p>特点：</p>
<ul>
<li>既可以像struct一样实例化，</li>
<li>也可以像元组一样使用；<ul>
<li>解构为单独的部分，</li>
<li>或者使用<code>.</code>后索引来访问单独的值。</li>
</ul>
</li>
</ul>
<p>使用场景：</p>
<ul>
<li>给整个元组取个名字，并使元组成为与其他元组不同的类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如上面例子，black 和 origin 值的类型不同，因为它们是不同的元组结构体的实例。</p>
</blockquote>
<h2 id="类单元结构体"><a href="#类单元结构体" class="headerlink" title="类单元结构体"></a>类单元结构体</h2><p>类单元结构体（unit-like structs）</p>
<ul>
<li><p>没有任何字段的结构体；</p>
</li>
<li><p>类似于 <code>()</code> ，即 unit 类型；</p>
</li>
</ul>
<p>使用场景：</p>
<ul>
<li>常在你想要在某个类型上实现 trait ，但是不需要在类型中存储数据的时候发挥作用。</li>
</ul>
<h1 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h1><p>结构体中除了可以存储自身拥有所有权的数据类型，还可以存储<strong>数据的引用</strong>（即所有权被其他对象拥有），</p>
<ul>
<li>存储引用，需要引入<a href="10%E6%B3%9B%E5%9E%8B%E3%80%81trait%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.md"><strong>第10章 生命周期</strong>（lifetimes）</a><ul>
<li>TODO回去找一下把同目录下的生命周期的文章链接进来；</li>
</ul>
</li>
<li>生命周期确保结构体引用的数据有效性跟结构体本身保持一致。</li>
<li>如果尝试在结构体中存储一个引用而不指定生命周期，是无效的。</li>
</ul>
<h1 id="一个使用结构体的示例程序"><a href="#一个使用结构体的示例程序" class="headerlink" title="一个使用结构体的示例程序"></a>一个使用结构体的示例程序</h1><h2 id="通过派生-trait-增加实用功能"><a href="#通过派生-trait-增加实用功能" class="headerlink" title="通过派生 trait 增加实用功能"></a>通过派生 trait 增加实用功能</h2><ol>
<li><code>println!()</code> 宏能处理很多类型的格式，不过要使用<code>&#123;&#125;</code>格式输出，需要类型实现 <code>Display</code> trait。<ul>
<li><code>std::fmt::Display</code></li>
<li>也可以在类型上添加<code>#[derive(Debug)]</code>，或实现 <code>std::fmt::Debug</code>，然后使用<code>println!(&quot;&#123;:?&#125;&quot;, rect)</code>的写法，让 Rust 打印出调试信息<ul>
<li>注：rect是一个类型变量</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//println!(&quot;rect1 is &#123;:#?&#125;&quot;, rect1); 使用&#123;:#?&#125; 打印可以更好看一些。</span></span><br></pre></td></tr></table></figure>



<h1 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a>方法语法</h1><p>方法为结构体实例指定行为。</p>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><p>结构体的方法写在<code>impl</code> 块中（<code>impl</code> 是 implementation 缩写）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名称 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> 结构体名称 &#123;</span><br><span class="line">    <span class="comment">// 定义该结构体的方法</span></span><br><span class="line">    e.g. <span class="keyword">fn</span> <span class="title function_">xx</span>() &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>impl</code>与 <code>struct</code>  是分离的，这点与 Java 不一样。</li>
</ul>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>方法与函数类似，</p>
<p>最大的不同是，**方法的第一个参数总是<code>self</code>**，它代表调用该方法的结构体实例。</p>
<ul>
<li><p><code>self</code>,<code>mut self</code>,<code>&amp;self</code>,<code>&amp;mut self</code></p>
</li>
<li><p>方法签名中，可以在<code>self</code> 后增加多个参数，这些参数就像函数中的参数一样工作；</p>
</li>
<li><p>方法与实例关联，实例化后才能调用方法；</p>
</li>
<li><p>函数可以独立存在，也可以与结构体关联（关联函数，不需要实例化可以直接通过<code>::</code>符号调用）；</p>
</li>
</ul>
<blockquote>
<p>直接将<code>self</code> 作为第一个参数来使用，获取实例的所有权是很少见的；</p>
</blockquote>
<ul>
<li><p>通常用在当方法将<code>self</code>转换成别的实例的时候，这时我们想要防止调用者在转换之后使用原始的实例。（通过移动所有权来做防范）</p>
</li>
<li><p>大部分情况是使用 <code>&amp;self</code> 或者<code>&amp;mut self</code> ，即我们只希望能够使用（读取&#x2F;修改）结构体中的数据，并不想获取所有权。</p>
</li>
</ul>
<p>自动引用和解引用（automatic referencing and dereferencing）</p>
<ul>
<li>当在 Rust 中使用 <code>object.something()</code>调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使<code>object</code> 与方法签名匹配。</li>
</ul>
<p>样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug,Copy,Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">distance</span>(&amp;<span class="keyword">self</span>, other: &amp;Point) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">x_squared</span> = <span class="type">f64</span>::<span class="title function_ invoke__">powi</span>(other.x - <span class="keyword">self</span>.x, <span class="number">2</span>);</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">y_squared</span> = <span class="type">f64</span>::<span class="title function_ invoke__">powi</span>(other.y - <span class="keyword">self</span>.y, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">f64</span>::<span class="title function_ invoke__">sqrt</span>(x_squared + y_squared)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">0.0</span>, y: <span class="number">0.0</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="number">5.0</span>, y: <span class="number">6.5</span> &#125;;</span><br><span class="line"><span class="comment">// 计算p1，p2 两点的距离</span></span><br><span class="line"><span class="comment">// 下面两种方法调用的写法是等价的。</span></span><br><span class="line">p1.<span class="title function_ invoke__">distance</span>(&amp;p2); <span class="comment">// rust 自动处理了</span></span><br><span class="line">(&amp;p1).<span class="title function_ invoke__">distance</span>(&amp;p2); </span><br></pre></td></tr></table></figure>



<h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><p>关联函数将特定功能置于结构体的命名空间中并且无需一个实例。</p>
<p>在 <code>impl</code> 块中，可以定义<strong>不</strong>以<code>self</code> 作为参数的函数，称为<strong>关联函数</strong>（associated functions）。</p>
<ul>
<li>关联函数与结构体相关联；（它们仍然是函数而不是方法）<ul>
<li>从与结构体的关系上来看，有点类似于 Java 中的静态方法；</li>
<li>例如 <code>String::from</code> 关联函数。</li>
</ul>
</li>
</ul>
<p>调用方式：</p>
<ul>
<li>使用结构体名和 <code>::</code> 语法来调用关联函数；</li>
</ul>
<h2 id="多个-impl-块"><a href="#多个-impl-块" class="headerlink" title="多个 impl 块"></a>多个 <code>impl</code> 块</h2><p>每个结构体都允许拥有多个 <code>impl</code> 块。每个方法都属于其中一个 <code>impl</code> 块。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>结构体允许你创建出在你的领域中有意义的自定义类型。通过结构体，我们可以将相关联的数据片段联系起来并命名。</li>
<li>方法，允许为结构体实例指定行为；</li>
<li>关联函数，将特定功能置于结构体的命名空间中，并且无需一个实例；</li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>06枚举与模式匹配</title>
    <url>//06%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html</url>
    <content><![CDATA[<p>枚举（enumerations），也被成为 enums。</p>
<h1 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h1><p>枚举名命名规范：驼峰格式</p>
<p>枚举的内容称为，<strong>成员</strong>。</p>
<ul>
<li>枚举的成员位于其标识符的命名空间中，使用<code>::</code>（两个冒号）分开。</li>
<li>枚举成员可以附加数据，使用<code>()</code>圆括号。<ul>
<li>可以将<strong>任意类型</strong>的数据放入枚举成员中<ul>
<li>例如，字符串、数字类型或者结构体，甚至还可以包含另一个枚举</li>
</ul>
</li>
</ul>
</li>
<li>可以使用 <code>impl</code> 在枚举上定义方法</li>
</ul>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接访问</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数获取</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_type: IpAddrKind) &#123;&#125;</span><br><span class="line"><span class="title function_ invoke__">route</span>(IpAddrKind::V4);</span><br><span class="line"><span class="title function_ invoke__">route</span>(IpAddrKind::V6);</span><br></pre></td></tr></table></figure>

<p>成员包含多种类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,  <span class="comment">// 没有关联任何数据</span></span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,  <span class="comment">// 包含一个匿名结构体</span></span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>), <span class="comment">// 包含单独一个 `String`</span></span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>), 包含三个`<span class="type">i32</span>`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在枚举上定义方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里定义方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个Message枚举，并调用call方法</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">m.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure>



<blockquote>
<p>使用枚举时需要注意：</p>
<ol>
<li>枚举成员的类型，是枚举本身；</li>
<li>同一枚举成员的类型，是相同的；</li>
<li>（与 Java 一样）</li>
</ol>
</blockquote>
<p>在 Rust 中，如果定义一个枚举，任何值只能是一个枚举的成员，且枚举的成员从根本上将仍是枚举，所以使用枚举中任何成员时，都应该看做是相同的类型。</p>
<ul>
<li>例如：IP地址要么是IPv4，要么是IPv6，只能是其中之一，且IPv4和IPv6都是IP地址，所以任何类型的IP地址都是看做相同的类型；</li>
<li>举例2：Result&lt;T,E&gt;，无论是 Ok(T) ，还是 Err(E)，它们本质上都是一种结果。所以在使用时，Ok 和 Err 是相同类型，即 Result。</li>
</ul>
<h2 id="Option-枚举和其相对于空值的优势"><a href="#Option-枚举和其相对于空值的优势" class="headerlink" title="Option 枚举和其相对于空值的优势"></a>Option 枚举和其相对于空值的优势</h2><p>空值（Null）是一个值，它代表没有值。</p>
<ul>
<li>空值的问题在于当你尝试像一个非空值那样使用一个空值，会出现某种形式的错误。因为空和非空的属性无处不在，非常容易出现这类错误。</li>
</ul>
<p>空值表达的概念是有意义的：空值是一个因为某种原因目前无效或缺失的值。</p>
<p>Rust 中没有空值。不过拥有一个可以编码存在或不存在概念的枚举。</p>
<ul>
<li><code>Optin&lt;T&gt;</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>&lt;T&gt;,</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义于标准库中，并被包含在 prelude 之中，不需要显示引入作用域；</li>
<li>它的成员可以不需要<code>Option::</code> 前缀，可以直接使用 <code>Some</code> 和 <code>None</code>；</li>
<li><code>Some&lt;T&gt;</code> 中的 <code>&lt;T&gt;</code> 语法是 Rust 的<a href="10%E6%B3%9B%E5%9E%8B%E3%80%81trait%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.md">泛型</a>；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用 None 而不是 Some，需要告诉 Rust `Option&lt;T&gt;` 是什么类型</span></span><br><span class="line"><span class="comment">// 因为编译器无法根据 None 值推断出 Some 成员保存的值的类型；</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注： <code>Option&lt;T&gt;</code> 和 <code>T</code> （这里的 <code>T</code>  可以是任何类型）是不同的类型。</p>
</blockquote>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol>
<li><p>当想拥有一个可能为空的值时，显示的将其放入对应的类型的<code>Option&lt;T&gt;</code> 中；</p>
</li>
<li><p>当使用该值时，必须明确的而处理值为空的情况。</p>
<blockquote>
<p>只要一个值不是<code>Option&lt;T&gt;</code> 类型，就可以安全的认定它的值不为空。</p>
</blockquote>
</li>
</ol>
<p>Rust 这个设计可以限制空值的泛滥以增加 Rust 的安全性。</p>
<p>TODO： 记录几个常用的 <code>Option&lt;T&gt;</code> 的方法</p>
<p>枚举常常和 <code>match</code> 一起使用。</p>
<h1 id="match-控制流运算符"><a href="#match-控制流运算符" class="headerlink" title="match 控制流运算符"></a>match 控制流运算符</h1><p><code>match</code> 是控制流运算符 （有点类似于 Java 的 switch，与scala 中的 match 极其相似）</p>
<ul>
<li>允许我们将一个值与一系列的模式相比较，并根据匹配的模式执行相应的代码</li>
<li><a href="18%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8C%B9%E9%85%8D.md">第十八章会涉及所有不同种类的模式及作用</a></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> 表达式 &#123;</span><br><span class="line">    模式 =&gt; 表达式,   <span class="comment">// 表达式的结果值将作为整个 match 表达式的返回值;</span></span><br><span class="line">    模式<span class="number">2</span> =&gt; &#123;       <span class="comment">// 分支代码比较短,通常不使用大括号,长的则使用大括号;</span></span><br><span class="line">        表达式<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h2><p>不管枚举成员是否包含值, 都可以进行 <code>match</code> 模式匹配</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="匹配Option-lt-T-gt"><a href="#匹配Option-lt-T-gt" class="headerlink" title="匹配Option&lt;T&gt;"></a>匹配<code>Option&lt;T&gt;</code></h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>



<h2 id="匹配是穷尽的"><a href="#匹配是穷尽的" class="headerlink" title="匹配是穷尽的"></a>匹配是穷尽的</h2><p>Rust 中 <code>match</code> 匹配是<strong>穷尽的</strong>(exhaustive)</p>
<ul>
<li>必须<strong>穷举到最后</strong>的可能性来使代码有效</li>
<li>Rust 编译器会帮我们检查</li>
</ul>
<h2 id="通配模式和-占位符"><a href="#通配模式和-占位符" class="headerlink" title="通配模式和 _ 占位符"></a>通配模式和 <code>_</code> 占位符</h2><p>Rust 提供了一个通配模式，和一个使用<code>_</code>的特殊模式，用于不想列举出所有可能值的场景。</p>
<p><strong>通配模式</strong>：</p>
<ol>
<li>将匹配所有未被列出的值；（满足了<code>match</code>必须被穷尽的要求）</li>
<li>通配分支要放在最后；（后面不能有其他分支，有也不会被匹配到）</li>
<li><strong>可以使用</strong>自定义的变量；</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    other =&gt; <span class="title function_ invoke__">move_player</span>(other),   <span class="comment">// other分支，通过将 other传递给函数来使用这个变量。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">remove_fancy_hat</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">move_player</span>(num_spaces: <span class="type">u8</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>_</code> 占位符模式</strong>：</p>
<ol>
<li>与通配模式的不同点：匹配后的表达式中<strong>不能使用</strong><code>_</code>，<ul>
<li>即<code>_</code>占位符不能被用于模式右边的表达式中；（告诉 Rust 我们不会使用该值，所以 Rust 也不会警告我们存在未使用的变量）</li>
</ul>
</li>
<li>其余特点与通配模式一样；</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_u8_value</span> = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">    _ =&gt; (),  <span class="comment">// 剩下的所有可能在这里，() 表示 unit 值，就是什么也不做；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="if-let-简洁控制流"><a href="#if-let-简洁控制流" class="headerlink" title="if let 简洁控制流"></a>if let 简洁控制流</h1><p>当我们只关心匹配一个模式分支的时候，可以使用 <code>if let</code> 表达式代替 <code>match</code></p>
<blockquote>
<p>疑问：直接使用 if 表达式不是也可以吗？为什么要单独创建 if let 表达式？</p>
</blockquote>
<p>语法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">pattern</span> = value &#123;   <span class="comment">// 这里是关心匹配的模式</span></span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    <span class="comment">// else 中的内容与 match 的 _ 通配符效果一样，即剩下的所有模式；</span></span><br><span class="line">    <span class="comment">// another</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if let</code> 是 <code>match</code> 的一个语法糖</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">let</span> <span class="variable">some_u8_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">0u8</span>);</span><br><span class="line"><span class="comment">// if let 的方式与 match 行为一致</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>08常见集合</title>
    <url>//08%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[<p>集合（collections）由标准库（std）提供；</p>
<p>集合（collections）指向的数据是存储在<strong>堆</strong>上的，可以随着程序的运行增长或缩小。</p>
<ul>
<li>集合可以存储多个值</li>
</ul>
<h1 id="使用可变长数组（Vector）存储一系列的值"><a href="#使用可变长数组（Vector）存储一系列的值" class="headerlink" title="使用可变长数组（Vector）存储一系列的值"></a>使用可变长数组（Vector）存储一系列的值</h1><p><code>Vec&lt;T&gt;</code>，也被称为 vector。</p>
<ul>
<li>可以存储多个值；</li>
<li>只能存储<strong>相同类型</strong>的值；</li>
<li>在内存中彼此相邻地排列所有值。<ul>
<li>内存连续</li>
</ul>
</li>
</ul>
<p>与slices类似，其大小在编译期是不可知的。</p>
<p>一个 vector 由三部分组成：</p>
<ul>
<li>指向堆上数据的指针；</li>
<li>当前长度；</li>
<li>当前总容量；<ul>
<li>表示vector预留的内存大小。当长度超过阈值，就会扩容。</li>
</ul>
</li>
</ul>
<h2 id="新建-vector"><a href="#新建-vector" class="headerlink" title="新建 vector"></a>新建 vector</h2><p>有两种方法</p>
<p>方法一：使用<code>Vec::new</code>函数创建新的空 vector。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个空的 vector，存储 i32 类型的值；</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当新建空的 vector 时，</p>
<ol>
<li>如果不存储数据，那么 Rust 无法知道存储什么类型的元素，所以要声明变量类型；</li>
<li>如果后面添加数据，则可以不用显示声明变量类型；</li>
</ol>
</blockquote>
<p>方法二：使用 <code>vec!</code> 宏，提供初始值来创建一个 <code>vec</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个包含初值的 vector;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为提供的初始值为 <code>i32</code> 类型的，所以 Rust 可以推断出 v 的类型是 <code>Vec&lt;i32&gt;</code>，因此可以省略标注类型。</p>
</blockquote>
<h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>使用 <code>push</code> 向 vector 中添加其他元素；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>想改变 v 的值，需要使用 <code>mut</code> 关键字使其可变。</p>
<p>因为放入的值都是 <code>i32</code> 类型的，所以这里也可以省略类型标注。</p>
</blockquote>
<p>不能向 immutable vector 中添加数据；</p>
<h2 id="丢弃-vector-时也会丢弃其所有元素"><a href="#丢弃-vector-时也会丢弃其所有元素" class="headerlink" title="丢弃 vector 时也会丢弃其所有元素"></a>丢弃 vector 时也会丢弃其所有元素</h2><p>与其他 struct 类似，vector 在其离开作用域时会被释放。其中包含的数据也将被清理。</p>
<h2 id="读取-vector-的元素"><a href="#读取-vector-的元素" class="headerlink" title="读取 vector 的元素"></a>读取 vector 的元素</h2><p>有两种方法引用 vector 中存储的值。</p>
<p>方法一：索引语法（索引从 0 开始），<code>[&lt;索引&gt;]</code> ， 返回一个引用；</p>
<p>方法二：<code>get(&lt;索引&gt;)</code> 方法，返回一个 <code>Option&lt;&amp;T&gt;</code>；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];  <span class="comment">// 这里 third = 3；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">second</span>: <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; = v.<span class="title function_ invoke__">get</span>(<span class="number">1</span>); <span class="comment">// 这里 second = 2;</span></span><br></pre></td></tr></table></figure>



<p>注意：Rust 提供两种引用元素的方法，我们可以选择如何处理当索引值在 vector 中没有对应值的情况。</p>
<ul>
<li>索引语法，<code>[]</code> ，当引用一个不存在的元素时，Rust 会发生 panic。<ul>
<li>适合当程序认为尝试访问<strong>超过</strong> vector 结尾的元素是一个严重错误的时候，使程序<strong>崩溃</strong>。</li>
</ul>
</li>
<li>get 方法，当传递一个数组外的索引时，它<strong>不会 panic</strong>，而是返回 <code>None</code>，（因为是 <strong><code>Option&lt;T&gt;</code> 类型</strong>）。<ul>
<li>适合当偶尔超出 vector 范围的访问属于正常情况的时候；</li>
<li>同时需要你的代码后面有处理 <code>Some(&amp;element)</code> 或 <code>None</code> 的逻辑。</li>
<li>例如，索引参数来自用户输入，在用户输入过大数字时，程序得到 <code>None</code> 值，程序可以告诉用户当前 vector 元素的数量，并请求他们再输入一个有效值。这样比因为输入错误而使得程序崩溃要友好的多。</li>
</ul>
</li>
</ul>
<p>vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下（连续内存空间），可能会要求分配新内存并将老的元素拷贝到新的空间中。原有空间会被释放。</p>
<p>一旦程序获取一个有效的引用，借用检查器会执行所有权和借用规则，确保 vector 内容的引用和任何其他引用保持有效。</p>
<blockquote>
<p> 注意：关于 <code>Vec&lt;T&gt;</code> 类型的更多实现细节，在 <a href="https://doc.rust-lang.org/stable/nomicon/vec.html">https://doc.rust-lang.org/stable/nomicon/vec.html</a> 查看 “The Nomicon”</p>
</blockquote>
<h2 id="遍历-vector-中的元素"><a href="#遍历-vector-中的元素" class="headerlink" title="遍历 vector 中的元素"></a>遍历 vector 中的元素</h2><p>使用 <code>for</code> 循环依次获取 vector 中的元素</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>,<span class="number">32</span>,<span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;  <span class="comment">// 这里获取的是不可变引用</span></span><br><span class="line">    <span class="built_in">println!</span>&#123;<span class="string">&quot;&#123;&#125;&quot;</span>,i&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>,<span class="number">32</span>,<span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;  <span class="comment">// 这里是可变引用；</span></span><br><span class="line">    *i += <span class="number">50</span>;   <span class="comment">// 为了修改可变引用所指向的值，需要使用 解引用符号 * ，获取 i 中的值；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第十五章的 <a href="15%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md#%E9%80%9A%E8%BF%87%E8%A7%A3%E5%BC%95%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%BD%E8%B8%AA%E6%8C%87%E9%92%88%E7%9A%84%E5%80%BC">“通过解引用运算符追踪指针的值”</a> 部分会详细介绍解引用运算符。</p>
<h2 id="使用枚举来存储多种类型"><a href="#使用枚举来存储多种类型" class="headerlink" title="使用枚举来存储多种类型"></a>使用枚举来存储多种类型</h2><p>vector 是可变数组，所以和数组一样只能存储相同类型的值。</p>
<p>如何存储不同类型的值？</p>
<ul>
<li>使用枚举；</li>
</ul>
<p><strong>枚举的成员都被定义为相同的枚举类型</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个枚举，便能在 vector 中存放不同类型的数据了。对于 Rust 来说，vector 中存放的都是 SpreadsheetCell 枚举类型。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>



<p>为什么 Rust 需要在编译时知道 vector 中数据的类型？</p>
<ol>
<li>因为 Rust 需要知道存储每个元素需要多少内存；</li>
<li>可以准确的知道 vector 中允许什么类型，防止操作不同类型元素时造成错误；</li>
</ol>
<p>所以使用枚举 + <code>match</code>匹配，意味着 Rust 能在编译时就保证可以处理所有可能的情况。</p>
<h2 id="TODO-，查看-vec-的标准库-API-文档，了解-vec-的其他用法"><a href="#TODO-，查看-vec-的标准库-API-文档，了解-vec-的其他用法" class="headerlink" title="TODO ，查看 vec 的标准库 API 文档，了解 vec 的其他用法"></a>TODO ，查看 vec 的标准库 API 文档，了解 vec 的其他用法</h2><h1 id="使用字符串（String）存储-UTF-8-编码的文本"><a href="#使用字符串（String）存储-UTF-8-编码的文本" class="headerlink" title="使用字符串（String）存储 UTF-8 编码的文本"></a>使用字符串（String）存储 UTF-8 编码的文本</h1><h2 id="什么是字符串？"><a href="#什么是字符串？" class="headerlink" title="什么是字符串？"></a>什么是字符串？</h2><p>Rust 核心语言中，只有一种字符串类型： <code>str</code>，字符串切片（slice），它通常以被借用的形式出现，即 <code>&amp;str</code>。 </p>
<p><code>String</code> 是由标准库（std）提供的，可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。（所以在堆上）</p>
<ul>
<li><code>String</code> 和 <code>&amp;str</code> 都是 UTF-8 编码的。</li>
<li><code>&amp;str</code> 是 <code>&amp;[u8]</code></li>
</ul>
<p>Rust 标准库中还包含一系列其他字符串类型，例如，<code>OsStgring</code>，<code>OsStr</code>，<code>CString</code>等，更多有关如何使用它们以及各自适合的场景，请参考其 API 文档。</p>
<blockquote>
<p>注意：<code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。</p>
</blockquote>
<h2 id="新建字符串"><a href="#新建字符串" class="headerlink" title="新建字符串"></a>新建字符串</h2><ol>
<li>新建空字符串</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从已有数据中创建新字符串类型<ul>
<li><code>.to_string()</code> 方法</li>
<li><code>String::from()</code> 关联函数</li>
</ul>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;initial&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = data.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样适用于字符串字面值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">&quot;initial&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;initial&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="更新字符串"><a href="#更新字符串" class="headerlink" title="更新字符串"></a>更新字符串</h1><p><code>String</code> 大小是可变的，内容也可以更改。</p>
<ol>
<li><p>使用 <code>+</code> 运算符，或 <code>format!</code> 宏来拼接 <code>String</code> 值；</p>
<ul>
<li><code>+</code> 类似于<code>fn add(self, s: &amp;str) -&gt; String &#123;</code> 这样的签名，因为<code>sefl</code>没有使用<code>&amp;</code>。所以<code>+</code> 号前的变量会获取所有权，而 <code>+</code> 号后的变量仅是获取引用；</li>
<li>使用 <code>format!</code>宏，不会获取任何参数的所有权，类似于 <code>println!</code> 宏</li>
</ul>
</li>
<li><p>使用 <code>push_str</code> 和 <code>push</code> 附加字符串</p>
<ul>
<li><code>push_str</code> 将一个字符串切片追加（&amp;str 是一种引用，不获取所有权）;</li>
<li><code>push</code> 将一个字符追加 <code>.push(ch: char)</code> ,char 是单引号；</li>
</ul>
</li>
</ol>
<p>例如：使用 <code>push_str</code> 和 <code>push</code> 的例子</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = s1 + <span class="string">&quot;-&quot;</span> + &amp;s2 + <span class="string">&quot;-&quot;</span> + &amp;s3;</span><br><span class="line"></span><br><span class="line">返回：<span class="string">&quot;tic-tac-toe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是多个字符串连接，可以使用 format! 宏</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1,s2,s3);</span><br></pre></td></tr></table></figure>



<p>为什么 <code>+</code> 运算符可以允许 <code>&amp;str</code> 与 <code>String</code> 相加？而不能将两个 <code>String</code> 值相加？也是因为 add 的签名：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面第二个参数是 <code>&amp;str</code> ，在 <code>add</code> 调用中使用 <code>&amp;str</code> 是因为 <code>&amp;String</code> 可以被<strong>强制转换</strong>（coerced）成 <code>&amp;str</code>。 Rust 使用了一个被称为<strong>解引用强制多态</strong>（derefcoercion）的技术，把 <code>&amp;String</code> 变为 <code>&amp;str</code> ，即把 <code>&amp;s2</code> 变为了 <code>&amp;s2[..]</code> 。</p>
<blockquote>
<p><a href="15%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md">第十五章</a>会更深入的讨论解引用强制多态。</p>
</blockquote>
<h2 id="不支持使用索引语法获取字符串的内容"><a href="#不支持使用索引语法获取字符串的内容" class="headerlink" title="不支持使用索引语法获取字符串的内容"></a>不支持使用索引语法获取字符串的内容</h2><p>在 Rust 中不允许使用索引语法获取 <code>String</code> 的一部分。</p>
<p>因为字符串索引返回的类型是不明确的，可能是：字节值、字符、字形簇或者字符串切片。</p>
<h2 id="字节、标量值和字形簇"><a href="#字节、标量值和字形簇" class="headerlink" title="字节、标量值和字形簇"></a>字节、标量值和字形簇</h2><p>从 Rust 的角度看，有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中的<strong>字母</strong>的概念）。</p>
<p><code>String</code> 的底层存储使用 <code>Vec&lt;u8&gt;</code> 的形式。，所以存储的是 <code>u8</code>格式，并不是我们眼中的字母。</p>
<h2 id="支持使用字符串切片"><a href="#支持使用字符串切片" class="headerlink" title="支持使用字符串切片"></a>支持使用字符串切片</h2><p>因为字符串切片使用的是<code>[]</code> 和 <code>range</code>（一个范围）来创建含特定字节的字符串切片。</p>
<p><strong>但是</strong>：如果获取的无效索引范围不能表达一个完整字符，那么 Rust 会在运行是 panic，与访问 vector 中的无效索引一样。所以要小心使用字符串切片获取部分字符串的操作。</p>
<h2 id="遍历字符串的方法"><a href="#遍历字符串的方法" class="headerlink" title="遍历字符串的方法"></a>遍历字符串的方法</h2><ol>
<li>如果希望操作单独的 Unicode 标量值，最好的选择是使用 <code>chars</code>方法</li>
<li><code>bytes</code>方法返回每一个原始字节。</li>
</ol>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回 <span class="number">6</span> 个<span class="type">char</span> 类型的值：</span><br><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回 <span class="number">18</span>个字节：</span><br><span class="line"><span class="number">224</span></span><br><span class="line"><span class="number">164</span></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="number">165</span></span><br><span class="line"><span class="number">135</span></span><br></pre></td></tr></table></figure>



<p>Rust 中必须更多的思考如何预先处理 UTF-8 数据，</p>
<ul>
<li>这种权衡取舍比其他语言更多的暴露了字符串的复杂性；</li>
<li>不过也使你在开发生命周期后期免于处理涉及非 ASCII 字符的错误。</li>
</ul>
<h2 id="字符串解析"><a href="#字符串解析" class="headerlink" title="字符串解析"></a>字符串解析</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Basic usage</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">four</span>: <span class="type">u32</span> = <span class="string">&quot;4&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">4</span>, four);</span><br><span class="line">Using the <span class="symbol">&#x27;turbofish</span>&#x27; instead of annotating four:</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = <span class="string">&quot;4&quot;</span>.parse::&lt;<span class="type">u32</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Ok</span>(<span class="number">4</span>), four);</span><br></pre></td></tr></table></figure>

<p><code>path::&lt;xx&gt;,</code></p>
<p><code>method::&lt;xx&gt;()</code></p>
<p>为表达式中的泛型类型，函数或方法指定参数，有助于推测算法具体了解我们需要解析的类型。</p>
<h1 id="在-Hash-映射中存储键值对"><a href="#在-Hash-映射中存储键值对" class="headerlink" title="在 Hash 映射中存储键值对"></a>在 Hash 映射中存储键值对</h1><p><code>HashMap&lt;K,V&gt;</code> 类型存储了一个键类型 K，对应一个值类型 V 的映射。</p>
<p>通过一个 hash 函数（hashing function）来实现映射，决定如何将键和值放入内存中。</p>
<p>更多方法需要查看标准库文档。</p>
<h2 id="新建一个-HashMap"><a href="#新建一个-HashMap" class="headerlink" title="新建一个 HashMap"></a>新建一个 HashMap</h2><p>因为 <code>HashMap</code> 在标准库，但不在 prelude 中，所以使用 <code>HashMap</code> 之前，必须使用 <code>use</code> 将标准库中集合部分的 <code>HashMap</code> 引入当前项目作用域中。</p>
<p>有两种方法</p>
<p>方法一，使用 <code>new</code>关联函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>创建空 <code>HashMap</code> 后，需要使用 <code>insert</code> 方法插入数据；</p>
<p>方法二：使用一个元组的 vector 的 <code>collect</code> 方法。其中每个元组包含一个键值对。</p>
<p><code>collect</code> 方法可以将数据收集进一系列的集合方法，包括 <code>HashMap</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">teams</span>  = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 HashMap&lt;_,_&gt; 类型标注是必要的，因为可能 collect 很多不同的数据结构，除非显示指定，否则 Rust 无从知道你需要的类型。但是对于键值对类型参数来说，可以使用 _ 下划线占位，Rust 能够根据 vector 中数据的类型推断出 HashMap 所包含的类型。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">scores</span>: HashMap&lt;_, _&gt; = teams.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>



<h2 id="HashMap-和所有权"><a href="#HashMap-和所有权" class="headerlink" title="HashMap 和所有权"></a>HashMap 和所有权</h2><p>像 <code>i32</code> 这样实现了 <code>Copy</code> trait 的类型，其值可以拷贝进 HashMap；</p>
<p>像 String 这样拥有所有权的值，其值将被移动，而 HashMap 会成为这些值的所有者。</p>
<p>如果将值的引用插入 HashMap，那么这些值本身将不会被移动进 HashMap，但是这些引用指向的值必须至少在 HashMap 有效时也是有效的。</p>
<ul>
<li>参考 <a href="10%E6%B3%9B%E5%9E%8B%E3%80%81trait%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.md">10泛型、trait与生命周期</a></li>
</ul>
<h2 id="访问-HashMap-中的值"><a href="#访问-HashMap-中的值" class="headerlink" title="访问 HashMap 中的值"></a>访问 HashMap 中的值</h2><p>可以使用 <code>get</code> 方法，通过键来获取值。</p>
<ul>
<li><code>get</code> 返回 <code>Option&lt;V&gt;</code>，有结果就返回<code>Some&lt;V&gt;</code>，没有结果就返回 <code>None</code>。</li>
</ul>
<p>也可以使用 <code>vector</code> 类似的方式来遍历 <code>HashMap</code> 中的键值对</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="更新HashMap"><a href="#更新HashMap" class="headerlink" title="更新HashMap"></a>更新HashMap</h2><h3 id="覆盖一个值"><a href="#覆盖一个值" class="headerlink" title="覆盖一个值"></a>覆盖一个值</h3><p><code>insert</code> 方法默认会将同一个<code>key</code> 的原有值覆盖掉；</p>
<h3 id="只在键没有对应值时插入"><a href="#只在键没有对应值时插入" class="headerlink" title="只在键没有对应值时插入"></a>只在键没有对应值时插入</h3><ol>
<li><code>Entry</code> 会检查是否存在该键值，返回一个枚举。</li>
<li>然后调用 Entry 的 <code>or_insert</code> 方法。有值就不插入，没有值就插入。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>



<h3 id="根据旧值更新一个值"><a href="#根据旧值更新一个值" class="headerlink" title="根据旧值更新一个值"></a>根据旧值更新一个值</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure>

<p><code>or_insert</code> 方法事实上返回这个键的值的一个可变引用（<code>&amp;mut V</code>）。我们这里将这个可变引用存储在 count 变量中，所以为了赋值必须首先使用星号（<code>*</code>）解引用 <code>count</code>。然后在 for 循环作用域内完成，这样所有改变都是安全的并复合借用规则的。</p>
<h2 id="作为-HashMap-的Key"><a href="#作为-HashMap-的Key" class="headerlink" title="作为 HashMap 的Key"></a>作为 HashMap 的Key</h2><p>任何类型实现了 <code>Eq</code> 和 <code>Hash</code> 两个 trait 都可以作为 HashMap 的 Key。 </p>
<ul>
<li><code>bool</code></li>
<li><code>int</code>，<code>uint</code>，和其他所有的变化，</li>
<li><code>String</code> 和 <code>&amp;str</code></li>
</ul>
<p><code>f32</code> 和 <code>f64</code> 不能作为 Key，因为不能实现 <code>Hash</code>，原因是浮点数的精度问题，如果作为hashmap的key 非常容易出错。</p>
<p>如果集合类包含的类型也分别实现了Eq和Hash，那么所有集合类都实现了Eq和Hash。例如，如果T实现Hash, Vec<T>将实现Hash。？？？</p>
<h3 id="自定义类型如何实现-Eq-和-Hash？"><a href="#自定义类型如何实现-Eq-和-Hash？" class="headerlink" title="自定义类型如何实现 Eq 和 Hash？"></a>自定义类型如何实现 <code>Eq</code> 和 <code>Hash</code>？</h3><p>只需要如下属性：</p>
<p><code>#[derive(PartialEq, Eq, Hash)]</code></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>07使用包、Crate和模块</title>
    <url>//07%E4%BD%BF%E7%94%A8%E5%8C%85%E3%80%81Crate%E5%92%8C%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<p>模块系统（the module system）</p>
<ul>
<li>包（packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate；</li>
<li>Crates：一个模块的树形结构，它形成了库或二进制项目；</li>
<li>模块（modules）和 use ：允许你控制作用域和路径的私有性；</li>
<li>路径（path）：一个命名例如结构体、函数或模块等项的方式；</li>
</ul>
<h1 id="包和crate"><a href="#包和crate" class="headerlink" title="包和crate"></a>包和crate</h1><p>包（package）：我们通过 <code>cargo new &lt;my-project&gt;</code> 命令创建出来的 my-project 项目中，my-project 就是我们的包名。</p>
<p>crate 是一个二进制项或者库。</p>
<p><code>crate root</code> 是一个源文件，Rust 编译器以它为起点，并构建你的 crate 的根模块。</p>
<p>包（package）是提供一系列功能的一个或多个 crate。</p>
<ul>
<li>一个包会包含一个 Cargo.toml 文件，阐述如何取构建这些 crate。</li>
</ul>
<p>包中包含的内容由以下几条规则来确立：</p>
<ol>
<li>一个包中至多只能包含一个库 crate（library crate）；</li>
<li>包中可以包含任意多个二进制 crate（binary crate）；</li>
<li>包中至少包含一个 crate（库 crate &#x2F; 二进制 crate）;</li>
</ol>
<p>当我们使用 <code>cargo new my-project</code> 的方式创建新项目<code>my-project</code>的时候，Cargo 会自动创建<code>src/main.rs</code> 的文件</p>
<ul>
<li><p>my-project 就是我们当前项目的包（package）;</p>
</li>
<li><p>Cargo 遵守了一个约定，</p>
<ul>
<li><code>src/main.rs</code> 就是一个与包同名的二进制 crate 的 crate 根；</li>
<li><code>src/lib.rs</code> ，则是一个与包同名的 库 crate，且 <code>src/lib.rs</code> 是 crate 根;</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cargo 命令创建项目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的是默认包含 src/main.rs 的二进制 crate</span></span><br><span class="line">cargo new &lt;my-project&gt;  </span><br><span class="line"><span class="comment">// 创建的是默认包含 src/lib.rs 的库 crate</span></span><br><span class="line">cargo new --lib &lt;my-project&gt;  </span><br></pre></td></tr></table></figure>



<p><strong>crate 根文件</strong>的作用：</p>
<ul>
<li>Cargo 会将 crate 根文件传递给 rustc 来实际构建库或者二进制项目。</li>
</ul>
<p>一个包如何拥有多个二进制 crate ？</p>
<ul>
<li>通过将文件放在 <code>src/bin</code> 目录下；</li>
<li>每个 <code>src/bin</code> 下的文件都会被编译成为一个独立的二进制 crate；</li>
</ul>
<p>一个 crate 的功能是在自身作用域中进行命名的，例如，当我们将 <code>rand</code> 作为一个依赖，编译器不会混淆 <code>Rng</code> 这个名字的指向。我们可以通过<code>rand::Rng</code> 的方式来访问 rand crate 中的 Rng trait，而我们也可以在我们的 crate 中，创建自己的 Rng struct，指向不一样。</p>
<h1 id="定义模块来控制作用域与私有性"><a href="#定义模块来控制作用域与私有性" class="headerlink" title="定义模块来控制作用域与私有性"></a>定义模块来控制作用域与私有性</h1><p><code>模块</code> 的作用：</p>
<ul>
<li>将一个 crate 中的代码分组。提高可读性与重用性。</li>
<li>控制项的私有性，<ul>
<li>即可以被外部代码访问的 public；</li>
<li>作为内部实现的，不能被外部代码使用的 private；<ul>
<li>Rust 默认所有项（函数、方法、结构体、枚举、模块和常量）都是 private 的；</li>
<li>父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项。</li>
<li>可以使用 [<code>pub</code> ](# 使用 pub 关键字暴露路径)关键字创建公共项，使子模块的内部部分暴露给上级模块。</li>
<li>模块（mod）上的 <code>pub</code> 关键字只允许其父模块引用它。样例参考 [<code>pub</code>](# 使用 pub 关键字暴露路径)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>定义模块</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> &lt;模块名&gt; &#123;  <span class="comment">// 花括号内的是模块的主体；</span></span><br><span class="line">    <span class="comment">// 模块主体；</span></span><br><span class="line">    <span class="comment">// 可以定义其他模块；</span></span><br><span class="line">    <span class="comment">// 可以定义例如结构体、枚举、常量、trait、函数等其他项；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>模块树（module tree）</p>
<ul>
<li><p>从 crate 根文件开始向下展示模块嵌套的树结构；</p>
</li>
<li><p>如果一些模块定义在同一模块中，则它们是互为兄弟（siblings）的；</p>
</li>
<li><p>如果模块A包含模块B，则A是B的父（parent）,B是A的子（child）;</p>
</li>
</ul>
<blockquote>
<p>注意：整个模块树都在名为 crate 的隐式模块下，即 crate 根文件下；</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">crate</span>  <span class="comment">// 这里是隐式的，Rust 中使用 crate 表示根，就像路径中的 / 根路径一样。</span></span><br><span class="line"> └── front_of_house  <span class="comment">// 定义在crate 根文件中的顶层 mod</span></span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         └── take_order</span><br></pre></td></tr></table></figure>

<p>这些类似与文件系统</p>
<h1 id="路径用于引用模块树中的项"><a href="#路径用于引用模块树中的项" class="headerlink" title="路径用于引用模块树中的项"></a>路径用于引用模块树中的项</h1><p>Rust 中使用路径的方式在模块中找到一个项的位置</p>
<ul>
<li>就像文件系统使用路径一样。</li>
</ul>
<p>如果想要调用一个函数，我们需要知道它的路径。</p>
<p>路径的两种形式：</p>
<ul>
<li><strong>绝对路径</strong>（absolute path），从 crate 根开始，以 crate 名或者字面值 crate（<code>crate</code>） 开头。</li>
<li><strong>相对路径</strong>（relative path），从当前模块开始，以 <code>self</code>、<code>super</code> 或当前模块的标识符开头。</li>
</ul>
<p>路径分割使用 <code>::</code> 双冒号。</p>
<p>如何使用绝对路径和相对路径？</p>
<ul>
<li>取决于如何管理模块；</li>
<li>我们更倾向使用<strong>绝对路径</strong>，因为它更适合移动代码定义和项调用的相对独立；</li>
</ul>
<h2 id="使用-pub-关键字暴露路径"><a href="#使用-pub-关键字暴露路径" class="headerlink" title="使用 pub 关键字暴露路径"></a>使用 pub 关键字暴露路径</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;  <span class="comment">// 因为同级，是兄弟，所以mod这里不需要添加 pub；</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;   <span class="comment">// 没有pub 关键字 下面hosting和add_to_waitlist会报错;</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// Absolute path</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-super-起始的相对路径"><a href="#使用-super-起始的相对路径" class="headerlink" title="使用 super 起始的相对路径"></a>使用 <code>super</code> 起始的相对路径</h2><p>可以使用 <code>super</code> 开头来构建从父模块开始的相对路径。</p>
<ul>
<li>这类似于文件系统中以 <code>..</code> 来头的语法</li>
</ul>
<p>使用场景：</p>
<ul>
<li>也属于相对路径，所以适用于重新组织 crate 的模块树时，一起移动提供者与调用者的场景中。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();   <span class="comment">// 这里的 super 就是fix_incorrect_order 的上一层 .. ,即代指 back_of_house 这一层</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong><code>super</code> 和 <code>self</code> 在模块路径中使用的作用主要有两个：</p>
<ol>
<li>消除访问项的歧义；</li>
<li>防止不需要的路径硬编码；</li>
</ol>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里self 1. 起消除歧义的作用，与下面的function区分开；</span></span><br><span class="line"><span class="comment">// 2. 代替模块名的硬编码，例如my_mod:function();</span></span><br><span class="line">self::<span class="title function_ invoke__">function</span>();</span><br><span class="line"><span class="title function_ invoke__">function</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里self 和 super，有代替模块名硬编码的作用</span></span><br><span class="line">self::cool::<span class="title function_ invoke__">function</span>();</span><br><span class="line">super::<span class="title function_ invoke__">function</span>();</span><br></pre></td></tr></table></figure>





<h2 id="创建共有的结构体和枚举"><a href="#创建共有的结构体和枚举" class="headerlink" title="创建共有的结构体和枚举"></a>创建共有的结构体和枚举</h2><p>额外注意事项：</p>
<p>结构体：</p>
<ol>
<li>结构体定义前添加 <code>pub</code> 关键字，这个结构体会变成公有的，但是结构体中的字段仍然是私有的，需要根据情况<strong>单独为字段添加</strong> <code>pub</code> 关键字。</li>
<li>如果结构体具<strong>有私有字段</strong>，这个结构体需要提供一个<strong>公共的关联函数</strong>来创建实例，否则我们无法在外部调用时创建结构体的实例。<ul>
<li>因为我们不能在外部设置私有字段的值；</li>
<li>结构体通常使用时，不必将它们的字段公有化；</li>
</ul>
</li>
</ol>
<p>枚举：</p>
<ol>
<li>如果枚举设为公有，则它的所有成员都将变成公有的。我们只需要在 <code>enum</code> 关键字前添加 <code>pub</code> 关键字。<ul>
<li>如果枚举成员不是公有的，那么枚举会显得用处不大；</li>
</ul>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="使用-use-关键字将名称引入作用域"><a href="#使用-use-关键字将名称引入作用域" class="headerlink" title="使用 use 关键字将名称引入作用域"></a>使用 use 关键字将名称引入作用域</h1><p>使用 <code>use</code> 关键字，可以一次性将路径引入作用域，方便我们调用该路径中的项。</p>
<ul>
<li>与 Java 和 python 中的 import 类似；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();  <span class="comment">// 这里调用函数时指定父模块，可以清晰地表明函数不是在本地定义的；</span></span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：use 引入时，use + path 的方式，我们通常引入到调用项所在模块即可，使用时 <code>模块名+调用项</code>。</p>
<ol>
<li>这样在调用函数时，通过指定父模块，可以清晰地表明函数<strong>不是在本地定义的</strong>；</li>
<li>同时使完整路径的重复度最小化；</li>
<li>使用 use 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。</li>
<li>如果两个模块具有相同的名字，但是父模块名字不同时，我们通常引入到它们的父模块；（Rust 不允许直接引入具有相同名字模块的完整路径，因为直接使用该模块时，不容易分清是哪个模块的。）</li>
</ol>
</blockquote>
<p>第1，2，3点的样例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 HashMap 结构体引入作用域的习惯用法；</span></span><br><span class="line"><span class="comment">// 指定到该结构体的完整路径即可。</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4点的样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="comment">// 这样的引入路径，我们就可以比较容易分清两个Result分别是哪个模块中的了。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-as-关键字提供新的名称"><a href="#使用-as-关键字提供新的名称" class="headerlink" title="使用 as 关键字提供新的名称"></a>使用 <code>as</code> 关键字提供新的名称</h2><p>针对使用 <code>use</code> 将两个同名类型引入同一作用域这个问题，还有另一个解决办法：</p>
<ul>
<li>使用 <code>as</code> 关键字，即 在这个类型的路径后面，使用 <code>as</code> 指定一个新的本地名称或者别名。<ul>
<li>这点与 python 很像；</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">#     <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-pub-use-重导出名称"><a href="#使用-pub-use-重导出名称" class="headerlink" title="使用 pub use 重导出名称"></a>使用 <code>pub use</code> 重导出名称</h2><p>使用 <code>use</code> 将路径（名称）导入到作用域内后，该名称在此作用域内是<strong>私有</strong>的。</p>
<p><code>pub use</code>作用：（这个组合更多用在将 crate 对外发布使用的场景。）</p>
<ul>
<li>将条目引入作用域；<ul>
<li>（在当前作用域与使用 <code>use</code> 效果一样）</li>
</ul>
</li>
<li>该条目可以被外部代码引入到它们的作用域；<ul>
<li>（通常我们自己的模块代码要作为 库 crate 对外发布的情况下，最好使用 <code>pub use</code> 的形式，这样外部调用者就可以根据我们 <code>pub use</code> 的路径引入模块和项了，而不用关心我们真正实现时的路径）</li>
</ul>
</li>
</ul>
<p>样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以参考 <a href="#">在文档</a> 中的样例效果。</p>
<h2 id="使用外部包"><a href="#使用外部包" class="headerlink" title="使用外部包"></a>使用外部包</h2><p>当我们的项目需要引入外部包时，</p>
<ol>
<li>首先在项目的 Cargo.toml 文件的 <code>dependencies</code>段落中加入依赖的包名；<ul>
<li>要从<code>crates.io</code> 中下载，可以修改源地址加快下载速度；</li>
</ul>
</li>
<li>使用 <code>use</code> 将模块引入项目作用域；</li>
</ol>
<blockquote>
<p>注意：标准库（std）对于我们的包来说也是外部 crate。因为标准库随 Rust 语言一同发布，无需修改 Cargo.toml 来引入 std，不过依然需要使用 use 将标准库中定义的项引入项目包的作用域中。例如 HashMap。</p>
</blockquote>
<h2 id="嵌套路径来消除大量的-use-行"><a href="#嵌套路径来消除大量的-use-行" class="headerlink" title="嵌套路径来消除大量的 use 行"></a>嵌套路径来消除大量的 <code>use</code> 行</h2><p>语法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">指定路径的相同部分::&#123;[<span class="keyword">self</span>,]子路径各自不同的部分<span class="number">1</span>,不同<span class="number">2</span>...&#125;</span><br></pre></td></tr></table></figure>

<p>样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line">=&gt;</span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在夫模块路径和子模块路径时，父模块使用 self 关键字</span></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line">=&gt;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以在路径的任何层级使用嵌套路径。</p>
<h2 id="通过-glob-和-运算符将所有的公有定义引入作用域"><a href="#通过-glob-和-运算符将所有的公有定义引入作用域" class="headerlink" title="通过 glob 和 * 运算符将所有的公有定义引入作用域"></a>通过 glob 和 <code>*</code> 运算符将所有的公有定义引入作用域</h2><p>如果希望将一个路径下 <strong>所有</strong> 公有项引入作用域，可以指定路径后跟 * ，glob 运算符。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里指将 collections 中定义的所有公有项引入当前作用域。</span></span><br><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用 glob 运算符时需要小心，glob 会使得我们难以推导作用域中有什么名字和它们是在何处定义的。</p>
<p>glob 运算符经常用于测试模块 <code>tests</code> 中，将所有内容引入作用域。</p>
</blockquote>
<h1 id="将模块分割进不同文件"><a href="#将模块分割进不同文件" class="headerlink" title="将模块分割进不同文件"></a>将模块分割进不同文件</h1><p>对于 二进制 crate 或 库 crate 来说，我们可以将该文件中的多个 <code>mod</code> 拆分到不同的子文件或者子目录中。</p>
<p>模块定义时，如果模块名后边是 “;” ，而不是代码块：</p>
<ul>
<li>Rust 会从与模块同名的文件中加载内容；</li>
<li>模块树的结构不会变化；</li>
</ul>
<p>随着模块逐渐变大，该技术可以把模块的内容移动到其他文件中。</p>
<p>如果拆分到子文件，</p>
<ol>
<li><p>新建一个以 <em>需要移除的 mod 名</em> 命名的 rs 文件；</p>
</li>
<li><p>将该 mod 中的内容复制到 新 rs 文件中；</p>
</li>
<li><p>在原文件中添加 mod 声明语句（带<code>;</code>号），这将告诉 Rust 在另一个与模块同名的文件中加载模块的内容；</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// 也可以使用相对路径</span></span><br><span class="line"><span class="comment">// pub use front_of_house::hosting;</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二，如果该 mod 还包含子 mod，可以创建 <code>目录+子文件</code> 的多层结构；</p>
<ol>
<li>创建一个以 <em>需要移动的父 mod 模块名</em> 命名的 rs 文件；在文件中添加子 mod 的声明；</li>
<li>在步骤1中的同级目录下，创建一个以 <em>需要移动的父 mod 模块名</em> 命名的目录，和一个子 mod 名命名的 rs 文件；</li>
<li>移动子 mod 的内容到同名文件中；</li>
<li>原始文件中依然需要声明父 mod ；</li>
<li>在原始文件中，使用子 mod 的方式与方式一中一样。</li>
</ol>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|-- front_of_house</span><br><span class="line">|   `-- hosting.rs</span><br><span class="line">|-- front_of_house.rs</span><br><span class="line">`-- main.rs</span><br><span class="line"></span><br><span class="line">文件名: src/front_of_house.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"></span><br><span class="line">目录名：src/front_of_house</span><br><span class="line">文件名: src/front_of_house/hosting.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">此时原文件中的使用 <span class="title function_ invoke__">add_to_waitlist</span>() 的方式不变；</span><br></pre></td></tr></table></figure>



<p>在拆分模块到文件的过程中，</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">|-- my</span><br><span class="line">|   |-- inaccessible.rs</span><br><span class="line">|   |-- <span class="keyword">mod</span>.rs</span><br><span class="line">|   `-- nested.rs</span><br><span class="line">`-- split.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下两种方式效果相同</span></span><br><span class="line"></span><br><span class="line">|-- my</span><br><span class="line">|   |-- inaccessible.rs</span><br><span class="line">|   `-- nested.rs</span><br><span class="line">|-- my.rs</span><br><span class="line">`-- split.rs</span><br></pre></td></tr></table></figure>



<p><code>my.rs</code> &#x3D;&#x3D; <code>my/mod.rs</code> ，即效果是相同的，在其他模块中使用时，都是作如下声明 ：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pub 是可选的，根据访问需求添加；</span></span><br><span class="line">[<span class="keyword">pub</span>] <span class="keyword">mod</span> my;</span><br></pre></td></tr></table></figure>

<p>如上所示，Rust 会将该文件内容放进名为 <code>my</code> 的模块中，然后插入到当前声明的作用域中。</p>
<h2 id="多个二进制文件如何处理"><a href="#多个二进制文件如何处理" class="headerlink" title="多个二进制文件如何处理"></a>多个二进制文件如何处理</h2><p>常规单个二进制文件的结构</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>main.rs 是默认的二进制 crate</p>
</blockquote>
<p>多个二进制文件的结构</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── main.rs</span><br><span class="line">    └── bin</span><br><span class="line">        └── my_other_bin.rs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果希望有除默认 main.rs 之外的二进制 crate，就在 main.rs 同级目录下创建 bin 目录，然后添加二进制 crate。</p>
</blockquote>
<h1 id="二进制文件中如何引入上级模块"><a href="#二进制文件中如何引入上级模块" class="headerlink" title="二进制文件中如何引入上级模块"></a>二进制文件中如何引入上级模块</h1><p>通过 mod 上添加路径属性，指定 mod 所在 rs 文件路径。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[path =<span class="string">&quot;../dbaccess/mod.rs&quot;</span>]</span></span><br><span class="line"><span class="keyword">mod</span> db_access;</span><br><span class="line"><span class="meta">#[path =<span class="string">&quot;../errors.rs&quot;</span>]</span></span><br><span class="line"><span class="keyword">mod</span> errors;</span><br></pre></td></tr></table></figure>





<h1 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h1><p>如果直接 <code>use</code> 导入，而没有依赖进来，那么会有类似如下报错：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">unresolved import `animal_test`</span><br><span class="line"><span class="keyword">use</span> of undeclared <span class="keyword">crate</span> or module `animal_test`</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ol>
<li>上述错误，是本地mod，则在使用的rs文件中 使用 <code>pub mod animal_test;</code></li>
<li>如果不是外部crate，那么需要在 <code>Cargo.toml</code> 文件中依赖此 crate；</li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>09错误处理</title>
    <url>//09%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<p>编程语言常用的两种错误处理方式：</p>
<ul>
<li>异常 （例如，Java，C#）</li>
<li>返回值（例如，Go，Rust ）</li>
</ul>
<p>Rust 将错误组合分成两个主要类别：</p>
<ul>
<li>可恢复错误（recoverable）<ul>
<li>通常代表向用户报错错误和重试操作是合理的情况，比如未找到文件。</li>
</ul>
</li>
<li>不可恢复错误（unrecoverable）<ul>
<li>通常是 bug 的同义词，比如尝试访问超过数组结尾的位置。</li>
</ul>
</li>
</ul>
<p>尝试从错误中恢复还是停止执行时的注意事项。</p>
<h1 id="panic-与不可恢复的错误"><a href="#panic-与不可恢复的错误" class="headerlink" title="panic! 与不可恢复的错误"></a>panic! 与不可恢复的错误</h1><p>遇到 panic 时</p>
<ul>
<li><p>默认展开（unwinding）</p>
<ul>
<li>Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并<strong>清理</strong>的过程有很多工作。</li>
</ul>
</li>
<li><p>终止（abort）</p>
<ul>
<li>这会<strong>不清理</strong>数据就退出程序。操作系统会清理程序所使用的内存。</li>
</ul>
</li>
</ul>
<p>windows 下 powershell设置环境变量：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$env:RUST_BACKTRACE</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h1 id="Result-与可恢复的错误"><a href="#Result-与可恢复的错误" class="headerlink" title="Result 与可恢复的错误"></a>Result 与可恢复的错误</h1><p>Rust 希望开发者显示的处理错误，因此，可能出错的函数返回 Result 枚举类型，其定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><code>Result</code> 是比 <code>Option</code> 类型更为丰富的版本。它提供可能出现的错误，而不是可能缺失值。</p>
<p>因此 <code>Result&lt;T,E&gt;</code> 有两种可能：</p>
<ul>
<li><code>Ok(T)</code>：发现了元素 T；</li>
<li><code>Err(E)</code>：发现了错误E；</li>
</ul>
<p><code>Result</code> 枚举和其成员与 <code>Option</code> 枚举一样，也被导入了 <code>prelude</code> 中，所以使用时不需要在 <code>Ok</code> 和 <code>Err</code> 之前指定 <code>Result::</code>。</p>
<p><code>io::ErrorKind</code> 值一个标准库提供的枚举，它的成员对应<code>io</code> 操作可能导致的不同错误类型。</p>
<h2 id="匹配不同的错误"><a href="#匹配不同的错误" class="headerlink" title="匹配不同的错误"></a>匹配不同的错误</h2><p>可以结合 <code>match</code> 模式匹配，来匹配并处理不同的错误</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="失败时-panic-的简写：-unwrap-和-expect"><a href="#失败时-panic-的简写：-unwrap-和-expect" class="headerlink" title="失败时 panic 的简写： unwrap 和 expect"></a>失败时 panic 的简写： unwrap 和 expect</h2><p><code>match</code> 处理 panic 时有点冗长并且不总能很好的表明意图。</p>
<p><code>Result&lt;T, E&gt;</code> 类型定义了很多辅助方法来处理各种情况。</p>
<ul>
<li><code>unwrap</code> ，如果<code>Result</code> 值是成员<code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值；如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。</li>
<li><code>expect</code>，允许我们选择<code>panic!</code>的错误信息。可以更好的表明你的意图并易于追踪 panic 的根源。</li>
</ul>
<p>区别：</p>
<ul>
<li><code>unwrap</code> ，使用默认的 <code>panic!</code> 信息；</li>
<li><code>expect</code>，可以自定义<code>panic!</code>信息</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();  <span class="comment">// 调用 panic! 默认错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);  <span class="comment">// 允许我们自定义 panic! 错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h2><p>将错误给调用者来处理。方法返回 <code>Err(e)</code></p>
<p>遇到错误不处理，而是直接返回给调用者。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),  <span class="comment">// match 后遇到错误直接返回给调用者</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),  <span class="comment">// match 后遇到错误直接返回给调用者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="传播错误的简写：-运算符"><a href="#传播错误的简写：-运算符" class="headerlink" title="传播错误的简写：? 运算符"></a>传播错误的简写：? 运算符</h3><p>Rust 提供了 <code>?</code> 问号运算符，便于传播错误。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Result</code> 值之后接的<code>?</code> 运算符，与上面章节使用 <code>match</code> 表达式处理完全相同。</p>
<ul>
<li><p>在某个函数中使用？运算符，该运算符尝试从 Result 中获取值，</p>
<ul>
<li>如果不成功，它就会接收 Error，中止函数执行，并把错误传播到调用该函数的函数。</li>
</ul>
</li>
<li><p>如果<code>Result</code> 的值是<code>Ok</code>，这个表达式将会<strong>返回 <code>Ok</code> 中的值</strong>，而程序继承执行。</p>
<ul>
<li>与 <code>match</code> 处理的方式不同点，<code>?</code> 运算符返回的是<code>Ok</code> 中的值，而不是<code>Ok</code>本身，所以返回正确内容时，如果返回类型是 <code>Result</code>，则需要使用 <code>Ok</code> 封装一下；</li>
</ul>
</li>
<li><p>如果值是 <code>Err</code> ，<code>Err</code> 作为整个函数的返回值，就好像只用了 <code>return</code> 关键字一样，将错传播给了调用者。</p>
<ul>
<li>疑问，遇到 Err，也是返回 Err 中的值？</li>
</ul>
</li>
</ul>
<h3 id="运算符实现方式"><a href="#运算符实现方式" class="headerlink" title="? 运算符实现方式"></a><code>?</code> 运算符实现方式</h3><p><strong>总结</strong>：依赖 <code>From</code> trait 的 <code>from</code> 函数。</p>
<p><code>?</code> 运算符将使用的错误值传递给了 <code>from</code> 函数，它定义于标准库的 <code>From</code> trait 中，其用来将错误从一种类型转为另一种类型。当 <code>?</code> 运算符调用 <code>from</code> 函数时，收到的错误类型被转换为由当前函数返回类型所指定的错误类型。</p>
<p>只要每一个错误类型都实现了 <code>from</code> 函数来定义如何将其他类型转换为返回自定义的错误类型，<code>?</code> 运算符会自动处理这些转换。</p>
<p><code>?</code> 运算符可以使得函数的实现更简单</p>
<p>同时可以在 <code>?</code> 运算符之后直接使用链式方法调用。</p>
<p>例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败了返回 Err(E)，符合返回类型</span></span><br><span class="line">    <span class="comment">// 但是成功了返回展开后的结果，不符合展开后的类型，所以还需要在后面添加`Ok()`的情况</span></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用 <code>?</code> 的使用，因为其与<code>unwrap()</code> 的返回方式类似，所以返回结果时，还需要再最后添加 <code>Ok(T)</code> 的返回结果。</p>
</blockquote>
<h3 id="运算符用于返回-Result-Option-类型的函数"><a href="#运算符用于返回-Result-Option-类型的函数" class="headerlink" title="? 运算符用于返回 Result / Option 类型的函数"></a><code>?</code> 运算符用于返回 <code>Result / Option</code> 类型的函数</h3><p>如果函数返回值类型不是 <code>Result&lt;T,E&gt;</code> 或者 <code>Option&lt;T,E&gt;</code>类型（或者任何一种实现了 <code>FromResidual</code> trait 的类型）那么编译时会报错。</p>
<ul>
<li>只能用于…</li>
</ul>
<blockquote>
<p>the <code>?</code> operator <strong>can only be used</strong> in a function that returns <code>Result</code> or <code>Option</code> (or another type that implements <code>FromResidual</code>)</p>
</blockquote>
<h3 id="try-宏"><a href="#try-宏" class="headerlink" title="try! 宏"></a><code>try!</code> 宏</h3><p>在 <code>?</code> 出现之前，Rust 提供了<code>try!()</code> 宏，两者作用相同，但是目前已经推荐使用<code>!</code>。</p>
<p>不过阅读以前代码时，可能会遇到<code>try!()</code> 宏</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两者作用相同，推荐使用 `?` 符号</span></span><br><span class="line"><span class="built_in">try!</span>(File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>))</span><br><span class="line"></span><br><span class="line">File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)? </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="多-error-类型"><a href="#多-error-类型" class="headerlink" title="多 error 类型"></a>多 error 类型</h2><p>有时 <code>Option</code> 需要与 <code>Result</code> 交互，或者 <code>Result&lt;T, Error1&gt;</code> 需要与 <code>Result&lt;T, Error2&gt;</code> 交互。在这些情况下，我们希望以一种可组合且易于交互的方式管理不同的错误类型。</p>
<h3 id="相互嵌入处理"><a href="#相互嵌入处理" class="headerlink" title="相互嵌入处理"></a>相互嵌入处理</h3><p>方式1. 处理混合错误类型的最基本方法是将它们相互嵌入。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_first</span>(vec: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt;&gt; &#123;</span><br><span class="line">    vec.<span class="title function_ invoke__">first</span>().<span class="title function_ invoke__">map</span>(|first| &#123;</span><br><span class="line">        first.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|n| <span class="number">2</span> * n)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些时候，我们希望遇到错误时，停止进程(比如?)，但当Option为None时继续。</p>
<p>可以使用形如 <code>Result&lt;Option&lt;i32&gt;, ParseIntError&gt;</code> 的嵌入形式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_first</span>(vec: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;<span class="type">i32</span>&gt;, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">opt</span> = vec.<span class="title function_ invoke__">first</span>().<span class="title function_ invoke__">map</span>(|first| &#123;</span><br><span class="line">        first.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|n| <span class="number">2</span> * n)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    opt.<span class="title function_ invoke__">map_or</span>(<span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>), |r| r.<span class="title function_ invoke__">map</span>(<span class="literal">Some</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，上面使用了 <code>map_or()</code> 的方法，第一个参数为 default，即值为None时的情况，第二个参数才是有值时的参数，分不清时点进方法看一下方法签名。</p>
</blockquote>
<h3 id="定义error-类型"><a href="#定义error-类型" class="headerlink" title="定义error 类型"></a>定义error 类型</h3><p>Rust 允许我们自定义 error 类型</p>
<p>它可以是多种错误类型的抽象</p>
<p>一个好的 error 类型，需要满足以下几个条件：</p>
<ul>
<li>同一个类型可以表示不同的错误？</li>
<li>向用户显示良好的错误消息</li>
<li>与其他类型做比较是容易的<ul>
<li>好的：<code>Err(EmptyVec)</code>；</li>
<li>坏的：<code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code>；</li>
</ul>
</li>
<li>可以保存有关错误的信息<ul>
<li>好的：<code>Err(BadChar(c, position))</code>；</li>
<li>坏的：<code>Err(&quot;+ cannot be used here&quot;.to_owned())</code>；</li>
</ul>
</li>
<li>与其他错误配合的很好</li>
</ul>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个自定义枚举类型 MyError 可以实现统一处理 ParseError和IOError的需求</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    ParseError,</span><br><span class="line">    IOError,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建自定义错误处理器步骤：</p>
<ol>
<li>创建一个自定义错误类型；</li>
<li>实现 From trait，用于把其它错误类型转化为该类型；</li>
<li>如果有其它需要实现的 trait，为自定义错误类型实现这些 trait；</li>
<li>使用自定义错误类型；</li>
</ol>
<h3 id="Boxing-errors"><a href="#Boxing-errors" class="headerlink" title="Boxing errors ???"></a>Boxing errors ???</h3><p>编写简单代码同时保留原始错误的一种方法是将它们框起来。其缺点是，底层错误类型仅在运行时才知道，而不是静态确定的。</p>
<p>stdlib通过让Box实现从任何实现Error trait的类型到trait对象<code>Box&lt;Error&gt;</code>的转换，来帮助装箱我们的错误。通过 <code>From</code> trait。</p>
<blockquote>
<p>??? 其实不太明白使用 <code>Box&lt;dyn Err&gt;</code> 的场景。</p>
</blockquote>
<h3 id="Wrapping-errors"><a href="#Wrapping-errors" class="headerlink" title="Wrapping errors"></a>Wrapping errors</h3><p>可以将 error 包装到自定义的 error 中。</p>
<h3 id="各个包中的-Error-如何使用？"><a href="#各个包中的-Error-如何使用？" class="headerlink" title="各个包中的 Error 如何使用？"></a>各个包中的 Error 如何使用？</h3><h1 id="panic-还是不-panic"><a href="#panic-还是不-panic" class="headerlink" title="panic! 还是不 panic!"></a>panic! 还是不 panic!</h1><p>何时应该 <code>panic!</code> ？何时应该返回 <code>Result</code> ？</p>
<p>通用指导原则：</p>
<ol>
<li>当代码对值进行操作时，应该首先验证值是有效的，并在无效时 <code>panic!</code>。<ul>
<li>尝试操作无效数据会暴露代码BUG。例如，标准库在尝试越界访问数组时会 <code>panic!</code>。</li>
</ul>
</li>
<li>当可能发生有害状态的情况，建议使用 <code>panic!</code>，超出预期的情况；</li>
<li>当函数中存在预期可能出错的情况，需要考虑是否应该由调用者来处理这个错误，如果是，那么返回 <code>Result</code> ；</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>总的来说，遇到错误，有两处处理方式：<ol>
<li>直接 <code>panic!</code>，报错；</li>
<li>捕获 <code>Err</code>，然后自己处理或者传递给上层调用者；</li>
</ol>
</li>
<li>希望程序遇到某种情况停止运行时，使用 <code>panic!</code>；<ul>
<li>使用 <code>panic!</code> 时，可以直接用<code>panic!</code>这个宏输出；</li>
<li>当函数返回值为 <code>Result&lt;T,E&gt;</code>时，可以使用 <code>unwrap()</code> 或 <code>expect()</code> 方法来简化处理；<ul>
<li><code>unwrap</code> 方法，如果正确正常返回，如果错误则抛出 <code>panic!</code> 默认错误；</li>
<li><code>expect</code> 方法，如果正确正常返回，如果错误，则抛出自定义的<code>panic!</code> 错误信息；</li>
</ul>
</li>
</ul>
</li>
<li>如果处理可能出错，也可能修复的情况，使用 <code>Result</code>；<ul>
<li>可以自己处理；</li>
<li>可以抛出，传给调用者处理；<ul>
<li>可以直接返回 <code>Err</code>,</li>
<li>可以利用 <code>?</code> 运算符简化错误传播，但函数返回值类型是有限制的<ul>
<li>查看 [Result&#x2F;Option 章节](#  运算符用于返回  类型的函数)；</li>
<li><code>?</code> 运算符支持链式调用；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>10泛型、trait与生命周期</title>
    <url>//10%E6%B3%9B%E5%9E%8B%E3%80%81trait%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content><![CDATA[<p>重复代码的危害：</p>
<ul>
<li>容易出错；</li>
<li>需求变更时需要在多出进行修改；</li>
</ul>
<p>消除重复代码的方式：</p>
<p>方式一：提取函数</p>
<ol>
<li>识别重复代码；</li>
<li>将重复代码提取到一个函数中，并在函数签名中指定了代码中的输入和返回值；</li>
<li>将重复代码改为调用函数；</li>
</ol>
<p>方式二：泛型</p>
<h1 id="泛型数据类型"><a href="#泛型数据类型" class="headerlink" title="泛型数据类型"></a>泛型数据类型</h1><p>高效处理重复概念的工具。</p>
<p>泛型：提高代码复用能力</p>
<ul>
<li>处理重复代码问题</li>
</ul>
<p>泛型是具体类型或属性的抽象代替</p>
<ul>
<li>你编写的代码不是最终的代码，而是一种模板，里面有一些<strong>占位符</strong>；</li>
<li>编译器在<strong>编译时</strong>，将占位符<strong>替换为具体的类型</strong>；（单太化，所以没有运行时开销，效率与不使用泛型一样高）</li>
</ul>
<p>使用泛型定义函数、结构体、枚举和方法</p>
<h2 id="在函数中使用泛型"><a href="#在函数中使用泛型" class="headerlink" title="在函数中使用泛型"></a>在函数中使用泛型</h2><p>使用泛型定义函数时，函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。</p>
<p>当在函数签名中使用一个<strong>泛型参数</strong>时，必须在使用它之前就声明它（给它起个名字，就像给函数形参起名字一样）。</p>
<ol>
<li>先声明泛型参数名称；</li>
<li>在形参类型和函数返回值类型中使用声明的泛型参数；</li>
</ol>
<ul>
<li><p>泛型参数声明位于<strong>函数名称</strong>与参数列表中间的尖括号<code>&lt;&gt;</code> 中，</p>
<p>例如：<code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</code></p>
</li>
<li><p>任何标识符都可以作为泛型参数的名字，通常使用单个字母，例如 T（type 的缩写）,V （value的缩写）,E…</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型定义的函数 （注意这个代码不能编译，缺少内容）</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 显示指定参数类型</span></span><br><span class="line">    largest::&lt;<span class="type">i32</span>&gt;(&amp;vec1);</span><br><span class="line">    <span class="comment">// 隐式指定/推断</span></span><br><span class="line">    <span class="title function_ invoke__">largest</span>(&amp;vec1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="结构体定义中的泛型"><a href="#结构体定义中的泛型" class="headerlink" title="结构体定义中的泛型"></a>结构体定义中的泛型</h2><p>与在函数定义中使用泛型类似，</p>
<ol>
<li>必须在结构体<strong>名称后</strong>的<strong>尖括号<code>&lt;&gt;</code>中</strong>声明泛型参数的名称；<ul>
<li>声明时，根据需要声明泛型参数的个数，可以为多个的；</li>
</ul>
</li>
<li>在结构体中需要指定字段类型的位置，使用声明的泛型类型；</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个类型参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,  <span class="comment">// 使用时 x和y 只能是一种类型</span></span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用2个类型参数，由于是泛型，所以这两个参数使用时可以相同，可以不同</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 这两个参数使用时可以相同，可以不同</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">both_integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">both_float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer_and_float</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="枚举定义中的泛型"><a href="#枚举定义中的泛型" class="headerlink" title="枚举定义中的泛型"></a>枚举定义中的泛型</h2><p>和结构体类似，枚举也可以在成员中存放泛型数据类型。</p>
<p>定义泛型参数的方式与结构体一样。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样就可以表达一个可能存在的值的抽象概念</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),  <span class="comment">// 存放值</span></span><br><span class="line">    <span class="literal">None</span>,     <span class="comment">// 不存放值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便的表达任何可能成功（返回T），也可能失败（返回E）的操作</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="在方法定义中的泛型"><a href="#在方法定义中的泛型" class="headerlink" title="在方法定义中的泛型"></a>在方法定义中的泛型</h2><p>因为结构体方法与结构体是分开定义的，所以在方法中使用泛型更灵活一些。</p>
<p>在定义方法时声明和使用泛型类型，有两处要声明泛型类型</p>
<ol>
<li>在 <strong><code>impl</code> 后面</strong>使用尖括号<code>&lt;&gt;</code> 声明泛型；</li>
<li>在<strong>结构体名称后面</strong>使用尖括号<code>&lt;&gt;</code>声明泛型；</li>
</ol>
<blockquote>
<p>注意，必须在 <code>impl</code> 后面声明泛型。</p>
<p>必须先声明再使用，否则编译器会报错，提示使用了没有声明的生命周期参数。</p>
</blockquote>
<p>原因：在 Rust 中，当结构体使用了泛型，那么为结构体创建方法时，可以为指定类型创建方法，也可以为泛型（例如，T）创建方法。参考 [使用 trait bound 有条件地实现方法](# 使用 trait bound 有条件地实现方法)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为泛型 T，即所有类型创建x方法，</span></span><br><span class="line"><span class="comment">// 所以 impl 后需要声明T</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;     </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为 f32 类型创建distance_from_origin方法，如果类型不是 f32，则无法使用该方法</span></span><br><span class="line"><span class="comment">// 为具体类型创建方法，所以 impl后无需声明T</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意点2：</p>
<p>结构体方法签名中使用的泛型可以与结构体中的泛型类型参数不同。</p>
<ul>
<li>此时，方法中使用的泛型就需要向函数一样在方法名后使用尖括号<code>&lt;&gt;</code>声明；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 &lt;T,U&gt; 声明于 impl后，因为与结构体定义相对应，</span></span><br><span class="line"><span class="comment">// &lt;V,W&gt; 声明于方法名 mixup之后，因为它们只与方法本身对应。</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="trait-定义共享的行为"><a href="#trait-定义共享的行为" class="headerlink" title="trait: 定义共享的行为"></a>trait: 定义共享的行为</h1><p>trait 的功能类似于 Java 中的 接口（interface），scala 中也有 trait。</p>
<p>一个类型的行为由其可供调用的方法构成。</p>
<h2 id="定义-trait"><a href="#定义-trait" class="headerlink" title="定义 trait"></a>定义 trait</h2><p>trait 定义，是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必须的行为的集合。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[修饰符] <span class="keyword">trait</span> &lt;<span class="keyword">trait</span>名称&gt; &#123;</span><br><span class="line">    方法签名;  <span class="comment">// 只有签名，没有实现</span></span><br><span class="line">    方法签名<span class="number">2</span>;  <span class="comment">// 只有签名，没有实现</span></span><br><span class="line">    默认方法<span class="number">1</span>;  <span class="comment">// trait 中也可以提供有默认实现的方法；</span></span><br><span class="line">    默认方法<span class="number">2</span>;  <span class="comment">// 默认方法中可以调用没有实现的方法签名。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 trait 中为某些方法提供默认行为，当为某个特定类型实现 trait 时，可以选择保留或重载方法的默认行为。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="为类型实现-trait"><a href="#为类型实现-trait" class="headerlink" title="为类型实现 trait"></a>为类型实现 trait</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> &lt;<span class="keyword">trait</span>名称&gt; <span class="keyword">for</span> &lt;结构体名&gt; &#123;</span><br><span class="line">    [实现<span class="keyword">trait</span>中的方法] <span class="comment">// 如果只有默认方法，就可以是一个空花括号；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>struct</code> 上实现 trait  方法与实现普通方法的区别：</p>
<ul>
<li>在于 <code>impl</code> 关键字之后，我们要提供需要实现的 trait 的名字，接着是 <code>for</code> 和需要实现 trait 的类型的名字。</li>
</ul>
<h3 id="孤儿原则"><a href="#孤儿原则" class="headerlink" title="孤儿原则"></a>孤儿原则</h3><p>实现 trait 时的限制：<strong>孤儿原则</strong>（orphan rule），只有当 trait 或者要实现 trait 的类型两者至少有一个位于 crate 的本地作用域时，才能为该类型实现 trait。不能为外部类型实现外部 trait。</p>
<ul>
<li>这条规则确保了其他人的代码不会破坏你的代码，反之亦然。</li>
</ul>
<h2 id="trait-作为参数"><a href="#trait-作为参数" class="headerlink" title="trait 作为参数"></a>trait 作为参数</h2><p>如何使用 trait 来接受多种不同类型的参数。</p>
<ul>
<li>限制参数可接受的类型<ul>
<li>不符合要求的不能通过编译</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// item 参数的类型需要实现了 Summary trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为参数时，可以有两种用法：</p>
<ul>
<li><p><code>参数名：impl &lt;trait名称&gt; + &lt;trait名称2&gt;[+...]</code></p>
<ul>
<li>使用这种方式而不是具体的类型，表示该参数支持任何实现了指定 trait 的类型。</li>
</ul>
</li>
<li><p>trait Bound 语法</p>
<ul>
<li>将参数类型限制，写在函数名&#x2F;方法名后的尖括号<code>&lt;&gt;</code>中，</li>
<li>形如：<code>&lt;T: trait名 + trait名2[+ ...]&gt;</code> ，trait 限制可以有多个。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>impl Trait</code> 与 trait bound 的对比：</p>
<ul>
<li><code>impl Trait</code> 形式很方便，适用于短小的例子；</li>
<li>trait bound 则适用于更复杂的场景。比如多个参数限制时，<code>impl Trait</code> 形式会使得形参列表很长。</li>
</ul>
<blockquote>
<p>注：<code>impl Trait</code> 是 trait bound 形式的语法糖。</p>
<p>即简单场景下的简写。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// impl Trait 形式</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: <span class="keyword">impl</span> <span class="title class_">Summary</span> + Display, item2: <span class="keyword">impl</span> <span class="title class_">Summary</span> + Display) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trait bound 形式</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item1: T, item2: T) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对比上面两种形式，当更复杂的场景时，trait bound 就更适合一些。</p>
<h2 id="通过-where-简化-trait-bound"><a href="#通过-where-简化-trait-bound" class="headerlink" title="通过 where 简化 trait bound"></a>通过 <code>where</code> 简化 trait bound</h2><p>当使用过多的 trait bound 时多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读。</p>
<p>使用 <code>where</code> 从句 简化 trait bound。</p>
<p>将函数名&#x2F;方法名后的 trait bound 内容，改写到 <code>where</code> 从句中：</p>
<ul>
<li><code>where</code>从句写在函数<strong>签名后</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: T, u: U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    </span><br><span class="line">=&gt;</span><br><span class="line"><span class="comment">// 使用 where 从句简写</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: T, u: U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>



<h2 id="返回实现了-trait-的类型"><a href="#返回实现了-trait-的类型" class="headerlink" title="返回实现了 trait 的类型"></a>返回实现了 trait 的类型</h2><p>可以在返回值中使用 <code>impl Trait</code> 语法，来返回实现了某个 trait 的类型。</p>
<ul>
<li>这在闭包和迭代器场景十分有用，第十三章会介绍。</li>
</ul>
<p><strong>限制：</strong></p>
<p>只能返回同一种类型。</p>
<ul>
<li><a href="17Rust%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7.md">trait对象</a> 章节内容可以解决这个限制。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line"><span class="comment">// 如果多种类型实现了 Summary trait，那么只能允许一种类型返回，不允许返回多种类型。</span></span><br><span class="line">    <span class="comment">// 这样是不允许的。</span></span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        NewsArticle &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tweet &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T&#123;</span><br><span class="line">    <span class="comment">// 这里需要注意，list[0] 会发生所有权转移，但是因为参数list 是切片，没有其中值的所有权，所以会报错。</span></span><br><span class="line">    <span class="comment">// 1. 让slice中的值实现copy trait，这样就不会发生所有权转移；而基本数据类型都实现了copy trait</span></span><br><span class="line">    <span class="comment">// 2. 也可以限制其实现 clone</span></span><br><span class="line">    <span class="comment">// 3. 或者使用引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="impl-Trait-语法，也可以用于返回闭包"><a href="#impl-Trait-语法，也可以用于返回闭包" class="headerlink" title="impl Trait 语法，也可以用于返回闭包"></a><code>impl Trait</code> 语法，也可以用于返回闭包</h3><p>在 Rust 中，每个闭包都有唯一的匿名类型，直接作为返回值类是不行的，因为没有具体类型名，这时就可以利用<code>impl Trait</code>的形式来处理。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns a function that adds `y` to its input</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">make_adder_function</span>(y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure</span> = <span class="keyword">move</span> |x: <span class="type">i32</span>| &#123; x + y &#125;;</span><br><span class="line">    closure</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">plus_one</span> = <span class="title function_ invoke__">make_adder_function</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">plus_one</span>(<span class="number">2</span>), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="返回带有闭包的迭代器"><a href="#返回带有闭包的迭代器" class="headerlink" title="返回带有闭包的迭代器"></a>返回带有闭包的迭代器</h3><p>可以使用<code>impl Trait</code> 语法返回一个使用 <code>map</code> 或 <code>filter</code> 的迭代器。</p>
<p>这样使用<code>map</code>或<code>filter</code> 会更容易些。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_positives</span>&lt;<span class="symbol">&#x27;a</span>&gt;(numbers: &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">i32</span>&gt; + <span class="symbol">&#x27;a</span> &#123;</span><br><span class="line">    numbers</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|x| x &gt; &amp;&amp;<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 通过查看 map 的方法签名可知，map返回闭包</span></span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| x * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">singles</span> = <span class="built_in">vec!</span>[-<span class="number">3</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">doubles</span> = <span class="title function_ invoke__">double_positives</span>(&amp;singles);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(doubles.collect::&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;(), <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="当-trait-中有关联类型时"><a href="#当-trait-中有关联类型时" class="headerlink" title="当 trait 中有关联类型时"></a>当 trait 中有关联类型时</h3><p><strong>注意：</strong>当 trait 中有关联类型（type&#x3D;Item）的时候，需要使用 <code>impl trait名&lt;Item=xxx&gt;</code> 的语法来指定返回的关联类型。否则会报错找不到具体类型。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">combine_vecs</span>(</span><br><span class="line">    v: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    u: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    <span class="comment">// 下面的 Iterator 指定了关联类型 i32；</span></span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">chain</span>(u.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">cycle</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v3</span> = <span class="title function_ invoke__">combine_vecs</span>(v1, v2);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(<span class="number">1</span>), v3.<span class="title function_ invoke__">next</span>());</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(<span class="number">2</span>), v3.<span class="title function_ invoke__">next</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面样例返回类型这样写<code> -&gt; impl Iterator &#123;</code></p>
<p>会在调用处则会报错如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">consider constraining the associated <span class="keyword">type</span> `&lt;<span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">as</span> <span class="built_in">Iterator</span>&gt;::Item` to `&#123;integer&#125;`: `&lt;Item = &#123;integer&#125;&gt;`</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Using the <span class="symbol">&#x27;turbofish</span>&#x27; instead of annotating `doubled`:</span><br><span class="line"></span><br><span class="line">**<span class="keyword">let</span>** a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">**<span class="keyword">let</span>** doubled = a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x * <span class="number">2</span>).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>], doubled);</span><br></pre></td></tr></table></figure>





<h2 id="使用-trait-bound-有条件地实现方法"><a href="#使用-trait-bound-有条件地实现方法" class="headerlink" title="使用 trait bound 有条件地实现方法"></a>使用 trait bound 有条件地实现方法</h2><ol>
<li>通过使用带有 trait bound 的泛型参数的 <code>impl</code>块，可以有条件地只为那些实现了特定 trait 的类型实现方法。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有类型都有 new 方法</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有实现了 Display 和 PartialOrd 两个 trait 的类型才有 cmp_display 方法。</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 <em>blanket implementations</em></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为任何实现了 Display trait 的类型实现了 ToString 这个trait，</span></span><br><span class="line"><span class="comment">// 这样任何实现了 Display trait 的类型都可以调用由 ToString 定义的 to_string 方法。</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Trait-的高级特性-19高级特性-md-高级-trait"><a href="#Trait-的高级特性-19高级特性-md-高级-trait" class="headerlink" title="[Trait 的高级特性](19高级特性.md# 高级 trait)"></a>[Trait 的高级特性](19高级特性.md# 高级 trait)</h2><p>请参考上面的链接地址中的 <strong>高级特性</strong>部分。</p>
<h1 id="生命周期与引用有效性"><a href="#生命周期与引用有效性" class="headerlink" title="生命周期与引用有效性"></a>生命周期与引用有效性</h1><p>生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联，保证内存安装的行为。</p>
<p>Rust 中每一个引用都有<strong>生命周期</strong>（lifetime），即引用保持有效的作用域。</p>
<ul>
<li>生命周期的使用与类型相似，即部分场景是可以隐含的并可以推断的，部分场景需要显示标注。</li>
</ul>
<p>泛型生命周期参数</p>
<h2 id="生命周期避免了悬垂引用"><a href="#生命周期避免了悬垂引用" class="headerlink" title="生命周期避免了悬垂引用"></a>生命周期避免了悬垂引用</h2><p>当变量尝试使用离开作用域的值的引用时，会发生悬垂引用，这是Rust 不允许的。</p>
<p>Rust 编译器通过使用<strong>借用检查器</strong>（borrow checker）</p>
<ul>
<li>它会比较作用域，确保所有的借用都是有效的。</li>
<li>增加泛型生命周期参数来定义引用间的关系，以便借用检查器可以进行分析。</li>
</ul>
<p>一个有效的引用，需要数据比引用有着更长的生命周期。</p>
<h2 id="生命周期注解语法"><a href="#生命周期注解语法" class="headerlink" title="生命周期注解语法"></a>生命周期注解语法</h2><p>生命周期注解并不改变任何引用的生命周期，只是指出任何不遵守这个协议的传入值都将被借用检查器拒绝。</p>
<p>使用生命周期，也需要像泛型类似，声明一个生命周期参数。</p>
<p>例如，报错内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">expected named lifetime parameter</span><br><span class="line"><span class="comment">// 意思是，需要一个命名的生命周期参数</span></span><br></pre></td></tr></table></figure>



<p>生命周期参数名称必须以撇号（<code>&#39;</code>）开头，其名称同城全是小写。</p>
<ul>
<li><code>&#39;a</code> 是大多数人默认使用的名称</li>
<li>生命周期参数注解，在引用符号<code>&amp;</code> 之后，并由一个空格来将引用类型与生命周期注解分隔开。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>注：单个生命周期注解本身没有意义，因为生命周期注解告诉 Rust 多个引用的泛型声明周期参数如何相互联系的。</p>
</blockquote>
<p><strong>重要</strong>：引用型参数的生命周期，是告诉Rust，生命周期标注的引用，其生命周期必须与该泛型生命周期<strong>一样久</strong>。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 上面的生命周期注解告诉 Rust ，引用 x 与 y ，必须与这泛型生命周期存在的一样久。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="函数签名中的生命周期注解"><a href="#函数签名中的生命周期注解" class="headerlink" title="函数签名中的生命周期注解"></a>函数签名中的生命周期注解</h2><p>与泛型类型参数类似，</p>
<p>泛型生命周期参数需要声明在函数名和参数列表间的尖括号<code>&lt;&gt;</code>中。</p>
<blockquote>
<p>函数并不需要知道涉及参数会存在多久，只需要知道有某个可以被<code>&#39;a</code>替代的作用域将满足签名</p>
</blockquote>
<p>多个引用参数时，生命周期与传入参数的生命周期较短那个保持一致。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面代码就会报错，因为result的生命周期与string2生命周期保持一致</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="comment">// longest() 函数的定义在上面</span></span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="结构体定义中的生命周期注解"><a href="#结构体定义中的生命周期注解" class="headerlink" title="结构体定义中的生命周期注解"></a>结构体定义中的生命周期注解</h2><p>结构体中可以包含引用类型的成员，此时需要为每个引用添加生命周期。</p>
<p>类似于泛型参数类型，必须<strong>在结构体名称后面</strong>的<strong>尖括号<code>&lt;&gt;</code>中声明</strong>泛型生命周期参数，以便在结构体定义中使用生命周期参数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="生命周期省略（Lifetime-Elision）"><a href="#生命周期省略（Lifetime-Elision）" class="headerlink" title="生命周期省略（Lifetime Elision）"></a>生命周期省略（Lifetime Elision）</h2><p><strong>生命周期省略规则</strong>（lifetime elision rules）：</p>
<ol>
<li>每个引用的参数都有它自己的生命周期参数。<ul>
<li>有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，<code>fn foo&lt;&#39;a,&#39;b&gt;(x:&amp;&#39;a i32,y: &amp;&#39;b i32)</code>，依此类推。</li>
</ul>
</li>
<li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数<ul>
<li><code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code></li>
</ul>
</li>
<li>如果方法有多个输入生命周期参数，其中之一为<code>&amp;self</code> 或 <code>&amp;mut self</code> ，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数。<ul>
<li>第三条规则真正能够适用的只有方法签名。（所以方法签名中一般不需要标注生命周期）</li>
</ul>
</li>
</ol>
<ul>
<li>适用范围：这些规则适用于<code>fn</code>定义，和<code>impl</code>定义。</li>
</ul>
<p>第一条规则适用于<strong>输入生命周期</strong>（函数&#x2F;方法的参数的生命周期），二三条适用于<strong>输出生命周期</strong>（返回值的生命周期）。</p>
<p>生命周期省略规则是给编译器考虑的。</p>
<p>编译器采用上面三条规则来判断何时可以省略生命周期标注。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将报错。</p>
<ul>
<li>此时需要显示地标注生命周期</li>
</ul>
<h2 id="方法定义中的生命周期注解"><a href="#方法定义中的生命周期注解" class="headerlink" title="方法定义中的生命周期注解"></a>方法定义中的生命周期注解</h2><p>实现方法时，结构体字段的生命周期必须总<strong>在 <code>impl</code> 关键字之后声明</strong>，并在<strong>结构体名称之后被使用</strong>。</p>
<p>方法中是否声明和使用生命周期参数，取决于方法的引用参数是否与结构体中的引用字段相关联，方法中可以使用，也可以不使用结构体中的引用字段。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><p><code>&#39;static</code> ，静态生命周期，其生命周期能够存活于整个程序期间。</p>
<ul>
<li><p>所有<strong>字符串字面值</strong>都拥有 <code>&#39;static</code> 生命周期。</p>
</li>
<li><p>常量和静态变量也都拥有<code>&#39;static</code>生命周期。</p>
</li>
<li><p>也可以显示的指定</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>=<span class="string">&quot;i have a static lifetime.&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，将引用指定为<code>&#39;static</code> 之前，需要考虑这个引用是否真的在整个程序的生命周期里都有效。</p>
<h2 id="结合泛型类型参数，trait-bounds-和生命周期"><a href="#结合泛型类型参数，trait-bounds-和生命周期" class="headerlink" title="结合泛型类型参数，trait bounds 和生命周期"></a>结合泛型类型参数，trait bounds 和生命周期</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, ann: T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line">    <span class="keyword">where</span> T: Display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为生命周期也是泛型，所以生命周期参数和泛型类型参数都位于函数名后的同一尖括号列表中。</p>
<p>更多内容参考</p>
<p>第十七章会讨论 trait 对象，这是另一种使用 trait 的方式。</p>
<p>第十九章会涉及到生命周期注解更复杂的场景。</p>
<p>第二十章讲解一些高级的类型系统功能。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>12一个IO项目：构建命令行程序</title>
    <url>//12%E4%B8%80%E4%B8%AAIO%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F.html</url>
    <content><![CDATA[<ul>
<li>代码组织（使用 <a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">第七章</a> 学习的模块）</li>
<li>vector 和字符串（<a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch08-00-common-collections.html">第八章</a>，集合）</li>
<li>错误处理（<a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch09-00-error-handling.html">第九章</a>）</li>
<li>合理的使用 trait 和生命周期（<a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch10-00-generics.html">第十章</a>）</li>
<li>测试（<a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch11-00-testing.html">第十一章</a>）</li>
</ul>
<p>当所需函数嵌套了多于一层模块时，通常将<strong>父模块</strong>引入作用域，而不是其自身。这便于我们利用 <code>std::env</code> 中的其他函数。这比增加了 <code>use std::env::args;</code> 后仅仅使用 <code>args</code> 调用函数要更明确一些，因为 <code>args</code> 容易被错认成一个定义于当前模块的函数。</p>
<h3 id="args-函数和无效的-Unicode"><a href="#args-函数和无效的-Unicode" class="headerlink" title="args 函数和无效的 Unicode"></a><code>args</code> 函数和无效的 Unicode</h3><p>注意 <code>std::env::args</code> 在其任何参数包含无效 Unicode 字符时会 panic。如果你需要接受包含无效 Unicode 字符的参数，使用 <code>std::env::args_os</code> 代替。</p>
<p>然而 <code>collect</code> 是一个经常需要注明类型的函数，因为 Rust 不能推断出你想要什么类型的集合。</p>
<h2 id="二进制项目的关注分离"><a href="#二进制项目的关注分离" class="headerlink" title="二进制项目的关注分离"></a>二进制项目的关注分离</h2><p>对 <code>main</code> 函数进行二进制程序的关注分析的指导性过程。</p>
<ul>
<li>将程序拆分成 <code>main.rs</code> 和 <code>lib.rs</code> 并将程序的逻辑放入 lib.rs 中；</li>
<li>当命令行解析逻辑比较小时，可以保留在 main.rs 中；</li>
<li>当命令行解析开始变得复杂时，也同样将其从 <code>main.rs</code> 提取到 <code>lib.rs</code> 中。</li>
</ul>
<p>经过这些过程之后，保留在 <code>main</code> 函数中的责任应该被限制为：</p>
<ul>
<li><p>使用参数值调用命令行解析逻辑；</p>
</li>
<li><p>设置任何其他的配置；</p>
</li>
<li><p>调用 <code>lib.rs</code> 中的 <code>run</code> 函数；</p>
</li>
<li><p>如果 <code>run</code> 返回错误，则处理这个错误；</p>
</li>
<li><p>main.rs 处理程序运行，</p>
<ul>
<li>不能直接测试 main 函数，所以将所有需要测试的都放进 lib.rs 中</li>
</ul>
</li>
<li><p>lib.rs 处理所有的真正的任务逻辑。</p>
</li>
</ul>
<p>Rust 中 默认项目是私有的，这个私有范围在同一个 mod 模块中，如果没有明确标注 mod ，则一个文件就是一个 mod</p>
<h4 id="使用-clone-的权衡取舍"><a href="#使用-clone-的权衡取舍" class="headerlink" title="使用 clone 的权衡取舍"></a>使用 <code>clone</code> 的权衡取舍</h4><p>由于其运行时消耗，许多 Rustacean 之间有一个趋势是倾向于避免使用 <code>clone</code> 来解决所有权问题。在关于<strong>迭代器</strong>的第十三章中，我们将会学习如何更有效率的处理这种情况。</p>
<p><code>Result&lt;T,E&gt;</code> 中的 <code>unwrap_or_else</code> 方法</p>
<ul>
<li>通过传递一个<strong>闭包</strong>（closure）作为参数，可以自定义非 <code>panic!</code> 的错误处理；</li>
<li>当 Result 是 Ok 时，这个方法的行为类似于 unwrap，返回 Ok 内部封装的值；</li>
<li>如果是 Err ，该方法会调用传进去的闭包。</li>
</ul>
<p>trait 对象</p>
<p><a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch17-00-oop.html">第十七章</a> 会涉及 trait 对象。</p>
<p>将 <code>std::error::Error</code>引入作用域，同时使用<code>Box&lt;dyn Error&gt;</code> trait 对象，意味着函数会返回实现了<code>Error</code> trait  的类型，不过无需指定具体将会返回的值的类型。这提供了在不同的错误场景可能有不同的错误返回值的灵活性。这也就是 <code>dyn</code> ，它是<em>动态</em>（dynamic）的缩写。</p>
<ul>
<li>这比在返回值上使用 impl trait 语法灵活多了。</li>
</ul>
<p>当使用 <code>Result&lt;T,E&gt;</code> 处理没有返回值的函数的错误时，</p>
<ul>
<li>没有错误时一般使用 <code>Ok(())</code>,<code>()</code> 即unit类型，表示没有返回值</li>
<li>错误就使用 <code>Err</code> 将错误包装一下返回。</li>
</ul>
<h1 id="处理环境变量"><a href="#处理环境变量" class="headerlink" title="处理环境变量"></a>处理环境变量</h1><h1 id="将错误打印到标准错误中"><a href="#将错误打印到标准错误中" class="headerlink" title="将错误打印到标准错误中"></a>将错误打印到标准错误中</h1><p>使用 <code>eprintln!</code> 宏</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>11编写自动化测试</title>
    <url>//11%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html</url>
    <content><![CDATA[<p>主要内容：</p>
<ul>
<li><p>Rust 测试功能的机制，</p>
</li>
<li><p>编写测试时会用到的注解和宏，</p>
</li>
<li><p>运行测试的默认行为和选项，</p>
</li>
<li><p>如何将测试组织成单元测试和集成测试</p>
</li>
</ul>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>Unit test</p>
<p>单元测试所在位置</p>
<p>在 <code>tests</code> mod 中，该 mod 会有一个 <code>#[cfg(test)]</code> 属性注解，</p>
<p>单元测试则是标记了 <code>#[test]</code> 属性的函数&#x2F;方法。</p>
<h1 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h1><p>测试函数，带有<code>test</code> 属性注解的函数。</p>
<p>在 <code>fn</code> 上面加上 <code>#[test]</code> 属性</p>
<p>执行 <code>cargo test</code> 命令运行测试时，Rust 会构建一个测试执行程序，调用标记了 <code>test</code> 属性的函数。</p>
<p>使用 cargo 新建库项目时，它会自动为我们生成一个测试模板和一个测试函数。</p>
<p>每一个测试都在一个新线程中运行，当主线程发现测试线程异常了，就将对应测试标记为失败。</p>
<ul>
<li>直接调用<code>panic!</code>宏，是最简单的造成 panic 的方法。</li>
</ul>
<h2 id="使用-assert-宏来检查结果"><a href="#使用-assert-宏来检查结果" class="headerlink" title="使用 assert! 宏来检查结果"></a>使用 <code>assert!</code> 宏来检查结果</h2><p><code>assert!</code>宏由标准库提供，需要条件结果为 <code>true</code>，否则会调用<code>panic!</code>宏，让测试失败。</p>
<h2 id="使用-assert-eq-和assert-ne-宏来测试相等"><a href="#使用-assert-eq-和assert-ne-宏来测试相等" class="headerlink" title="使用 assert_eq! 和assert_ne!宏来测试相等"></a>使用 <code>assert_eq!</code> 和<code>assert_ne!</code>宏来测试相等</h2><p>分别比较两个值是相等还是不相等来进行断言。</p>
<p><code>assert_eq!</code> 和 <code>assert_ne!</code> 宏在底层分别使用了 <code>==</code> 和 <code>!=</code> 。</p>
<p>当断言失败时，这两个宏辉使用调式格式打印出其参数，所以，被比较的值必须要实现<code>PartialEq</code> 和 <code>Debug</code> 两个 trait。</p>
<ul>
<li><code>PartialEq</code> 用于判断值是否相等；</li>
<li><code>Debug</code> 用于打印值；</li>
</ul>
<blockquote>
<p>注意，因为 PartialEq 和 Debug 两个 trait 都是派生 trait，所以通常可以直接在结构体或者枚举上添加 <code>#[derive(PartialEq,Debug)]</code> 注解。</p>
</blockquote>
<p>可以参考附录C <a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/appendix-03-derivable-traits.html">“可派生 trait”</a>  中更多关于可派生 trait 的信息。</p>
<h2 id="自定义失败信息"><a href="#自定义失败信息" class="headerlink" title="自定义失败信息"></a>自定义失败信息</h2><p>可以向<code>assert!、assert_eq!、assert_ne!</code> 宏传递一个可选的失败信息参数，可以在测试失败时将自定义失败信息打印出来。</p>
<p>可以使用<code>&#123;&#125;</code>占位符</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greeting_contains_name</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">greeting</span>(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(</span><br><span class="line">        result.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;Carol&quot;</span>),</span><br><span class="line">        <span class="string">&quot;Greeting did not contain name, value was `&#123;&#125;`&quot;</span>, result</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用-should-panic-检查-panic"><a href="#使用-should-panic-检查-panic" class="headerlink" title="使用 should_panic 检查 panic"></a>使用 <code>should_panic</code> 检查 panic</h2><p>检查代码是否按照期望处理错误，可以使用 <code>should_panic</code> 。</p>
<p>在 <code>#[test]</code> 属性下面</p>
<ul>
<li>添加一个 <code>#[should_panic]</code> 属性；</li>
<li>或者 <code>#[should_panic(expected = &quot;xxx&quot;)]</code> 属性，expected 参数，会匹配panic 时错误信息，匹配则成功，否则失败</li>
</ul>
<p>当函数panic 时测试通过，没有panic 时则失败。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">    Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic(expected = <span class="string">&quot;Guess value must be less than or equal to 100&quot;</span>)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">    Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="将-Result-lt-T-E-gt-用于测试"><a href="#将-Result-lt-T-E-gt-用于测试" class="headerlink" title="将 Result&lt;T,E&gt; 用于测试"></a>将 <code>Result&lt;T,E&gt;</code> 用于测试</h2><p>测试失败时除了发生 panic，也可以使用 <code>Result&lt;T,E&gt;</code>。这样被测试函数中可以使用<code>?</code>运算符返回 <code>Err</code> 错误（参考[09错误处理](09错误处理.md###  传播错误的简写：? 运算符) 章节的？运算符部分）</p>
<p>测试通过返回<code>Ok(())</code> –<code>Ok()</code> 中返回类型为 <code>()</code>即unit，返回空值。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;two plus two does not equal four&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：不能对使用 <code>Result&lt;T,E&gt;</code> 的测试使用 <code>#[should_panic]</code> 注解。</p>
<p>当使用 <code>Result&lt;T,E&gt;</code> 的时候，应该在测试失败时直接返回 <code>Err</code> 值。</p>
</blockquote>
<h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><p>运行测试使用 <code>cargo test</code> 命令，</p>
<p>与 <code>cargo run</code> 一样，test 命令也会编译并运行生成的测试二进制文件。</p>
<p>默认情况下，<code>cargo test</code> </p>
<ul>
<li><strong>并行</strong>的运行所有测试；</li>
<li>截获测试运行过程中产生的输出，<strong>不展示过程输出</strong>，只关心测试结果；</li>
</ul>
<p>可使用的命令行参数分两部分，</p>
<ol>
<li>一部分传递个<code>cargo test</code>,</li>
<li>另一部分传递给生成的测试二进制文件，</li>
</ol>
<p>使用 <code>--</code> 分隔符分隔这两种参数。</p>
<p>格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo test [传递给cargo test 的参数] -- [传递给二进制测试文件的参数]</span><br><span class="line"></span><br><span class="line">cargo test [OPTIONS] [TESTNAME] [-- &lt;args&gt;...]</span><br><span class="line"></span><br><span class="line">ARGS:</span><br><span class="line">    &lt;TESTNAME&gt;    If specified, only run tests containing this string in their names</span><br><span class="line">    &lt;args&gt;...     Arguments for the test binary</span><br></pre></td></tr></table></figure>

<p>使用帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo test --help     # 查看哪些参数可以传递给 cargo test </span><br><span class="line">cargo test -- --help  # 查看哪些参数可以传递给二进制测试文件</span><br></pre></td></tr></table></figure>



<h2 id="并行或连续的运行测试"><a href="#并行或连续的运行测试" class="headerlink" title="并行或连续的运行测试"></a>并行或连续的运行测试</h2><p><code>--test-threads</code> 参数传递给二进制测试文件，支持控制线程的数量</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo test -- --test-threads=<span class="number">1</span>  <span class="comment">// 使用1个线程，即不使用并行机制</span></span><br></pre></td></tr></table></figure>



<h2 id="显示函数输出"><a href="#显示函数输出" class="headerlink" title="显示函数输出"></a>显示函数输出</h2><p>默认情况下测试时不会输出调用函数中的正常输出内容，例如<code>println!()</code> 的输出，仅会在测试执行失败时输出。</p>
<p><code>--nocapture</code> 参数传递给二进制测试文件，支持打印测试中的值。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo test -- --nocapture</span><br></pre></td></tr></table></figure>



<h2 id="指定名字运行部分测试"><a href="#指定名字运行部分测试" class="headerlink" title="指定名字运行部分测试"></a>指定名字运行部分测试</h2><p>cargo test [要运行的测试全称或者部分]</p>
<ul>
<li>指定全名称就运行单个test</li>
<li>指定模糊名称就运行所有匹配上的test</li>
</ul>
<h2 id="忽略某些测试"><a href="#忽略某些测试" class="headerlink" title="忽略某些测试"></a>忽略某些测试</h2><p>在<code>#[test]</code> 属性下面添加 <code>#[ignore]</code> 属性，这样运行时会自动忽略有该属性的test</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expensive_test</span>() &#123;</span><br><span class="line">    <span class="comment">// 需要运行一个小时的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>cargo test -- --ignored</code> 命令可以运行有 <code>#[ignored]</code> 属性标记的test</p>
<h1 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h1><p>documentation testing</p>
<p>相关内容查看<a href="14%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8ECargo%E5%92%8CCrate.io%E7%9A%84%E5%86%85%E5%AE%B9.md#%E7%BC%96%E5%86%99%E6%9C%89%E7%94%A8%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A">14章编写有用的文档注释这部分</a></p>
<p>因为文档注释采用 <code>Markdown</code> 的语法，所以除了常规内容，插入代码，可以使用<strong>一对三个反引号</strong> 来标记。</p>
<p>如果代码可能引起panic，那么在反引号后添加<code>rust,should_panic</code> 的内容。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ```rust,should_panic</span></span><br><span class="line"><span class="comment">/// // panics on division by zero</span></span><br><span class="line"><span class="comment">/// testing_rbe::documentation_testing_rbe::div(10, 0);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br></pre></td></tr></table></figure>

<p>上面的内容，在编译出来的文档中就会标记为红色感叹号。</p>
<p>注意，在文档注释中调用代码，需要使用绝对路径，如上面样例所示，否则编译时会报错，找不到函数&#x2F;方法。</p>
<h1 id="测试的组织结构"><a href="#测试的组织结构" class="headerlink" title="测试的组织结构"></a>测试的组织结构</h1><p>Rust 中测试主要分为两类：</p>
<ul>
<li>单元测试（unit tests）<ul>
<li>Rust 支持测试 private 的接口、方法、函数</li>
</ul>
</li>
<li>集成测试（integration tests）<ul>
<li>集成测试主要测试库的对外暴露的内容；</li>
<li>主要目的时测试库的多个部分是否能够一起正常工作；</li>
</ul>
</li>
</ul>
<h2 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li>单元测试与要测试的源代码放在同一个文件中，</li>
<li>测试模块需要在 <code>tests</code>模块中，同时标注 <code>#[cfg(test)]</code> 属性<ul>
<li>这个属性告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码，其他任务时不处理测试代码；</li>
<li>这样在只希望构建库的时候，可以节省编译时间，同时不包含测试代码，减少编译后文件的大小；</li>
</ul>
</li>
</ul>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>集成测试相对于源码来说是单独目录（ <code>tests</code> 目录，与 <code>src</code> 同级）（独立 crate）</p>
<ul>
<li>所以使用库时与使用其他模块的方式一样，</li>
<li>它们测试时只能调用被测库中的公有 API；</li>
<li>tests 目录下得测试文件不需要 <code>#[cfg(test)]</code> 属性标记；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   └── main.rs</span><br><span class="line">│   └── lib.rs</span><br><span class="line">└── tests</span><br><span class="line">    ├── my_test.rs</span><br><span class="line">    └── my_other_test.rs</span><br></pre></td></tr></table></figure>





<p>可以在 <code>tests</code> 目录下创建任意多个测试文件。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">文件名：tests/integration_test.rs</span><br><span class="line">内容：</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> adder;   <span class="comment">// 引入 adder mod</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="指定集成测试文件运行测试"><a href="#指定集成测试文件运行测试" class="headerlink" title="指定集成测试文件运行测试"></a>指定集成测试文件运行测试</h3><p><code>cargo test --test &lt;集成测试文件名&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo test --test integration_test   <span class="comment">//  测试文件 tests/integration_test.rs</span></span><br></pre></td></tr></table></figure>



<h3 id="集成测试中的子模块"><a href="#集成测试中的子模块" class="headerlink" title="集成测试中的子模块"></a>集成测试中的子模块</h3><p>tests 目录中的所有文件都会被编译为单独的 crate。</p>
<p>那么如何在集成测试目录下创建可以被多个测试调用的公共函数？</p>
<ul>
<li>Rust 中 tests 目录下得子目录不会被作为单独的 crate 编译，不会被认为临时测试文件。</li>
<li>所以，在tests 目录下创建子目录，然后创建单独文件即可。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">将 setup 函数放到 tests/common/<span class="keyword">mod</span>.rs 文件中</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src</span><br><span class="line">│   └── main.rs</span><br><span class="line">│   └── lib.rs</span><br><span class="line">└── tests</span><br><span class="line">    ├── my_test.rs</span><br><span class="line">    |-- common     <span class="comment">// 公共模块</span></span><br><span class="line">        \-- <span class="keyword">mod</span>.rs</span><br><span class="line">    └── my_other_test.rs</span><br></pre></td></tr></table></figure>





<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二进制-crate-的集成测试"><a href="#二进制-crate-的集成测试" class="headerlink" title="二进制 crate 的集成测试"></a>二进制 crate 的集成测试</h2><p>如果项目是二进制 crate 并且只包含 <code>src/main.rs</code> ，没有 <code>src/lib.rs</code> ，那么不能在tests目录创建集成测试。</p>
<ul>
<li>只有库 crate 才会向其他 crate 暴露可供调用和使用的函数</li>
<li>二进制 crate 只关心单独运行。</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>13函数式语言特性：迭代器和闭包</title>
    <url>//13%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85.html</url>
    <content><![CDATA[<p><strong>函数式</strong>（functional programming）编程风格通常包含将<strong>函数</strong>作为参数值或其他函数的返回值、将函数赋值给变量以供之后执行等。</p>
<p>Rust 上的函数式语言功能：</p>
<ul>
<li><strong>闭包</strong>（Closures），一个可以存储在变量里的类似函数的结构；</li>
<li>迭代器（Iterators），一种处理元素序列的方式；</li>
</ul>
<h1 id="闭包：可以捕获其环境的匿名函数"><a href="#闭包：可以捕获其环境的匿名函数" class="headerlink" title="闭包：可以捕获其环境的匿名函数"></a>闭包：可以捕获其环境的匿名函数</h1><p><strong>闭包</strong>（Closures），是可以将作为值赋值给变量，或作为参数传递给其他函数的<strong>匿名函数</strong>。</p>
<ul>
<li><p>可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。</p>
</li>
<li><p>不同于函数，闭包允许捕获调用者作用域中的值。</p>
<blockquote>
<p>直接使用其所在位置上下文中定义的变量，无需将这些外部变量作为参数传入。</p>
</blockquote>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">color</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;green&quot;</span>);</span><br><span class="line"><span class="comment">// 这里直接捕获外部变量 color。同时这里是通过不可变借用的方式捕获。不影响 color 在后面的使用。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">print</span> = || <span class="built_in">println!</span>(<span class="string">&quot;`color`: &#123;&#125;&quot;</span>, color);</span><br><span class="line"><span class="comment">// Call the closure using the borrow.</span></span><br><span class="line"><span class="title function_ invoke__">print</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_reborrow</span> = &amp;color;</span><br></pre></td></tr></table></figure>



<h2 id="使用闭包创建行为的抽象"><a href="#使用闭包创建行为的抽象" class="headerlink" title="使用闭包创建行为的抽象"></a>使用闭包创建行为的抽象</h2><p>闭包的行为特点：</p>
<ul>
<li>允许我们在一个地方创建闭包，然后再程序的指定位置需要结果的时候<strong>才执行</strong>这些代码<ul>
<li>与函数的区别，函数会直接调用，然后将计算结果返回给变量，而闭包是将整体作为参数赋值给变量，在后面调用该变量时才执行。即将整体压进栈中，而不是将返回值压进栈中。</li>
</ul>
</li>
</ul>
<p>例子，调用函数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里调用函数，然后将函数结果返回赋值给变量，后面直接使用变量值。</span></span><br><span class="line">    <span class="comment">// 缺点是不管后面用不用都会先调用函数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_result</span> = <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity);</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,expensive_result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">simulated_expensive_calculation</span>(intensity: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br></pre></td></tr></table></figure>

<p>例子，创建闭包</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>闭包定义：</p>
<ol>
<li>闭包的一定以一对竖线（<code>|</code>）开始，在竖线中指定闭包的参数，多个参数间，使用逗号（<code>,</code>）分隔；（与Ruby的闭包定义类似）<ul>
<li><code>|param1, param2|</code></li>
</ul>
</li>
<li>参数后，是存放闭包体的大括号（如果比包体只有一行，可以省略大括号）；</li>
<li>闭包体内，与函数体一样，最后一行没有分号，默认作为返回值；</li>
</ol>
<p>闭包调用：</p>
<ul>
<li>调用闭包类似于调用函数，</li>
<li>指定存放闭包定义的变量名，并在后面跟包含要使用的参数的括号；</li>
<li><code>存放闭包定义的变量名(参数);</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里表示将闭包的定义赋值给变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是闭包的调用，</span></span><br><span class="line"><span class="comment">// 存储闭包定义的变量名(参数)</span></span><br><span class="line"><span class="title function_ invoke__">expensive_closure</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>



<h2 id="闭包类型推断和注解"><a href="#闭包类型推断和注解" class="headerlink" title="闭包类型推断和注解"></a>闭包类型推断和注解</h2><p>闭包不要求 <code>fn</code>函数那样显示注明参数和返回值的类型。</p>
<ul>
<li>函数需要暴露给用户，所以严格的定义有利于保证正确的参数和返回值的类型；</li>
<li>闭包不对外暴露，同时上下文比较小，编译器能可靠的推断参数和返回值的类型；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下都是合法定义</span></span><br><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>

<p>闭包定义会为每个参数和返回值推断一个唯一具体类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能有一种类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));  --ok</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);  --wrong</span><br></pre></td></tr></table></figure>



<h2 id="使用带有泛型和Fn-trait-的闭包"><a href="#使用带有泛型和Fn-trait-的闭包" class="headerlink" title="使用带有泛型和Fn trait 的闭包"></a>使用带有泛型和<code>Fn</code> trait 的闭包</h2><p>闭包还可以存放在结构体，枚举或函数参数中</p>
<ul>
<li>需要指定闭包的类型</li>
<li>需要使用泛型和 trait bound</li>
</ul>
<blockquote>
<p> 注：每个闭包实例有其独有的匿名类型。</p>
<ul>
<li>即便两个闭包有相同的签名，它们的类型仍然可以被认为是不同的。</li>
</ul>
</blockquote>
<h3 id="Fn-系列-trait-之间的区别"><a href="#Fn-系列-trait-之间的区别" class="headerlink" title="Fn 系列 trait 之间的区别"></a><code>Fn</code> 系列 trait 之间的区别</h3><p><code>Fn</code> 系列 trait 由标准库提供。所有的闭包都实现了 <code>Fn、FnMut、FnOnce</code> trait 中的一个。</p>
<ul>
<li><code>Fn</code> trait，从其环境中获取不可变借用；</li>
<li><code>FnMut</code> trait，获取可变借用值，所以可以改变其环境值；</li>
<li><code>FnOnce</code> trait，获取其所有权并在定义闭包时将其移动进闭包。<ul>
<li>从名字中<code>Once</code> 部分也可以说明不能多次获取相同变量的所有权，所以只能是<code>Once</code>；</li>
</ul>
</li>
</ul>
<p>当创建闭包时，Rust 编译器会根据其如何使用环境中的变量来推断如何实现 <code>Fn</code>系列 trait。</p>
<p>三个 <code>Fn</code> 系列 trait 的关系可以简单理解：（更深层次的理解有些复杂，放在以后处理）</p>
<ul>
<li>实现了 <code>Fn</code> 的一定实现了 <code>FnMut</code> ，</li>
<li>实现了 <code>FnMut</code> 的一定实现了 <code>FnOnce</code>，</li>
</ul>
<blockquote>
<p>所有闭包都可以被调用至少一次，所以所有闭包都实现了<code>FnOnce</code>，</p>
<p>没有移动捕获的环境值所有权的闭包也实现了<code>FnMut</code>，</p>
<p>不需要对捕获的变量进行可变借用访问的闭包则实现了<code>Fn</code>，</p>
</blockquote>
<p><strong>实际使用时</strong>，</p>
<ul>
<li>当需要指定一个 <code>Fn</code> 系列 trait bound 的时候，可以从<code>Fn</code> 开始，然后编译器会根据闭包体中的情况告诉你是否需要 <code>FnMut</code> 或 <code>FnOnce</code>。</li>
</ul>
<blockquote>
<p>注意：函数也都实现了这三个 <code>Fn</code> trait。如果不需要捕获环境中的值，则可以使用实现了 <code>Fn</code> trait 的函数而不是闭包。</p>
</blockquote>
<h2 id="闭包会捕获其环境"><a href="#闭包会捕获其环境" class="headerlink" title="闭包会捕获其环境"></a>闭包会捕获其环境</h2><p>对于上面提到的闭包捕获其环境，</p>
<p>就是闭包可以使用其上下文中定义的变量。（闭包周围的作用域被称为其<strong>环境</strong>environment）</p>
<ul>
<li>函数不行，函数不能使用没有在函数签名或函数体中定义的变量。<ul>
<li>闭包捕获其环境的能力，需要使用内存并产生额外开销，</li>
<li>函数不允许捕获其环境值，所以定义和使用函数也就不会有这些额外开销。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x; <span class="comment">// 闭包这样用可以</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fn equal_to_x(z: i32) -&gt; bool &#123; z == x &#125; --这样用会报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>闭包可以通过三种方式捕获其环境，对应函数的三种获取参数的方法：三种不同的 trait</p>
<ul>
<li>获取所有权 <code>FnOnce</code>；（在[上面](#  系列 trait 之间的区别)已经解释过三者之间的区别）</li>
<li>获取可变借用 <code>FnMut</code>；</li>
<li>获取不可变借用 <code>Fn</code>；</li>
</ul>
<p>三者的使用范围：</p>
<p>如果一个参数使用<code>FnOnce</code> 标记，那么<code>&amp;T</code>，<code>&amp;mut T</code> 或 <code>T</code>三种形式闭包都可以捕获。</p>
<p>反过来，如果一个参数使用<code>Fn</code> 标记，那么只能捕获<code>&amp;T</code>这种形式。</p>
<h2 id="如何强制闭包获取其使用的环境值的所有权？"><a href="#如何强制闭包获取其使用的环境值的所有权？" class="headerlink" title="如何强制闭包获取其使用的环境值的所有权？"></a>如何强制闭包获取其使用的环境值的所有权？</h2><ul>
<li>可以在参数列表前使用 <code>move</code> 关键字。</li>
<li>使用场景：在将闭包传递给<strong>新线程</strong>以便将数据移动到新线程中时最为实用。<ul>
<li><a href="16%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91.md">第十六章</a>讨论并发时会展示更多 <code>move</code> 闭包的例子。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;  <span class="comment">// ok，x 已经移动到闭包中了。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x);  <span class="comment">// 编译器报错，x 的所有权在上面已经发生了移动，且 vec 没有实现 Copy trait。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="作为输入参数"><a href="#作为输入参数" class="headerlink" title="作为输入参数"></a>作为输入参数</h2><p>因为闭包是匿名类型（type anonymity），所以闭包作为参数时，需要使用**<code>泛型+trait bounds</code>** 的形式。</p>
<ul>
<li>其中 trait bounds 一般是 <code>Fn</code>，<code>FnMut</code>，<code>FnOnce</code> 这三个trait。</li>
</ul>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `F` must be generic.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">apply</span>&lt;F&gt;(f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_me</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(f: F) &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>闭包作为输入参数时，闭包必须使用<code>Fn</code>，<code>FnMut</code>，<code>FnOnce</code> 这三个trait之一来显示标注。</p>
<p>这三个 trait 的限制从多到少依次是：</p>
<ul>
<li><p><code>Fn</code>：闭包通过引用的方式捕获（<code>&amp;T</code>）;</p>
</li>
<li><p><code>FnMut</code>：闭包通过可变引用的方式捕获（<code>&amp;mut T</code>）；</p>
</li>
<li><p><code>FnOnce</code>：闭包通过值捕获（<code>T</code>，通过值，也就是通过获取所有权的方式）；</p>
</li>
</ul>
<p>在逐个变量的基础上，编译器将以尽可能少的限制方式捕获变量。</p>
<p>当定义闭包时，编译器会隐式创建一个新的匿名结构体来存储被捕获的变量。同时将定义时Fn<code>、</code>FnMut<code>、</code>FnOnce&#96;其中用到的 trait 作为这个变量的类型，直到被调用。</p>
<h2 id="作为输出参数"><a href="#作为输出参数" class="headerlink" title="作为输出参数"></a>作为输出参数</h2><p>根据定义，匿名闭包类型是未知的，所以我们必须使用<code>impl Trait</code>来返回它们。</p>
<p>除此之外，必须使用<code>move</code>关键字，这表示所有捕获都是按值进行的（需要获取所有权）。这是必需的，因为任何通过引用捕获的内容都会在函数退出时被删除，在闭包中留下无效的引用。</p>
<ul>
<li>防止出现无效引用。</li>
</ul>
<h1 id="使用迭代器处理元素序列"><a href="#使用迭代器处理元素序列" class="headerlink" title="使用迭代器处理元素序列"></a>使用迭代器处理元素序列</h1><p>迭代器模式，允许你对一个项的序列进行某些处理。</p>
<p>迭代器（iterator），负责遍历序列中的每一项和决定序列何时结束的逻辑。</p>
<p>在 Rust 中，迭代器是惰性的（lazy），</p>
<ul>
<li>即，仅创建迭代器，没有调用执行方法，迭代器是不工作的。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>(); <span class="comment">// 创建一个迭代器。不过这段代码没有任何作用，因为不会执行。</span></span><br></pre></td></tr></table></figure>

<p>迭代器的实现方式，提供了对多种不同的序列使用相同逻辑的灵活性。</p>
<h2 id="Iterator-trait-和-next-方法"><a href="#Iterator-trait-和-next-方法" class="headerlink" title="Iterator trait 和 next 方法"></a><code>Iterator</code> trait 和 <code>next</code> 方法</h2><p>迭代器都实现了一个叫做 <code>Iterator</code> 的 trait，定义在标准库中。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略了方法的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>type Item</code> 和 <code>Self::Item</code>，它们定义了 trait 的 关联类型（associated type），在 <a href="19%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.md">19章高级特性</a> 中会深入讲解。<ul>
<li>现在简单知道这表明实现 <code>Iterator</code> trait 要求同时定义一个 <code>Item</code> ，这个 <code>Item</code> 类型被用作 <code>next</code> 方法的<strong>返回值类型</strong>。换句话说，<code>Item</code> 类型将是迭代器返回元素的类型。</li>
</ul>
</li>
<li><code>next</code> 是 <code>Iterator</code> 实现者被要求定义的唯一方法。<code>next</code> 一次返回迭代器中的一个项，封装在 <code>Some</code> 中，当迭代器结束时，它返回 <code>None</code>。</li>
</ul>
<p>在迭代器上调用 <strong><code>next</code></strong> 方法<strong>改变</strong>了迭代器中用来记录序列位置的<strong>状态</strong>。</p>
<ul>
<li>即，代码<strong>消费</strong>（consume）了，或使用了迭代器（每个 next 调用都会从迭代器中消费一个项）。</li>
</ul>
<p><strong>注意</strong>：使用 <code>for</code> 循环时无需使迭代器可变（mut），因为 <code>for</code> 循环会获取迭代器的所有权并在后台使用迭代器可变。</p>
<h3 id="关于迭代器和所有权："><a href="#关于迭代器和所有权：" class="headerlink" title="关于迭代器和所有权："></a>关于迭代器和所有权：</h3><blockquote>
<p>注意：从next 调用中得到的值是不可变引用。<code>iter()</code>方法生成一个<strong>不可变引用</strong>的迭代器。</p>
<p><code>into_iter</code> 可以<strong>获取所有权</strong>并返回拥有所有权的迭代器；</p>
<p><code>iter_mut</code> 可以获取<strong>可变引用</strong>的迭代器。</p>
</blockquote>
<h2 id="消费迭代器的方法"><a href="#消费迭代器的方法" class="headerlink" title="消费迭代器的方法"></a>消费迭代器的方法</h2><p><code>Iterator</code> trait 有一系列不同的由标准库提供的默认实现方法。通过标准库API文档查找。</p>
<p>一些方法在其定义中调用了<code>next</code> 方法，这也是为什么在实现 <code>Iterator</code> trait 时要求实现 <code>next</code> 方法的原因。</p>
<ul>
<li>它们被称为 消费适配器（consuming adaptors），因为调用它们会消耗迭代器。</li>
<li>例如，sum</li>
</ul>
<h2 id="产生其他迭代器的方法"><a href="#产生其他迭代器的方法" class="headerlink" title="产生其他迭代器的方法"></a>产生其他迭代器的方法</h2><p><strong>迭代器适配器</strong>（iterator adaptors） ，允许我们将当前迭代器转变为不同类型的迭代器。可以链式调用多个迭代器适配器。</p>
<ul>
<li>所有迭代器都是惰性的。必须调用一个消费适配器方法才能获取结果。</li>
</ul>
<blockquote>
<p>迭代器适配器和消费适配器，有些像 spark 中的 转换（transformation）和行动（action），转换用于在已有的数据集上生成新的数据集，行动用于产生结果集。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么这里 x 的类型为 &amp;i32,但是却可以进行 &amp;i32 + 1?</span></span><br><span class="line"><span class="comment">// 因为标准库实现了 &amp;i32 + i32的操作。 </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>



<h2 id="实现-Iterator-trait-来创建自定义迭代器"><a href="#实现-Iterator-trait-来创建自定义迭代器" class="headerlink" title="实现 Iterator trait 来创建自定义迭代器"></a>实现 <code>Iterator</code> trait 来创建自定义迭代器</h2><p>可以为标准库中其他的集合类型创建迭代器。</p>
<p>同时因为定义中唯一要求实现的方法<code>next</code> 方法，所以可以通过实现它来创建自定义迭代器。</p>
<h2 id="使用自定义迭代器中其他-Iterator-trait-方法"><a href="#使用自定义迭代器中其他-Iterator-trait-方法" class="headerlink" title="使用自定义迭代器中其他 Iterator trait 方法"></a>使用自定义迭代器中其他 <code>Iterator</code> trait 方法</h2><p>a % b ，如果 b 是2 的n次幂，那么就有 a &amp; (b -1)</p>
<p>zip 方法在任一输入迭代器返回 <code>None</code> 时也返回 None，所以如果两组迭代组合不可能产生类似 (5,None) 这样的组合。</p>
<h1 id="改进之前的-I-x2F-O-项目"><a href="#改进之前的-I-x2F-O-项目" class="headerlink" title="改进之前的 I&#x2F;O 项目"></a>改进之前的 I&#x2F;O 项目</h1><h2 id="使用迭代器并去掉-clone"><a href="#使用迭代器并去掉-clone" class="headerlink" title="使用迭代器并去掉 clone"></a>使用迭代器并去掉 <code>clone</code></h2><p>函数式编程风格倾向于最小化可变状态的数量来使代码更简洁。</p>
<p>去掉可变状态可能会使得将来进行并行搜索的增强变得更容易，因为我们不必管理 <code>results</code> vector 的并发访问</p>
<h1 id="性能比较：循环对迭代器"><a href="#性能比较：循环对迭代器" class="headerlink" title="性能比较：循环对迭代器"></a>性能比较：循环对迭代器</h1><p>闭包和迭代器的实现，达到了不影响运行时性能的程序。</p>
<p>这是Rust 竭力提供<strong>零成本抽象</strong>的目标的一部分。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>15智能指针</title>
    <url>//15%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.html</url>
    <content><![CDATA[<p><strong>指针</strong>（pointer）是一个包含内存地址的变量的通用概念。</p>
<ul>
<li>这个地址，引用或指向（points at）一些其他数据</li>
<li>Rust 中最常用的指针是<strong>引用</strong>（reference）。<ul>
<li>以<code>&amp;</code>符号为标志并借用它们所指向的值。</li>
<li>引用除了借用数据没有任何其他功能，也没有额外开销。</li>
</ul>
</li>
</ul>
<p><strong>智能指针</strong>（smart pointers）是一类数据结构</p>
<ul>
<li>表现与指针类似；</li>
<li>但拥有额外的元数据和功能；</li>
<li>起源于 C++，在其他语言中也存在；</li>
</ul>
<p>普通引用与智能指针的一个额外区别：</p>
<ul>
<li>引用是一类只借用数据的指针；</li>
<li>大部分情况下，智能指针<strong>拥有</strong>它们指向的数据的<strong>所有权</strong>；</li>
</ul>
<p>例如，<code>String</code> 和 <code>Vec&lt;T&gt;</code> 都属于智能指针。</p>
<p>智能指针通常使用<strong>结构体</strong>实现</p>
<ul>
<li>与常规结构体的区别，实现了 <code>Deref</code> 和 <code>Drop</code> 两个 trait</li>
<li><code>Deref</code> trait 允许智能指针结构体实例<strong>像引用一样工作</strong>；<ul>
<li>这样可以编写既用于引用、又用于智能指针的代码；</li>
</ul>
</li>
<li><code>Drop</code> trait 允许我们自定义当智能指针离开作用域时运行的代码；<ul>
<li>例如，<code>Box&lt;T&gt;</code> 类型实现了 <code>Drop</code> trait ，box 所指向的堆数据也会被清除。</li>
</ul>
</li>
</ul>
<p>所以：</p>
<p>智能指针是一类可以像引用一样工作的结构体。</p>
<p>标准库中最常用的智能指针：</p>
<ul>
<li><code>Box&lt;T&gt;</code>，用于在对上分配值；</li>
<li><code>Rc&lt;T&gt;</code>，一个引用计数类型，其数据可以有多个所有者；</li>
<li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCell&lt;T&gt;</code> 访问，一个在运行时而不是在编译时执行借用规则的类型。</li>
</ul>
<h1 id="使用Box-lt-T-gt-指向堆上的数据"><a href="#使用Box-lt-T-gt-指向堆上的数据" class="headerlink" title="使用Box&lt;T&gt; 指向堆上的数据"></a>使用<code>Box&lt;T&gt;</code> 指向堆上的数据</h1><p>box 允许你将一个<strong>值放在堆上</strong>而不是栈上。留在栈上的则是指向堆数据的指针。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值得时候；<ul>
<li>例如，box 允许创建递归类型。</li>
</ul>
</li>
<li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候；<ul>
<li>转移大量数据的所有权可能花费很长的时间，因为数据在栈上进行了拷贝，使用 box 可以将这些数据存储在堆上，然后只有少量指针数据在栈上被拷贝。</li>
</ul>
</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候；<ul>
<li>称为 <strong>trait对象</strong>（trait object），<a href="17Rust%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7.md">17章</a> 有专门将这个主题。</li>
</ul>
</li>
</ul>
<h2 id="使用-Box-lt-T-gt-在堆上存储数据"><a href="#使用-Box-lt-T-gt-在堆上存储数据" class="headerlink" title="使用 Box&lt;T&gt; 在堆上存储数据"></a>使用 <code>Box&lt;T&gt;</code> 在堆上存储数据</h2><p>如何创建和使用 <code>Box&lt;T&gt;</code>?</p>
<p>语法：</p>
<p>创建<code>Box&lt;T&gt;</code> 对象</p>
<p><code>Box::new(xxx)</code> 要创建的具体类型数据</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>); <span class="comment">// 使用box 在堆上存储一个 i32 值；</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>,b);</span><br></pre></td></tr></table></figure>

<p>当b离开作用域时，它会被释放，box 本身（位于栈上）和它所指向的数据（位于堆上）。</p>
<h2 id="Box-允许创建递归类型"><a href="#Box-允许创建递归类型" class="headerlink" title="Box 允许创建递归类型"></a>Box 允许创建递归类型</h2><p>Rust 需要在编译时知道类型占用多少空间。</p>
<p><strong>递归类型</strong>（recursive type），其值得一部分可以是相同类型的另一个值。这种值得嵌套理论上可以无限的进行下去。</p>
<ul>
<li>从名字可以理解为与嵌套函数极为相似。</li>
</ul>
<p>如果 Rust 中使用这种递归类型，那么 Rust 在编译期是不知道递归类型需要多少空间的。</p>
<p>解决：</p>
<p>box 有一个已知大小，所以可以通过在循环类型定义中插入 box，就可以创建间接存储的递归类型了。</p>
<h3 id="cons-list-的更多内容"><a href="#cons-list-的更多内容" class="headerlink" title="cons list 的更多内容"></a>cons list 的更多内容</h3><p>cons list 是一个来源于 Lisp 语言及其方言的数据结构。</p>
<p><code>cons</code> 函数（construction function 的缩写）利用两个参数构造一个新的<strong>列表</strong>，它们通常是一个单独的值和另一个列表。</p>
<ul>
<li>写法虽然不一样，但是作用与 Java 中的列表list 一样</li>
</ul>
<p>cons list 的每一项都包含两个元素：</p>
<ul>
<li>当前项的值；</li>
<li>下一项；<ul>
<li>最后一项值包含一个叫做 <code>Nil</code> 的值，并且没有下一项</li>
<li>代表递归的终止条件（base case）的规范名称是 <code>Nil</code>，它表示列表终止（是枚举的一项）</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：Rust 中需要列表的时候， <code>Vec&lt;T&gt;</code> 是一个更好的选择。</p>
</blockquote>
<h2 id="计算非递归类型的大小"><a href="#计算非递归类型的大小" class="headerlink" title="计算非递归类型的大小"></a>计算非递归类型的大小</h2><p><a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch15-01-box.html">Box 指向堆上数据，并且可确定大小 · Rust 程序设计语言（第二版） 简体中文版 (gitbooks.io)</a></p>
<h2 id="使用-Box-lt-T-gt-给递归类型一个已知的大小"><a href="#使用-Box-lt-T-gt-给递归类型一个已知的大小" class="headerlink" title="使用 Box&lt;T&gt; 给递归类型一个已知的大小"></a>使用 <code>Box&lt;T&gt;</code> 给递归类型一个已知的大小</h2><p>Rust 无法计算出要为定义为递归的类型分配多少空间。</p>
<p>不同于直接存储一个值，我们可以通过 box 间接存储一个指向值得指针。</p>
<ul>
<li>因为 <code>Box&lt;T&gt;</code> 是一个指针，我们总是知道它需要多少空间：<ul>
<li>指针的大小并不会根据其指向的数据量而改变。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不对的方式：</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Box 的方式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如上面例子，将 <code>Box</code> 放入 <code>Cons</code>成员中，而不是直接存放另一个 <code>List</code>值。</p>
<p><code>Box</code> 会指向另一个位于堆上的 <code>List</code> 值，而不是存放在 <code>Cons</code> 成员中。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>,</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>,</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>,</span><br><span class="line">                <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>box 只提供了间接存储和堆分配；</p>
<ul>
<li><code>Box&lt;T&gt;</code> 实现了 <code>Deref</code> trait ，所以它允许 <code>Box&lt;T&gt;</code> 值被当做引用对待；</li>
<li><code>Box&lt;T&gt;</code>实现了 <code>Drop</code> trait，所以当 <code>Box&lt;T&gt;</code> 值离开作用域时，box 所指向的堆数据也会被清除。</li>
</ul>
<h1 id="通过Deref-trait-将智能指针当作常规引用处理"><a href="#通过Deref-trait-将智能指针当作常规引用处理" class="headerlink" title="通过Deref trait 将智能指针当作常规引用处理"></a>通过<code>Deref</code> trait 将智能指针当作常规引用处理</h1><p>实现 <code>Deref</code> trait 允许我们重载<strong>解引用运算符</strong>（dereference operator）<code>*</code>（与乘法运算符或通配符相区别）。</p>
<p>通过这种方式实现 <code>Deref</code> trait 的智能指针可以被当做常规引用来对待，可以编写操作应用的代码并用于智能指针。</p>
<h2 id="通过解引用运算符追踪指针的值"><a href="#通过解引用运算符追踪指针的值" class="headerlink" title="通过解引用运算符追踪指针的值"></a>通过解引用运算符追踪指针的值</h2><p>常规引用，是一个指针类型，</p>
<ul>
<li>可以看成指向存储在其他地方值得箭头。</li>
</ul>
<p><strong>解引用</strong>运算符（<code>*</code>） 的作用：</p>
<ul>
<li>追踪引用所指向的数据</li>
</ul>
<blockquote>
<p>这个知识点记住就可以了。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="通过实现-Deref-trait-将某类型像引用一样处理"><a href="#通过实现-Deref-trait-将某类型像引用一样处理" class="headerlink" title="通过实现 Deref trait 将某类型像引用一样处理"></a>通过实现 <code>Deref</code> trait 将某类型像引用一样处理</h2><p><code>Deref</code> trait 由标准库提供，要求实现名为 <code>deref</code> 的方法，其借用 <code>self</code> 并返回一个内部数据的引用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义了用于此 triat 的关联类型。见19章</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供了*运算符访问的值的引用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有 <code>Deref</code> trait 的话，编译器只会解引用 <code>&amp;</code> 引用类型。</p>
<p><code>deref</code> 方法向编译器提供了获取任何实现了 <code>Deref</code> trait 的类型的值，并且调用这个类型的 <code>deref</code> 方法来获取一个它知道如何解引用的 <code>&amp;</code> 引用的能力。</p>
<ul>
<li>上面这句话拆分一下，能做两件事<ol>
<li>deref 方法让编译器可以获得任何实现了 <code>Deref</code> trait 的类型的值；</li>
<li>编译器可以调用这些类型的 <code>deref</code> 方法获得一个<code>&amp;</code>引用类型（这样它就知道如何解引用了）。</li>
</ol>
</li>
</ul>
<p>示例 15-9 </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br></pre></td></tr></table></figure>

<p>上面这段代码，Rust 事实上在底层运行了如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">*(y.<span class="title function_ invoke__">deref</span>())</span><br></pre></td></tr></table></figure>

<p>– 我理解就是任何类型先调用它实现的 <code>Deref</code> trait 的 <code>deref</code>方法来获得一个 <code>&amp;</code>引用类型，然后使用 <code>*</code>解引用运算符解引用，获取引用指向的数据。</p>
<p>官方解释：</p>
<p>Rust 将 <code>*</code> 运算符替换为先调用 <code>deref</code> 方法再进行普通解引用的操作，如此我们便不用担心是否还需手动调用 <code>deref</code> 方法了。Rust 的这个特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 <code>Deref</code> 的类型。</p>
<p><code>deref</code> 方法返回值的引用，以及 <code>*(y.deref())</code> 括号外边的普通解引用仍为必须的原因在于所有权。如果 <code>deref</code> 方法直接返回值而不是值的引用，其值（的所有权）将被移出 <code>self</code>。在这里以及大部分使用解引用运算符的情况下我们并不希望获取 <code>MyBox&lt;T&gt;</code> 内部值的所有权。</p>
<p>注意，每次当我们在代码中使用 <code>*</code> 时， <code>*</code> 运算符都被替换成了先调用 <code>deref</code> 方法再接着使用 <code>*</code> 解引用的操作，且只会发生一次，不会对 <code>*</code> 操作符无限递归替换，解引用出上面 <code>i32</code> 类型的值就停止了，这个值与示例 15-9 中 <code>assert_eq!</code> 的 <code>5</code> 相匹配</p>
<h3 id="函数和方法的隐式解引用强制多态"><a href="#函数和方法的隐式解引用强制多态" class="headerlink" title="函数和方法的隐式解引用强制多态"></a>函数和方法的隐式解引用强制多态</h3><p><strong>解引用强制多态</strong>（<em>deref coercions</em>）是 Rust 在函数或方法传参上的一种便利。</p>
<p>其将实现了 <code>Deref</code> 的类型的引用转换为原始类型通过 <code>Deref</code> 所能够转换的类型的引用。（有些拗口）</p>
<p>当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，<strong>解引用强制多态将自动发生</strong>。这时会有一系列的 <code>deref</code> 方法被调用，把我们提供的类型转换成了参数所需的类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用强制多态</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有解引用强制多态的写法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注：解引用强制多态分析发生在编译时，所以并没有运行时开销。</p>
</blockquote>
<h3 id="解引用强制多态如何与可变性交互"><a href="#解引用强制多态如何与可变性交互" class="headerlink" title="解引用强制多态如何与可变性交互"></a>解引用强制多态如何与可变性交互</h3><p>类似于如何使用 <code>Deref</code> trait 重载不可变引用的 <code>*</code> 运算符，Rust 提供了 <code>DerefMut</code> trait 用于重载可变引用的 <code>*</code> 运算符。</p>
<p>Rust 在发现类型和 trait 实现满足三种情况时会进行解引用强制多态：</p>
<ul>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;T</code> 到 <code>&amp;U</code>。</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code>。</li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;U</code>。</li>
</ul>
<p>前两种情况除了可变性之外是相同的：</p>
<ul>
<li>第一种情况，表明如果有一个 <code>&amp;T</code> ，而 <code>T</code> 实现了返回 <code>U</code> 类型的 <code>Deref</code> ，则可以直接得到<code>&amp;U</code>。</li>
<li>第二种情况表明对于可变引用也有着相同的行为。</li>
<li>第三种情况有些微妙：Rust 也会将可变引用强转为不可变引用。但是反之<strong>不可能</strong>的。<ul>
<li>转换不能打破<strong>借用规则</strong></li>
<li>将不可变引用转换为可变引用则需要数据只能有一个不可变引用，而借用规则无法保证这一点。</li>
</ul>
</li>
</ul>
<h1 id="使用-Drop-Trait-运行清理代码"><a href="#使用-Drop-Trait-运行清理代码" class="headerlink" title="使用 Drop Trait 运行清理代码"></a>使用 <code>Drop</code> Trait 运行清理代码</h1><p><code>Drop</code> trait 允许我们在值要离开作用域时执行一些代码。</p>
<ul>
<li>是对于智能指针模式第二重要的 trait</li>
</ul>
<p>例如，<code>Box&lt;T&gt;</code> 自定义了<code>Drop</code> 用来释放 box 所指向的堆空间。</p>
<p>在 Rust 中，通过实现 <code>Drop</code> trait ，可以指定每当值离开作用域时被执行的代码，编译器会自动插入这些代码。</p>
<ul>
<li>这样系统就不会因为忘记清理或释放资源导致负载过重而崩溃。</li>
</ul>
<blockquote>
<p><strong>注意：</strong>这个特性并不需要为每个类型实现，只有在你的类型需要自己的析构函数（destructor ）逻辑时才需要实现它。</p>
</blockquote>
<p>实现 <code>Drop</code> trait：</p>
<ul>
<li>要实现 <code>drop</code> 方法，它获取一个 <code>self</code> 的可变引用。</li>
</ul>
<p><code>Drop</code> trait 包含在 prelude 中，所以使用时无需导入它。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ToDrop</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">ToDrop</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ToDrop is being dropped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = ToDrop;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Made a ToDrop!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="通过-std-mem-drop-提早丢弃值"><a href="#通过-std-mem-drop-提早丢弃值" class="headerlink" title="通过 std::mem::drop 提早丢弃值"></a>通过 <code>std::mem::drop</code> 提早丢弃值</h3><p><code>Drop</code> 是Rust <strong>自动调用</strong>的，Rust 不允许我们主动调用 <code>Drop</code> trait 的 <code>drop</code> 方法。</p>
<ul>
<li>我们不能禁用当值离开作用域时自动插入的<code>drop</code>，并且不能显示调用<code>drop</code></li>
</ul>
<p>当我们希望在作用域结束之前就强制释放变量的话，应该使用由标准库提供的 <code>std::mem::drop</code>。</p>
<ul>
<li>例如，当使用智能指针管理锁时，你可能希望强制运行<code>drop</code> 方法来释放锁以便作用域中的其他代码可以获取锁；</li>
</ul>
<p> <code>std::mem::drop</code> 也在 prelude 中。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123; data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;some data&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created.&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(c);  <span class="comment">// 这里调用了 std::mem::drop 方法。</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer dropped before the end of main.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Rc-lt-T-gt-引用计数智能指针"><a href="#Rc-lt-T-gt-引用计数智能指针" class="headerlink" title="Rc&lt;T&gt; 引用计数智能指针"></a><code>Rc&lt;T&gt;</code> 引用计数智能指针</h1><p>背景：大部分情况下所有权是非常明确的，可以准确的世道哪个变量拥有某个值。但是，有些情况单个值可能会有多个所有者。例如，图数据结构中，点与边的关系。</p>
<ul>
<li><p>点从概念上讲为所有指向它的边所拥有。节点直到没有任何边指向它之前都不应该被清理；</p>
</li>
<li><p>问题：Rust中所有权规则规定，一个值仅能有一个所有者，这里为什么会说有多个所有者？多个值使用不可以使用引用吗？一个所有权拥有者，其他使用引用。–问题是类似点与边的关系中，编译时无法知道谁最后离开，把所有权给谁？只有在运行时才能知道，最后一个离开后才能清除数据；</p>
<ul>
<li>所以我理解多所有权即谁都有资格拥有它，这样最后一个离开的人只要确定没有多余引用了，就可以将数据清除。</li>
</ul>
</li>
<li><p>例如，看电视，一人打开后，可以多人一起看，当最后一个人离开房间时，他关掉电视因为它不再被使用了。如果某人在其他人还在看的时候就关掉了电视，正在看电视的人肯定会抓狂的！</p>
</li>
</ul>
<p><code>Rc&lt;T&gt;</code> 类型，为<strong>引用计数</strong>（reference counting）的缩写。</p>
<ul>
<li>引用计数意味着通过记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代码没有任何有效引用并可以清理。</li>
</ul>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p><code>Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的<strong>多个部分读取</strong>，但是<strong>无法在编译时确定</strong>程序的哪一个部分会最后结束使用它的时候。</p>
<ul>
<li>如果确定知道哪部分是最后一个结束使用的话，就可以令其成为数据所有者，正常的所有权规则就可以在编译时生效。</li>
<li>多所有权，可以理解为是共享所有权。</li>
<li>涉及生命周期问题</li>
</ul>
<blockquote>
<p>注意，<code>Rc&lt;T&gt;</code> 只能用于<strong>单线程</strong>场景；</p>
<p>多线程有自己的引用计数；</p>
</blockquote>
<p>使用方式：</p>
<ol>
<li><p>创建<code>Rc&lt;T&gt;</code>；</p>
<p><code>Rc::new();</code></p>
</li>
<li><p>增加 Rc 实例的引用计数；每次被其他变量使用时都只用下面这个方法</p>
<p>例如：<code>Rc::clone(&amp;a)</code></p>
</li>
<li><p>查看当前Rc的强引用数</p>
<p><code>Rc::strong_count(&amp;a)</code></p>
</li>
<li><p><code>Rc&lt;T&gt;</code> 在与 <code>RefCell&lt;T&gt;</code>结合使用时，Rust 实现了自动解引用获取其中<code>RefCell&lt;T&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line">*value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 1.首先，Rust 自动解引用，获取了Rc&lt;T&gt; 内部的 RefCell&lt;T&gt;</span></span><br><span class="line"><span class="comment">// 2.然后，RefCell&lt;T&gt; 的 borrow_mut() 返回的是 RefMut&lt;T&gt; ，所以使用 * 解引用运算符后获取数值5</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用-Rc-lt-T-gt-共享数据"><a href="#使用-Rc-lt-T-gt-共享数据" class="headerlink" title="使用 Rc&lt;T&gt; 共享数据"></a>使用 <code>Rc&lt;T&gt;</code> 共享数据</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上的例子中，如果使用 <code>Box&lt;T&gt;</code>，则会报错，因为<code>Box&lt;a&gt;</code> 时会发生所有权的转移，</p>
<p>这里使用 <code>Rc::clone()</code>，只会增加 a 的引用计数；</p>
<blockquote>
<p>Rc::clone() 区别于大部分类型的 <code>clone</code>，</p>
<p>Rc::clone() 只会<strong>增加引用计数</strong>，不会花费多少时间；</p>
<p>而普通的 clone 则是深拷贝，则会花费很长时间；</p>
<p>所以当查找代码中的性能时，只需考虑深拷贝的clone，而无需考虑<code>Rc::clone</code>调用。</p>
</blockquote>
<h2 id="克隆-Rc-lt-T-gt-会增加引用计数"><a href="#克隆-Rc-lt-T-gt-会增加引用计数" class="headerlink" title="克隆 Rc&lt;T&gt; 会增加引用计数"></a>克隆 <code>Rc&lt;T&gt;</code> 会增加引用计数</h2><p><code>Rc&lt;T&gt;</code> 离开作用域时，因为实现了 <code>Drop</code> trait 所以会自动减少引用计数；</p>
<p>当引用计数为0时，会同时清理<code>Rc</code>。</p>
<p>注意：通过不可变引用，<code>Rc&lt;T&gt;</code> 允许在程序的多个部分之间只读地共享数据，</p>
<ul>
<li>如果 <code>Rc&lt;T&gt;</code> 也允许多个可变引用，则会违反借用规则（相同位置的多个可变借用可能造成数据竞争和不一致）。</li>
</ul>
<h1 id="RefCell-与内部可变性模式"><a href="#RefCell-与内部可变性模式" class="headerlink" title="RefCell 与内部可变性模式"></a>RefCell 与内部可变性模式</h1><p><strong>内部可变性</strong>（<em>Interior mutability</em>）是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。为了改变数据，该模式在数据结构中使用 <code>unsafe</code> 代码来模糊 Rust 通常的可变性和借用规则。</p>
<h2 id="通过-RefCell-lt-T-gt-在运行时检查借用规则"><a href="#通过-RefCell-lt-T-gt-在运行时检查借用规则" class="headerlink" title="通过 RefCell&lt;T&gt; 在运行时检查借用规则"></a>通过 <code>RefCell&lt;T&gt;</code> 在运行时检查借用规则</h2><p>对于引用和 <code>Box&lt;T&gt;</code> ，借用规则的不可变性作用于编译时；</p>
<ul>
<li>违反借用规则，得到一个编译错误；</li>
</ul>
<p>对于<code>RefCell&lt;T&gt;</code>，借用规则的不可变性作用于<strong>运行时</strong>。</p>
<ul>
<li>违反则会运行时触发panic并退出；</li>
</ul>
<p>Rust 的编译器是天生保守的，为了保证安全，会拒绝编译器无法理解的代码，无论是否正确。</p>
<p>所以<code>RefCell&lt;T&gt;</code> 适用于，开发者确信代码遵守借用规则，而编译器不能理解和确定的时候。</p>
<h2 id="Box-lt-T-gt-Rc-lt-T-gt-和-RefCell-lt-T-gt-选择依据"><a href="#Box-lt-T-gt-Rc-lt-T-gt-和-RefCell-lt-T-gt-选择依据" class="headerlink" title="Box&lt;T&gt;,Rc&lt;T&gt; 和 RefCell&lt;T&gt; 选择依据"></a><code>Box&lt;T&gt;,Rc&lt;T&gt; 和 RefCell&lt;T&gt;</code> 选择依据</h2><table>
<thead>
<tr>
<th></th>
<th><code>Box&lt;T&gt;</code></th>
<th><code>Rc&lt;T&gt;</code></th>
<th><code>RefCell&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td>所有权</td>
<td>单一所有权</td>
<td>多所有权</td>
<td>单一所有权</td>
</tr>
<tr>
<td>检查时期</td>
<td>编译时</td>
<td>编译时</td>
<td>运行时</td>
</tr>
<tr>
<td>借用可变性</td>
<td>可变或不可变借用</td>
<td>不可变借用</td>
<td>可变或不可变借用</td>
</tr>
</tbody></table>
<h2 id="内部可变性-mock"><a href="#内部可变性-mock" class="headerlink" title="内部可变性 mock"></a>内部可变性 mock</h2><p><strong>测试替身</strong>（test double）是一个通用编程概念，它代表一个在测试中替代某个类型的类型。</p>
<p><strong>mock 对象</strong>是特定类型的测试替身，它们记录测试过程中发生了什么以便可以断言操作是正确的。</p>
<h2 id="RefCell-lt-T-gt-在运行时记录借用"><a href="#RefCell-lt-T-gt-在运行时记录借用" class="headerlink" title="RefCell&lt;T&gt; 在运行时记录借用"></a><code>RefCell&lt;T&gt;</code> 在运行时记录借用</h2><p>当创建不可变和可变引用时，我们分别使用 <code>&amp;</code> 和 <code>&amp;mut</code> 语法。</p>
<p>对于 <code>RefCell&lt;T&gt;</code> 来说，则是 <code>borrow</code> 和 <code>borrow_mut</code> 方法，这属于 <code>RefCell&lt;T&gt;</code> 安全 API 的一部分。</p>
<ul>
<li><code>borrow</code> 方法返回 <code>Ref</code> 类型的智能指针，</li>
<li><code>borrow_mut</code> 方法返回 <code>RefMut</code> 类型的智能指针。</li>
<li>这两个类型都实现了 <code>Deref</code>，所以可以当作常规引用对待。</li>
</ul>
<p><code>RefCell&lt;T&gt;</code> 记录当前有多少个活动的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针。</p>
<p>每次调用 <code>borrow</code>，<code>RefCell&lt;T&gt;</code> 将活动的不可变借用计数加一。当 <code>Ref</code> 值离开作用域时，不可变借用计数减一。</p>
<p>就像<strong>编译时借用规则</strong>一样，<code>RefCell&lt;T&gt;</code> 在任何时候<strong>只允许</strong>有多个不可变借用或一个可变借用。</p>
<h2 id="结合-Rc-lt-T-gt-和-RefCell-lt-T-gt-来拥有多个可变数据所有者"><a href="#结合-Rc-lt-T-gt-和-RefCell-lt-T-gt-来拥有多个可变数据所有者" class="headerlink" title="结合 Rc&lt;T&gt; 和 RefCell&lt;T&gt; 来拥有多个可变数据所有者"></a>结合 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 来拥有多个可变数据所有者</h2><p><code>RefCell&lt;T&gt;</code> 的一个常见用法是<strong>与 <code>Rc&lt;T&gt;</code> 结合</strong>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;  <span class="comment">// 这样就可以得到有多个所有者并且可以修改的值了。</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意，因为 <code>Rc&lt;T&gt;</code> 只存放不可变值，所以一旦创建值后就不能修改。</p>
<p>加入 <code>RefCell&lt;T&gt;</code> 来获得修改其中值的能力。</p>
</blockquote>
<p>注意： <code>Rc&lt;T&gt;</code> 与 <code>RefCell&lt;T&gt;</code> 结合使用时，Rust会自动解引用获取其内部的值</p>
<h1 id="引用循环与内存泄漏是安全的"><a href="#引用循环与内存泄漏是安全的" class="headerlink" title="引用循环与内存泄漏是安全的"></a>引用循环与内存泄漏是安全的</h1><p><strong>内存泄漏</strong>（memory leak）是指永远也不会被清理的内存部分</p>
<p><code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 结合很灵活但是也可以创建出引用循环的可能。</p>
<ul>
<li>这会造成内存泄漏，因为每一项的引用计数永远也到不了0，其值也永远也不会被丢弃。</li>
</ul>
<p><strong>只有</strong>所有权关系才能影响值是否可以被丢弃。</p>
<h2 id="避免引用循环：将Rc-lt-T-gt-变为-Weak-lt-T-gt"><a href="#避免引用循环：将Rc-lt-T-gt-变为-Weak-lt-T-gt" class="headerlink" title="避免引用循环：将Rc&lt;T&gt; 变为 Weak&lt;T&gt;"></a>避免引用循环：将<code>Rc&lt;T&gt;</code> 变为 <code>Weak&lt;T&gt;</code></h2><p><strong>弱引用</strong>（weak reference），无需计数为 0 就能使<code>Rc</code> 实例被清理。</p>
<p>强引用代表如何共享 <code>Rc&lt;T&gt;</code> 实例的所有权，但弱引用并不属于所有权关系。</p>
<ul>
<li>弱引用不会造成引用循环。因为任何弱引用的循环会在其相关的强引用计数为 0 时被打断。</li>
</ul>
<p>如何用 <code>Weak&lt;T&gt;</code> ?</p>
<p>调用<code>Rc::downgrade</code> 时，会得到<code>Weak&lt;T&gt;</code>类型的智能指针，<code>Rc&lt;T&gt;</code> 实例的弱引用计数（weak_count）会加1。</p>
<p>为了使用<code>Weak&lt;T&gt;</code>所指向的值，要保证其值仍然有效。可以调用 <code>Rc::upgrade</code>，会返回<code>Option&lt;Rc&lt;T&gt;&gt;</code> ，如果<code>Rc&lt;T&gt;</code> 的值还未被丢弃，则返回<code>Some</code>；如果已经被丢弃，则返回<code>None</code>。</p>
<ul>
<li>因为返回是<code>Option&lt;T&gt;</code>，Rust 会处理 <code>Some</code> 和 <code>None</code> 的情况，不会返回非法指针。</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>14更多关于Cargo和Crate.io的内容</title>
    <url>//14%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8ECargo%E5%92%8CCrate.io%E7%9A%84%E5%86%85%E5%AE%B9.html</url>
    <content><![CDATA[<ul>
<li>使用发布配置来自定义构建</li>
<li>将库发布到 crates.io</li>
<li>使用工作空间来组织更大的项目</li>
<li>从 crates.io 安装二进制文件</li>
<li>使用自定义的命令来扩展 Cargo</li>
</ul>
<p>更多内容，参考 <a href="https://doc.rust-lang.org/cargo/">Cargo 文档</a></p>
<h1 id="采用发布配置自定义构建"><a href="#采用发布配置自定义构建" class="headerlink" title="采用发布配置自定义构建"></a>采用发布配置自定义构建</h1><p>在 Rust 中 发布配置（release profiles）是预定义的、可定制的带有不同选项的配置</p>
<p>Cargo 有两个主要配置：</p>
<ul>
<li>运行 <code>cargo build</code> 时采用的 <code>dev</code> 配置<ul>
<li>是开发时的默认配置</li>
</ul>
</li>
<li>运行 <code>cargo build --release</code> 的 <code>release</code> 配置<ul>
<li>时发布构建时的默认配置</li>
</ul>
</li>
</ul>
<p>如果需要修改，在 Cargo.toml 文件中添加对应的 <code>[profile.*]</code> 部分</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[profile.dev]</span><br><span class="line">opt-level = <span class="number">0</span>    # opt-level 控制 Rust 对代码进行何种程度的优化，<span class="number">0</span>~<span class="number">3</span>，数值越高优化级别越高，需要的编译时间也越多。</span><br><span class="line"></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = <span class="number">3</span></span><br></pre></td></tr></table></figure>





<h1 id="将-crate-发布到-crates-io"><a href="#将-crate-发布到-crates-io" class="headerlink" title="将 crate 发布到 crates.io"></a>将 crate 发布到 crates.io</h1><h2 id="编写有用的文档注释"><a href="#编写有用的文档注释" class="headerlink" title="编写有用的文档注释"></a>编写有用的文档注释</h2><p><code>///</code> 为 Rust 的文档注释（documentation comments）</p>
<ul>
<li>支持 Markdown 格式；</li>
<li>会生成 HTML 文档，这些文档展示<strong>公有 API</strong> （有 pub 标注的api）的注释部分的内容；</li>
<li>这些文档帮助使用者如何<strong>使用</strong>这个 crate，而不是关注如何实现的。</li>
</ul>
<p>生成：</p>
<ul>
<li><code>cargo doc</code> 命令生成文档，这个命令实际由 Rust 分发的工具 <code>rustdoc</code> 运行并将生成的 HTML 文档放入 <code>target/doc</code> 目录。</li>
<li>使用 <code>cargo doc --open</code> 会构建当前 crate 文档（同时还有所有 crate 依赖的文档）的 HTML 并在浏览器中打开。</li>
</ul>
<h3 id="文档注释作为测试"><a href="#文档注释作为测试" class="headerlink" title="文档注释作为测试"></a>文档注释作为测试</h3><p>文档注释中可添加代码示例，好处：</p>
<ol>
<li>清楚的表明如何使用库的方法；</li>
<li><code>cargo test</code> 也会像测试那样运行文档中的示例代码；<ul>
<li>这样可以避免当代码修改后，注释与代码不匹配的问题。</li>
<li>运行 <code>cargo test</code> ，结果中的 Doc-test 部分就是文档测试部分</li>
</ul>
</li>
</ol>
<h3 id="注释包含项的结构"><a href="#注释包含项的结构" class="headerlink" title="注释包含项的结构"></a>注释包含项的结构</h3><p><code>//!</code> 这中注释风格，通常用于 crate 根文件（通常是 <code>src/lib.rs</code>）或模块的根文件，为 crate 或模块整体提供文档。</p>
<h2 id="使用-pub-use-导出合适的公有-API"><a href="#使用-pub-use-导出合适的公有-API" class="headerlink" title="使用 pub use 导出合适的公有 API"></a>使用 <code>pub use</code> 导出合适的公有 API</h2><p>有时我们项目的结构可能是一个包含多个层级的分层结构，对外公布时，对于使用者来说过多的层级可能不是很方便。</p>
<p>解决：</p>
<p>通过使用 <code>pub use</code> 重导出（re-export）项来调整公有 API 的结构，使对外的公有结构不同于内部结构。</p>
<ul>
<li>重导出获取位于一个位置的公有项并将其公开到另一个位置，好像它就定义在这个新位置一样。</li>
</ul>
<p>问题：如何将原有的内部结构重新导出到顶层结构？语法是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self::&lt;mod名称&gt;::...? 原有内部结构路径？</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注：使用 pub use 重导出公有 API 结构之后，用户仍然可以使用原有的内部结构</p>
</blockquote>
<h2 id="发布新-crate-之前"><a href="#发布新-crate-之前" class="headerlink" title="发布新 crate 之前"></a>发布新 crate 之前</h2><p>通过 <code>cargo publish</code> 命令可以将本地 crate 发布到 crates.io 仓库中。</p>
<p>发布之前，需要修改要对外发布的 crate 的 元信息（在 Cargo.toml 文件中）。</p>
<ul>
<li>crate 在 crates.io 上是唯一的，发布之前需要查询确认，名称遵循先到先得的分配原则。</li>
<li>其他元信息可以通过执行 <code>cargo publish</code> 命令后看编译器报错修改。</li>
<li>可以参考 <a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch14-02-publishing-to-crates-io.html">发布 crate 章节内容</a> 。</li>
</ul>
<h2 id="发布到-crates-io"><a href="#发布到-crates-io" class="headerlink" title="发布到 crates.io"></a>发布到 crates.io</h2><p>注意，发布时需要注意，发布是<strong>永久性的</strong>（permanent）。</p>
<p>对应版本不可能被覆盖，代码不能被删除。</p>
<ul>
<li>主要目的时保证所有项目的依赖都可以正常获取；</li>
</ul>
<h2 id="发布现存-crate-的新版本"><a href="#发布现存-crate-的新版本" class="headerlink" title="发布现存 crate 的新版本"></a>发布现存 crate 的新版本</h2><p>通过修改 Cargo.toml 文件中的 <code>version</code>的值，</p>
<p>然后运行 <code>cargo publish</code>。</p>
<h2 id="从-crates-io-撤回版本"><a href="#从-crates-io-撤回版本" class="headerlink" title="从 crates.io 撤回版本"></a>从 crates.io 撤回版本</h2><p>通过命令 <code>cargo yank --vers &lt;要撤回的版本号&gt;</code></p>
<ul>
<li>注意，撤回并没有删除任何代码。撤回只是新项目不能依赖该版本，原有已经依赖的项目不受影响。</li>
</ul>
<p>撤销撤回操作：</p>
<p><code>cargo yank --vers &lt;之前撤回的版本号&gt; --undo</code></p>
<h1 id="Cargo-工作空间"><a href="#Cargo-工作空间" class="headerlink" title="Cargo 工作空间"></a>Cargo 工作空间</h1><p>随着项目的扩大，希望将原有的库 crate 拆分成多个库 crat。</p>
<p>这种情况使用 Cargo 提供的<strong>工作空间</strong>（workspaces）。</p>
<ul>
<li>它可以帮助我们管理多个相关的系统开发的包；</li>
</ul>
<h2 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h2><p><strong>工作空间</strong> 是一系列共享同样的 Cargo.lock 和输出目录的包。</p>
<p>有很多组织工作空间的方式，需要之后多学习。</p>
<p>先学习最常用的一种方式。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>共有内容：</p>
<ul>
<li>Cargo.lock</li>
<li>target 结果目录</li>
</ul>
<p>工作空间在顶级目录下有一个 target 目录，是所有 crate 共有的，不管在外面还是在子 crate 目录下编译都会将构建结果生成在顶级目录下的 target 目录中。</p>
<ul>
<li>这样避免单独在 crate 中编译生成构建结果导致的重复构建问题；</li>
</ul>
<p>最外层 Carog.toml 文件内容，样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[workspace]</span><br><span class="line"></span><br><span class="line">members = [</span><br><span class="line">    <span class="string">&quot;adder&quot;</span>,</span><br><span class="line">    <span class="string">&quot;add-one&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>目录结构样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── add-one</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── lib.rs</span><br><span class="line">├── adder</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.rs</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>



<h2 id="工作空间中-crate-相互依赖"><a href="#工作空间中-crate-相互依赖" class="headerlink" title="工作空间中 crate 相互依赖"></a>工作空间中 crate 相互依赖</h2><p>cargo 并不假设工作空间中的 crates 会相互依赖，所以需要明确表明工作空间中 crate 的依赖关系。</p>
<ul>
<li>在需要依赖其他库 crate 的 crate 中 Cargo.toml 文件的 <code>[dependencies]</code> 部分添加路径依赖</li>
</ul>
<p>例如：</p>
<p>在上面给出的目录结构中，让 <code>adder</code> 依赖库crate <code>add-one</code>，需要在 <code>adder/Cargo.toml</code>中添加路径依赖</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line"></span><br><span class="line">add-one = &#123; path = <span class="string">&quot;../add-one&quot;</span>&#125;</span><br></pre></td></tr></table></figure>



<p>为了在顶层 <em>add</em> 目录运行二进制 crate，需要通过 <code>-p</code> 参数和包名称来运行 <code>cargo run</code> 指定工作空间中我们希望使用的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run -p adder</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</span><br><span class="line">     Running `target/debug/adder`</span><br><span class="line">Hello, world! 10 plus one is 11!</span><br></pre></td></tr></table></figure>



<h2 id="在工作空间中依赖外部-crate"><a href="#在工作空间中依赖外部-crate" class="headerlink" title="在工作空间中依赖外部 crate"></a>在工作空间中依赖外部 crate</h2><p>工作空间中只在根目录有一个 Cargo.lock 文件，</p>
<ul>
<li>这保证了所有的 crate都使用完全相同版本的依赖。</li>
</ul>
<p><strong>但是</strong>，每个库crate 中依赖的外部 crate仅能在它自己项目中使用，不能在其他crate中使用，除非需要使用该依赖的crate也在它们的 Cargo.toml 文件中添加依赖声明。</p>
<p><strong>解决：</strong></p>
<p>如果工作空间中多个 crate 中需要使用相同的外部crate，那么可以在工作空间的顶级 Cargo.toml 中声明依赖</p>
<h1 id="使用-Cargo-install-从-crates-io安装二进制程序"><a href="#使用-Cargo-install-从-crates-io安装二进制程序" class="headerlink" title="使用 Cargo install 从 crates.io安装二进制程序"></a>使用 Cargo install 从 crates.io安装二进制程序</h1><p><code>cargo install</code> 命令用于在本地安装和使用二进制 crate。</p>
<p>用于开发者们安装 crates.io 上共享的工具。</p>
<p>只有拥有二进制目标文件的crate 能够被安装。</p>
<ul>
<li>二进制目标文件，是在 crate 有 <code>src/main.rs</code> 或者其他指定为二进制文件时所创建的可执行程序。<ul>
<li>库crate 是自身不能执行但适合包含在其他程序中。</li>
</ul>
</li>
</ul>
<h1 id="Cargo-自定义扩展命令"><a href="#Cargo-自定义扩展命令" class="headerlink" title="Cargo 自定义扩展命令"></a>Cargo 自定义扩展命令</h1><p><code>cargo --list</code> 查看所有 cargo 可以使用的本地命令</p>
<h1 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h1><p>当为编写测试引入依赖包时，仅希望该包在测试阶段使用，添加到 <code>Cargo.toml</code> 文件中的 <code>[dev-dependencies]</code> 中</p>
<p>还可以参考如下内容</p>
<p><a href="https://rust-cli.github.io/book/tutorial/packaging.html">Packaging and distributing a Rust tool - Command Line Applications in Rust (rust-cli.github.io)</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>16无畏并发</title>
    <url>//16%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91.html</url>
    <content><![CDATA[<p><strong>并发编程</strong>（Concurrent programming），代表程序的不同部分<strong>相互独立</strong>的执行。</p>
<p><strong>并行编程</strong>（parallel programming），代表程序不同部分<strong>同时</strong>执行。</p>
<p>Rust 利用所有权系统和类型检查，在编译时发现并发错误。</p>
<ul>
<li>如何创建线程来同时运行多段代码。</li>
<li><strong>消息传递</strong>（Message passing）并发，其中通道（channel）被用来在线程间传递消息。</li>
<li><strong>共享状态</strong>（Shared state）并发，其中多个线程可以访问同一片数据。</li>
<li><code>Sync</code> 和 <code>Send</code> trait，将 Rust 的并发保证扩展到用户定义的以及标准库提供的类型中。</li>
</ul>
<h1 id="使用线程同时运行代码"><a href="#使用线程同时运行代码" class="headerlink" title="使用线程同时运行代码"></a>使用线程同时运行代码</h1><p><strong>进程</strong>（process）</p>
<p><strong>线程</strong>（threads）</p>
<p>将程序中的计算拆分为多个线程可以改善性能。不过同时会增加复杂性。</p>
<p>编程语言实现线程的方式：</p>
<ul>
<li><p><code>1:1</code> 模型，一个OS线程对应一个语言线程；</p>
<ul>
<li>编程语言调用操作系统创建新线程的API；</li>
</ul>
</li>
<li><p><code>M:N</code> 模型 ，M个绿色线程，对应 N个OS线程（M和N不必相同）</p>
<ul>
<li><p>编程语言提供了自己特殊的线程实现，这些线程被称为绿色（green）线程；</p>
</li>
<li><p>使用绿色线程的语言会在不同数量的OS线程的上下文中执行它们。</p>
</li>
</ul>
</li>
</ul>
<h2 id="使用-spawn-创建新线程"><a href="#使用-spawn-创建新线程" class="headerlink" title="使用 spawn 创建新线程"></a>使用 <code>spawn</code> 创建新线程</h2><p><code>thread::spawn</code> 函数用于创建新线程，</p>
<ul>
<li>需要传递一个<strong>闭包</strong>作为参数，闭包体是希望在新线程运行的代码</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="使用-join-等待所有线程结束"><a href="#使用-join-等待所有线程结束" class="headerlink" title="使用 join 等待所有线程结束"></a>使用 <code>join</code> 等待所有线程结束</h3><p>默认各个线程单独运行，主线程结束不会等待其他线程运行。</p>
<ul>
<li>可能导致的问题，主线程结束后，其他线程可能没有执行或者没有执行完提早结束。</li>
</ul>
<p>解决：</p>
<p> <code>thread::spawn</code> 的返回值类型是 <code>JoinHandle</code> ，拥有所有权，调用其 <code>join</code> 方法，会<strong>阻塞</strong>（Blocking）当前线程，直到<code>JoinHandle</code>所代表的线程结束。</p>
<ul>
<li><strong>阻塞</strong>（Blocking）线程意味着阻止该线程执行工作或退出。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();   <span class="comment">// 等待线程结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>JoinHandle 类型是泛型的，其参数类型是线程的返回值，</p>
<ul>
<li>如果没有返回值，那么默认就是<code>()</code>，所以就是<code>JoinHandle&lt;()&gt;</code>；</li>
<li>如果有返回值时，就是返回值类型，例如，<code>JoinHandle&lt;i32&gt;</code>；</li>
</ul>
<p>通常在主线程中会调用 <code>joinhandle.join()</code> 方法来阻塞主线程，<code>join()</code> 的返回值是 <code>Result&lt;T&gt;</code>，所以想获得线程返回值，那么可以使用<code>unwrap()</code> 或者处理 Result 类型的其他方法。</p>
<h2 id="线程与-move-闭包"><a href="#线程与-move-闭包" class="headerlink" title="线程与 move 闭包"></a>线程与 <code>move</code> 闭包</h2><p>什么情况下需要使用 <code>move</code>关键字？</p>
<p>线程中的闭包直接使用外部环境值，分为两种情况：</p>
<ol>
<li><p>获取其所有权；</p>
<ul>
<li>没有问题，所有权转移到线程中的闭包里，可以直接使用。</li>
</ul>
</li>
<li><p>借用；</p>
<ul>
<li>有问题，不能直接用；需要添加 <code>move</code>关键字；</li>
<li>线程中的闭包不能直接借用环境值，为什么？<ul>
<li>因为在这种情况下， Rust 无法判断新线程会执行多久，所以无法知晓外部的引用是否一直有效。所以会出现如下报错：<code>may outlive borrowed value v</code></li>
</ul>
</li>
<li>如何正确使用？<ul>
<li>当线程中的闭包需要借用外部环境值时（即使用引用），在闭包前添加 <code>move</code> 关键字，强制将其所有权转移到闭包内。（即转为第1种）</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种情况，闭包内获取环境值所有权，</span></span><br><span class="line"><span class="comment">// ok，直接用</span></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种情况，闭包内借用环境值，</span></span><br><span class="line"><span class="comment">// wrong，不能直接用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">	<span class="comment">// 下面代码会报错的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="comment">// println! 是仅借用vec</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种情况的，正确方式，</span></span><br><span class="line"><span class="comment">// 添加 move</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>





<p><code>move</code> 闭包，经常与 <code>thread::spawn</code> 一起使用</p>
<ul>
<li><p><code>move</code> 关键字，强制闭包获取其使用的环境值的所有权；</p>
</li>
<li><p>最佳使用方式：在创建新线程，将值得所有权从一个线程移到另一个线程；</p>
</li>
</ul>
<h1 id="使用消息传递在线程间传递数据"><a href="#使用消息传递在线程间传递数据" class="headerlink" title="使用消息传递在线程间传递数据"></a>使用消息传递在线程间传递数据</h1><p>消息传递（message passing），线程或actor 通过发送包含数据的消息来相互沟通。</p>
<p><strong>通道</strong>（channel），是 Rust 中实现消息传递并发的主要工具。</p>
<ul>
<li>由两部分组成：<ul>
<li>发送者（transmitter），位于上游位置</li>
<li>接受者（receiver），位于下游位置</li>
</ul>
</li>
<li>代码中的一部分调用发送者的方法以及希望发送的数据，另一部分则检查接收端收到的消息。</li>
<li>当发送者或接受者任一被丢弃时，可以认为通道被关闭（closed）了。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mpsc</code> 是<strong>多个生产者，单个消费者</strong>（multiple producer,single consumer）的缩写。</p>
<ul>
<li><p><code>mpsc::channel</code> 函数可以创建一个新的通道。</p>
<ul>
<li>返回一个元祖，第一个元素是发送端，第二个元素是接收端。</li>
<li>通常，tx 为发送者（transmitter），rx 为接受者（receiver）的缩写。（有历史原因）</li>
</ul>
</li>
<li><p>Rust 标准库实现通道的方式，意味着一个通道可以有多个生产者，但只能有一个消费者。</p>
<ul>
<li>类似于多条小何最终汇聚成大河。</li>
</ul>
</li>
</ul>
<p>发送端的方法：</p>
<ul>
<li><code>send</code> 将数据放入通道，<ul>
<li>返回一个<code>Result&lt;T,E&gt;</code> 类型，如果没有接受者，发送操作会返回错误。</li>
</ul>
</li>
</ul>
<p>接收端的方法：</p>
<ul>
<li><code>recv</code>，（receive 的缩写）<ul>
<li>会阻塞主线程执行，知道从通道中接收一个值；</li>
<li>返回 <code>Result&lt;T,E&gt;</code>，如果通道发送端关闭，则返回一个错误表明不会有新值过来；</li>
</ul>
</li>
<li><code>try_recv</code>，<ul>
<li>不会阻塞，会立刻返回一个 <code>Result&lt;T,E&gt;</code><ul>
<li><code>Ok</code> 值包含可用的信息，</li>
<li><code>Err</code> 值代表此时没有任何信息。</li>
</ul>
</li>
<li>如果线程在等待消息过程中还有其他工作时，使用 <code>try_recv</code>很有用，可以编写一个循环来频繁调用<code>try_recv</code>，在有可用消息时进行处理，其他时候则处理一会儿其他工作知道再次检查。</li>
</ul>
</li>
</ul>
<p><code>mspc::channel</code> 返回的接受者可以被作为迭代器使用在 for 循环中。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"><span class="comment">//--snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="通过克隆发送者来创建多个生产者"><a href="#通过克隆发送者来创建多个生产者" class="headerlink" title="通过克隆发送者来创建多个生产者"></a>通过克隆发送者来创建多个生产者</h2><p>对通道的发送端调用 <code>clone</code> 方法，可以实现克隆通道的发送端来实现多个发送端。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tx1</span> = mpsc::Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br></pre></td></tr></table></figure>



<h2 id="通道和所有权转移"><a href="#通道和所有权转移" class="headerlink" title="通道和所有权转移"></a>通道和所有权转移</h2><p><code>send</code> 函数获取其参数的所有权并移动这个值归接受者所有。</p>
<ul>
<li>这可以防止在发送后再次意外地使用这个值。</li>
</ul>
<h1 id="共享状态并发"><a href="#共享状态并发" class="headerlink" title="共享状态并发"></a>共享状态并发</h1><p>在某种程度上，任何编程语言中的通道都类似于单所有权，即一旦将一个值传送到通道中，将无法再使用这个值。</p>
<p>共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。</p>
<h2 id="互斥器一次只允许一个线程访问数据"><a href="#互斥器一次只允许一个线程访问数据" class="headerlink" title="互斥器一次只允许一个线程访问数据"></a>互斥器一次只允许一个线程访问数据</h2><p><strong>互斥器</strong>（mutex）是 mutual exclusion 的缩写，</p>
<ul>
<li>即任意时刻，其只允许一个线程访问某些数据。</li>
</ul>
<p>如何访问互斥器中的数据？</p>
<ol>
<li>线程通过获取互斥器的<strong>锁</strong>（lock）来表明其希望访问数据；</li>
</ol>
<p><strong>锁</strong>是一个作为互斥器一部分的数据结构，</p>
<ul>
<li>记录谁有数据的排他访问权；</li>
</ul>
<h2 id="Mutex-lt-T-gt-的-API"><a href="#Mutex-lt-T-gt-的-API" class="headerlink" title="Mutex&lt;T&gt; 的 API"></a><code>Mutex&lt;T&gt;</code> 的 API</h2><p><code>Mutex::new</code> 创建 <code>Mutex&lt;T&gt;</code>，即互斥器</p>
<p><code>lock</code> 方法获取锁，以访问互斥器中的数据；</p>
<ul>
<li><p>这个方法调用会阻塞当前线程，知道线程拥有锁为止。</p>
</li>
<li><p>如果拥有锁的线程 panic了，那么其他线程调用 <code>lock</code> 会失败。且没有线程能再获取锁。</p>
</li>
<li><p><code>lock</code> 方法返回一个 <code>MutexGuard</code> 类型的智能指针，所以一旦获取锁，就可以将返回值视为一个引用了。</p>
<ul>
<li><p><code>MutexGuard</code> 实现了 <code>Deref</code> 来指向其内部数据，<code>Drop</code> 实现了当 <code>MutexGuard</code> <strong>离开作用域时自动释放锁</strong>。</p>
<blockquote>
<p>锁自动释放，这个功能使得我们不会忘记释放锁，导致其他线程无法使用互斥器。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>获取锁之后，因为返回值是一个智能指针，所以要使用内部数据，需要使用 <code>*</code>解引用运算符</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);  <span class="comment">// 返回类型为 Mutex&lt;i32&gt;</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();  <span class="comment">// num 的类型为 MutexGuard&lt;i32&gt; 的智能指针</span></span><br><span class="line">        *num = <span class="number">6</span>;   <span class="comment">// * 解引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="在线程间共享-Mutex-lt-T-gt"><a href="#在线程间共享-Mutex-lt-T-gt" class="headerlink" title="在线程间共享 Mutex&lt;T&gt;"></a>在线程间共享 <code>Mutex&lt;T&gt;</code></h2><h3 id="多线程和多所有权"><a href="#多线程和多所有权" class="headerlink" title="多线程和多所有权"></a>多线程和多所有权</h3><p><code>Arc&lt;T&gt;</code> <strong>原子引用计数</strong>（atomically reference counted）</p>
<ul>
<li>类似 <code>Rc&lt;T&gt;</code> ，可以安全的用在并发环境的类型。A 是原子性（atomic）</li>
<li>原子性乐行工作起来类似原始类型，不过可以安全的在线程间共享。</li>
<li>具体查看<code>std::sync::atomic</code>的文档</li>
</ul>
<p>为什么不是所有原始类型都是原子性的？或所有类型都使用 <code>Arc&lt;T&gt;</code>?</p>
<ul>
<li>因为线程安全带有性能惩罚（即消耗多一些），所以只在必要时才做。单线程没有必要</li>
</ul>
<h2 id="RefCell-lt-T-gt-x2F-Rc-lt-T-gt-与-Mutex-lt-T-gt-x2F-Arc-lt-T-gt-的相似性"><a href="#RefCell-lt-T-gt-x2F-Rc-lt-T-gt-与-Mutex-lt-T-gt-x2F-Arc-lt-T-gt-的相似性" class="headerlink" title="RefCell&lt;T&gt;&#x2F;Rc&lt;T&gt; 与 Mutex&lt;T&gt;&#x2F;Arc&lt;T&gt; 的相似性"></a><code>RefCell&lt;T&gt;</code>&#x2F;<code>Rc&lt;T&gt;</code> 与 <code>Mutex&lt;T&gt;</code>&#x2F;<code>Arc&lt;T&gt;</code> 的相似性</h2><p>单线程中，</p>
<p><code>RefCell&lt;T&gt;</code>&#x2F;<code>Rc&lt;T&gt;</code> 组合，可以提供多所有权且可以修改内部可变性，</p>
<p>并发环境中，</p>
<p> <code>Mutex&lt;T&gt;</code>&#x2F;<code>Arc&lt;T&gt;</code>组合也有相同功效，<code>Mutex&lt;T&gt;</code> 提供了内部可变性的功能。</p>
<p>问题：</p>
<p><code>RefCell&lt;T&gt;</code>&#x2F;<code>Rc&lt;T&gt;</code> 组合，可能造成引用循环的风险，</p>
<p><code>Mutex&lt;T&gt;</code> 也有造成死锁（deadlock）的风险，</p>
<ul>
<li>当一个操作需要锁住两个资源，而两个线程各持一个锁，这会造成它们永远相互等待。</li>
<li>查看标准库的<code>Mutex&lt;T&gt;</code> 和 <code>MutexGuard</code> 的 API 文档获取规避死锁的策略。</li>
</ul>
<h1 id="使用-Sync-和-Send-trait-的可扩展并发"><a href="#使用-Sync-和-Send-trait-的可扩展并发" class="headerlink" title="使用 Sync 和 Send trait 的可扩展并发"></a>使用 <code>Sync</code> 和 <code>Send</code> trait 的可扩展并发</h1><p>Rust 语言本身不提供并发相关的基础设施。这章节所提到的所有内容都属于标准库。</p>
<p><code>std::marker</code> 中的 <code>Sync</code> 和 <code>Send</code> trait 是内嵌于语言中的两个并发概念。</p>
<h2 id="通过-Send-允许在线程间转移所有权"><a href="#通过-Send-允许在线程间转移所有权" class="headerlink" title="通过 Send 允许在线程间转移所有权"></a>通过 <code>Send</code> 允许在线程间转移所有权</h2><p><code>Send</code> trait 表明类型的<strong>所有权可以在线程间传递</strong>。</p>
<p>几乎所有的 Rust 类型都是 <code>Send</code> 的，</p>
<ul>
<li><p>目前学到的<code>Rc&lt;T&gt;</code>不是，这个不能<code>Send</code>，因为如果克隆了<code>Rc&lt;T&gt;</code> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程可能同时更新引用计数。</p>
</li>
<li><p>裸指针（raw pointer） 除外，裸指针也不是<code>Send</code>的。</p>
</li>
</ul>
<p>任何完全由 <code>Send</code> 的类型组成的类型也会<strong>自动</strong>被标记为 <code>Send</code>。</p>
<h2 id="Sync-允许多线程访问"><a href="#Sync-允许多线程访问" class="headerlink" title="Sync 允许多线程访问"></a><code>Sync</code> 允许多线程访问</h2><p><code>Sync</code> trait 表明一个实现了<code>Sync</code> 的类型可以安全的在多个线程中拥有其值的引用（传递引用）。</p>
<ul>
<li>对于任意类型<code>T</code>，如果<code>&amp;T</code>（<code>T</code>的引用）是<code>Send</code>的话，<code>T</code>就是 <code>Sync</code>的，这意味着其引用就可以安全的发送到另一个线程。</li>
<li>类似于 <code>Send</code>，基本类型都是<code>Sync</code>的，</li>
<li>完全由<code>Sync</code>的类型组成的类型也是<code>Sync</code>的，</li>
<li><code>Mutex&lt;T&gt;</code> 是 <code>Sync</code> 的</li>
</ul>
<p><strong>目前已学不是<code>Sync</code>的类型：</strong></p>
<ul>
<li><p><code>Rc&lt;T&gt;</code> 也不是 <code>Sync</code> 的，理由与不是 <code>Send</code>相同。</p>
</li>
<li><p><code>RefCell&lt;T&gt;</code> 和 <code>Cell&lt;T&gt;</code> 系列类型都不是 <code>Sync</code>的。</p>
<ul>
<li><code>RefCell&lt;T&gt;</code> 在运行时所进行的借用检查也不是线程安全的。</li>
</ul>
</li>
</ul>
<h2 id="手动实现Send-和Sync-是不安全的"><a href="#手动实现Send-和Sync-是不安全的" class="headerlink" title="手动实现Send 和Sync 是不安全的"></a>手动实现<code>Send</code> 和<code>Sync</code> 是不安全的</h2><p>通常不需要手动实现<code>Send</code> 和 <code>Sync</code> trait，因为由<code>Send</code> 和 <code>Sync</code> 的类型组成的类型，自动就是 <code>Send</code> 和<code>Sync</code>的。</p>
<p>它们都是标记 trait，不需要实现任何方法，只是用来加强并发相关的不可变性的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为 Rust 本身很少有处理并发的部分内容，有很多的并发方案都由 crate 实现。他们比标准库要发展的更快；请在网上搜索当前最新的用于多线程场景的 crate。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>17Rust的面向对象编程特性</title>
    <url>//17Rust%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7.html</url>
    <content><![CDATA[<p>面向对象编程（Object-Oriented Programming, OOP）是一种模式化编程方式。</p>
<h1 id="面向对象语言的特性"><a href="#面向对象语言的特性" class="headerlink" title="面向对象语言的特性"></a>面向对象语言的特性</h1><p>面向对象编程语言共享的特性：</p>
<p>对象、封装、继承</p>
<h2 id="对象包含数据和行为"><a href="#对象包含数据和行为" class="headerlink" title="对象包含数据和行为"></a>对象包含数据和行为</h2><p>参考 Gang of Four 中对象的定义：</p>
<ul>
<li>面向对象的程序是由对象组成的。一个 <strong>对象</strong> 包含数据和操作这些数据的过程。这些过程通常被称为 <strong>方法</strong> 或 <strong>操作</strong>。</li>
<li>Rust 中的 结构体和枚举满足</li>
</ul>
<p><strong>封装</strong>（<em>encapsulation</em>）的思想：对象的实现细节不能被使用对象的代码获取到。所以唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。封装使得改变和重构对象的内部时无需改变使用对象的代码。</p>
<ul>
<li>Rust 中不同部分使用<code>pub</code> 与否可以封装其实现细节。</li>
</ul>
<p>Rust 中没有继承，</p>
<p>Rust 使用 trait 对象来实现<strong>多态</strong>。</p>
<h1 id="为使用不同类型的值而设计的-trait-对象"><a href="#为使用不同类型的值而设计的-trait-对象" class="headerlink" title="为使用不同类型的值而设计的 trait 对象"></a>为使用不同类型的值而设计的 trait 对象</h1><p>图形用户接口（Graphical User Interface， GUI）</p>
<h2 id="定义通用行为的-trait"><a href="#定义通用行为的-trait" class="headerlink" title="定义通用行为的 trait"></a>定义通用行为的 trait</h2><p><strong>trait 对象</strong>（trait object）指向一个实现了指定 trait 的类型的实例，以及一个用于在运行时查找给类型的 trait 方法的表。</p>
<p>如何创建？</p>
<p>通过指定某种指针来创建 trait 对象，</p>
<ul>
<li>例如，<code>&amp;</code>引用，或 <code>Box&lt;T&gt;</code> 智能指针，还有<code>dyn</code> 关键字，以及指定相关的 trait。<ul>
<li>第十九章 <a href="https://kaisery.gitbooks.io/trpl-zh-cn/content/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">““动态大小类型和 <code>Sized</code> trait”</a> 部分会介绍 trait 对象必须使用指针的原因</li>
</ul>
</li>
</ul>
<p>trait 对象</p>
<p><code>Box&lt;dyn TRAIT类型&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="comment">// 这里便是一个 trait 对象</span></span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们可以使用 trait对象代替泛型或具体类型。</p>
<ul>
<li>任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象中指定的 trait。如此便<strong>无需在编译时</strong>就知晓所有可能的类型。</li>
</ul>
<p>trait 对象的具体作用是：</p>
<ul>
<li>允许对通用<strong>行为</strong>进行抽象；</li>
<li>与一般意义上的对象不同，trait对象不允许添加数据；只是行为的抽象。</li>
</ul>
<p>使用 trait 对象的优势：</p>
<ul>
<li>无需在运行时检查一个值是否实现了特定方法或担心在调用时因为值没有实现方式而产生错误。<ul>
<li>Rust 编译器会检查值是否实现了 trait对象所需要的trait。</li>
</ul>
</li>
</ul>
<h3 id="trait-对象-与-泛型-trait-bound-的不同"><a href="#trait-对象-与-泛型-trait-bound-的不同" class="headerlink" title="trait 对象 与 泛型+trait bound 的不同"></a>trait 对象 与 泛型+trait bound 的不同</h3><p>泛型+trait bound 的组合，适用于只需要同质（相同类型）的集合，一次实例只能是一种类型，在编译时采用具体类型，进行<strong>单态化</strong>。</p>
<ul>
<li>没有运行时性能开销</li>
</ul>
<p>trait 对象，则可以包含多种实现了指定 trait 的类型，是一种<strong>多态化</strong>的手段。</p>
<ul>
<li>有运行时性能开销</li>
</ul>
<h2 id="trait-对象执行动态分发"><a href="#trait-对象执行动态分发" class="headerlink" title="trait 对象执行动态分发"></a>trait 对象执行动态分发</h2><p>Rust 实现泛型时，使用了单态化，即在编译时将使用了泛型类型参数的地方替换为了具体类型，</p>
<ul>
<li>单态化所产生的代码进行<strong>静态分发</strong>（static dispatch）。</li>
</ul>
<p><strong>静态分发</strong>（static dispatch），发生于编译器在<strong>编译时就知晓</strong>调用了什么方法的时候。</p>
<p><strong>动态分发</strong>（dynamic dispatch），编译器在编译时无法知晓调用了什么方法，而是在<strong>运行时确定</strong>调用了什么方法的代码。</p>
<p>使用 trait 对象时，Rust 必须使用动态分发。</p>
<ul>
<li>编译器无法知晓所有可能用于 trait 对象代码的类型，所以也就不知道应该调用哪个类型的哪个方法实现。</li>
<li>同时动态分发也会阻止编译器有选择的内联方法代码，这会相应的禁用一些优化。</li>
<li>优点就是编写代码更加灵活。</li>
<li>所以需要在灵活性与性能上做权衡。</li>
</ul>
<h2 id="trait-对象要求对象安全"><a href="#trait-对象要求对象安全" class="headerlink" title="trait 对象要求对象安全"></a>trait 对象要求对象安全</h2><p>只有 <strong>对象安全</strong>（<em>object safe</em>）的 trait 才可以组成 trait 对象。</p>
<p>如果一个 trait 中<strong>所有的方法</strong>有如下属性时，则该 trait 是对象安全的：</p>
<ul>
<li>返回值类型不为 <code>Self</code>；<ul>
<li>注意，<code>&amp;self</code> 和 <code>&amp;mut self</code> 是可以的，只有 <code>Self</code> 是不可以的。</li>
</ul>
</li>
<li>方法没有任何泛型类型参数（generic type parameter）；</li>
</ul>
<p><code>Self</code> 关键字是我们要实现的 trait 或方法的<strong>类型别名</strong>。</p>
<blockquote>
<p>对象安全对于 trait object 是必须的，因为一旦有了 trait 对象，就不再知晓实现该 trait 的具体类型是什么了。</p>
<p>如果 trait 方法返回具体的 <code>Self</code> 类型，但是 trait 对象忘记了其真正的类型，那么方法不可能使用已经忘却的原始具体类型。</p>
<p>同理对于泛型类型参数来说，当使用 trait 时其会放入具体的类型参数：此具体类型变成了实现该 trait 的类型的一部分。当使用 trait 对象时其具体类型被抹去了，故无从得知放入泛型参数类型的类型是什么。</p>
</blockquote>
<p>下面这个标准库中的 <code>Clone</code> trait 不是对象安全的，因为其 <code>clone</code>方法的方法返回值是 <code>Self</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Clone</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code> 实现了 <code>Clone</code> trait，当在 <code>String</code> 实例上调用 <code>clone</code> 方法时会得到一个 <code>String</code> 实例。类似的，当调用 <code>Vec&lt;T&gt;</code> 实例的 <code>clone</code> 方法会得到一个 <code>Vec&lt;T&gt;</code> 实例。</p>
<p><code>clone</code> 的签名需要知道什么类型会代替 <code>Self</code>，因为这是它的返回值。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的 trait 因为 foo 的返回值为 Self，所以 Trait 无法创建 trait对象</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Trait</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foo</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="comment">// more functions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当 trait 中只有一些方法不是对象安全的，可以通过给该方法添加 <code>where Self: Sized</code> 约束。将其标记为对 trait object（trait 对象）不可用的形式，让该 trait 依然可以生产 trait object。</p>
<p>同时被标记的方法依然除了不能在 trait object 中使用，依然可以在该 trait 的其他 impl 实现中使用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Trait</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foo</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line">    <span class="comment">// more functions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foo()不能再被trait对象调用了，但是现在可以创建一个trait对象，并且可以调用任何对象安全的方法。</p>
<h1 id="面向对象设计模式的实现"><a href="#面向对象设计模式的实现" class="headerlink" title="面向对象设计模式的实现"></a>面向对象设计模式的实现</h1><p><strong>状态模式</strong>（state pattern）是一个面向对象的设计模式。</p>
<ul>
<li>该模式的关键在于一个值有某些内部状态，体现为一系列的<strong>状态对象</strong>，同时值的行为随着其内部状态而改变。</li>
<li>状态对象，是共享功能的（有相同的功能&#x2F;方法）<ul>
<li>在 Rust 中通过结构体（struct）和 trait 来实现，其他语言比如Java 可能通过对象和继承（或面向接口编程）来实现。</li>
</ul>
</li>
<li>每个状态对象对其自己的行为负责，并在应该转换为另一个状态时负责管理。</li>
<li>保存状态对象的值不知道状态的不同行为，也不知道何时在状态之间转换。<ul>
<li>这里或许表示为，保存状态对象的值不关心，或无感知状态的不同行为和状态间转换。</li>
</ul>
</li>
<li>当程序业务需求改变时，只需要更新某个状态对象内的代码来更改它的规则或者添加更多的状态对象即可。</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>18模式和匹配</title>
    <url>//18%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8C%B9%E9%85%8D.html</url>
    <content><![CDATA[<p>模式（pattern）是 Rust 中特殊的语法，它用来匹配类型中的结构，无论类型是简单还是复杂。</p>
<p>可以提供更多对程序控制流的支配权。</p>
<p>模式（pattern）由如下一些内容组合而成：</p>
<ul>
<li>字面值</li>
<li>解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
<p>这些部分描述了我们要处理的数据的形状，接着将一些值与模式相比较，如果数据符合这个形状，就可以进行相应的处理，如果不符合，与该模式相关的代码则不会运行。</p>
<p>本章涉及</p>
<ul>
<li>所有可能使用模式的位置</li>
<li>可反驳（refutable） 与不可反驳 （irrefutable） 模式的区别</li>
<li>不同类型的模式语法</li>
</ul>
<h1 id="所有可能会用到模式的位置"><a href="#所有可能会用到模式的位置" class="headerlink" title="所有可能会用到模式的位置"></a>所有可能会用到模式的位置</h1><h2 id="match-分支"><a href="#match-分支" class="headerlink" title="match 分支"></a><code>match</code> 分支</h2><p><code>match</code> 表达式的分支是模式常用的位置，</p>
<p>形式上，<code>match</code>表达式由以下几部分构成：</p>
<ul>
<li><code>match</code>关键字，</li>
<li>用于匹配的值，</li>
<li>一个或多个分支，<ul>
<li>一个模式</li>
<li>表达式（在值匹配分支的模式时运行的表达式）</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> VALUE &#123;</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>match</code>表达式必须是<strong>穷尽的</strong>（exhaustive），即所有可能的值都必须被考虑到。</p>
<p>确保覆盖每个可能的方式是在最后一个分支使用捕获所有的模式</p>
<ul>
<li>即可以使用一个匹配任何值的命名变量，因为是无可反驳模式所以可以覆盖剩下所有的情况。</li>
</ul>
<p>有一个特定的模式,<code>_</code> 也可以匹配所有的情况，不过它从不绑定任何变量。</p>
<ul>
<li>如果希望忽略任何未指定值得情况，使用 <code>_</code> 很有用。</li>
<li>会在**[忽略模式中的值](# 忽略模式中的值)** 部分详细介绍<code>_</code> 模式内容。</li>
</ul>
<h2 id="if-let-条件表达式"><a href="#if-let-条件表达式" class="headerlink" title="if let 条件表达式"></a><code>if let</code> 条件表达式</h2><p><code>if let</code> 是只关心一种情况的 <code>match</code> 表达式的简写。</p>
<p><strong>优点：</strong></p>
<p><code>if let</code> 表达式可以组合匹配 <code>else if, else if let , else</code> 等分支表达式，更灵活。</p>
<p><strong>缺点：</strong></p>
<p><code>if let</code> 表达式的缺点在于其穷尽性没有被编译器检查，而<code>match</code> 表达式则检查了。</p>
<h2 id="while-let-条件循环"><a href="#while-let-条件循环" class="headerlink" title="while let 条件循环"></a><code>while let</code> 条件循环</h2><p><code>while let</code> 是一个与 <code>if let</code> 结构类似的条件循环。</p>
<ul>
<li>其实与 while 与 if 的性质一样。</li>
</ul>
<p>它允许只要模式能匹配就一直进行 <code>while</code> 循环。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h2><p><code>for</code> 循环也可以获取一个模式。</p>
<p>在 <code>for</code> 循环中，模式是<code>for</code> 关键字直接跟随的值，</p>
<ul>
<li>例如，<code>for x in y</code> 中的 <code>x</code>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// (index,value) 就是一个模式，</span></span><br><span class="line"><span class="comment">// 这里for循环中使用模式来解构元组</span></span><br><span class="line"><span class="title function_ invoke__">for</span> (index, value) <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>, value, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="let-语句"><a href="#let-语句" class="headerlink" title="let 语句"></a><code>let</code> 语句</h2><p><code>let</code>语句更为正式的样子如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">let PATTERN = EXPRESSION;</span><br></pre></td></tr></table></figure>



<p>例如，<code>let x = 5;</code>，这里 <code>x</code> 位于 <code>pattern</code>位置，变量名是形式特别朴素的模式。</p>
<p>我们将表达式与模式比较，并<strong>将匹配到的任何值绑定到变量<code>x</code></strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y, z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这里将一个元组与模式匹配。Rust 会比较值 <code>(1, 2, 3)</code> 与模式 <code>(x, y, z)</code> 并发现此值匹配这个模式。将会把 <code>1</code> 绑定到 <code>x</code>，<code>2</code> 绑定到 <code>y</code> 并将 <code>3</code> 绑定到 <code>z</code>。</p>
<p><strong>注意：</strong></p>
<p>如果模式中元素的<strong>数量不匹配</strong>元组中元素的数量，则整个类型不匹配，并会得到一个编译时错误。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在函数中，函数参数变量名也是一个模式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>x</code>部分就是一个模式，类似于<code>let</code>语句。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里 &amp;(x,y) 就是一个模式，</span></span><br><span class="line"><span class="comment">// 值 &amp;(3,5) 会匹配模式 &amp;(x,y),这样x=3，y=5</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_coordinates</span>(&amp;(x, y): &amp;(<span class="type">i32</span>, <span class="type">i32</span>)) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Current location: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = (<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_coordinates</span>(&amp;point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Refutability（可反驳性）：模式是否会匹配失败"><a href="#Refutability（可反驳性）：模式是否会匹配失败" class="headerlink" title="Refutability（可反驳性）：模式是否会匹配失败"></a>Refutability（可反驳性）：模式是否会匹配失败</h1><p>模式由两种形式：</p>
<ul>
<li>refutable（可反驳的）<ul>
<li>对某些可能的值进行匹配会失败的模式，被称为可反驳的（refutable）。</li>
<li>例如：<code>if let Some(x) = a_value</code>，表达式中的<code>Some(x)</code>，如果a_value中的值是 <code>None</code>而不是<code>Some</code>,那么<code>Some(x)</code> 模式不能匹配，匹配失败。</li>
</ul>
</li>
<li>irrefutable（不可反驳的）<ul>
<li>能<strong>匹配任何</strong>传递的可能的值得模式，被称为<strong>不可反驳的</strong>（irrefutable）。</li>
<li>例如：<code>let x = 5;</code>，语句中的<code>x</code>可以匹配任何值所以不可能会失败。</li>
</ul>
</li>
</ul>
<p>函数参数、<code>let</code>语句和<code>for</code>循环<strong>只能</strong>接受不可反驳的模式。</p>
<ul>
<li>因为如果值不匹配，程序执行是无意义的。</li>
<li>在只接受不可反驳模式的地方使用可反驳模式，编译器在编译时会报错</li>
</ul>
<p><code>if let</code>和<code>while let</code>表达式被编译器<strong>限制</strong>为只能接受可反驳的模式。</p>
<ul>
<li>因为这条件表达式的功能就是，根据成功或失败执行不同的操作。<ul>
<li>设计上就允许匹配失败，一定成功的情况就没有必要使用条件表达式了。</li>
</ul>
</li>
<li>如果使用不可反驳的模式，编译器会给出一个警告（warning）</li>
</ul>
<blockquote>
<p>通常我们无需担心可反驳和不可反驳模式的区别，不过确实需要熟悉可反驳性的概念，这样当在错误信息中看到时就知道如何应对。遇到这些情况，根据代码行为的意图，需要修改模式或者使用模式的结构。</p>
</blockquote>
<h1 id="所有的模式语法"><a href="#所有的模式语法" class="headerlink" title="所有的模式语法"></a>所有的模式语法</h1><p>会列出所有在模式中有效的语法，并阐述你为什么可能会希望使用其中的每一个语法。</p>
<h2 id="匹配字面值"><a href="#匹配字面值" class="headerlink" title="匹配字面值"></a>匹配字面值</h2><p>可以直接匹配字面值模式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;two&quot;</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h2><p>命名变量是可以匹配任何值的不可反驳的模式。</p>
<p>在<code>let</code>语句和<code>match</code>表达式中使用过多次。</p>
<p>不过在<code>match</code>表达式中使用时当出现与外部同名变量时，与普通变量一样，在作用域内会发生覆盖，（要避免这一问题就不要在模式中尤其是Some(T)中定义新变量，还可以参考[match guard部分内容](# 匹配守卫提供的额外条件)）</p>
<ul>
<li><code>match</code> 表达式中作为模式的一部分声明的变量，会覆盖 <code>match</code> 结构之外的同名变量，直到离开<code>match</code>表达式的作用域，外部同名变量才恢复为被覆盖之前的值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;  <span class="comment">// 外部变量y</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="comment">// 模式引入了一个新变量y,它会匹配任何Some中的值，</span></span><br><span class="line">        <span class="comment">// 同时这个y是在match表示的作用域内定义的，所以当离开此作用域该y就失效了。</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的y还是开头定义的y=10</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="多个模式"><a href="#多个模式" class="headerlink" title="多个模式"></a>多个模式</h2><p>在 <code>match</code> 表达式中，可以使用 <code>|</code> 语法匹配多个模式，它代表 <strong>或</strong>（<em>or</em>）的意思。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),  <span class="comment">// 匹配此分支的任一个值就会运行</span></span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="通过-匹配值的范围"><a href="#通过-匹配值的范围" class="headerlink" title="通过 ..= 匹配值的范围"></a>通过 <code>..=</code> 匹配值的范围</h2><p><code>..=</code> 语法允许你匹配一个<strong>闭区间</strong>范围内的值。</p>
<ul>
<li>范围<strong>只允许</strong>用于<strong>数字</strong>或 <strong><code>char</code> 值</strong>，<ul>
<li><code>char</code> 值和数字是 Rust <strong>仅有的</strong>可以判断范围是否为空的类型。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字的例子</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="comment">// 当模式匹配任何在此范围内的值时(1,2,3,4,5)，该分支会执行</span></span><br><span class="line">    <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one through five&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// char 值得例子</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;j&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;early ASCII letter&quot;</span>),</span><br><span class="line">    <span class="string">&#x27;k&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;late ASCII letter&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解构并分解值"><a href="#解构并分解值" class="headerlink" title="解构并分解值"></a>解构并分解值</h2><p>可以使用模式来解构结构体、枚举、元组和引用，以便使用这些值的不同部分。</p>
<h3 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h3><p>解构一个结构体时，模式中的变量名不必与结构体中的字段名一致。</p>
<ul>
<li>不过通常使用简写，即变量名与字段名一致时的省略写法。<ul>
<li>只列出结构体<strong>字段</strong>的名称</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">或者直接使用简写语法</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123; x, y &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也可以使用<strong>字面值</strong>作为结构体模式的一部分进行解构。</p>
<ul>
<li>即把部分字段设置为固定的值，解析并匹配部分值确定的情况。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        <span class="comment">// 匹配在x轴上的点</span></span><br><span class="line">        Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>, x),</span><br><span class="line">		<span class="comment">// 匹配在y轴上的点</span></span><br><span class="line">        Point &#123; x: <span class="number">0</span>, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>, y),</span><br><span class="line">        <span class="comment">// 匹配任意点</span></span><br><span class="line">        Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的p会匹配第二个分支</span></span><br></pre></td></tr></table></figure>



<h3 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a>解构枚举</h3><p><strong>重要</strong>：解构枚举的模式应该与枚举<em>定义中存储数据的方式相对应。</em></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure.&quot;</span>),</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>, x, y)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Text message: &#123;&#125;&quot;</span>, text),</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r,g,b) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>, r,g,b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举"></a>解构嵌套的结构体和枚举</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">   <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">   <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),  <span class="comment">// 嵌套使用了枚举</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        <span class="comment">// match 需要穷举，所以这里关注的两个也需要全部列举</span></span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,r,g,b)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;&quot;</span>,h,s,v)</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解构结构体和元组"><a href="#解构结构体和元组" class="headerlink" title="解构结构体和元组"></a>解构结构体和元组</h3><p>也可以用复杂的方式来混合、匹配和嵌套解构模式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ((feet, inches), Point &#123;x, y&#125;) = ((<span class="number">3</span>, <span class="number">10</span>), Point &#123; x: <span class="number">3</span>, y: -<span class="number">10</span> &#125;);</span><br></pre></td></tr></table></figure>



<h2 id="忽略模式中的值"><a href="#忽略模式中的值" class="headerlink" title="忽略模式中的值"></a>忽略模式中的值</h2><h3 id="使用-忽略整个值"><a href="#使用-忽略整个值" class="headerlink" title="使用_忽略整个值"></a>使用<code>_</code>忽略<em>整个值</em></h3><p>下划线（<code>_</code>）可以作为<strong>匹配但不绑定</strong>任何值的通配符模式</p>
<p>同时可以在函数参数中使用，当某个参数暂时不需要实现时或不需要关心时。</p>
<ul>
<li>此时<strong>编译器就不会警告</strong>说存在未使用的函数参数了。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(_: <span class="type">i32</span>, y: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This code only uses the y parameter: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用嵌套的-忽略部分值"><a href="#使用嵌套的-忽略部分值" class="headerlink" title="使用嵌套的_忽略部分值"></a>使用嵌套的<code>_</code>忽略<em>部分值</em></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">match</span> (setting_value, new_setting_value) &#123;</span><br><span class="line">    <span class="comment">// 这里不关心具体值是什么，只关心是否有值</span></span><br><span class="line">    (<span class="title function_ invoke__">Some</span>(_), <span class="title function_ invoke__">Some</span>(_)) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Can&#x27;t overwrite an existing customized value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里是匹配剩下的情况</span></span><br><span class="line">    _ =&gt; &#123;</span><br><span class="line">        setting_value = new_setting_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;setting is &#123;:?&#125;&quot;</span>, setting_value);</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> numbers &#123;</span><br><span class="line">    <span class="comment">// 这里是忽略部分值</span></span><br><span class="line">    (first, _, third, _, fifth) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, first, third, fifth)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过在名字前以一个下划线开头来忽略未使用的变量"><a href="#通过在名字前以一个下划线开头来忽略未使用的变量" class="headerlink" title="通过在名字前以一个下划线开头来忽略未使用的变量"></a>通过在名字前以一个下划线开头来忽略<em>未使用的变量</em></h3><p>可以用下划线作为变量名的开头，希望告诉 Rust <strong>不要警告未使用的变量</strong>。否则创建了变量却没有任何地方使用，Rust 会在编译时给一个警告。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>, 只使用 <code>_</code> 和使用以下划线开头的名称有些微妙的不同：</p>
<ul>
<li>比如 <code>_x</code> 仍<strong>会将值绑定到变量</strong>，而 <code>_</code> 则完全<strong>不会绑定</strong>。</li>
<li>以下划线开头的未使用变量仍然会绑定值，它可能会获取值的所有权。</li>
<li>只使用下划线本身，并不会绑定值，也不会获取所有权。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(_s) = s &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;found a string&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure>



<h3 id="用-忽略剩余值"><a href="#用-忽略剩余值" class="headerlink" title="用 .. 忽略剩余值"></a>用 <code>..</code> 忽略剩余值</h3><p>对于有多个部分的值，可以使用 <code>..</code> 语法来只使用部分并忽略其它值，同时避免不得不每一个忽略值列出下划线。</p>
<ul>
<li>但是要明确，不能有歧义，否则会报错。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">    z: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">--正常</span><br><span class="line"><span class="keyword">match</span> origin &#123;</span><br><span class="line">    <span class="comment">// 这里只关心x，忽略y和z，所以可以使用 .. 代替使用两个_</span></span><br><span class="line">    Point &#123; x, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--正常</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        <span class="comment">// 这个匹配第一个和最后一个</span></span><br><span class="line">        (first, .., last) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;</span>, first, last);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--会报错</span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        <span class="comment">// 会报错，Rust 不知道哪一个是second</span></span><br><span class="line">        (.., second, ..) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;&quot;</span>, second)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="匹配守卫提供的额外条件"><a href="#匹配守卫提供的额外条件" class="headerlink" title="匹配守卫提供的额外条件"></a>匹配守卫提供的额外条件</h2><p><strong>匹配守卫</strong>（<em>match guard</em>）是一个指定于 <code>match</code> 分支模式之后的<strong>额外 <code>if</code> 条件</strong>，它也<strong>必须被满足</strong>才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="comment">// 这里除了Some(x)要满足，x&lt;5也要满足</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;less than five: &#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">    <span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用匹配守卫的情况下，可以在 <code>if</code> 条件中使用外部变量</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="comment">// 这里新定义了一个变量n，然后用n与外部y相比较</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) <span class="keyword">if</span> n == y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, n = &#123;&#125;&quot;</span>, n),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end: x = &#123;:?&#125;, y = &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也可以在匹配守卫中使用 <strong>或</strong> 运算符 <code>|</code> 来指定多个模式，同时匹配守卫的条件<strong>会作用于所有</strong>的模式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="comment">// (4 | 5 | 6) if y =&gt; ... 相等</span></span><br><span class="line">    <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> <span class="keyword">if</span> y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;yes&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;no&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不满足因为y=false，所以会匹配到第二个分支no</span></span><br></pre></td></tr></table></figure>



<h2 id="绑定"><a href="#绑定" class="headerlink" title="@ 绑定"></a><code>@</code> 绑定</h2><p><em>at</em> 运算符（<code>@</code>）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。</p>
<ul>
<li>语法：<code>新变量 @ 条件</code></li>
<li>使用场景：当我们使用 match 时，匹配的条件是一个范围 <code>1..100</code>,此时如果不绑定一个变量无法在右边语句中使用匹配中的值；看样例。</li>
<li>这个语法需要定义一个新变量，（可以与原有字段一样，但是不能省略）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    <span class="comment">// 这里的 id_variable 可以定义为 id,但是因为用来 @符号，所以不能省略</span></span><br><span class="line">    Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这里没有将字段id绑定到新变量，仅是给id限制一个范围，所以表达式中不能使用id</span></span><br><span class="line">    Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这里是id:id 的简写，所以可以匹配任何值</span></span><br><span class="line">    Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否位于 <code>3...7</code> 范围内，同时也希望能将其值绑定到 <code>id_variable</code> 变量中以便此分支相关联的代码可以使用它。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>19高级特性</title>
    <url>//19%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.html</url>
    <content><![CDATA[<p>本章将要学习的功能在一些非常特定的场景下很有用处。虽然很少会碰到它们，你可以将本章作为不经意间遇到未知的内容时的参考。</p>
<p>本章将涉及如下内容：</p>
<ul>
<li>不安全 Rust：用于当需要舍弃 Rust 的某些保证并负责手动维持这些保证</li>
<li>高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法（fully qualified syntax），超（父）trait（supertraits）和 newtype 模式</li>
<li>高级类型：关于 newtype 模式的更多内容，类型别名，never 类型和动态大小类型</li>
<li>高级函数和闭包：函数指针和返回闭包</li>
<li>宏：定义在编译时定义更多更多代码的方式</li>
</ul>
<h1 id="不安全-Rust"><a href="#不安全-Rust" class="headerlink" title="不安全 Rust"></a>不安全 Rust</h1><p>不安全 Rust（unsafe Rust），不会强制执行内存安全保证，其他部分于常规 Rust 代码无异。</p>
<p>存在的原因：</p>
<ol>
<li>因为静态分析本质上是保守的，编译器可能会拒绝一段其无法理解的程序，但是当你确定这是没有问题的，可以放到不安全代码块中；</li>
<li>底层计算机硬件固有的不安全性，Rust 允许直接与操作系统交互或者编写底层系统。</li>
</ol>
<p>有五类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作，被称为“不安全的超能力”：</p>
<ul>
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
<li>访问 <code>union</code> 的字段</li>
</ul>
<p><strong>重要：</strong></p>
<p><code>unsafe</code> 并不会关闭借用检查器或禁用任何其他 Rust 安全检查</p>
<ul>
<li>如果在不安全代码中使用引用，它仍会被检查。</li>
</ul>
<p><code>unsafe</code> 关键字只是提供了那<strong>五个不会被编译器检查内存安全</strong>的功能。</p>
<ul>
<li>仍然能在不安全块中获得某种程度的安全。</li>
</ul>
<p><code>unsafe</code>的意图在于作为程序员你将会确保 <code>unsafe</code> 块中的代码以有效的方式访问内存。而不是意味着代码块中的代码一定危险。</p>
<p>保持 <code>unsafe</code> 块尽可能小，方便定位内存bug。</p>
<p>将不安全代码封装进一个安全的抽象并提供安全 API ，在尽可能隔离不安全代码的比较好。</p>
<h2 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h2><p>不安全 Rust，有两个被被称为<strong>裸指针</strong>（raw pointers）的新类型，类似于引用。</p>
<ul>
<li>不可变的 <code>*const T</code>，</li>
<li>可变的 <code>*mut T</code>，</li>
</ul>
<blockquote>
<p>这里的星号（*）是<strong>类型名称的一部分</strong>，并不是解引用运算符。</p>
</blockquote>
<p>在裸指针的上下文中，<strong>不可变</strong>意味着指针解引用后不能直接赋值。</p>
<p>裸指针与引用和智能指针的区别在于：</p>
<ul>
<li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针；</li>
<li>不保证指向有效的内存；</li>
<li>允许为空；</li>
<li>不能实现任何自动清理功能；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r2 is: &#123;&#125;&quot;</span>, *r2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里创建指向任意内存地址的裸指针</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">address</span> = <span class="number">0x012345usize</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span> = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意，可以在安全代码中 <strong>创建</strong> 裸指针，只是不能在不安全块之外 <strong>解引用</strong> 裸指针和读取其指向的数据。</p>
<p>创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值。</p>
</blockquote>
<p>使用场景：</p>
<ul>
<li><p>一个主要的应用场景便是调用 C 代码接口，这在下一部分 <a href="https://kaisery.github.io/trpl-zh-cn/ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method">“调用不安全函数或方法”</a> 中会讲到。</p>
</li>
<li><p>另一个场景是构建借用检查器无法理解的安全抽象。</p>
</li>
</ul>
<h2 id="调用不安全函数或方法"><a href="#调用不安全函数或方法" class="headerlink" title="调用不安全函数或方法"></a>调用不安全函数或方法</h2><p>调用不安全函数，要求使用不安全块操作。</p>
<p>不安全函数和方法与常规函数方法十分类似，除了其开头有额外的<code>unsafe</code>。</p>
<ul>
<li>关键字<code>unsafe</code>表示该函数具有调用时需要满足的要求，而 Rust 不会保证满足这些要求。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">dangerous</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须在<code>unsafe</code>块中调用不安全函数，否则会报错。</p>
<p>不安全函数体也是有效的 <code>unsafe</code> 块，所以在不安全函数中进行另一个不安全操作时无需新增额外的 <code>unsafe</code> 块。</p>
<h3 id="创建不安全代码的安全抽象"><a href="#创建不安全代码的安全抽象" class="headerlink" title="创建不安全代码的安全抽象"></a>创建不安全代码的安全抽象</h3><p>将不安全代码封装进安全函数是一个常见的抽象。</p>
<h3 id="使用-extern-函数调用外部代码"><a href="#使用-extern-函数调用外部代码" class="headerlink" title="使用 extern 函数调用外部代码"></a>使用 <code>extern</code> 函数调用外部代码</h3><p><code>extern</code> 关键字，有助于创建和使用<strong>外部函数接口</strong>（Foreign Function Interface,FFI）。</p>
<ul>
<li>有时你的 Rust 代码可能需要与其他语言编写的代码交互。</li>
<li>外部函数接口允许不同编程语言调用这些函数。</li>
</ul>
<p><code>extern</code> 块中声明的函数在 Rust 代码中总是<strong>不安全的</strong>。</p>
<ul>
<li>因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明并调用C语言标准库的<code>abs</code>函数，定义的 <code>extern</code> 函数</p>
<h2 id="访问或修改可变静态变量"><a href="#访问或修改可变静态变量" class="headerlink" title="访问或修改可变静态变量"></a>访问或修改可变静态变量</h2><p><strong>全局变量</strong>（global variables）在 Rust 中被称为静态（static）变量。</p>
<p>静态变量与常量类似</p>
<ul>
<li><p>静态变量</p>
<ul>
<li><p>使用<code>static</code>关键字声明；</p>
</li>
<li><p>只能存储拥有<code>&#39;static</code> 生命周期的引用</p>
<ul>
<li>Rust 可以自己计算出其生命周期所以无需显示标注。</li>
</ul>
</li>
<li><p>访问不可变静态变量是安全的，</p>
</li>
<li><p>但访问和修改可变静态变量是不安全的。</p>
<ul>
<li>拥有可以全局访问的可变数据，难以保证不存在数据竞争，所以 Rust 认为可变静态变量是不安全的。</li>
</ul>
</li>
<li><p>静态变量中的值有一个固定的内存地址，使用这个总是会访问相同的地址。</p>
</li>
</ul>
</li>
<li><p><a href="03%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5.md">常量</a></p>
<ul>
<li><p>使用 <code>const</code> 关键字声明；</p>
</li>
<li><p>程序整个生命周期都是有效的；</p>
</li>
<li><p>是不可变的，不允许对常量使用<code>mut</code>关键字；</p>
</li>
<li><p>常量允许在任何被用到的时候复制其数据。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可变静态变量</span></span><br><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="type">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 访问不可变静态变量是安全的</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name is: &#123;&#125;&quot;</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变静态变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_to_count</span>(inc: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="comment">// 修改可变静态变量是不安全的</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_count</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 访问可变静态变量也是不安全的</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="type">u32</span> = <span class="number">100_000</span>;  <span class="comment">// 数字中的下划线仅起到增加可读性的作用；</span></span><br></pre></td></tr></table></figure>



<h2 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h2><p><code>unsafe</code> 的另一个操作用例是实现不安全 trait。</p>
<p>当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的。可以在 <code>trait</code> 之前增加 <code>unsafe</code> 关键字将 trait 声明为 <code>unsafe</code>，同时 trait 的实现也必须标记为 <code>unsafe</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="comment">// methods go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;</span><br><span class="line">    <span class="comment">// method implementations go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="访问联合体中的字段"><a href="#访问联合体中的字段" class="headerlink" title="访问联合体中的字段"></a>访问联合体中的字段</h2><p>仅适用于 <code>unsafe</code> 的最后一个操作是访问 <strong>联合体</strong> 中的字段，<code>union</code> 和 <code>struct</code> 类似，但是在一个实例中同时只能使用一个声明的字段。联合体主要用于和 C 代码中的联合体交互。访问联合体的字段是不安全的，因为 Rust 无法保证当前存储在联合体实例中数据的类型。可以查看<a href="https://doc.rust-lang.org/reference/items/unions.html">参考文档</a>了解有关联合体的更多信息。</p>
<h2 id="何时使用不安全代码"><a href="#何时使用不安全代码" class="headerlink" title="何时使用不安全代码"></a>何时使用不安全代码</h2><p>使用 <code>unsafe</code> 来进行这五个操作（超能力）之一是没有问题的，甚至是不需要深思熟虑的，不过使得 <code>unsafe</code> 代码正确也实属不易，因为编译器不能帮助保证内存安全。当有理由使用 <code>unsafe</code> 代码时，是可以这么做的，通过使用显式的 <code>unsafe</code> 标注可以更容易地在错误发生时追踪问题的源头。</p>
<h1 id="高级-trait"><a href="#高级-trait" class="headerlink" title="高级 trait"></a>高级 trait</h1><h2 id="关联类型在-trait-定义中指定占位符类型"><a href="#关联类型在-trait-定义中指定占位符类型" class="headerlink" title="关联类型在 trait 定义中指定占位符类型"></a>关联类型在 trait 定义中指定占位符类型</h2><p><strong>关联类型</strong>（associated types），是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。</p>
<ul>
<li><p>trait 的实现者会针对特定的实现在这个类型的位置<strong>指定相应的具体类型</strong>。</p>
</li>
<li><p>如此可以定义一个使用多种类型的 trait，直到实现此 trait 时都无需知道这些类型具体是什么。</p>
</li>
</ul>
<p>一个带有关联类型的 trait 的例子是标准库提供的 <code>Iterator</code> trait。</p>
<ul>
<li>它有一个叫做 <code>Item</code> 的关联类型来替代遍历的值的类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;  <span class="comment">// type 定义的 Item 就是关联类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关联类型看起来与泛型有些类似，因为它运行定义一个函数而不指定其可以处理的类型。</p>
<ul>
<li>通过关联类型，无需标注类型，如果是泛型则需要标注类型，</li>
</ul>
<h2 id="默认泛型类型参数和运算符重载"><a href="#默认泛型类型参数和运算符重载" class="headerlink" title="默认泛型类型参数和运算符重载"></a>默认泛型类型参数和运算符重载</h2><p>默认类型参数（defalut type parameters）主要用于如下两个方面：</p>
<ul>
<li>扩展类型而不破坏现有代码。</li>
<li>在大部分用户都不需要的特定情况进行自定义。</li>
</ul>
<p><strong>运算符重载</strong>（<em>Operator overloading</em>）是指在特定情况下自定义运算符（比如 <code>+</code>）行为的操作。</p>
<ul>
<li>Rust 并不允许创建自定义运算符或重载任意运算符，不过 <code>std::ops</code> 中所列出的运算符和相应的 trait 可以通过实现运算符相关 trait 来重载。</li>
</ul>
<h2 id="消除歧义的完全限定语法：调用同名方法"><a href="#消除歧义的完全限定语法：调用同名方法" class="headerlink" title="消除歧义的完全限定语法：调用同名方法"></a>消除歧义的完全限定语法：调用同名方法</h2><p>Rust 允许为不同 trait 创建相同方法，同时允许同一个类型实现相同的方法。</p>
<p>但是当调用这些方法时，需要告诉 Rust 我们希望使用哪一个。</p>
<blockquote>
<p>注：编译器默认调用直接实现在类型上的方法。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个 trait 定义为拥有 fly 方法，并在直接定义有 fly 方法的 Human 类型上实现这两个 trait</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Pilot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Wizard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pilot</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is your captain speaking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wizard</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*waving arms furiously*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当调用 Human 实例的 fly 时，编译器默认调用直接实现在类型上的方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：*waving arms furiously*</span></span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们需要使用更明显的语法以便能指定我们指的是哪个 fly 方法。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person);</span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person);</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然而，关联函数是 trait 的一部分，但没有 <code>self</code> 参数。当同一作用域的两个类型实现了同一 trait，Rust 就不能计算出我们期望的是哪一个类型，除非使用 <strong>完全限定语法</strong>（<em>fully qualified syntax</em>）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，它直接调用了定义于 Dog 之上的关联函数。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Dog::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试调用 Animal trait 的 baby_name 函数，不过因为baby_name() 是关联函数而不是方法，因此没有self参数，Rust 并不知道该使用哪一个实现。</span></span><br><span class="line"><span class="comment">// 会得到编译时报错。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Animal::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了消歧义并告诉 Rust 我们希望使用的是 <code>Dog</code> 的 <code>Animal</code> 实现，需要使用 <strong>完全限定语法</strong>（<em>fully qualified syntax</em>），这是调用函数时最为明确的方式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用完全限定语法来指定我们希望调用的是 Dog 上 Animal trait 实现中的 baby_name 函数。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, &lt;Dog <span class="keyword">as</span> Animal&gt;::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会输出，A baby dog is called a puppy。</span></span><br></pre></td></tr></table></figure>



<p><strong>完全限定语法</strong>定义为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完整语法：</span></span><br><span class="line">&lt;Type <span class="keyword">as</span> Trait&gt;::<span class="title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法时的省略语法：</span></span><br><span class="line"><span class="comment">// 因为方法有self，即receiver_if_method 部分，所以 Rust 可以计算出它属于那个type,所以可以省略 Type 部分；</span></span><br><span class="line">Trait::<span class="title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用关联函数时的省略语法：</span></span><br><span class="line"><span class="comment">// 因为关联函数没有 receiver_if_method部分，所以需要告诉Rust 调用那个类型上的trait 实现</span></span><br><span class="line">&lt;Type <span class="keyword">as</span> Trait&gt;::<span class="title function_ invoke__">function</span>(next_arg, ...);</span><br></pre></td></tr></table></figure>



<h2 id="使用-supertrait-可以使我们的-trait-包含另一个-trait-的功能"><a href="#使用-supertrait-可以使我们的-trait-包含另一个-trait-的功能" class="headerlink" title="使用 supertrait 可以使我们的 trait 包含另一个 trait 的功能"></a>使用 supertrait 可以使我们的 trait 包含另一个 trait 的功能</h2><p>有时我们可能会需要某个 trait 使用另一个 trait 的功能。</p>
<p>限制：</p>
<blockquote>
<p>在这种情况下，相关被依赖的 trait 也被实现。</p>
</blockquote>
<p>这个被依赖的 trait 是我们实现的 trait 的 <strong>父（超） trait</strong>（<em>supertrait</em>）。</p>
<ul>
<li>这类似于为 trait 增加 trait bound。</li>
<li>要使用该 trait 就要同时实现其父 trait（supertrait）</li>
</ul>
<p>语法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TraitB是TraitA的supertrait，要使用TraitA就要实现TraitB</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">TraitA</span>: TraitB &#123;&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = output.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;* &#123;&#125; *&quot;</span>, output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种情况下，实现 OutlinePrint trait 时就需要实现 fmt:Display，否则编译器会报错。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">OutlinePrint</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="newtype-模式用以在外部类型上实现外部-trait"><a href="#newtype-模式用以在外部类型上实现外部-trait" class="headerlink" title="newtype 模式用以在外部类型上实现外部 trait"></a>newtype 模式用以在外部类型上实现外部 trait</h2><p>为类型试下 trait 时，默认遵守<strong>孤儿原则</strong>（orphan rule），即只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait。</p>
<p>一个绕开这个限制的方法是使用 <strong>newtype 模式</strong>（<em>newtype pattern</em>），它涉及到在一个元组结构体中创建一个新类型。这个元组结构体带有一个字段作为希望实现 trait 的类型的简单封装。接着这个封装类型对于 crate 是本地的，这样就可以在这个封装上实现 trait。</p>
<blockquote>
<p>注：使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此方法的<strong>缺点</strong>是，因为 <code>Wrapper</code> 是一个新类型，它没有定义于其值之上的方法；必须直接在 <code>Wrapper</code> 上实现 <code>Vec&lt;T&gt;</code> 的所有方法，这样就可以代理到<code>self.0</code> 上 —— 这就允许我们完全像 <code>Vec&lt;T&gt;</code> 那样对待 <code>Wrapper</code>。如果希望新类型拥有其内部类型的每一个方法，为封装类型实现 <code>Deref</code> trait 并返回其内部类型是一种解决方案。如果不希望封装类型拥有所有内部类型的方法 —— 比如为了限制封装类型的行为 —— 则必须只自行实现所需的方法。</p>
<h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="为了类型安全和抽象而使用-newtype-模式"><a href="#为了类型安全和抽象而使用-newtype-模式" class="headerlink" title="为了类型安全和抽象而使用 newtype 模式"></a>为了类型安全和抽象而使用 newtype 模式</h2><p>newtype 模式可以用于</p>
<ul>
<li>一些其他我们还未讨论的功能，包括静态的确保某值不被混淆，和用来表示一个值的单元。</li>
<li>抽象掉一些类型的实现细节<ul>
<li>例如，封装类型可以暴露出与直接使用其内部私有类型时所不同的公有 API，以便限制其功能。</li>
</ul>
</li>
<li>可以隐藏其内部的泛型类型。<ul>
<li>例如，可以提供一个封装了 <code>HashMap&lt;i32, String&gt;</code> 的 <code>People</code> 类型，用来储存人名以及相应的 ID。使用 <code>People</code> 的代码只需与提供的公有 API 交互即可，比如向 <code>People</code> 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 <code>i32</code> ID 赋予了这个名字了。newtype 模式是一种实现第十七章 <a href="https://kaisery.github.io/trpl-zh-cn/ch17-01-what-is-oo.html#%E5%B0%81%E8%A3%85%E9%9A%90%E8%97%8F%E4%BA%86%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82">“封装隐藏了实现细节”</a> 部分所讨论的隐藏实现细节的封装的轻量级方法。</li>
</ul>
</li>
</ul>
<h2 id="类型别名用来创建类型同义词"><a href="#类型别名用来创建类型同义词" class="headerlink" title="类型别名用来创建类型同义词"></a>类型别名用来创建类型同义词</h2><p>Rust 还提供了声明 <strong>类型别名</strong>（<em>type alias</em>）的能力，使用 <code>type</code> 关键字来给予现有类型另一个名字。</p>
<p>例如，可以像这样创建 <code>i32</code> 的别名 <code>Kilometers</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Kilometers</span> = <span class="type">i32</span>;</span><br></pre></td></tr></table></figure>

<p>这意味着 <code>Kilometers</code> 是 <code>i32</code> 的 <strong>同义词</strong>（<em>synonym</em>）；<code>Kilometers</code> 类型的值将被完全当作 <code>i32</code> 类型值来对待。</p>
<p>类型别名的<strong>主要用途</strong>是<strong>减少重复</strong>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Box&lt;dyn Fn() + Send + &#x27;static&gt; 类型很长</span></span><br><span class="line"><span class="comment">// 使用类型别名前</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_long_type</span>(f: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_long_type</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名后</span></span><br><span class="line"><span class="comment">// 这里我们为这个冗长的类型引入了一个叫做 Thunk 的别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Thunk</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: Thunk = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_long_type</span>(f: Thunk) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_long_type</span>() <span class="punctuation">-&gt;</span> Thunk &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>标准库中的 <code>std::io</code> 模块中也是用了类型别名</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名前</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>, Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_fmt</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fmt: fmt::Arguments) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), Error&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名后</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, std::io::Error&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_fmt</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fmt: Arguments) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型别名在两个方面有帮助：易于编写 <strong>并</strong> 在整个 <code>std::io</code> 中提供了一致的接口。</p>
<h3 id="as-与-type-的区别"><a href="#as-与-type-的区别" class="headerlink" title="as 与 type 的区别"></a><code>as</code> 与 type 的区别</h3><p><code>as</code> 有如下功能</p>
<ul>
<li>强制类型转换，消除特定包含项的 trait 的歧义；</li>
<li>对 <code>use</code> 或 <code>extern</code> crate 语句中的项重命名；</li>
</ul>
<p><code>type</code> 的主要功能：</p>
<ul>
<li>定义一个类型别名或关联类型</li>
</ul>
<p>使用场景：</p>
<p>通常当需要为一个类型定义别名时，通常使用 <code>type</code>，这样更清楚地暗示意图。</p>
<ul>
<li><code>type Result&lt;T&gt; = std::result::Result&lt;T, MyError&gt;;</code></li>
</ul>
<p>当你导入特定项目时发现它与当前命名空间中已有的内容冲突时，一般使用 <code>use ... as ...</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Read <span class="keyword">as</span> StdRead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Read</span>: StdRead &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>不过，我们应该优先使用路径限定标识符，然后才尝试使用 <code>use...as...</code>重命名。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Read</span>: io::Read &#123; ... &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：应该避免使用<code>use...as..</code> 代替 <code>type</code>的情况。</p>
</blockquote>
<h2 id="从不返回的-never-type"><a href="#从不返回的-never-type" class="headerlink" title="从不返回的 never type"></a>从不返回的 never type</h2><p>Rust 有一个叫做 <code>!</code> 的特殊类型。在类型理论术语中，它被称为 <em>empty type</em>，因为它没有值。我们更倾向于称之为 <em>never type</em>。</p>
<ul>
<li>这个名字描述了它的作用：在函数从不返回的时候充当返回值。</li>
<li>描述 <code>!</code> 的行为的正式方式是 never type 可以<strong>强转为任何其他类型</strong>。</li>
</ul>
<p>从不返回的函数被称为 <strong>发散函数</strong>（<em>diverging functions</em>）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bar</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>作用：</p>
<ul>
<li><p>用于<code>continue</code>，continue 的返回值是<code>!</code>即并不真正返回一个值，相反它把控制权交回上层循环；</p>
<ul>
<li><p>例如，当用于<code>match</code>的分支时，<code>match</code>的分支要求必须返回相同的类型，那么<code>continue</code>返回<code>!</code>，则其实就是强转为了其他分支返回的值的类型了。它把控制权交回上层循环，由Rust决定类型是什么。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误形式</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">guess</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="number">5</span>,  <span class="comment">// i32</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="string">&quot;hello&quot;</span>,  <span class="comment">// String</span></span><br><span class="line">&#125;  <span class="comment">// 类型不统一，所以编译出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确形式</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,  <span class="comment">// continue 返回!,即不返回任何值，所以Rust决定 guess的类型是 num的类型即u32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>用于<code>panic!</code>，<code>panic!</code> 的返回值也是<code>!</code>，即没有返回任何值，类型的决定权就由Rust 根据其他分支决定；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),  <span class="comment">// 这里知道 val 是T类型，panic!返回！，即不返回任何值，它终止程序，所以最终unwrap返回的就是T类型。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个有着 <code>!</code> 类型的表达式是 <code>loop</code>；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">print!</span>(<span class="string">&quot;forever &quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// loop 表达式的值是 !,</span></span><br><span class="line">  <span class="keyword">loop</span> &#123;  <span class="comment">// 这里循环永远不结束，所以表达式的值是!</span></span><br><span class="line">      <span class="built_in">print!</span>(<span class="string">&quot;and ever &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 希望结束就引入 break</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="与-的区别"><a href="#与-的区别" class="headerlink" title="! 与 () 的区别"></a><code>!</code> 与 <code>()</code> 的区别</h3><p><code>()</code> 有一个唯一的值<code>()</code>，即有值；</p>
<ul>
<li><p><code>()</code> 是rust中的unit type，该类型是zero-size的，并且有一个唯一的值：<code>()</code>；</p>
</li>
<li><p>用在函数返回值时，有点类似于<code>void</code>；</p>
</li>
<li><p>当一个表达式或函数没有返回一个值时，返回的是<code>()</code>;</p>
</li>
<li><p>当一个<code>Option</code>或者<code>Result</code>并不关心返回值时，即当没有其他有意义的值可返回时使用，可以使用<code>Option&lt;()&gt;</code>或者<code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>；</p>
</li>
<li><p><code>HashSet&lt;T&gt;</code> 实际上就是<code>HashTable&lt;T,()&gt;</code>；</p>
</li>
<li><p>当我们需要表示一个<code>raw pointer</code>，但是并不关心其实际的类型时，就可以使用<code>*mut ()</code>或者<code>*const ()</code>，类似于c中的<code>void*</code>和<code>const void*</code>。</p>
</li>
</ul>
<p><code>!</code>没有值</p>
<ul>
<li><p>在Rust 中是 empty type ，即never type</p>
</li>
<li><p>不能创建 <code>!</code> 类型的值；</p>
</li>
<li><p>使用它时表示该函数不会返回；</p>
</li>
</ul>
<h2 id="动态大小类型和-Sized-trait"><a href="#动态大小类型和-Sized-trait" class="headerlink" title="动态大小类型和 Sized trait"></a>动态大小类型和 Sized trait</h2><p><strong>动态大小</strong>（dynamically sized types），是运行时才知道大小的类型。也被称为“DST”或“unsized types”。</p>
<p>Rust 需要在编译时知道为类型的值分配多少空间。</p>
<p>Rust 中动态大小类型的黄金规则：</p>
<ul>
<li><strong>必须将动态大小类型的值置于某种指针之后</strong>。</li>
</ul>
<p>例如，可以将<code>str</code>与所有类型的指针结合：比如<code>Box&lt;str&gt;</code>或<code>Rc&lt;str&gt;</code>。</p>
<p>另外一个动态大小类型是：trait。</p>
<ul>
<li>每一个 <strong>trait 都是</strong>一个可以通过 trait 名称来引用的<strong>动态大小类型</strong>。</li>
<li>在<a href="17Rust%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7.md">“为使用不同类型的值而设计的 trait 对象”</a>部分，我们知道为了将 trait 用于 trait 对象，<strong>必须将它们放入指针之后</strong>，比如<code>&amp;dyn Trait, 或 Box&lt;dyn Trait&gt;, 或 Rc&lt;dyn Trait&gt;</code>。</li>
</ul>
<p>Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知：<code>Sized trait</code>。</p>
<p>这个 trait 为编译器在编译时就知道大小的类型自动实现。</p>
<ul>
<li>另外，Rust 隐式的为每一个泛型函数增加了 <code>Sized</code> bound。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T&gt;(t: T) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上被当作如下处理：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: <span class="built_in">Sized</span>&gt;(t: T) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>?Sized</code> trait bound 与 <code>Sized</code> 相对；也就是说，它可以读作 “<code>T</code> 可能是也可能不是 <code>Sized</code> 的”。这个语法<strong>只能</strong>用于 <code>Sized</code> ，而不能用于其他 trait。</p>
<p>另外注意我们将 <code>t</code> 参数的类型从 <code>T</code> 变为了 <code>&amp;T</code>：因为其类型可能不是 <code>Sized</code> 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。</p>
<h1 id="高级函数与闭包"><a href="#高级函数与闭包" class="headerlink" title="高级函数与闭包"></a>高级函数与闭包</h1><p>函数指针以及返回值闭包。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>我们不仅可以向函数传递闭包，还可以传递常规函数。</p>
<p><strong>函数指针</strong>（function pointer）允许我们使用函数作为另一个函数的参数。</p>
<ul>
<li><code>fn</code> 是函数指针，（使用小写的<code>f</code>，区别于<code>Fn</code>闭包 trait）。</li>
<li>不同于闭包，<code>fn</code> 是一个类型而不是一个 trait，<ul>
<li>所以使用时，直接指定<code>fn</code>作为参数而不是声明一个带有<code>Fn</code> 作为 trait bound 的泛型参数。</li>
</ul>
</li>
<li>函数指针实现了所有三个闭包 trait（<code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>），<ul>
<li>所以总是可以在调用期望闭包的函数时传递函数指针作为参数。</li>
<li>所以，我们也更倾向于编写使用泛型和闭包 trait 的函数。<ul>
<li>这样它就能接受函数或闭包作为参数。</li>
</ul>
</li>
<li>只有当与不存在闭包的外部代码交互时，才定义只期望接受<code>fn</code>而不接受闭包的情况。<ul>
<li>例如 C语言的函数没有闭包，就只接受函数作为参数。</li>
</ul>
</li>
</ul>
</li>
<li>指定参数为函数指针的语法类似于闭包。</li>
</ul>
<p>例如，使用 <code>fn</code> 类型接受函数指针作为参数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 fn 参数指针类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>(f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>, arg: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(arg) + <span class="title function_ invoke__">f</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">answer</span> = <span class="title function_ invoke__">do_twice</span>(add_one, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The answer is: &#123;&#125;&quot;</span>, answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>作为一个既可以使用内联定义的闭包又可以使用命名函数的例子，让我们看看一个 <code>map</code> 的应用。使用 <code>map</code> 函数将一个数字 vector 转换为一个字符串 vector，就可以使用闭包，比如这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|i| i.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>或者可以将函数作为 <code>map</code> 的参数来代替闭包，像是这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>注意这里必须使用 <a href="#%E6%B6%88%E9%99%A4%E6%AD%A7%E4%B9%89%E7%9A%84%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95%EF%BC%9A%E8%B0%83%E7%94%A8%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95">“高级 trait”</a> 部分讲到的完全限定语法，因为存在多个叫做 <code>to_string</code> 的函数；这里使用了定义于 <code>ToString</code> trait 的 <code>to_string</code> 函数，标准库为所有实现了 <code>Display</code> 的类型实现了这个 trait。</li>
</ul>
<p>另一个实用的模式暴露了元组结构体和元组结构体枚举成员的实现细节。这些项使用 <code>()</code> 作为初始化语法，这看起来就像函数调用，同时它们确实被实现为返回由参数构造的实例的函数。它们也被称为实现了闭包 trait 的函数指针，并可以采用类似如下的方式调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Value</span>(<span class="type">u32</span>),</span><br><span class="line">    Stop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">list_of_statuses</span>: <span class="type">Vec</span>&lt;Status&gt; =</span><br><span class="line">    (<span class="number">0u32</span>..<span class="number">20</span>)</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(Status::Value)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<p>这里创建了 <code>Status::Value</code> 实例，它通过 <code>map</code> 用范围的每一个 <code>u32</code> 值调用 <code>Status::Value</code> 的初始化函数。一些人倾向于函数风格，一些人喜欢闭包。这两种形式最终都会产生同样的代码，所以请使用对你来说更明白的形式吧。</p>
<h2 id="返回闭包"><a href="#返回闭包" class="headerlink" title="返回闭包"></a>返回闭包</h2><p>之前在<a href="10%E6%B3%9B%E5%9E%8B%E3%80%81trait%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.md">“第十章泛型”</a> 中讲过，如果将泛型作为返回值，那么每次只能返回一种类型，而不是动态返回多种类型。</p>
<ul>
<li>所以，闭包表现为 trait，这意味着不能直接返回闭包。</li>
</ul>
<p>对于大部分需要返回 trait 的情况，可以使用实现了期望返回的 trait 的具体类型来替代函数的返回值。但是这不能用于闭包，因为他们没有一个可返回的具体类型；例如不允许使用函数指针 <code>fn</code> 作为返回值类型。</p>
<p>这段代码尝试直接返回闭包，它并不能编译：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    |x| x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译器报错：</span></span><br><span class="line">error[E0277]: the <span class="keyword">trait</span> <span class="title class_">bound</span> `std::ops::<span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> + <span class="symbol">&#x27;static</span>:</span><br><span class="line">std::marker::<span class="built_in">Sized</span>` is not satisfied</span><br><span class="line">= note: the <span class="keyword">return</span> <span class="keyword">type</span> <span class="title class_">of</span> a function must have a statically known size</span><br></pre></td></tr></table></figure>

<p>错误又一次指向了 <code>Sized</code> trait！Rust 并不知道需要多少空间来储存闭包。不过我们在上一部分见过这种情况的解决办法：<strong>可以使用 trait 对象</strong>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码正好可以编译。</p>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p><strong>宏</strong>（<em>Macro</em>）指的是 Rust 中一系列的功能：使用 <code>macro_rules!</code> 的 <strong>声明</strong>（<em>Declarative</em>）宏，和三种 <strong>过程</strong>（<em>Procedural</em>）宏：</p>
<ul>
<li>自定义 <code>#[derive]</code> 宏在结构体和枚举上指定通过 <code>derive</code> 属性添加的代码；</li>
<li>类属性（Attribute-like）宏定义可用于任意项的自定义属性；</li>
<li>类函数宏看起来像函数不过作用于作为参数传递的 token；</li>
</ul>
<p><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">宏的更多内容参考这里</a>。</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>20最后的项目：构建多线程web server</title>
    <url>//20%E6%9C%80%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8Bweb%20server.html</url>
    <content><![CDATA[<p>在本章中，我们将一同构建另一个项目，来展示最后几章所学，同时复习更早的章节。</p>
<p>如下是我们将怎样构建此 web server 的计划：</p>
<ol>
<li>学习一些 TCP 与 HTTP 知识</li>
<li>在套接字（socket）上监听 TCP 请求</li>
<li>解析少量的 HTTP 请求</li>
<li>创建一个合适的 HTTP 响应</li>
<li>通过线程池改善 server 的吞吐量</li>
</ol>
<p>不过在开始之前，需要提到一点细节：这里使用的方法并不是使用 Rust 构建 web server 最好的方法。<a href="https://crates.io/">crates.io</a> 上有很多可用于生产环境的 crate，它们提供了比我们所要编写的更为完整的 web server 和线程池实现。</p>
<p>然而，本章的目的在于学习，而不是走捷径。因为 Rust 是一个系统编程语言，我们能够选择处理什么层次的抽象，并能够选择比其他语言可能或可用的层次更低的层次。因此我们将自己编写一个基础的 HTTP server 和线程池，以便学习将来可能用到的 crate 背后的通用理念和技术。</p>
<h1 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h1><p> <strong>超文本传输协议</strong>（<em>Hypertext Transfer Protocol</em>，<em>HTTP</em>）</p>
<p><strong>传输控制协议</strong>（<em>Transmission Control Protocol</em>，<em>TCP</em>）</p>
<ul>
<li>都是 <strong>请求-响应</strong>（<em>request-response</em>）协议，</li>
<li>也就是说，有 <strong>客户端</strong>（<em>client</em>）来初始化请求，并有 <strong>服务端</strong>（<em>server</em>）监听请求并向客户端提供响应。请求与响应的内容由协议本身定义。</li>
</ul>
<p>标准库提供了 <code>std::net</code> 模块处理这些功能。</p>
<p><code>TcpListener</code> 用于监听 TCP 连接。</p>
<ul>
<li>具体内容可以查看API文档；</li>
<li><code>bind</code> 函数返回 <code>Result&lt;T, E&gt;</code>，这表明绑定可能会失败；</li>
<li><code>TcpListener</code> 的 <code>incoming</code> 方法返回一个迭代器，它提供了一系列的流（更准确的说是 <code>TcpStream</code> 类型的流）。</li>
</ul>
<p><strong>流</strong>（<em>stream</em>）代表一个客户端和服务端之间打开的连接。</p>
<p><strong>连接</strong>（<em>connection</em>）代表客户端连接服务端、服务端生成响应以及服务端关闭连接的全部请求 &#x2F; 响应过程。</p>
<p>当客户端连接到服务端时 <code>incoming</code> 方法返回错误是可能的，因为我们实际上没有遍历连接，而是遍历 <strong>连接尝试</strong>（<em>connection attempts</em>）。</p>
<p>当 <code>stream</code> 在循环的结尾离开作用域并被丢弃，其连接将被关闭，作为 <code>drop</code> 实现的一部分。</p>
<h2 id="读取请求"><a href="#读取请求" class="headerlink" title="读取请求"></a>读取请求</h2><p>将 <code>std::io::prelude</code> 引入作用域来获取读写流所需的特定 trait。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br></pre></td></tr></table></figure>

<p>在 <code>handle_connection</code> 中，<code>stream</code> 参数是可变的。这是因为 <code>TcpStream</code> 实例在内部记录了所返回的数据。它可能读取了多于我们请求的数据并保存它们以备下一次请求数据。因此它需要是 <code>mut</code> 的<strong>因为其内部状态可能会改变</strong>；通常我们认为 “读取” 不需要可变性，不过在这个例子中则需要 <code>mut</code> 关键字。</p>
<p>HTTP 是一个基于文本的协议，同时一个请求有如下格式：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Method Request-URI HTTP-Version CRLF</span><br><span class="line">headers CRLF</span><br><span class="line">message-body</span><br></pre></td></tr></table></figure>

<p>第一行叫做 <strong>请求行</strong>（<em>request line</em>），它存放了客户端请求了什么的信息。</p>
<ul>
<li><p>请求行的第一部分是所使用的 <em>method</em>，比如 <code>GET</code> 或 <code>POST</code>，这描述了客户端如何进行请求。这里客户端使用了 <code>GET</code> 请求。</p>
</li>
<li><p>请求行接下来的部分是 <em>&#x2F;<em>，它代表客户端请求的 <strong>统一资源标识符</strong>（<em>Uniform Resource Identifier</em>，</em>URI</em>） —— URI 大体上类似，但也不完全类似于 URL（<strong>统一资源定位符</strong>，<em>Uniform Resource Locators</em>）。URI 和 URL 之间的区别对于本章的目的来说并不重要，不过 <strong>HTTP 规范使用术语 URI</strong>，所以这里可以简单的将 URL 理解为 URI。</p>
</li>
<li><p>最后一部分是客户端使用的HTTP版本，然后请求行以 <strong>CRLF序列</strong> （CRLF代表回车和换行，<em>carriage return line feed</em>，这是打字机时代的术语！）结束。CRLF序列也可以写成<code>\r\n</code>，其中<code>\r</code>是回车符，<code>\n</code>是换行符。 CRLF序列将请求行与其余请求数据分开。 请注意，打印CRLF时，我们会看到一个新行，而不是<code>\r\n</code>。</p>
</li>
</ul>
<p>第二行是 headers；从 <code>Host:</code> 开始的其余的行是 headers；<code>GET</code> 请求没有 body。</p>
<h2 id="编写响应"><a href="#编写响应" class="headerlink" title="编写响应"></a>编写响应</h2><p>我们将实现在客户端请求的响应中发送数据的功能。响应有如下格式：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HTTP-Version Status-Code Reason-Phrase CRLF</span><br><span class="line">headers CRLF</span><br><span class="line">message-body</span><br></pre></td></tr></table></figure>

<p>第一行叫做 <strong>状态行</strong>（<em>status line</em>），它包含响应的 HTTP 版本、一个数字状态码用以总结请求的结果和一个描述之前状态码的文本原因短语。</p>
<p>CRLF 序列之后是任意 header，另一个 CRLF 序列，和响应的 body。</p>
<p>例如，一个没有body的响应</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK\r\n\r\n</span><br></pre></td></tr></table></figure>





<p>数据开头增加 <code>b&quot;&quot;</code> <strong>字节字符串</strong>语法将其转换为字节字符串。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>通道可以通道任务队列的作用</p>
<p>如何创建并存储空线程？</p>
<ul>
<li>使用 <code>JoinHandle</code>来存储创建的线程</li>
</ul>
<p>看一下 <code>thread::spawn</code>的签名</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">spawn</span>&lt;F, T&gt;(f: F) <span class="punctuation">-&gt;</span> JoinHandle&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">        T: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span></span><br></pre></td></tr></table></figure>

<p><code>spawn</code>返回 <code>JoinHandle&lt;T&gt;</code>，<code>T</code> 是闭包返回的类型。不返回有意义的值则使用<code>()</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thread::spawn() -&gt; JoinHandle&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(||&#123;&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">spawn</span>&lt;F, T&gt;(f: F) <span class="punctuation">-&gt;</span> JoinHandle&lt;T&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">        T: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span></span><br></pre></td></tr></table></figure>

<p><code>F</code> 是这里我们关心的参数；</p>
<p>要理解<code>F</code>的三个 trait bound的目的，</p>
<ul>
<li><code>FnOnce()</code> ，线程仅对闭包执行一次，</li>
<li><code>Send</code> 来将闭包从一个线程转移到另一个线程（安全在线程间转移所有权）；</li>
<li><code>&#39;static</code> 是因为并不知道线程会执行多久。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里与上面 <code>spawn</code> 部分 <code>FnOnce</code>的不同有一个知识点：</p>
<ul>
<li>使用<code>FnOnce/FnMut/Fn</code>定义 trait bound时，就像普通定义函数签名时一样</li>
</ul>
<ol>
<li>如果有参数和返回值，需要<code>FnOnce(类型) -&gt; 类型2</code>；</li>
<li>如果没有参数和返回值，或者两者缺一，<ul>
<li>没有参数时也需要<code>()</code>，即<code>FnOnce()</code>，函数没有参数时也是这样；</li>
<li>没有返回值时，可以省略返回值，即<code>FnOnce(xxx)</code>（没有返回值时其实就是返回<code>()</code>，不过可以省略）;</li>
</ul>
</li>
</ol>
<p><code>Vec::with_capacity(size)</code>与 <code>Vec::new()</code>的区别？</p>
<ul>
<li><p><code>Vec::with_capacity(size)</code> 效率要高一些，因为会预先进行分配size个元素的空间。</p>
</li>
<li><p><code>Vec::new</code> 会随着插入元素而重新改变大小；</p>
</li>
</ul>
<h3 id="使用通道向线程发送请求"><a href="#使用通道向线程发送请求" class="headerlink" title="使用通道向线程发送请求"></a>使用通道向线程发送请求</h3><p>在线程池中，<code>Worker</code> 结构体能够从 <code>ThreadPool</code> 的队列中获取需要执行的代码，并发送到线程中执行他们。</p>
<p>我们要队列，在这里我们可以简单是使用<strong>通道</strong>来充当任务队列的作用。</p>
<ol>
<li><code>ThreadPool</code> 会创建一个通道，其<code>execute</code> 方法会在通道发送端发出期望执行的任务。</li>
<li>每个 <code>Worker</code> 将会充当通道的接收端。</li>
</ol>
<p>注意，<code>mpsc::channel()</code>中，Rust 提供的通道是多生产者，单消费者。</p>
<ul>
<li>在线程中的接收端是不能传递给多个<code>worker</code>实例的。</li>
<li>所以只能所有<code>worker</code>共享单一的receiver了，同时取出任务需要修改receiver。<ul>
<li>这涉及到在多个线程间共享所有权，并允许线程修改其值得问题。</li>
<li>需要使用<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>。<code>Arc</code>允许多个线程间共享所有权，<code>Mutex</code> 确保一次只有一个worker能从接收端获取任务并修改。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 共享所有权需要使用clone方法</span></span><br><span class="line">    workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id,Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接收闭包类型的-trait对象的类型别名"><a href="#接收闭包类型的-trait对象的类型别名" class="headerlink" title="接收闭包类型的 trait对象的类型别名"></a>接收闭包类型的 trait对象的类型别名</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br></pre></td></tr></table></figure>



<h3 id="为什么选择loop而不是while-let"><a href="#为什么选择loop而不是while-let" class="headerlink" title="为什么选择loop而不是while let?"></a>为什么选择<code>loop</code>而不是<code>while let</code>?</h3><p>我们需要闭包<strong>一直循环</strong>，向通道的接收端请求任务，并在得到任务时执行他们</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; got a job; executing.&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">                <span class="title function_ invoke__">job</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实现上使用了<code>loop</code>，而不是<code>while let</code>，为什么？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(job) = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; got a job; executing.&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">                <span class="title function_ invoke__">job</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以编译和运行，但是并不会产生所期望的线程行为：一个慢请求仍然会导致其他请求等待执行。– 这里主要因为获取锁的原因；</p>
<p>原因有些微妙：</p>
<ul>
<li><code>Mutex</code> 结构体没有公有 <code>unlock</code> 方法，因为锁的所有权依赖 <code>lock</code> 方法返回的 <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> 中 <code>MutexGuard&lt;T&gt;</code> 的生命周期。<ul>
<li>因为<code>MutexGuard&lt;T&gt;</code>是个智能指针，其实现了<code>Drop</code> trait，当<code>MutexGuard</code>离开作用域时会自动释放锁（lock）；</li>
<li>所以借用检查器可以在编译时就确保不会出现被<code>Mutex</code>守护的资源被没有持有锁的情况下被访问。</li>
<li>所以在处理锁的时候，需要考虑<code>lock</code>方法返回值的生命周期，否则可能出现持有锁的时间比预期长的情况，导致性能受损。</li>
</ul>
</li>
<li>问题来了，这与 <code>while let</code> 有什么关系呢？<ul>
<li><code>let</code>语句，当<code>let</code>语句结束时，表达式中等号右边的任何临时值都会被立即丢弃。</li>
<li><code>while let</code> 、<code>if let</code> 和 <code>match</code> 直到相关块的末尾才会丢弃临时值。</li>
</ul>
</li>
</ul>
<p>所以综上，</p>
<p>如果这里使用 <code>while let</code>，一次判断循环，在离开其代码块前，产生的<code>MutexGuard</code>临时值会一直存在，如果有慢请求，worker获取锁后，到执行完job都会一直持有锁，导致无法实现多线程并发。</p>
<p>而使用<code>loop</code>循环，因为<code>let</code>语句在内部，且<code>let</code>语句执行完，<code>MutexGuard</code>就会被丢弃，这样其他worker就可以争夺锁，就可以达到多个线程并发执行了。</p>
<h1 id="优雅停机与清理"><a href="#优雅停机与清理" class="headerlink" title="优雅停机与清理"></a>优雅停机与清理</h1><h2 id="为-ThreadPool-实现-Drop-trait"><a href="#为-ThreadPool-实现-Drop-trait" class="headerlink" title="为 ThreadPool 实现 Drop trait"></a>为 ThreadPool 实现 Drop trait</h2><p>当线程池被丢弃时，应该 join 所有线程以确保他们完成其操作。这个在 <code>Drop</code> trait 中实现。</p>
<p><code>JoinHandler.join</code> 的作用</p>
<ul>
<li>等待关联的thread结束，如果关联的线程结束了这个方法会立刻返回。</li>
<li>该方法需要获取实例的所有权。<ul>
<li>为了解决这个问题，需要一个方法将 <code>thread</code> 移动出拥有其所有权的 <code>Worker</code> 实例以便 <code>join</code> 可以消费这个线程。</li>
<li>如果 <code>Worker</code> 存放的是 <code>Option&lt;thread::JoinHandle&lt;()&gt;</code>，就可以在 <code>Option</code> 上调用 <code>take</code> 方法将值从 <code>Some</code> 成员中移动出来而对 <code>None</code> 成员不做处理。</li>
</ul>
</li>
</ul>
<h2 id="向线程发送信号使其停止接收任务"><a href="#向线程发送信号使其停止接收任务" class="headerlink" title="向线程发送信号使其停止接收任务"></a>向线程发送信号使其停止接收任务</h2><p>修改线程既监听是否有 <code>Job</code> 运行也要监听一个应该停止监听并退出无限循环的信号。</p>
<p>否则，如果没有停止退出无限循环的信号，那么线程将永远不会退出，泽县城永远阻塞在等待第一个线程结束上。</p>
<ul>
<li>所以通道将发送这个枚举的两个成员之一而不是 <code>Job</code> 实例。</li>
</ul>
<p>为什么在 Drop trait 实现中不能将发送terminate的循环与获取join的循环放在一起？而是分为两个for循环？</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>21知识拾遗</title>
    <url>//21%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97.html</url>
    <content><![CDATA[<h1 id="Formatted-print"><a href="#Formatted-print" class="headerlink" title="Formatted print"></a>Formatted print</h1><p>打印信息，是由<code>std::fmt</code> 包中的几个宏来处理的</p>
<ul>
<li><code>format!</code>：将格式化的内容转为 <code>String</code>;</li>
<li><code>print!</code>： 与<code>format!</code>类似，但是将内容打印到终端（<code>io::stdout</code>）;</li>
<li><code>println!</code>：与<code>print!</code>类似，会换行；</li>
<li><code>eprint!</code>：与<code>format!</code>类似，不过是将文本打印到标准错误（<code>io:stderr</code>）；</li>
<li><code>eprintln!</code>：与<code>eprint!</code>类似，会换行。</li>
</ul>
<p><code>std::fmt</code> 中包含了很多控制文本显示的 trait，下面列举两个重要的基本内容：</p>
<ul>
<li><p><code>fmt::Debug</code>：使用<code>&#123;:?&#125;</code>标记，格式化文本以便调试；</p>
</li>
<li><p><code>fmt::Debug</code>，还可以使用<code>&#123;:#?&#125;</code>标记，使文本打印更好看一些；</p>
<ul>
<li><p>所有<code>std</code>标准库下得类型都实现了这个 trait。</p>
</li>
<li><p>如果想使用在通用情况下，就使用<code>#[derive(Debug)]</code>;</p>
</li>
<li><p>对于自定义的struct，<code>fmt::Debug</code> 是派生trait，所以不需要手动实现，仅需要在struct上添加<code>#[derive(Debug)]</code> 注解即可。</p>
</li>
</ul>
</li>
<li><p><code>fmt::Display</code>：格式化文本使其以更优雅，更友好的方式展示；</p>
<ul>
<li><p>提供<code>&#123;&#125;</code>标记，按照实现<code>fmt::Display</code> 实现的自定义方式打印文本；</p>
</li>
<li><p>实现<code>fmt::Display</code> trait 的类型会自动实现<code>ToString</code> trait，这会允许我们将类型转换为<code>String</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="fmt-Display-实现的方式"><a href="#fmt-Display-实现的方式" class="headerlink" title="fmt::Display 实现的方式"></a><code>fmt::Display</code> 实现的方式</h3><p>需要实现 fmt 方法，同时需要利用 <code>write!</code>宏来处理</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Similarly, implement `Display` for `Point2D`</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="comment">// Customize so only `x` and `y` are denoted.</span></span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>write!</code>宏是将后面的参数写入 <code>f</code> 中，</p>
<ul>
<li><code>write!</code> 类似于 <code>format!</code>，不过它会将格式化内容写入buffer中（即第一个参数中）</li>
</ul>
<p>使用时，<code>println!(&quot;&#123;&#125;&quot;,xx)</code> ，即可。</p>
<h2 id="println-使用注意"><a href="#println-使用注意" class="headerlink" title="println! 使用注意"></a><code>println!</code> 使用注意</h2><p>注意：<code>println!</code> 语句每次打印都会将内容 flush 到终端，因为通常需要打印新行，所以如果在意程序性能，需要谨慎使用<code>println!</code>，</p>
<h2 id="格式化文本的方式"><a href="#格式化文本的方式" class="headerlink" title="格式化文本的方式"></a>格式化文本的方式</h2><p>格式化是通过格式字符串指定的。</p>
<h1 id="元组tuples"><a href="#元组tuples" class="headerlink" title="元组tuples"></a>元组tuples</h1><p>元组（tuples）是一个类型不同的值的集合</p>
<blockquote>
<p>与 数组相反，数组是类型相同的值的集合</p>
</blockquote>
<p>使用圆括号声明</p>
<p><code>(T1,T2,...)</code></p>
<h1 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h1><p>数组（array）是相同类型的值的集合，存储在连续的内存中</p>
<p>使用方括号<code>[]</code>声明，</p>
<p>编译时就已经知道其长度，</p>
<p>可以用<code>[T;length]</code>的方式声明类型和长度，</p>
<ul>
<li>也可以通过直接赋值的方式声明，这样编译器也可以知道其类型和长度；</li>
</ul>
<h1 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h1><p><code>struct</code>：定义一个结构体；</p>
<p><code>enum</code>： 定义一个枚举；</p>
<p><strong>常量</strong>（constants）可以通过 <code>const</code> 和 <code>static</code>关键字来定义；</p>
<ul>
<li>生命周期都是整个程序执行周期；</li>
<li><code>const</code>，关键字定义的常量不可修改</li>
<li><code>static</code> ，支持可变，它的<code>&#39;static</code>生命周期可以被推断出来，不需要显示指定。同时访问或修改一个可变的<code>static</code>变量是<code>unsafe</code>的；</li>
<li>无论使用<code>const</code> 还是 <code>static</code> 定义常量，都需要声明变量类型；</li>
</ul>
<p><code>enum</code>，允许我们创建一种有可能有多个变体的类型。</p>
<ul>
<li><code>struct</code> 可以作为 <code>enum</code>的变体之一。</li>
<li>每种变体的类型都是该<code>enum</code>本身。</li>
<li><code>enum</code> 也可以创建方法。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WebEvent</span> &#123;</span><br><span class="line">    <span class="comment">// An `enum` may either be `unit-like`,</span></span><br><span class="line">    PageLoad,</span><br><span class="line">    PageUnload,</span><br><span class="line">    <span class="comment">// like tuple structs,</span></span><br><span class="line">    <span class="title function_ invoke__">KeyPress</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Paste</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="comment">// or c-like structures.</span></span><br><span class="line">    Click &#123; x: <span class="type">i64</span>, y: <span class="type">i64</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="在enum-中使用别名"><a href="#在enum-中使用别名" class="headerlink" title="在enum 中使用别名"></a>在enum 中使用别名</h2><ol>
<li>如果枚举名太长或太通用，可以通过<code>type</code> 的方式创建别名，可以使用别名引用枚举中的每一个变体。</li>
<li>最常见的情况是在<code>impl</code>块中使用<code>Self</code>别名。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">VeryVerboseEnumOfThingsToDoWithNumbers</span> &#123;</span><br><span class="line">    Add,</span><br><span class="line">    Subtract,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a type alias</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Operations</span> = VeryVerboseEnumOfThingsToDoWithNumbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// We can refer to each variant via its alias, not its long and inconvenient</span></span><br><span class="line">    <span class="comment">// name.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Operations::Add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Self 做impl 块中做别名的情况。</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">VeryVerboseEnumOfThingsToDoWithNumbers</span> &#123;</span><br><span class="line">    Add,</span><br><span class="line">    Subtract,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">VeryVerboseEnumOfThingsToDoWithNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>, x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span>::Add =&gt; x + y,</span><br><span class="line">            <span class="keyword">Self</span>::Subtract =&gt; x - y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An attribute to hide warnings for unused code.</span></span><br><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br></pre></td></tr></table></figure>



<h2 id="枚举也可以用作类C（C-like）的枚举"><a href="#枚举也可以用作类C（C-like）的枚举" class="headerlink" title="枚举也可以用作类C（C-like）的枚举???"></a>枚举也可以用作类C（C-like）的枚举???</h2><ul>
<li>没懂有什么不同，感觉差不多，不过样例中有注释显示&#x2F;隐式的标识符。</li>
<li>可能需要先了解一下C语言中的enum是什么样子的。</li>
</ul>
<p>explicit 显示的</p>
<p>implicit 隐式的</p>
<h1 id="amp-vs-ref"><a href="#amp-vs-ref" class="headerlink" title="&amp; vs ref"></a>&amp; vs ref</h1><p>涉及到 <code>ref</code> 的内容，我们通常是在 <code>match</code> 表达式中使用。</p>
<p>默认情况下，<code>match</code> 表达式会消耗匹配中的值，即匹配到的值的所有权会发生转移；</p>
<p>这种情况下，后面就不能再次使用这些值。因为被匹配的值的所有权已经发生<code>move</code>；</p>
<blockquote>
<p>如果匹配的类型实现了 Copy trait，则不会发生move，而是 copy。不会出现上面的问题。</p>
</blockquote>
<p>当后面需要使用该值的情况下，可能发生的遇到的问题，</p>
<ul>
<li>怎么解决？</li>
<li>使用<code>ref</code>；</li>
</ul>
<p><code>ref</code> 使用在模式匹配中，可以使其变为借用（borrow）而不是<code>move</code>；</p>
<p><code>ref</code> 使用在 <code>match</code> 中，并不会影响值是否被匹配，只会影响匹配的方式；</p>
<p>样例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 默认情况下的情况</span><br><span class="line">let maybe_name = Some(String::from(&quot;Alice&quot;));</span><br><span class="line">// The variable &#x27;maybe_name&#x27; is consumed here ...</span><br><span class="line">match maybe_name &#123;</span><br><span class="line">    Some(n) =&gt; println!(&quot;Hello, &#123;&#125;&quot;, n),</span><br><span class="line">    _ =&gt; println!(&quot;Hello, world&quot;),</span><br><span class="line">&#125;</span><br><span class="line">// ... and is now unavailable.</span><br><span class="line">println!(&quot;Hello again, &#123;&#125;&quot;, maybe_name.unwrap_or(&quot;world&quot;.into()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用了 `ref` 关键字的效果</span><br><span class="line">let maybe_name = Some(String::from(&quot;Alice&quot;));</span><br><span class="line">// Using `ref`, the value is borrowed, not moved ...</span><br><span class="line">match maybe_name &#123;</span><br><span class="line">    Some(ref n) =&gt; println!(&quot;Hello, &#123;&#125;&quot;, n),</span><br><span class="line">    _ =&gt; println!(&quot;Hello, world&quot;),</span><br><span class="line">&#125;</span><br><span class="line">// ... so it&#x27;s available here!</span><br><span class="line">println!(&quot;Hello again, &#123;&#125;&quot;, maybe_name.unwrap_or(&quot;world&quot;.into()));</span><br></pre></td></tr></table></figure>



<h3 id="amp-vs-ref-1"><a href="#amp-vs-ref-1" class="headerlink" title="&amp; vs ref"></a><code>&amp;</code> vs <code>ref</code></h3><ul>
<li><code>ref</code> ，表示我们仅引用该值，</li>
<li><code>&amp;</code>，表示我们期望使用一个对象的引用，<ul>
<li><code>&amp;Foo</code> 与 <code>Foo</code> 是不一样的。</li>
</ul>
</li>
</ul>
<p><a href="https://doc.rust-lang.org/stable/std/keyword.ref.html">ref - Rust (rust-lang.org)</a></p>
<p>关键字 ref 与 主类型 reference 的区别</p>
<h1 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h1><p>这种行为称为 <code>variable bindings</code>，变量绑定；</p>
<p>编译器会警告没有使用的变量绑定。此时，可以通过使用带有下划线（underscore）的变量名的形式消除警告。</p>
<p><code>let _unused_variable = 3u32;</code></p>
<p><code>block</code>，在 Rust 中，变量绑定是由作用域的（语言都有），并且被限制在一个<code>block</code>中；</p>
<ul>
<li>block 是一个用花括号括起来的语句（statements）的集合；</li>
</ul>
<p>变量 shadow</p>
<p>变量 freezing</p>
<ul>
<li>在 shadow 的时候，如果使用不可变变量覆盖可变可变量，那么原来的可变变量就会发生<code>freezing</code>，即不能发生修改，直到不可变绑定离开作用域。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_mutable_integer</span> = <span class="number">7i32</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Shadowing by immutable `_mutable_integer`</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_mutable_integer</span> = _mutable_integer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Error! `_mutable_integer` is frozen in this scope</span></span><br><span class="line">        _mutable_integer = <span class="number">50</span>;</span><br><span class="line">        <span class="comment">// FIXME ^ Comment out this line</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// `_mutable_integer` goes out of scope</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ok! `_mutable_integer` is not frozen in this scope</span></span><br><span class="line">    _mutable_integer = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="类型-type"><a href="#类型-type" class="headerlink" title="类型 type"></a>类型 type</h1><h2 id="基础数据类型间的转换"><a href="#基础数据类型间的转换" class="headerlink" title="基础数据类型间的转换"></a>基础数据类型间的转换</h2><p><strong>Casting</strong></p>
<p>Rust 不提供基础数据类型间的隐式转换（强制类型转换）</p>
<p>但是，可以使用 <code>as</code> 关键字执行显式类型转换(类型转换 casting)。</p>
<ul>
<li>整型（integer）之间的转换通常遵循 C 语言的约定</li>
<li>只有 <code>u8</code> 类型可以转为 <code>char</code> 类型，其他类型不可以；</li>
</ul>
<blockquote>
<p>任何有符号的值转换为无符号的值T，都有：</p>
<p>原值 +&#x2F;- (T::MAX +1) 直到结果能填充到新的类型中。</p>
<p>但是对于底层，则是通过而二进制的截取或补充而的到的最终结果。</p>
<p>高位-&gt; 低位，就是截掉高位，仅保留低位的数。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -1 + 256 = 255</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;  -1 as a u8 is : &#123;&#125;&quot;</span>, (-<span class="number">1i8</span>) <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>float 转 int，在 Rust 1.45之后，使用 <code>as</code> 关键字转换时，如果浮点数超过了目标类型可以表示的数字范围，那么返回的结果就是最靠近的边界的值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 300 超过了u8的最大值255，所以返回值为255；</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;300.0 is &#123;&#125;&quot;</span>, <span class="number">300.0f32</span> <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line"><span class="comment">// 同理，返回值为 0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;-100.0 as u8 is: &#123;&#125;&quot;</span>, -<span class="number">100.0_f32</span> <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line"><span class="comment">// 返回值为0，NAN 即 not a number    </span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;nan as u8 is : &#123;&#125;&quot;</span>, <span class="type">f32</span>::NAN <span class="keyword">as</span> <span class="type">u8</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="From-and-Into"><a href="#From-and-Into" class="headerlink" title="From and Into"></a>From and Into</h1><p>实现这两个 trait ，允许我们方便的将 类型A 与 类型B 互转。</p>
<p>实现了 <code>From</code> 和 <code>Into</code> trait 的类型，会分别实现 <code>from</code> 和 <code>into</code> 两个关联函数。</p>
<p>我们也可以为自定义类型实现 <code>From</code> 和 <code>Into</code> 两个 trait，以实现指定类型的互转。</p>
<blockquote>
<p>注意，通常，我们只需要为自定义类型 B 实现 <code>From</code> trait ，即 type A -&gt; type B。</p>
<p>当我们需要 type B -&gt; type A 的时候，不需要为type A 实现 Into trait，只需要在使用时显示的声明变量类型即可。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为 i32 -&gt; Number 实现了 from</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Number</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">int</span> = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 这里显示声明 Number类型即可。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span>: Number = int.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型参数为 &amp;str </span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;&amp;<span class="type">str</span>&gt; <span class="keyword">for</span> <span class="title class_">Method</span> &#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型参数为 String</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">HttpRequest</span> &#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="转换为-String"><a href="#转换为-String" class="headerlink" title="转换为 String"></a>转换为 String</h1><p>将一个类型转为 <code>String</code> 需要实现 <code>ToString</code>  trait，同时更简单方法是为其实现<code>fmt::Display</code> trait，该 trait会自动实现 <code>ToString</code> trait，并且允许打印</p>
<h2 id="TryFrom-与-From"><a href="#TryFrom-与-From" class="headerlink" title="TryFrom 与 From"></a>TryFrom 与 From</h2><p>在实现类型转换时，除了可以实现 <code>From</code> trait 外，还可以实现 <code>TryFrom</code> trait，但是这两个 trait 同时只能实现一个，否则会有冲突。</p>
<p>如何选择？</p>
<ul>
<li>转换时不会出错，实现 <code>From</code> trait；</li>
<li>转换时可能会出错，实现 <code>TryFrom</code> trait；<ul>
<li>注意，<code>TryFrom</code>，实现时需要提供一个错误类型；</li>
</ul>
</li>
</ul>
<h1 id="指针的解构和解引用"><a href="#指针的解构和解引用" class="headerlink" title="指针的解构和解引用"></a>指针的解构和解引用</h1><p>对于<strong>指针</strong>来说，destructuring 和 dereferencing 是不同的概念。</p>
<p>引用是指针的一种。</p>
<p>dereferencing（解引用）</p>
<ul>
<li>使用 <code>*</code>；追踪引用所指向的数据。</li>
</ul>
<p>destructuring（解构&#x2F;析构）</p>
<ul>
<li>使用 <code>&amp;</code>，<code>ref</code> 和 <code>ref mut</code>；</li>
</ul>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>下面三个与迭代器有关的方法的使用提示。</p>
<ul>
<li><p><code>x.iter()</code></p>
</li>
<li><p><code>x.iter_mut()</code></p>
</li>
<li><p><code>x.into_iter()</code></p>
</li>
</ul>
<p><code>x.iter()</code>，返回类型为<code>Iter&lt;&#39;_, T&gt;</code> ，其被迭代元素的返回类型（即，<code>type Item</code>）是 <code>&amp;T</code>；</p>
<p><code>x.iter_mut()</code>，返回类型为<code>IterMut&lt;&#39;_, T&gt;</code>，其被迭代元素的返回类型（即，<code>type Item</code>）是<code>&amp;mut T</code>；</p>
<ul>
<li>容易搞错的部分是看到返回类型中的T，就以为迭代元素的类型也是T，其实不是。</li>
</ul>
<p><code>x.into_iter()</code>，返回类型为<code>Iterator&lt;Item = Self::Item&gt;</code>，，其被迭代元素的返回类型（即，<code>type Item</code>）是<code>T</code>；</p>
<p>样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec2</span> = <span class="built_in">vec!</span>[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;2 in vec1: &#123;&#125;&quot;</span>, vec1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">any</span>(|&amp;x| x == <span class="number">2</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;2 in vec2: &#123;&#125;&quot;</span>, vec2.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">any</span>(|x| x == <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码表示</p>
<p>同时可以通过for循环的方式来查看迭代器迭代元素的类型，</p>
<p>样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IDE中会显示 v的数据类型</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> vec1.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为了在常见情况下使用，<code>for</code> 结构体默认会使用 <code>.into_iter()</code> 方法将集合转换为迭代器。</p>
<p>当然也可以指定其他方法来转换为迭代器。</p>
<h1 id="泛型中的-trait-bounds"><a href="#泛型中的-trait-bounds" class="headerlink" title="泛型中的 trait bounds"></a>泛型中的 trait bounds</h1><p>在使用泛型作为类型参数时，通常会使用 trait bounds 来约束类型可以实现的功能。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">printer</span>&lt;T: Display&gt;(t: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong> 即使 trait 不包含任何东西（空 trait），我们依然可以将它作为 trait bounds。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cardinal</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BlueJay</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Turkey</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Red</span> &#123;&#125;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Blue</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Red</span> <span class="keyword">for</span> <span class="title class_">Cardinal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Blue</span> <span class="keyword">for</span> <span class="title class_">BlueJay</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These functions are only valid for types which implement these</span></span><br><span class="line"><span class="comment">// traits. The fact that the traits are empty is irrelevant.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">red</span>&lt;T: Red&gt;(_: &amp;T)   <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123; <span class="string">&quot;red&quot;</span> &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">blue</span>&lt;T: Blue&gt;(_: &amp;T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123; <span class="string">&quot;blue&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cardinal</span> = Cardinal;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">blue_jay</span> = BlueJay;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_turkey</span>   = Turkey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `red()` won&#x27;t work on a blue jay nor vice versa</span></span><br><span class="line">    <span class="comment">// because of the bounds.</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A cardinal is &#123;&#125;&quot;</span>, <span class="title function_ invoke__">red</span>(&amp;cardinal));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A blue jay is &#123;&#125;&quot;</span>, <span class="title function_ invoke__">blue</span>(&amp;blue_jay));</span><br><span class="line">    <span class="comment">//println!(&quot;A turkey is &#123;&#125;&quot;, red(&amp;_turkey));</span></span><br><span class="line">    <span class="comment">// ^ <span class="doctag">TODO:</span> Try uncommenting this line.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="作用域之部分转移"><a href="#作用域之部分转移" class="headerlink" title="作用域之部分转移"></a>作用域之部分转移</h1><p><code>partial move</code> ，如果一个struct的<strong>存在没有实现 <code>Copy</code> trait 的字段</strong>的时候，那么当这个类型实例通过<strong>解构</strong>，将字段赋值给其他变量后，没有实现 <code>Copy</code> trait的字段就会发生<strong>所有权的转移</strong>，那么该类型的实例就不能再作为一个整体来使用了，仅能使用未发生所有权转移的部分。</p>
<p>参考下面样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        age: <span class="type">u8</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>),</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `name` is moved out of person, but `age` is referenced</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Person</span> &#123; name, <span class="keyword">ref</span> age &#125; = person;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The person&#x27;s age is &#123;&#125;&quot;</span>, age);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The person&#x27;s name is &#123;&#125;&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error! borrow of partially moved value: `person` partial move occurs</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">//println!(&quot;The person struct is &#123;:?&#125;&quot;, person);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `person` cannot be used but `person.age` can be used as it is not moved</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;</span>, person.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：</p>
<ol>
<li>一个 struct 为所有可能发生所有权转移的字段类型实现 <code>Copy</code> trait；（成本高）</li>
<li>（推荐）当以引用的方式使用时，例如 <code>&amp;</code> 和 <code>ref</code>；</li>
<li>如果发生在 <code>match</code> 表达式中，可以使用 <code>_</code> 不绑定值，即不获取所有权；</li>
</ol>
<h1 id="借用，ref-模式"><a href="#借用，ref-模式" class="headerlink" title="借用，ref 模式"></a>借用，ref 模式</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"><span class="comment">// 在赋值语句中，`ref` 在左侧，与使用`&amp;`在右侧是相等的。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref</span> ref_c1 = c;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ref_c2</span> = &amp;c;</span><br></pre></td></tr></table></figure>





<h1 id="Copy-amp-Clone"><a href="#Copy-amp-Clone" class="headerlink" title="Copy &amp; Clone"></a>Copy &amp; Clone</h1><p><code>Clone</code> 是 <code>Copy</code> 的supertrait，即要实现<code>Copy</code> trait 一定要先实现<code>Clone</code> trait。</p>
<h2 id="Copy-与-Clone-的不同"><a href="#Copy-与-Clone-的不同" class="headerlink" title="Copy 与 Clone 的不同"></a>Copy 与 Clone 的不同</h2><p>Copy 是隐式执行的，</p>
<p>Clone 是显示执行的，显示调用 <code>x.clone()</code>;</p>
<h3 id="有两种方式实现Copy-trait"><a href="#有两种方式实现Copy-trait" class="headerlink" title="有两种方式实现Copy trait"></a>有两种方式实现<code>Copy</code> trait</h3><p>方法一，通过<code>#[derive(Clone,Copy)]</code> 的方式派生；</p>
<p>方法二，分别手动实现<code>Clone</code>和<code>Copy</code> trait。</p>
<blockquote>
<p>注意：为 struct 实现 <code>Copy</code> 时，只有当struct的所有字段都实现了 <code>Copy</code> trait 时，才能为struct 整体实现 <code>Copy</code> ，否则不可以。</p>
</blockquote>
<p>更多内容参考标准库内容。</p>
<h1 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h1><p>Rust 有几个保留字用于生命周期命名。</p>
<p><code>&#39;static</code></p>
<p>有两种情况会遇到<code>&#39;static</code>,</p>
<ol>
<li>作为引用的 static 生命周期；</li>
<li>作为 trait bound 的一部分；</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为引用的生命周期</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// 作为trait bound 的一部分</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T&gt;(x: T) <span class="keyword">where</span> T: <span class="symbol">&#x27;static</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-引用的作为生命周期"><a href="#1-引用的作为生命周期" class="headerlink" title="1. 引用的作为生命周期"></a>1. 引用的作为生命周期</h3><p>有两种方式使得一个变量获取<code>&#39;static</code> 的生命周期。它们都存在二进制的只读内存中？？？</p>
<blockquote>
<p>There are two ways to make a variable with <code>&#39;static</code> lifetime, and both are stored in the read-only memory of the binary:</p>
</blockquote>
<ul>
<li>使用 <code>static</code> 声明一个常量；</li>
<li>创建一个字符串字面值，即 <code>&amp;&#39;static str</code>；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> NUM: <span class="type">i32</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">static_string</span> = <span class="string">&quot;I&#x27;m in read-only memory&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="2-作为-trait-bound-的一部分"><a href="#2-作为-trait-bound-的一部分" class="headerlink" title="2. 作为 trait bound 的一部分"></a>2. 作为 trait bound 的一部分</h3><p>作为 trait bound 时，意味着类型 T 不能有非静态的引用（即全部都要时静态的static）。</p>
<p><strong>注意：</strong>有一点比较重要，任何拥有所有权的数据永远可以传递<code>&#39;static</code> 条件的生命周期，但是引用通常不行。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Debug</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_it</span>( input: <span class="keyword">impl</span> <span class="title class_">Debug</span> + <span class="symbol">&#x27;static</span> ) &#123;</span><br><span class="line">    <span class="built_in">println!</span>( <span class="string">&quot;&#x27;static value passed in is: &#123;:?&#125;&quot;</span>, input );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// i is owned and contains no references, thus it&#x27;s &#x27;static:</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_it</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oops, &amp;i only has the lifetime defined by the scope of</span></span><br><span class="line">    <span class="comment">// main(), so it&#x27;s not &#x27;static:</span></span><br><span class="line">    <span class="title function_ invoke__">print_it</span>(&amp;i);  <span class="comment">// 编译器会报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会报错：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error[E0597]: `i` does not live long enough</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/lib.rs:<span class="number">15</span>:<span class="number">15</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">15</span> |     <span class="title function_ invoke__">print_it</span>(&amp;i);</span><br><span class="line">   |     ---------^^--</span><br><span class="line">   |     |         |</span><br><span class="line">   |     |         borrowed value does not live long enough</span><br><span class="line">   |     argument requires that `i` is borrowed <span class="keyword">for</span> `<span class="symbol">&#x27;static</span>`</span><br><span class="line"><span class="number">16</span> | &#125;</span><br><span class="line">   | - `i` dropped here <span class="keyword">while</span> still borrowed</span><br></pre></td></tr></table></figure>





<h1 id="struct-与-trait-中的方法实现"><a href="#struct-与-trait-中的方法实现" class="headerlink" title="struct 与 trait 中的方法实现"></a>struct 与 trait 中的方法实现</h1><p>在 Rust 中尽管为 struct 实现的方法与为其实现 trait 的方法是分开的，但是在实际定义和使用时，依然可以把它们看作是一个整体，在相互的作用域内可以互相调用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_naked</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.naked</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">shear</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 impl Animal for Sheep 中的 name()</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is already naked...&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">name</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the `Animal` trait for `Sheep`.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 impl Sheep 中的 is_naked() 方法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">is_naked</span>() &#123;</span><br><span class="line">            <span class="string">&quot;baaaaah?&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="keyword，modifier"><a href="#keyword，modifier" class="headerlink" title="keyword，modifier"></a>keyword，modifier</h1><p>查看官方文档，了解哪些常用的保留字是关键词或修饰符。</p>
<blockquote>
<p>问题，根据什么来判断定义一个词是keyword？还是modifier？</p>
</blockquote>
<p>关键词</p>
<ul>
<li><code>ref</code></li>
</ul>
<p>修饰符</p>
<ul>
<li><code>mut</code></li>
</ul>
<h1 id="todo-宏与-unimplemented-宏的区别"><a href="#todo-宏与-unimplemented-宏的区别" class="headerlink" title="todo! 宏与 unimplemented! 宏的区别"></a>todo! 宏与 unimplemented! 宏的区别</h1><h1 id="crate-mod"><a href="#crate-mod" class="headerlink" title="crate,mod"></a>crate,mod</h1><p>“src\result_rbe.rs” and “src\result_rbe\mod.rs” 是相等的</p>
<h1 id="Derive-trait"><a href="#Derive-trait" class="headerlink" title="Derive trait"></a>Derive trait</h1><p>Rust 提供了几个通过使用<code>#[derive]</code> 属性自动实现的trait。</p>
<ul>
<li>也可以手动实现。</li>
</ul>
<p>下面是可派生的 trait:</p>
<ul>
<li>用于比较的 trait ：<code>Eq</code>，<code>PartialEq</code>，<code>Ord</code>，<code>PartialOrd</code>；<ul>
<li>这四个的区别？</li>
<li><code>PartialEq</code> 允许使用 <code>==</code>或 <code>!=</code>对类型进行比较</li>
<li><code>Eq</code> 只能用在实现了<code>PartialEq</code> 的类型上；</li>
<li><code>PartialOrd</code> 用于排序比较即，<code>&gt;,&lt;,&gt;=,&lt;=</code>；也只能用在实现了<code>PartialEq</code> 的类型上；</li>
<li><code>Ord</code>，还没看。</li>
</ul>
</li>
<li><code>Clone</code></li>
<li><code>Copy</code>，实现该 trait，可以通过 copy 所有权代替 move 所有权。（需要同时添加 <code>Clone</code>，因为<code>Clone</code> 是 <code>Copy</code> 的supertrait）；</li>
<li><code>Hash</code>，计算一个引用的hash</li>
<li><code>Default</code>，创建一个空的数据类型实例；</li>
<li><code>Debug</code>，使用<code>&#123;:?&#125;</code> 的方式打印值；</li>
</ul>
<h1 id="trait-对象"><a href="#trait-对象" class="headerlink" title="trait 对象"></a>trait 对象</h1><p>因为 rust 编译器要求每个类型都要知道内存大小。所以类型要确定。</p>
<p>Rust 在堆上分配内存，无论何时都会尽可能明确。</p>
<p>这种情况下，单独使用 trait 是不行的，但是可以通过指针间接处理。</p>
<p>可以使用 <code>Box</code> 引用指向堆内存。</p>
<p><code>Box&lt;dyn Trait&gt;</code></p>
<p>例如：<code>Box&lt;dyn Animal&gt;</code></p>
<h1 id="所有权与方法调用"><a href="#所有权与方法调用" class="headerlink" title="所有权与方法调用"></a>所有权与方法调用</h1><p>拥有所有权的实例，调用方法时，</p>
<ul>
<li>不可变实例（immutable）：可以调用第一个参数为 <code>self</code> ，<code>mut self</code>和 <code>&amp;self</code> 的方法，</li>
<li>可变实例（mutable）：可以调用第一个参数为 <code>self</code>，<code>&amp;self</code> ， <code>mut self</code> 和 <code>&amp;mut self</code> 形式的方法。</li>
</ul>
<p>注意：尽管创建方法时第一个参数声明为 <code>**mut** self</code>，但是调用时，可能就变成 <code>self</code> 了，可以查看调用处的函数签名就能发现。所以这也是为什么不可变实例，也能调用 <code>**mut** self</code> 的原因。</p>
<h1 id="Cargo-中的惯例"><a href="#Cargo-中的惯例" class="headerlink" title="Cargo 中的惯例"></a>Cargo 中的惯例</h1><p>Cargo 中有一些约定俗成的惯例，遵守这些惯例有利于让 Rust 开发者更容易阅读你的代码。</p>
<p>文件位置上的惯例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">package</span><br><span class="line">|-- src                   <span class="comment">// 功能源码所在目录</span></span><br><span class="line">|   |-- bin       		  <span class="comment">// 其他二进制文件所在目录</span></span><br><span class="line">|   |   |-- &lt;name&gt;.rs</span><br><span class="line">|   |-- main.rs           <span class="comment">// 默认的main二进制文件</span></span><br><span class="line">|	|-- lib.rs            <span class="comment">// 默认的库文件</span></span><br><span class="line">|-- tests                 <span class="comment">// 集成测试所在目录</span></span><br><span class="line">	|-- &lt;test_name&gt;.rs</span><br><span class="line">|-- benches               <span class="comment">// 基准测试所在目录</span></span><br><span class="line">|	|-- &lt;benche_name&gt;.rs</span><br><span class="line">|-- examples              <span class="comment">// 样例所在目录</span></span><br><span class="line">|	|-- &lt;example_name&gt;.rs</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="导出包的使用技巧"><a href="#导出包的使用技巧" class="headerlink" title="导出包的使用技巧"></a>导出包的使用技巧</h1><p>技巧1，巧妙组合放入 prelude 中，在第三方 crate 中很常见的技巧。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.rs 文件中</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> prelude &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> crate::assert::PathAssert;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> crate::fixture::FileTouch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 先使用 <span class="keyword">pub</span> <span class="keyword">use</span> 将指定的内容重新导出，方便对外访问；</span><br><span class="line"><span class="number">2</span>. 在使用 <span class="keyword">pub</span> <span class="keyword">mod</span> prelude，将这些内容部分核心 <span class="keyword">trait</span> 放到 prelude 中，这样在使用时，可直接通过 `<span class="keyword">use</span> assert_fs::prelude::*` 的形式全部引入使用的代码中，这样基本在实际使用时大部分情况下这个 <span class="keyword">crate</span> 中涉及的引用内容都在这里了。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Cargo toml配置文件使用记录</title>
    <url>//Cargo%20toml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="dependencies"><a href="#dependencies" class="headerlink" title="[dependencies]"></a>[dependencies]</h1><p>在同一个 workspace 下，如何引用其他 cargo 子项目？</p>
<p>答：</p>
<p>通过 path 指定相对路径的方式</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">utils</span> = &#123;path = <span class="string">&quot;../utils&quot;</span>&#125;</span><br></pre></td></tr></table></figure>







<h1 id="package-section"><a href="#package-section" class="headerlink" title="[package] section"></a><code>[package]</code> section</h1><p>default-run &#x3D; “xxx”</p>
<p>表明，当执行 cargo 命令的时候，如果不指定 package 下的 bin 文件时，会默认执行该二进制文件。</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 默认执行 teacher-service.rs 二进制文件</span></span><br><span class="line"><span class="attr">default-run</span> = <span class="string">&quot;teacher-service&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="bin-section"><a href="#bin-section" class="headerlink" title="[[bin]] section"></a><code>[[bin]]</code> section</h1><p>name&#x3D;”xxx”</p>
<ul>
<li>指定 bin 目录下的二进制文件名（不用带后缀）；</li>
<li>一个文件一个 <code>[[bin]]</code> section；</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust hello world</title>
    <url>//Rust%20hello%20world.html</url>
    <content><![CDATA[<h1 id="Rust-编程入门"><a href="#Rust-编程入门" class="headerlink" title="Rust 编程入门"></a>Rust 编程入门</h1><h2 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">rustup doc</span><br></pre></td></tr></table></figure>

<p>更新到最新版本</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">rustup update</span><br></pre></td></tr></table></figure>



<h2 id="Rust-程序解剖"><a href="#Rust-程序解剖" class="headerlink" title="Rust 程序解剖"></a>Rust 程序解剖</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义函数：fn main(){}</p>
<ul>
<li>没有参数，没有返回值</li>
</ul>
<p><code>main</code> 函数是每个 Rust 可执行程序最先运行的代码；</p>
<p>打印文本： println!(“Hello World”);</p>
<ul>
<li>Rust 的缩进是 4 个空格，而不是 tab</li>
<li><code>println!</code> 是一个 Rust macro（宏）<ul>
<li>如果是函数的话，没有 <code>!</code></li>
</ul>
</li>
<li>代码以 <code>;</code> 结尾</li>
</ul>
<h2 id="Rustc-编译与运行"><a href="#Rustc-编译与运行" class="headerlink" title="Rustc 编译与运行"></a>Rustc 编译与运行</h2><ul>
<li><p>运行 Rust 程序前必须先编译，命令： <code>rustc 源文件名</code></p>
<ul>
<li>rustc 中的 c &#x3D;&gt; compiler 编译器，的意思；</li>
<li>rustc main.rs</li>
</ul>
</li>
<li><p>编译成功后，会生成一个二进制文件</p>
<ul>
<li><p>Windows 下为 <code>源文件名.exe</code>；Linux&#x2F;Mac 下为 <code>源文件名</code></p>
</li>
<li><p>windows 上还会生成一个 <code>.pdb</code>文件，里面包含调试信息</p>
</li>
</ul>
</li>
<li><p>Rust 是 <code>ahead-of-time</code> 即预先编译的语言</p>
<ul>
<li>可以先编译程序，然后把可执行文件交给别人运行（无需安装 Rust）</li>
</ul>
</li>
<li><p>rustc 只适合简单的 Rust 程序，项目使用 cargo 编译工具来编译</p>
<ul>
<li>这里类似 javac 与 java 的关系，单个文件使用 javac 来编译，项目使用 maven&#x2F;gradle&#x2F;ant 等编译工具</li>
</ul>
</li>
</ul>
<h2 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h2><ul>
<li>cargo 是 Rust 的构建工具（构建系统和包管理工具）<ul>
<li>构建代码，下载依赖库，构建这些库。。。</li>
<li>类似 java 的 maven</li>
</ul>
</li>
<li>安装 Rust 的时候会安装 cargo<ul>
<li><code>cargo --version</code></li>
</ul>
</li>
</ul>
<h2 id="使用-cargo-创建项目"><a href="#使用-cargo-创建项目" class="headerlink" title="使用 cargo 创建项目"></a>使用 cargo 创建项目</h2><ul>
<li>创建项目： <code>cargo new &lt;项目名&gt;</code><ul>
<li>cargo new hello_cargo</li>
<li>会创建一个新的目录（项目名目录）<ul>
<li>Cargo.toml</li>
<li>src 目录<ul>
<li>main.rs</li>
</ul>
</li>
<li>初始化了一个新的 Git 仓库， .gitignore<ul>
<li>可以使用其他的 vcs 或者不适用 vcs：cargo new 的时候使用 –vcs 这个flag</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Cargo.toml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;hello-cargo&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2021&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line">[dependencies]</span><br></pre></td></tr></table></figure>

<ul>
<li>TOML (Tom’s Obvious, Minimal Language) 格式，是 Cargo 配置文件的格式<ul>
<li>类似与 YAML 和 JSON</li>
</ul>
</li>
<li>[package] ，是一个区域标题（section），表示下方内容是用来配置包（package）的，cargo 编译程序需要的配置<ul>
<li>name，项目名</li>
<li>version，项目版本</li>
<li>edition，使用的 Rust 版本</li>
<li>…，其他内容会根据系统自动提取，例如，authors 作者</li>
</ul>
</li>
<li>[dependencies]，它会列出项目的依赖项</li>
<li>还可以增加其他片段&#x2F;区域(section)</li>
</ul>
<h4 id="Cargo-lock-文件确保构建是可重现的"><a href="#Cargo-lock-文件确保构建是可重现的" class="headerlink" title="Cargo.lock 文件确保构建是可重现的"></a>Cargo.lock 文件确保构建是可重现的</h4><p>Cargo 通过 Cargo.lock 文件来确保任何人在任何时候重新构建代码，都会生成相同的结果。</p>
<p>Cargo 只会使用你指定的依赖版本，除非重新修改配置文件中的依赖版本。</p>
<p>在第一次构建项目时，Cargo 计算出所有符合要求的依赖版本，并写入 Cargo.lock 文件。当之后构建项目时，Cargo 会发现 Cargo.lock 已存在并使用其中指定的版本，而不是再次计算所有的版本。</p>
<h5 id="更新-crate-到一个新版本"><a href="#更新-crate-到一个新版本" class="headerlink" title="更新 crate 到一个新版本"></a>更新 crate 到一个新版本</h5><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo update</span><br></pre></td></tr></table></figure>

<p>这个命令会忽略 <code>Cargo.lock</code> 文件，并计算出所有符合 Cargo.toml 声明的最新版本。如果成功了，Cargo 会把这些版本写入 Cargo.lock 文件。</p>
<h2 id="构建并运行-Cargo-项目"><a href="#构建并运行-Cargo-项目" class="headerlink" title="构建并运行 Cargo 项目"></a>构建并运行 Cargo 项目</h2><p>Cargo 的命令是操作系统无关的，不管使用什么操作系统，命令一样。</p>
<ul>
<li><code>cargo build</code> ，<strong>编译并生成</strong>可执行文件。<ul>
<li>首次运行时，会在项目根目录创建一个 <strong><code>Cargo.lock</code><strong>文件，记录项目以来的实际版本（</strong>永远不需要碰该文件</strong>，让 Cargo 处理就行）。</li>
<li>在项目根目录下生成 <code>target/debug</code>&#x2F;项目可执行文件，可以直接运行</li>
</ul>
</li>
<li><code>cargo check</code> ，可以<strong>快速检查</strong>代码，确保其可以编译，但不产生可执行文件。<ul>
<li>适用于编写代码时定期运行 <code>cargo check</code> ，确保它们可以编译，加速开发。</li>
</ul>
</li>
<li><code>cargo run</code> ，通过一条命令，<strong>编译并运行</strong>生成的可执行文件。<ul>
<li>相当于 <code>cargo build</code> + 运行文件</li>
</ul>
</li>
<li><code>cargo build --release</code> ，发布构建<ul>
<li>可以优化编译项目。<ul>
<li>有些优化可以让 Rust 代码运行的更快。不过启用这些优化也需要消耗更长的编译时间。所以会有两种不同的编译方式</li>
<li>一种用来快速重新构建；</li>
<li>一种是为用户构建最终程序，不会经常重新构建，并且希望程序运行越快越好。</li>
</ul>
</li>
<li>会在<code>target/release</code> 目录下生成可执行文件。</li>
</ul>
</li>
</ul>
<h1 id="2-猜数小游戏"><a href="#2-猜数小游戏" class="headerlink" title="2. 猜数小游戏"></a>2. 猜数小游戏</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入非 prelude 模块中的内容，需要使用 use 关键字来导入</span></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;  <span class="comment">// fn 用来声明函数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);  </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取用户输入并打印结果作为输出，需要使用 <code>io</code>库，<code>io</code>库来自标准库（也被称为<code>std</code>）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>prelude</code> 是 Rust 的预导入模块，有少量类型可以直接使用。如果需要的类型不在 <code>prelude</code> 中，就必须使用 <code>use</code> 语句显示的将其引入作用域中。</li>
<li><code>std::io</code> 库是 Rust 的标准库之一。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fn</code> 语法用来声明一个函数</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>let</code> 语句用来创建变量(variable)。</p>
</li>
<li><p>默认 Rust 的变量是不可变的。（这个会在后面讨论，变量与可变性）。需要在变量名前使用 <code>mut</code> 关键字使其成为可变边变量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">apples</span> = <span class="number">5</span>; <span class="comment">// immutable</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">bananas</span> = <span class="number">5</span>; <span class="comment">// mutable</span></span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">遇到的问题</span><br><span class="line">use std::io;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Guess the number!&quot;);</span><br><span class="line">    println!(&quot;Please input your guess.&quot;);</span><br><span class="line">    let mut guess = String::new();</span><br><span class="line">    let mut apples = 5;  // line 8,9 两行，为什么 apples 重新赋值后，编译运行时，第8行还会有warning 告警？后面学习时看看能不能解答这个疑惑？</span><br><span class="line">    apples = 6;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,apples);</span><br><span class="line">    io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;You guessed: &#123;&#125;&quot;, guess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行告警如下：</span><br><span class="line">PS C:\Tableware\codes\rust\guessing_game&gt; cargo run</span><br><span class="line">   Compiling guessing_game v0.1.0 (C:\Tableware\codes\rust\guessing_game)</span><br><span class="line">warning: value assigned to `apples` is never read</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">src\main.rs:7:13</span></span><br><span class="line">  |</span><br><span class="line">7 |     let mut apples = 5;</span><br><span class="line">  |             ^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_assignments)]` on by default</span><br><span class="line">  = help: maybe it is overwritten before being read?</span><br><span class="line"></span><br><span class="line">warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.68s</span><br><span class="line">     Running `target\debug\guessing_game.exe`</span><br><span class="line">Guess the number!</span><br><span class="line">Please input your guess.</span><br><span class="line">6</span><br><span class="line">12</span><br><span class="line">You guessed: 12</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Rust遇到过的问题</title>
    <url>//%E5%AD%A6%E4%B9%A0Rust%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>Windows 上新安装 Rust 遇到过的问题</p>
<h2 id="1-首次-cargo-run-运行时缺少-linker-文件"><a href="#1-首次-cargo-run-运行时缺少-linker-文件" class="headerlink" title="1. 首次 cargo run 运行时缺少 linker 文件"></a>1. 首次 cargo run 运行时缺少 linker 文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: linker `link.exe` not found</span><br><span class="line">note: The system cannot find the file specified. (os error 2)</span><br><span class="line">note: the msvc targets depend on the msvc linker but `link.exe` was not found</span><br><span class="line">note: please ensure that VS 2013, VS 2015 or VS 2017 was installed with the Visual C++ option</span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<ol>
<li><p>通常登录 Rust 官网地址，选择安装时，会有相关提示，同时会给出一个下载 Build Tools 的地址，跳转后下载 Build Tools 文件即Visual Studio Installer，然后安装，注意，在安装界面选择 <code>C++</code>的那个组件即可，其他的组件不用安装，选择组件后，右侧会显示需要安装的模块，确保勾选了 <code>VS xxx C++ build tools</code>等与 C++ 有关的模块即可。安装后重启。</p>
</li>
<li><p><a href="https://stackoverflow.com/questions/55603111/unable-to-compile-rust-hello-world-on-windows-linker-link-exe-not-found">更多内容参考</a> ，StackOverflow 上第二个答案网上说也是可以的，没有尝试过。</p>
</li>
</ol>
<h1 id="vscode-使用注意事项"><a href="#vscode-使用注意事项" class="headerlink" title="vscode 使用注意事项"></a>vscode 使用注意事项</h1><p>使用vscode + rust-analyzer 写rust 时，项目名不要命名为 rust 的关键字，否则会报错：</p>
<ul>
<li>自动补全功能不能使用，且会报错，</li>
<li>例如，cargo new lifetime 那么该项目中就会报错</li>
<li>rust-analyzer 插件在vscode中的 <strong>快速修复</strong> 快捷键不能使用，<ul>
<li>解决：是因为与输入法的中英文标点切换的快捷键冲突了，关掉搜狗、微软输入法设置中的快捷键即可。</li>
</ul>
</li>
</ul>
<h1 id="20211207"><a href="#20211207" class="headerlink" title="20211207"></a>20211207</h1><ol>
<li><p>一个结点就能够引用其父结点，但不拥有其父结点。</p>
<ul>
<li>代码里不是传的引用吗？怎么就拥有了？</li>
</ul>
</li>
<li><p>大部分情况下，所有权是非常明确的，可以准确的知道哪个变量拥有某个值。</p>
</li>
<li><p>rust 有么有什么好用的编辑器？</p>
<ul>
<li>vscode 默认使用代码提示功能有些弱，是否需要添加什么插件？</li>
</ul>
</li>
<li><p>match 表达式赋值？Rust 是怎样处理的？</p>
</li>
<li><p>看下面这段代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码中 `other_error` 这个内部变量的作用与 `_` 一样吗？是可以代指余下所有的错误类型吗？</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Rust 中，如果定义一个枚举，任何值只能是一个枚举的成员，且枚举的成员从根本上将仍是枚举，所以使用枚举中任何成员时，都应该看做是相同的类型。</p>
<ul>
<li>例如：IP地址要么是IPv4，要么是IPv6，只能是其中之一，且IPv4和IPv6都是IP地址，所以任何类型的IP地址都是看做相同的类型；</li>
<li>举例2：Result&lt;T,E&gt;，无论是 Ok(T) ，还是 Err(E)，它们本质上都是一种结果。所以在使用时，Ok 和 Err 是相同类型，即 Result。</li>
</ul>
</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://kaisery.github.io/trpl-zh-cn/ch10-00-generics.html">泛型、trait 与生命周期</a> 章节的例子</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视频中说，这里相当于发生了解构，或者说是模式匹配？</span></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;   <span class="comment">// list 是切片，一种引用，item 为什么也是 &amp;i32? 为什么 &amp;item 之后，item 就变成 i32类型了？ 如果解引用不应该使用 *item 为什么报错？</span></span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大于运算符（&gt;）被定义在标准库中 trait <code>std::cmp::PartialOrd</code> 的一个默认方法。</p>
<ul>
<li><code>PartialOrd</code> 位于 <code>prelude</code> 中，不需要手动将其引入作用域。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[Error - 下午<span class="number">10</span>:<span class="number">06</span>:<span class="number">30</span>] Request textDocument/completion failed.</span><br><span class="line">  Message: server panicked: called `<span class="type">Option</span>::<span class="title function_ invoke__">unwrap</span>()` on a `<span class="literal">None</span>` value</span><br><span class="line">  Code: -<span class="number">32603</span> </span><br><span class="line">Panic context:</span><br><span class="line">&gt; </span><br><span class="line">version: <span class="number">0</span>add6e95e <span class="number">2021</span>-<span class="number">12</span>-<span class="number">20</span> stable</span><br><span class="line">request: textDocument/completion CompletionParams &#123;</span><br><span class="line">    text_document_position: TextDocumentPositionParams &#123;</span><br><span class="line">        text_document: TextDocumentIdentifier &#123;</span><br><span class="line">            uri: Url &#123;</span><br><span class="line">                scheme: <span class="string">&quot;file&quot;</span>,</span><br><span class="line">                cannot_be_a_base: <span class="literal">false</span>,</span><br><span class="line">                username: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                password: <span class="literal">None</span>,</span><br><span class="line">                host: <span class="literal">None</span>,</span><br><span class="line">                port: <span class="literal">None</span>,</span><br><span class="line">                path: <span class="string">&quot;/c%3A/Tableware/codes/rust/minigrep/src/main.rs&quot;</span>,</span><br><span class="line">                query: <span class="literal">None</span>,</span><br><span class="line">                fragment: <span class="literal">None</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        position: Position &#123;</span><br><span class="line">            line: <span class="number">3</span>,</span><br><span class="line">            character: <span class="number">43</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    work_done_progress_params: WorkDoneProgressParams &#123;</span><br><span class="line">        work_done_token: <span class="literal">None</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    partial_result_params: PartialResultParams &#123;</span><br><span class="line">        partial_result_token: <span class="literal">None</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    context: <span class="title function_ invoke__">Some</span>(</span><br><span class="line">        CompletionContext &#123;</span><br><span class="line">            trigger_kind: Invoked,</span><br><span class="line">            trigger_character: <span class="literal">None</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread &#x27;&lt;unnamed&gt;&#x27; panicked at <span class="symbol">&#x27;called</span> `<span class="type">Option</span>::<span class="title function_ invoke__">unwrap</span>()` on a `<span class="literal">None</span>` value&#x27;, C:\Users\runneradmin\.cargo\registry\src\github.com-<span class="number">1</span>ecc6299db9ec823\chalk-solve-<span class="number">0.75</span>.<span class="number">0</span>\src\clauses\builtin_traits\fn_family.rs:<span class="number">91</span>:<span class="number">55</span></span><br><span class="line">stack backtrace:</span><br><span class="line">note: <span class="literal">Some</span> details are omitted, run with `RUST_BACKTRACE=full` <span class="keyword">for</span> <span class="title class_">a</span> verbose backtrace.</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、下载安装racer（用于Rust代码自动补全）：</span><br><span class="line"></span><br><span class="line">cargo install racer</span><br><span class="line"></span><br><span class="line">如果不成功，先将rustup更新成nightly版本，再进行下载：</span><br><span class="line"></span><br><span class="line">rustup install nightly</span><br><span class="line"></span><br><span class="line">cargo +nightly install racer</span><br></pre></td></tr></table></figure>



<p>为什么 &amp;String 类型可以传递给 &amp;str 类型？Rust 内部做了转换？前面章节中好像有讲。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Cargo has produced no matching compilation artifacts.</span><br></pre></td></tr></table></figure>



<h1 id="20211229"><a href="#20211229" class="headerlink" title="20211229"></a>20211229</h1><p>看到19章时，关注一下 </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> 内联类型的内容</span><br><span class="line">写法<span class="number">1</span>，<span class="keyword">Self</span>::Item</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">写法<span class="number">2</span>，&amp;T</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>通过联系多理解一下，引用在函数和方法中的使用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>



<h1 id="对于Rust-的模块路径使用还不太熟"><a href="#对于Rust-的模块路径使用还不太熟" class="headerlink" title="对于Rust 的模块路径使用还不太熟"></a>对于Rust 的模块路径使用还不太熟</h1><p>use xxx(package名)::Post(pub 的struct名)</p>
<p>为什么能直接只用 use crate::Post?</p>
<p>或者 use crate::xxx(package名)::Post(pub 的 struct 名)？？？</p>
<p>lib.rs 文件中的顶级项，在其他文件中引用是不是路径都是 use xxx(package名)::bbb 的形式？</p>
<p>所以也就是为什么 Rust 的 crate 中只能有一个lib.rs 的原因（只能给一个为命名的文件启动添加名字？）？</p>
<ul>
<li><p>在同一个文件内部使用定义在文件内部的struct、enum、trait 时，使用 <code>use crate::xxx::xxx</code>的形式；</p>
</li>
<li><p>在跨文件中使用其他文件中定义的 struct、enum、trait时，使用<code>use pakcage名::xxx::xxx</code> 的形式；</p>
</li>
<li><p>当文件名本身为<code>mod.rs</code>时，此时若用到该文件中的定义项时，package的名称即为该mod的名称，</p>
<ul>
<li><p>例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">|-linked-list</span><br><span class="line">|--main.rs</span><br><span class="line">|--lib.rs</span><br><span class="line">|--<span class="keyword">mod</span>.rs</span><br><span class="line"></span><br><span class="line">那么此时如果需要在lib.rs中使用<span class="keyword">mod</span>.rs中定义的<span class="keyword">enum</span> <span class="title class_">List</span>,</span><br><span class="line">则为</span><br><span class="line"><span class="keyword">use</span> linked-list::List::Cons;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="何时使用if-let模式匹配？"><a href="#何时使用if-let模式匹配？" class="headerlink" title="何时使用if let模式匹配？"></a>何时使用if let模式匹配？</h1><p>什么场景下使用？为什么不直接使用简单的赋值语句？有什么好处？</p>
<p>或者说当只关心一个值得时候，使用 if let 模式匹配比使用if有哪些好处吗？</p>
<ul>
<li>更像 Rust 风格？</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">request_review</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = <span class="title function_ invoke__">Some</span>(s.<span class="title function_ invoke__">request_review</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，上面代码为什么不是</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.state = <span class="keyword">self</span>.state.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">request_review</span>() ?或者严谨写添加一个<span class="keyword">if</span> 判断</span><br></pre></td></tr></table></figure>





<h1 id="创建类型别名，使用-type-新类型-原类型-还是使用-as？"><a href="#创建类型别名，使用-type-新类型-原类型-还是使用-as？" class="headerlink" title="创建类型别名，使用 type 新类型=原类型;  还是使用 as？"></a>创建类型别名，使用 <code>type 新类型=原类型;</code>  还是使用 <code>as</code>？</h1><ul>
<li>使用 type语法</li>
</ul>
<h1 id="下列代码为什么可以？"><a href="#下列代码为什么可以？" class="headerlink" title="下列代码为什么可以？"></a>下列代码为什么可以？</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">        &#125;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法声明</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>方法不是声明mut的参数吗？为什么调用时传递不可变也可以？</p>
<h1 id="amp-和-ref，解构和解引用"><a href="#amp-和-ref，解构和解引用" class="headerlink" title="&amp; 和 ref，解构和解引用"></a>&amp; 和 ref，解构和解引用</h1><ol>
<li>&amp; 和 ref 的区别，分别在什么场景中使用；</li>
<li>解构和解引用分别在什么场景中使用；</li>
</ol>
<h2 id="amp-和-ref"><a href="#amp-和-ref" class="headerlink" title="&amp; 和 ref"></a>&amp; 和 ref</h2><p>涉及到 <code>ref</code> 的内容，我们通常是在 <code>match</code> 表达式中使用。</p>
<p>默认情况下，<code>match</code> 表达式会消耗匹配中的值，即匹配到的值的所有权会发生转移；</p>
<p>这种情况下，后面就不能再次使用这些值。因为被匹配的值的所有权已经发生<code>move</code>；</p>
<blockquote>
<p>如果匹配的类型实现了 Copy trait，则不会发生move，而是 copy。不会出现上面的问题。</p>
</blockquote>
<p>当后面需要使用该值的情况下，可能发生的遇到的问题，</p>
<ul>
<li>怎么解决？</li>
<li>使用<code>ref</code>；</li>
</ul>
<p><code>ref</code> 使用在模式匹配中，可以使其变为借用（borrow）而不是<code>move</code>；</p>
<p><code>ref</code> 使用在 <code>match</code> 中，并不会影响值是否被匹配，只会影响匹配的方式；</p>
<p>样例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 默认情况下的情况</span><br><span class="line">let maybe_name = Some(String::from(&quot;Alice&quot;));</span><br><span class="line">// The variable &#x27;maybe_name&#x27; is consumed here ...</span><br><span class="line">match maybe_name &#123;</span><br><span class="line">    Some(n) =&gt; println!(&quot;Hello, &#123;&#125;&quot;, n),</span><br><span class="line">    _ =&gt; println!(&quot;Hello, world&quot;),</span><br><span class="line">&#125;</span><br><span class="line">// ... and is now unavailable.</span><br><span class="line">println!(&quot;Hello again, &#123;&#125;&quot;, maybe_name.unwrap_or(&quot;world&quot;.into()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用了 `ref` 关键字的效果</span><br><span class="line">let maybe_name = Some(String::from(&quot;Alice&quot;));</span><br><span class="line">// Using `ref`, the value is borrowed, not moved ...</span><br><span class="line">match maybe_name &#123;</span><br><span class="line">    Some(ref n) =&gt; println!(&quot;Hello, &#123;&#125;&quot;, n),</span><br><span class="line">    _ =&gt; println!(&quot;Hello, world&quot;),</span><br><span class="line">&#125;</span><br><span class="line">// ... so it&#x27;s available here!</span><br><span class="line">println!(&quot;Hello again, &#123;&#125;&quot;, maybe_name.unwrap_or(&quot;world&quot;.into()));</span><br></pre></td></tr></table></figure>



<h3 id="amp-vs-ref"><a href="#amp-vs-ref" class="headerlink" title="&amp; vs ref"></a><code>&amp;</code> vs <code>ref</code></h3><ul>
<li><code>ref</code> ，表示我们仅引用该值，</li>
<li><code>&amp;</code>，表示我们期望使用一个对象的引用，<ul>
<li><code>&amp;Foo</code> 与 <code>Foo</code> 是不一样的。</li>
</ul>
</li>
</ul>
<p><a href="https://doc.rust-lang.org/stable/std/keyword.ref.html">ref - Rust (rust-lang.org)</a></p>
<p>关键字 ref 与 主类型 reference 的区别</p>
<h1 id="二进制有符号整数的表示"><a href="#二进制有符号整数的表示" class="headerlink" title="二进制有符号整数的表示"></a>二进制有符号整数的表示</h1><p>-1 ？</p>
<p>最小值如何表示为二进制？</p>
<h1 id="Iter-与-FnMut-的问题"><a href="#Iter-与-FnMut-的问题" class="headerlink" title="Iter 与 FnMut 的问题"></a>Iter 与 FnMut 的问题</h1><p><code>Iter&lt;i32&gt;</code> 为什么可以调用 <code>Iterator::any&lt;F&gt;(&amp;mut self, f: F)</code></p>
<p>any 的第一个参数不是 <code>&amp;mut self</code> 吗？不是需要可变借用才能调用吗？</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `iter()` for vecs yields `&amp;i32`. Destructure to `i32`.</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;2 in vec1: &#123;&#125;&quot;</span>, vec1.<span class="title function_ invoke__">iter</span>()     .<span class="title function_ invoke__">any</span>(|&amp;x| x == <span class="number">2</span>));</span><br></pre></td></tr></table></figure>



<h1 id="trait-的可见性？"><a href="#trait-的可见性？" class="headerlink" title="trait 的可见性？"></a>trait 的可见性？</h1><p>trait 是否与 enum 一样，只需要对整体进行 pub设置，所有方法都是可见的pub？</p>
<h1 id="基础数据类型的类型转换？"><a href="#基础数据类型的类型转换？" class="headerlink" title="基础数据类型的类型转换？"></a>基础数据类型的类型转换？</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">to_centimeters</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Centimeters &#123;</span><br><span class="line">    <span class="keyword">let</span> &amp;<span class="title function_ invoke__">Inches</span>(inches) = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Centimeters</span>(inches <span class="keyword">as</span> <span class="type">f64</span> * <span class="number">2.54</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，先通过解构获得 inches变量，然后i32 * f64 ，这里进行了类型转换 f64 * f64</p>
<p>所以在Rust 中，基础类型的类型转换也是需要我们自己做的是吗？</p>
<h1 id="collect-指定类型的写法"><a href="#collect-指定类型的写法" class="headerlink" title="collect 指定类型的写法"></a>collect 指定类型的写法</h1><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(doubles.collect::&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;(), <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure>

<p>如上，指定了<code>Vec&lt;i32&gt;</code>类型，这种写法的语法规则在哪里？或者查一下collect 的官方文档说明。</p>
<p>答：这是 turbofish 写法，因为 collect() 方法是泛型方法，使用时支持转换为多种类型，使用时，要么在定义时显示声明变量类型，要么使用 turbofish 语法，显示表示collect() 返回的类型。</p>
<h1 id="Error-之间的区别"><a href="#Error-之间的区别" class="headerlink" title="Error 之间的区别"></a>Error 之间的区别</h1><p>mismatched types<br>expected struct <code>Box&lt;dyn std::error::Error&gt;</code><br>   found struct <code>std::io::Error</code><br>for more on the distinction between the stack and the heap, read <a href="https://doc.rust-lang.org/book/ch15-01-box.html">https://doc.rust-lang.org/book/ch15-01-box.html</a>, <a href="https://doc.rust-lang.org/rust-by-example/std/box.html">https://doc.rust-lang.org/rust-by-example/std/box.html</a>, and <a href="https://doc.rust-lang.org/std/boxed/index.html">https://doc.rust-lang.org/std/boxed/index.html</a></p>
<p>看一下错误中提到的内容文档</p>
<p>写 Rust CLI程序需要考虑的问题</p>
<ol>
<li><p>如何处理error？</p>
<ul>
<li><p>是返回给调用者 result Result？还是触发 panic ？</p>
<ul>
<li><p>return Error，使用 match 模式匹配？使用 <code>?</code> 符号？</p>
<ul>
<li><p>Error 是 Result 的一个枚举分支；</p>
</li>
<li><p>如果使用 <code>?</code> 记得添加正常返回值Ok(xxx) 部分的内容；</p>
</li>
<li><p>使用默认返回的 Error 信息？还是自定义错误信息？当默认返回的错误信息无法囊括程序可能遇到的错误时，建议自定义struct，</p>
<ul>
<li><p>可以使用 <code>map_err()</code> 映射函数</p>
</li>
<li><p>建议使用 <code>anyhow</code> 第三方库。</p>
<ul>
<li>可以自定义错误信息，同时保留原始错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>panic，使用 match 模式匹配？还是 <code>unwrap()</code> ? 或是 <code>expect()</code> 指定以 panic 内容？</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>如何运行工作空间子项目CLI的程序？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo run -p grrs -- <span class="number">123</span> test.txt</span><br></pre></td></tr></table></figure>

<p>解释：<code>-p</code> 表示工作空间中的模块，<code>--</code> 后面的为 grrs 程序支持的命令行参数</p>
<h1 id="执行样例报错"><a href="#执行样例报错" class="headerlink" title="执行样例报错"></a>执行样例报错</h1><p>执行 [CLI样例](<a href="https://rust-cli.github.io/book/tutorial/testing.html">Testing - Command Line Applications in Rust (rust-cli.github.io)</a>)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> assert_fs::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_content_in_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = assert_fs::NamedTempFile::<span class="title function_ invoke__">new</span>(<span class="string">&quot;sample.txt&quot;</span>)?;</span><br><span class="line">    file.<span class="title function_ invoke__">write_str</span>(<span class="string">&quot;A test\nActual content\nMore content\nAnother test&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cmd</span> = Command::<span class="title function_ invoke__">cargo_bin</span>(<span class="string">&quot;grrs&quot;</span>)?;</span><br><span class="line">    cmd.<span class="title function_ invoke__">arg</span>(<span class="string">&quot;test&quot;</span>).<span class="title function_ invoke__">arg</span>(file.<span class="title function_ invoke__">path</span>());</span><br><span class="line">    <span class="comment">// 从这里开始引发错误，为什么？</span></span><br><span class="line">    cmd.<span class="title function_ invoke__">assert</span>()</span><br><span class="line">        .<span class="title function_ invoke__">success</span>().<span class="title function_ invoke__">stdout</span>(predicate::<span class="type">str</span>::<span class="title function_ invoke__">contains</span>(<span class="string">&quot;test\nAnother test&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>报错结果如下：查一下为什么会出现test.txt ？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">running 1 test</span><br><span class="line">thread &#x27;find_content_in_file&#x27; panicked at &#x27;Unexpected failure.</span><br><span class="line">code-1</span><br><span class="line">stderr=```&quot;Error: could not read file `test.txt`\n\nCaused by:\n    系统找不到指定的文件。 (os error 2)\n&quot;```</span><br><span class="line">command=`&quot;C:\\Codes\\rust-study-codes\\target\\debug\\grrs.exe&quot; &quot;test&quot; &quot;C:\\Users\\spoon\\AppData\\Local\\Temp\\.tmpKNow85\\sample.txt&quot;`</span><br><span class="line">code=1</span><br><span class="line">stdout=&quot;&quot;</span><br><span class="line">stderr=&quot;Error: could not read file `test.txt`\n\nCaused by:\n    系统找不到指定的文件。 (os error 2)\n&quot;</span><br><span class="line">&#x27;, /rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b\library\core\src\ops\function.rs:227:5</span><br></pre></td></tr></table></figure>



<h1 id="所有权与-Copy，Clone"><a href="#所有权与-Copy，Clone" class="headerlink" title="所有权与 Copy，Clone"></a>所有权与 Copy，Clone</h1><p>变量的所有权总是遵循相同的模式：</p>
<ul>
<li><p>将值赋值给另一个变量时移动它。</p>
<ul>
<li><p>如果值的类型实现了<code>clone</code>这个函数，可以通过复制该值给新变量。此时在堆上是有两个值。</p>
<blockquote>
<p>也就是使用时，如果方法需要的是获取所有权，而传参是引用时，可以通过调用 clone() 复制该值，然后传递。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">pre_block</span>: &amp;Block = xxx;</span><br><span class="line">Block::<span class="title function_ invoke__">new</span>(<span class="string">&quot;&quot;</span>, pre_block.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"><span class="comment">// Block::new() 的定义如下</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: &amp;<span class="type">str</span>, pre_block: Block)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当持有堆中数据值的变量离开作用域时，其值将通过<code>drop</code> 被清理掉，除非数据所有权移动给了另一个变量所有。</p>
</li>
<li><p>实现了<code>Copy</code> trait 的数据类型，赋值后所有权并不会移动。</p>
<ul>
<li>例如，常用的标量类型，分配到栈中。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>常用库学习</title>
    <url>//%E5%B8%B8%E7%94%A8%E5%BA%93%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p>对于实际开发应用问题，需要对同类 crate 进行深入引用、比较分析，有利于遇到实际应用问题时，找到合适解决方案。</p>
<p>Rust 正在发展，所以这个文档也应该随着 crate 发展而更改。</p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>利用模板生产字符串</p>
<p><code>format!()</code></p>
<p>样例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomError</span>(<span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ce</span> = <span class="title function_ invoke__">CustomError</span>(<span class="built_in">format!</span>(<span class="string">&quot;Error reading `&#123;&#125;`: &#123;&#125;&quot;</span>, path, err));</span><br></pre></td></tr></table></figure>



<h2 id="println-使用注意"><a href="#println-使用注意" class="headerlink" title="println! 使用注意"></a><code>println!</code> 使用注意</h2><p>注意：<code>println!</code> 语句每次打印都会将内容 flush 到终端，因为通常需要打印新行，所以如果在意程序性能，需要谨慎使用<code>println!</code>，</p>
<p>如何优化？</p>
<p>可以使用 <code>BufWriter</code></p>
<ul>
<li>它是将 stdout 句柄包装在<code>BufWriter</code> 中，</li>
<li>默认缓冲区 8KB，</li>
<li>当需要立刻写到磁盘时，调用<code>.flush()</code> 函数将 <code>BufWriter</code> 中的数据打印出来。</li>
<li>优点2：可以方便的获取 <code>stdout</code> 和 <code>stderr</code> 的锁，并使用 <code>writeln!()</code> 出来。</li>
</ul>
<p><code>std::env::args</code> </p>
<p>获取命令行参数</p>
<p>通用编程概念：</p>
<p>析构函数（destructor），是一个清理实例的函数；</p>
<p>构造函数，创建实例的函数；</p>
<ul>
<li>构造函数与析构函数是一对概念</li>
</ul>
<p>Rust 所有权系统会确保引用总是有效，也会确保<code>drop</code> 只会在值不再被使用时被自动调用一次。</p>
<ul>
<li>手动调用需要使用 <code>std::mem::drop</code> 方法。</li>
</ul>
<p>Rust 的 <code>Option&lt;T&gt;</code> 中 <code>task</code>方法会取出Option中的<code>Some</code>值，只留下<code>None</code>值。</p>
<ul>
<li>更多内容查看Option的 task 方法的 API，有实例。</li>
</ul>
<p><code>#[allow(dead_code)]</code> 相关内容</p>
<p>&#x2F;&#x2F; <code>#[allow(dead_code)]</code> is an attribute that disables the <code>dead_code</code> lint</p>
<p>作用：用在声明但没有使用的函数&#x2F;方法上，消除<code>dead_code</code>的告警。</p>
<p><code>cfg </code>相关内容</p>
<ul>
<li>the <code>cfg</code> attribute: <code>#[cfg(...)]</code> in attribute position</li>
<li>the <code>cfg!</code> macro: <code>cfg!(...)</code> in boolean expressions</li>
</ul>
<p>valgrind 工具的使用</p>
<p>we can double check for memory errors using <a href="http://valgrind.org/info/"><code>valgrind</code></a></p>
<h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h2><p>Combinators</p>
<p>组合器可以用模块化的方式管理控制流（control flow）</p>
<ul>
<li>控制流，即条件判断，if，match，for，等都可以用于控制流的表达式。</li>
</ul>
<p><code>match</code> 是一种处理 <code>Option</code> 类型有效的方式，但是有时候，当我们需要匹配的值只有一种有效输入时，使用 <code>match</code> 就太重了（即结构复杂，不易读和管理）。</p>
<p>一般由两种方式代替：</p>
<ul>
<li>只关心一种值是否能匹配，即简单模式使用<code>if let</code>模式匹配来处理；</li>
<li>如果有嵌套判断时（复杂点），使用Combinators中的方法来处理会更优雅一些。</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>map()</code></li>
<li><code>and_then()</code></li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a><code>map()</code></h3><p><code>.map()</code> ，是Option内置的一个方法，提供简单的映射关系，<code>Some-&gt;Some</code>，或<code>None-&gt;None</code>。</p>
<p>方法签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>&lt;U, F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> U&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;U&gt;</span><br><span class="line"></span><br><span class="line">说明：注意参数的返回值类型与外部返回值类型。</span><br><span class="line">f —&gt; U，而 map <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;U&gt;</span><br></pre></td></tr></table></figure>

<p>该方法支持链式调用。即map(xx).map(xx)。</p>
<h3 id="and-then"><a href="#and-then" class="headerlink" title="and_then()"></a><code>and_then()</code></h3><p><code>.and_then()</code> ，避免复杂的嵌套，类似其他语言中的<code>flatmap()</code>，</p>
<p>方法签名如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">and_then</span>&lt;U, F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;U&gt;&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;U&gt;</span><br><span class="line"></span><br><span class="line">说明：注意参数的返回值类型与外部返回值类型。</span><br><span class="line">f <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;U&gt;, and_then <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;U&gt;.</span><br></pre></td></tr></table></figure>

<p>当结果为None时，返回None。</p>
<blockquote>
<p>从上面的返回值类型对比，可知，</p>
<p>相同：两者返回类型都有一层封装Option类型，</p>
<p>不同：<code>map</code> 会比 <code>and_then</code> 多一层封装。</p>
</blockquote>
<p><strong>注意：</strong><code>map</code> 或 <code>and_then</code> 结合嵌套使用时，需要注意返回值类型。可以用 <code>and_then</code> 在外层。</p>
<h3 id="ok"><a href="#ok" class="headerlink" title="ok()"></a><code>ok()</code></h3><h3 id="ok-or"><a href="#ok-or" class="headerlink" title="ok_or()"></a><code>ok_or()</code></h3><p>用来转换<code>Option&lt;T&gt;</code> -&gt; <code>Result&lt;T, E&gt;</code></p>
<p>参数为转换后的 Error 类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ok_or</span>&lt;E&gt;(<span class="keyword">self</span>, err: E) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;T, E&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EmptyVec</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = vec.<span class="title function_ invoke__">first</span>().<span class="title function_ invoke__">ok_or</span>(EmptyVec)?;</span><br></pre></td></tr></table></figure>





<h3 id="ok-or-else"><a href="#ok-or-else" class="headerlink" title="ok_or_else()"></a><code>ok_or_else()</code></h3><p>Transforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T, E&gt;</code>, mapping [<code>Some(v)</code>] to [<code>Ok(v)</code>] and <code>None</code> to [<code>Err(err())</code>].</p>
<p>转换 <code>Option&lt;T&gt;</code> -&gt; <code>Result&lt;T, E&gt;</code></p>
<ul>
<li><p><code>Some(v)</code> -&gt; <code>Ok(v)</code></p>
</li>
<li><p><code>None</code> -&gt; <code>Err(e)</code></p>
<blockquote>
<p>转换 None -&gt; Err 的过程需要手动实现并作为参数传入。</p>
</blockquote>
</li>
</ul>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><ul>
<li><code>Ok(T)</code></li>
<li><code>Err(E)</code></li>
</ul>
<p><code>.unwrap()</code> </p>
<ul>
<li>成功，返回元素T，</li>
<li>失败，抛出，panic，</li>
</ul>
<p><code>.unwrap_or_else()</code></p>
<ul>
<li>成功，返回元素T，</li>
<li>失败，调用传入的闭包&#x2F;函数。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">echo</span>()...</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;`echo hello &gt; a/b.txxt`&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">echo</span>(<span class="string">&quot;hello&quot;</span>, &amp;Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;a/b.txt&quot;</span>)).<span class="title function_ invoke__">unwrap_or_else</span>(|why| <span class="built_in">println!</span>(<span class="string">&quot;! &#123;:?&#125;&quot;</span>, why.<span class="title function_ invoke__">kind</span>()));</span><br></pre></td></tr></table></figure>





<h3 id="在-main-函数中使用-Result"><a href="#在-main-函数中使用-Result" class="headerlink" title="在 main() 函数中使用 Result"></a>在 main() 函数中使用 Result</h3><p>通常的main函数如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当main 函数需要返回时，可以使用如下方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ParseIntError&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_str</span> = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">match</span> number_str.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(number) =&gt; number,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, number);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>与Option 类型中的组合器的使用方式与注意事项类似</p>
<ul>
<li><p><code>map()</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>&lt;U, F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> U&gt;(<span class="keyword">self</span>, op: F) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;U, E&gt;</span><br><span class="line"></span><br><span class="line">返回值类型注意点：</span><br><span class="line">op <span class="punctuation">-&gt;</span> U, map <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;U, E&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>and_then()</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">and_then</span>&lt;U, F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;U, E&gt;&gt;(<span class="keyword">self</span>, op: F) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;U, E&gt;</span><br><span class="line"></span><br><span class="line">返回值类型注意点：</span><br><span class="line">op <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;U, E&gt;, and_then <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;U, E&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p> 特殊点：</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_first_v3</span>(vec: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Option</span>&lt;<span class="type">i32</span>&gt;, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">opt</span> = vec.<span class="title function_ invoke__">first</span>().<span class="title function_ invoke__">map</span>(|first| &#123;</span><br><span class="line">        first.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|n| <span class="number">2</span> * n)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的map()，从上面的方法签名可以得知参数为实现了 FnOnce(T) -&gt; U 的类型</span></span><br><span class="line">    <span class="comment">// 这里直接使用了简写的 Some。</span></span><br><span class="line">    opt.<span class="title function_ invoke__">map_or</span>(<span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>), |r| r.<span class="title function_ invoke__">map</span>(<span class="literal">Some</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Ok"><a href="#Ok" class="headerlink" title="Ok()"></a><code>Ok()</code></h3><p>Converts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;T&gt;</code>.</p>
<p>Converts <code>self</code> into an <code>Option&lt;T&gt;</code>, consuming <code>self</code>, and discarding the error, if any.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Result</span>&lt;<span class="type">u32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(x.<span class="title function_ invoke__">ok</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Result</span>&lt;<span class="type">u32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Nothing here&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(x.<span class="title function_ invoke__">ok</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>



<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><code>string.trim_matches(chars_to_trim)</code></p>
<p>通过模式匹配，将前后缀中匹配中的重复内容删除</p>
<ul>
<li>返回一个字符串切片。</li>
</ul>
<p>参数可以是<code>char</code>，或者<code>&amp;[char]</code>（即char的切片），或者函数或闭包。</p>
<p>The [pattern] can be a [<code>char</code>], a slice of [<code>char</code>]s, or a function or closure that determines if a character matches.</p>
<h3 id="按字节的16进制值？"><a href="#按字节的16进制值？" class="headerlink" title="按字节的16进制值？"></a>按字节的16进制值？</h3><p>因为 &amp;str 与 String 内部都是 <code>Vec[u8]</code> 封装的，所以在处理字符串的时候，可以直接通过写该字节的16进制表示的形式。</p>
<ul>
<li>注意，写16进制表示的值需要<strong>使用<code>\</code> 转义符号</strong>；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// I&#x27;m writing Rust!;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">byte_escape</span> = <span class="string">&quot;I&#x27;m writing \x52\x75\x73\x74!&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;What are you doing\x3F (\\x3F means ?) &#123;&#125;&quot;</span>, byte_escape);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>\x</code>，表示是16进制；</li>
<li><code>\u</code>，表示是Unicode；</li>
</ul>
<h3 id="raw-原始字符串表示"><a href="#raw-原始字符串表示" class="headerlink" title="raw 原始字符串表示"></a>raw 原始字符串表示</h3><ul>
<li><code>r&quot;xxx&quot;</code> ，即表示原始字符串，此时Rust会输出引号内的内容 </li>
<li>如果在raw string 中需要 <code>&quot;</code>双引号，需要使用一对 <code>#</code> 符号来转义。</li>
<li>如果内容中需要<code>#</code>，则添加再添加一对 <code>#</code>符号；</li>
</ul>
<h3 id="字节字符串"><a href="#字节字符串" class="headerlink" title="字节字符串"></a>字节字符串</h3><p>byte string</p>
<h3 id="String-from-utf8-vec-Vec-lt-u8-gt"><a href="#String-from-utf8-vec-Vec-lt-u8-gt" class="headerlink" title="String::from_utf8(vec: Vec&lt;u8&gt;)"></a><code>String::from_utf8(vec: Vec&lt;u8&gt;)</code></h3><p>通常用于将字节数组转换为 String 时使用。</p>
<p>pub fn from_utf8(vec: Vec<u8>) -&gt; Result&lt;String, FromUtf8Error&gt;</p>
<hr>
<p>Converts a vector of bytes to a <code>String</code>.</p>
<p>将一个 <code>Vec&lt;u8&gt;</code> 转换为 String。</p>
<p>A string (<code>String</code>) is made of bytes (<code>u8</code>), and a vector of bytes ([<code>Vec&lt;u8&gt;</code>]) is made of bytes, so this function converts between the two. Not all byte slices are valid <code>String</code>s, however: <code>String</code> requires that it is valid UTF-8. <code>from_utf8()</code> checks to ensure that the bytes are valid UTF-8, and then does the conversion.</p>
<p>If you need a [<code>&amp;str</code>] instead of a <code>String</code>, consider <code>std::str::from_utf8</code>.</p>
<p>注意：</p>
<ul>
<li>因为不是所有的 <code>[u8]</code> (byte 切片) 都是 UTF-8 的，所以这个方法会做检查，如果不是 UTF-8 会报错。</li>
<li>Rust 中要求 String 必须是有效的 UT-8 编码。</li>
</ul>
<h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line">thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p>上面的代码作用，sleep 5s 。</p>
<p>需要两个标准库中的内容，<code>std::thread</code> 和 <code>std::time::Duration</code>。</p>
<h1 id="Iter"><a href="#Iter" class="headerlink" title="Iter"></a>Iter</h1><p><code>map()</code></p>
<p>解析失败的情况下，会将error类型返回，并不会触发panic。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run_map</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;tofu&quot;</span>,<span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line">    <span class="comment">// 这里当集合中有遇到解析错误的内容，则整体都会出错。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>: <span class="type">Vec</span>&lt;_&gt;= strings.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">map</span>(|s| s.parse::&lt;<span class="type">i32</span>&gt;()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Results: &#123;:?&#125;&quot;</span>, numbers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">Results: [<span class="title function_ invoke__">Err</span>(ParseIntError &#123; kind: InvalidDigit &#125;), <span class="title function_ invoke__">Ok</span>(<span class="number">93</span>), <span class="title function_ invoke__">Ok</span>(<span class="number">18</span>)]</span><br></pre></td></tr></table></figure>



<p><code>filter_map()</code></p>
<p><code>filter_map()</code>结合 <code>Ok()</code> 将失败的内容过滤掉，只输出成功的内容。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;tofu&quot;</span>, <span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>: <span class="type">Vec</span>&lt;_&gt; = strings</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|s| s.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Results: &#123;:?&#125;&quot;</span>, numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>Result</code> 实现了 <code>FromIter</code> ，因此<code>Vec&lt;Result&lt;T,E&gt;&gt;</code> -&gt; <code>Result&lt;Vec&lt;T&gt;, E&gt;</code>。</p>
<ul>
<li>同时，一旦发现<code>Result::Err</code>，迭代就会停止。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两种写法作用相同；</span></span><br><span class="line">iter.<span class="title function_ invoke__">find</span>(f) ==&gt; iter.<span class="title function_ invoke__">filter</span>(f).<span class="title function_ invoke__">next</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note that <code>iter.find(f)</code> is equivalent to <code>iter.filter(f).next()</code>.</p>
</blockquote>
<h1 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h1><p>在 stack 上所占内存空间为 32 bit（8 bytes）</p>
<p>使用<code>Box::new()</code> 封装的数据类型，在 stack 上占用的空间永远为 8 bytes。 </p>
<h1 id="集合或迭代器的常用方法"><a href="#集合或迭代器的常用方法" class="headerlink" title="集合或迭代器的常用方法"></a>集合或迭代器的常用方法</h1><p><code>collect()</code></p>
<p>Because <code>collect()</code> is so general, it can cause problems with type inference. As such, <code>collect()</code> is one of the few times you’ll see the syntax affectionately known as the ‘turbofish’: <code>::&lt;&gt;</code>. This helps the inference algorithm understand specifically which collection you’re trying to collect into.</p>
<blockquote>
<p>collect() 方法会通过使用<code>turbofish</code>语法，即<code>::&lt;&gt;</code> ，来标注生成的数据类型。</p>
</blockquote>
<p>扩展，是不是所有泛型方法都会这样使用？</p>
<p>尤其是泛型方法在处理 trait的时候。</p>
<h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p><code>Path</code> 结构体是用来表示底层操作系统的文件路径的，</p>
<p>注意：<code>Path</code> 使用 <code>Vec&lt;u8&gt;</code> 来存储的，并不是UTF-8字符串，所以使用<code>Path</code>转换为 <code>&amp;str</code> 可能会失败，因为<code>String</code> 和<code>&amp;str</code> 要求字符串为UTF-8编码的。</p>
<ul>
<li><code>Path::new()</code></li>
<li><code>path.display()</code><ul>
<li>为 Path 实现<code>Display</code> trait,</li>
</ul>
</li>
<li><code>path.join()</code><ul>
<li>路径拼接，不需要考虑分隔符</li>
</ul>
</li>
<li><code>pathbuf.to_str()</code></li>
</ul>
<h1 id="File-I-x2F-O"><a href="#File-I-x2F-O" class="headerlink" title="File I&#x2F;O"></a>File I&#x2F;O</h1><p>因为在执行文件I&#x2F;O操作时，很多事情都可能出错，所以所有的file方法都返回<code>io::Result&lt;T&gt;</code>类型，这是<code>Result&lt;T, io::Error&gt;</code>的别名。</p>
<h2 id="open"><a href="#open" class="headerlink" title="open"></a><code>open</code></h2><p>用只读模式打开一个文件。</p>
<h2 id="create"><a href="#create" class="headerlink" title="create"></a><code>create</code></h2><p>create函数以只写（write-only）模式打开文件。</p>
<ul>
<li>如果文件已经存在，旧的内容将被销毁。</li>
<li>否则，将创建一个新文件。</li>
</ul>
<h2 id="lines"><a href="#lines" class="headerlink" title="lines()"></a>lines()</h2><p>以迭代器的形式，返回一个文件的所有行。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">lines</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Lines&lt;<span class="keyword">Self</span>&gt;</span><br></pre></td></tr></table></figure>

<p>Lines 实现了 <code>Iterator</code> trait 。</p>
<h1 id="std-io-Stdout"><a href="#std-io-Stdout" class="headerlink" title="std::io::Stdout"></a><code>std::io::Stdout</code></h1><p>Stdout 需要的是 bytes，即<code>u8</code></p>
<blockquote>
<p>注意不是 String</p>
</blockquote>
<p>当直接传入字面值时，注意使用 <code>b&quot;xxx&quot;</code> 的形式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IncompleteUtf8</span> &#123;</span><br><span class="line">    bytes: [<span class="type">u8</span>; <span class="number">4</span>],</span><br><span class="line">    len: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以当需要利用 <code>write!() / writeln!()</code> 向其中写入数据的时候，需要使用 <code>std::io::Write</code> 而不是 <code>std::fmt::Write</code></p>
<h1 id="Child-process"><a href="#Child-process" class="headerlink" title="Child process"></a>Child process</h1><p>用于与操作系统命令进行交互。</p>
<p><code>process::Output</code>结构表示一个已完成的子进程的输出，而<code>process::Command</code>结构是一个进程构建器。</p>
<p><code>std::Child</code>结构表示一个正在运行的子进程，并公开stdin、stdout和stderr句柄，以便通过管道与底层进程进行交互。</p>
<p><code>child.wait()</code> ，会阻塞当前线程，并等待 child 进程执行结束。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">output</span>: <span class="type">Result</span>&lt;Output, Error&gt; = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;rustc&quot;</span>).<span class="title function_ invoke__">output</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">process</span>: <span class="type">Result</span>&lt;Child, Error&gt; = Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;rustc&quot;</span>).<span class="title function_ invoke__">spawn</span>();</span><br></pre></td></tr></table></figure>

<p>上面的 <code>output()</code> 方法是<code>spawn()</code> + <code>piped()</code> + <code>wait()</code></p>
<h3 id="常用组合"><a href="#常用组合" class="headerlink" title="* 常用组合"></a>* 常用组合</h3><p>在测试中，我们常常将 </p>
<p><code>std::process::Command</code> 与</p>
<p><code>assert_cmd</code> crate 进行组合使用</p>
<p>得益于 Rust 的 trait 特性，我们可以在自定义的 crate 中通过定义新 trait 从而扩展标准库中已有的 struct 的功能（函数&#x2F;方法）。</p>
<p>这也是为什么进入第三方 crate 后，标准库中相关 struct 实例调用方法会增多的原因。</p>
<p>例如：</p>
<p><code>assert_cmd</code> crate 就通过自定义 trait 并为 <code>std::process::Command</code> struct 实现该 trait，从而扩展了 Command 的方法。</p>
<ul>
<li>在使用 VsCode 编码时，可以通过点击该 struct 上面展示的 <code>N implementations</code> 提示来查看本地有多少个 <code>impl 实现块</code>，这些内容实现了 struct ，或者为该struct 实现了指定 trati。</li>
</ul>
<p><code>assert_cmd</code> crate 用于通过命令行的形式执行指定 二进制文件并判断执行结果。</p>
<h1 id="std-fs"><a href="#std-fs" class="headerlink" title="std::fs"></a><code>std::fs</code></h1><p><code>std::fs</code>模块包含几个处理文件系统的函数。</p>
<h1 id="常用-derive"><a href="#常用-derive" class="headerlink" title="常用 derive"></a>常用 derive</h1><p><code>Clone</code> 解决 rust 所有权问题。</p>
<p>涉及到所有权</p>
<ul>
<li>转移 move</li>
<li>复制<ul>
<li>copy （只有基本数据类型实现了 copy）<ul>
<li>栈</li>
</ul>
</li>
<li>clone<ul>
<li>堆</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Debug 调试</p>
<h1 id="Rust-Cookbook"><a href="#Rust-Cookbook" class="headerlink" title="Rust Cookbook"></a>Rust Cookbook</h1><p><a href="https://rust-lang-nursery.github.io/rust-cookbook/cli/arguments.html">Argument Parsing - Rust Cookbook (rust-lang-nursery.github.io)</a> 命令行解析 crate 的使用。</p>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><ul>
<li><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">The Book</a> chapter on testing</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on doc-testing</li>
</ul>
<p><code>predicates</code> crate 常用于测试中，与 assert 一起使用进行断言判断，具体如何使用？</p>
<p>当测试程序中需要读取文件信息时，有两种方法：</p>
<ul>
<li>方法一，提前准备好一个文件，并放到指定位置；</li>
<li>方法二，创建临时文件<ul>
<li>这个方法更灵活；</li>
</ul>
</li>
</ul>
<p><code>assert_fs</code> crate ，可以用来创建临时文件。</p>
<p> <a href="https://docs.rs/proptest"><code>proptest</code></a> 用于单元测试</p>
<p> <a href="https://rust-fuzz.github.io/book/introduction.html">fuzzer</a> 用于编写模糊测试发现边界错误；</p>
<h1 id="处理错误信息"><a href="#处理错误信息" class="headerlink" title="处理错误信息"></a>处理错误信息</h1><h2 id="anyhow"><a href="#anyhow" class="headerlink" title="anyhow"></a>anyhow</h2><p>自定义错误信息，建议使用 <code>anyhow</code> 第三方库。</p>
<ul>
<li>可以自定义错误信息，同时保留原始错误</li>
</ul>
<p>简单使用时，可以利用 <code>anyhow::Context</code> 和 <code>anyhow::Result</code>组合展示，<code>Result</code> 封装实现了标准库中的 trait，所以利用 编译器自动转换。</p>
<h1 id="可用于命令行的工具"><a href="#可用于命令行的工具" class="headerlink" title="可用于命令行的工具"></a>可用于命令行的工具</h1><h2 id="indicatif"><a href="#indicatif" class="headerlink" title="indicatif"></a><code>indicatif</code></h2><p>用户展示命令行中的进度条信息</p>
<p>更多内容查看文档和样例：</p>
<p>See the <a href="https://docs.rs/indicatif">documentation</a> and <a href="https://github.com/mitsuhiko/indicatif/tree/master/examples">examples</a> for more information.</p>
<h1 id="clap"><a href="#clap" class="headerlink" title="clap"></a>clap</h1><p>目前最受欢迎的命令行库</p>
<p>提供命令行参数解析，并带有友好的结果输出</p>
<p><code>std::fs::read_to_string()</code> 的缺点：会将整个文件读进内存，当文件过大时，可能导致报错。</p>
<ul>
<li>优化方法1，使用 <code>std::io::BufReader</code> 代替 <code>read_to_string()</code>；</li>
</ul>
<p>如果需要运行时支持 <code>--verbose</code> 打印详细信息的功能，</p>
<p>使用，<code>clap-verbosity-flag</code> crate，</p>
<p>具体使用信息参考，<a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a></p>
<h1 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h1><h2 id="log"><a href="#log" class="headerlink" title="log"></a><code>log</code></h2><p>rust 轻型日志框架，提供了抽象了实际日志实现的API，</p>
<p>日志级别：</p>
<p><em>error</em>, <em>warn</em>, <em>info</em>, <em>debug</em>, and <em>trace</em></p>
<blockquote>
<p>error 最高优先级，trace 最低优先级，</p>
<p>设置低优先级可以打印高优先级的日志信息，</p>
</blockquote>
<p>实际使用时，需要结合合适的日志实现 crate 一起使用。</p>
<ul>
<li>log crate，提供以日志级别命名的宏，</li>
<li>其他日志适配器 crate，提供处理日志的方式，</li>
</ul>
<p>日志适配器的使用很灵活，可以通过使用合适的日志适配器，将日志写到例如<code>syslog</code>文件，日志服务器等地方。</p>
<p>例如：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">&quot;0.4.0&quot;</span></span><br><span class="line"><span class="attr">env_logger</span> = <span class="string">&quot;0.8.4&quot;</span>  // 适合cli程序的日志适配器，方便在命名行设置日志级别</span><br></pre></td></tr></table></figure>

<p>更多内容可以查看crate库中的描述：</p>
<p><a href="https://crates.io/crates/log">log - crates.io: Rust Package Registry</a></p>
<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><h2 id="常规序列化"><a href="#常规序列化" class="headerlink" title="常规序列化"></a>常规序列化</h2><p>serde </p>
<p>目前最热的库，添加到 Cargo.toml 的方式如下，一般会添加一个 derive 的features，方便通过 derive 直接添加 <code>Serialize</code> 和 <code>Deserialize</code></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">serde</span> = &#123; version = <span class="string">&quot;1.0.136&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>



<h2 id="二进制序列化"><a href="#二进制序列化" class="headerlink" title="二进制序列化"></a>二进制序列化</h2><p>bincode</p>
<h1 id="日期时间库"><a href="#日期时间库" class="headerlink" title="日期时间库"></a>日期时间库</h1><p>chrono</p>
<p>目前最流行的 Date and time 库</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">chrono</span> = <span class="string">&quot;0.4.19&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="加密库"><a href="#加密库" class="headerlink" title="加密库"></a>加密库</h1><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rust-crypto</span> = <span class="string">&quot;0.2.36&quot;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>//Mybatis.html</url>
    <content><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><ul>
<li>ORM ，持久层框架</li>
<li>支持定制化 SQL、存储过程和高级映射</li>
<li>在 Spring 中使用 MyBatis <ul>
<li>mybatis-spring-boot-starter</li>
<li>MyBatis Spring Adapter</li>
</ul>
</li>
</ul>
<p>可以使Mybatis更好用的工具</p>
<ul>
<li>Mybatis Generator<ul>
<li>MyBatis 官方提供的代码生成器</li>
<li>根据数据库表生成相关代码<ul>
<li>POJO</li>
<li>Mapper 接口</li>
<li>SQL Map XML</li>
</ul>
</li>
<li>一些内嵌子工具</li>
</ul>
</li>
<li>Mybatis PageHelper<ul>
<li>帮助更好的处理分页的</li>
<li>支持多种数据库</li>
<li>支持多种分页形式</li>
<li>pagehelper-spring-boot-starter</li>
</ul>
</li>
</ul>
<p>注意：如果既要使用组件自动生成的部分，又需要对它做一个手动的微调</p>
<p>把手动处理的部分和自动生成的部分放在不同的位置</p>
<p>有两套model，mapper，xml，这样下次自动生成时就会仅覆盖自动成的部分，不会干扰手动处理的部分</p>
<p>尽管Mybatis Genertor有合并的逻辑，但是并不是很靠谱。</p>
<p>Mapper 的定义与扫描</p>
<ul>
<li>@MapperScan 配置扫描位置<ul>
<li>使用 Java Config 时使用此注解注册 MyBatis mapper interfaces。</li>
</ul>
</li>
<li>@Mapper 定义接口</li>
<li>DAO 层的定义方法，有两种<ul>
<li>mapper interface + SQL XML，扫描xml 文件</li>
<li>带有SQL注解 的 mapper interface</li>
</ul>
</li>
</ul>
<p>insert, update, delete 语句返回的结果与 数据库执行时一样，是受影响条数。</p>
<h3 id="20210901"><a href="#20210901" class="headerlink" title="20210901"></a>20210901</h3><p>整体学习前的杂记</p>
<ol>
<li>insert 语句中 插入的字段名使用表中的字段名，values 对应的名字使用 java Model 中的字段名，</li>
<li>selectKey 的作用是什么？</li>
<li>selectByExample 中的 example 是什么意思？</li>
<li>insert  与 insertSelective 有什么区别？</li>
<li></li>
</ol>
<h1 id="Mybatis-Generator"><a href="#Mybatis-Generator" class="headerlink" title="Mybatis Generator"></a>Mybatis Generator</h1><p>到官网查看详细内容</p>
<p>主要功能：</p>
<ul>
<li>用来生成简单的 CRUD (Create, Retrieve, Update, Delete) 代码， </li>
<li>不过仍然需要为连接查询或存储过程编写 SQL 和对象代码。</li>
</ul>
<p>目标：</p>
<ul>
<li>掌握如何开箱配置，运行，如何与代码整合一起使用，可以正常打包即可；</li>
<li>更高级用法，等有需要时再去查官方文档即可；</li>
</ul>
<h2 id="配置-MyBatis-Generator"><a href="#配置-MyBatis-Generator" class="headerlink" title="配置 MyBatis Generator"></a>配置 MyBatis Generator</h2><ol>
<li><p>配置文件要命名为 <code>generatorConfig.xml </code> ，</p>
</li>
<li><p>在 IDEA 中配置时，只要提供了 XML 文件的 DOCTYPE 头信息，涉及的标签就会有自动提示和补全，很方便（可以先抄一个官方文档的例子，然后修改）。</p>
</li>
<li><p>xml 配置文件提供哪些信息？</p>
<ul>
<li>如何连接到数据库</li>
<li>要生成什么对象，以及如何生成它们</li>
<li>应该使用哪些表来生成对象</li>
<li>java model class</li>
<li>SQL map XML files （可选）</li>
</ul>
</li>
<li><p>注意，配置内容是有顺序的，</p>
<ol>
<li>配置plugin</li>
<li>配置 jdbcConnection</li>
<li>配置 javaModelGenerator</li>
<li>。。。。</li>
</ol>
</li>
<li><p>需要注意的两个重要参数:</p>
<ul>
<li>targetProject ，必须是一个已存在的目录，如果不存在则报错，</li>
<li>targetPackage ，是 targetProject 属性的子目录，如果不存在 MBG 会自动创建<ul>
<li>targetProject + targetPackage &#x3D; 生成的代码最终存放的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>xml 配置文件中，有两种属性，</p>
<ul>
<li><p>attribute ，这是&lt;&gt; 标签内部的属性，例如：<contenxt id="xxx" defaultModelType="flat"> ，这些都写在标签内部。多个attribute 之间用 空格 分割；</p>
</li>
<li><p>property ，这个属性类似于标签的子元素，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;test.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;\MyProject\src&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">上面的例子中，分别表现了两种不同的属性的写法。</span><br><span class="line">1. targetPackage,targetProject 都属于 attribute;</span><br><span class="line">2. property 子元素有两个，而 name ，value 都属于 property 的 attribute </span><br><span class="line">3. <span class="tag">&lt;&gt;</span> 标签 ，当子元素时，是成对出现的 <span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> ； 当没有子元素时，是可以单独使用的 <span class="tag">&lt;<span class="name">property</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="一些常用元素"><a href="#一些常用元素" class="headerlink" title="一些常用元素"></a>一些常用元素</h3><ul>
<li><p><generatorConfiguration> ，是 generatorConfiguration.xml 配置文件的 root element 即根元素。</p>
<ul>
<li><p>可用的子元素如下：</p>
</li>
<li><p>[<properties>](# [<code>&lt;properties&gt; </code>](# 一些常用元素)) (0 or 1)</p>
</li>
<li><p><classPathEntry> (0..N)</p>
</li>
<li><p>[<context>](# [<code>&lt;context&gt;</code>](# 一些常用元素)) (1..N)</p>
<ul>
<li>[<property>](# [<code>&lt;property&gt;</code>](# 一些常用元素)) (0..N)</li>
<li>[<plugin>](# [](# 一些常用元素)) (0..N)</li>
<li>[<commentGenerator>](# [](# 一些常用元素)) (0 or 1)</li>
<li>[<connectionFactory>](# [](# 一些常用元素)) (either connectionFactory or jdbcConnection is Required)</li>
<li>[<jdbcConnection>](# [](# 一些常用元素)) (either connectionFactory or jdbcConnection is Required)</li>
<li>[<javaTypeResolver>](# [](# 一些常用元素)) (0 or 1)</li>
<li>[<javaModelGenerator>](# [](# 一些常用元素)) (1 Required)</li>
<li>[<sqlMapGenerator>](# [<code>&lt;sqlMapGenerator&gt;</code>](# 一些常用元素)) (0 or 1)</li>
<li>[<javaClientGenerator>](# [](# 一些常用元素)) (0 or 1)</li>
<li>[<table>](# [](# 一些常用元素)) (1..N)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面是一些元素的解释和样例：</p>
<h4 id="lt-properties-gt-一些常用元素"><a href="#lt-properties-gt-一些常用元素" class="headerlink" title="[&lt;properties&gt; ](# 一些常用元素)"></a>[<code>&lt;properties&gt; </code>](# 一些常用元素)</h4><p>用于指定外部properties 文件，该文件中的 property 可以用在 xml配置文件中，通过 ${property}，属性占位符</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">使用时，两个 attribute 二选一，</span><br><span class="line">1. resource, 在类路径中搜索指定的文件；</span><br><span class="line">2. url ，在文件系统中搜索指定的文件，给定 file:///C:/myfolder/generatorConfig.properties</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;generator.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="lt-context-gt-一些常用元素"><a href="#lt-context-gt-一些常用元素" class="headerlink" title="[&lt;context&gt;](# 一些常用元素)"></a>[<code>&lt;context&gt;</code>](# 一些常用元素)</h4><p>是 <generatorConfiguration> 的子元素，生成代码的核心配置都在里面，例如连接什么数据库，生成什么对象，怎么生成，需要用到什么表等。如果需要连接多个不同的数据库，可以添加多个 <context> 元素对。</p>
<ul>
<li><p>id ，是必须的 attribute，用作唯一标识符</p>
</li>
<li><p>一些可选属性 attribute</p>
</li>
<li><p>defaultModelType，模型类型，用于定义如何将表结构生成 domain 类</p>
<ul>
<li>conditional ，默认值，与分成模型有类似的地方，当某张表仅有一个字段的时候，不会生成单独的class，而是放到基类中；</li>
<li>flat ，每张表生成独立的 domain class；</li>
<li>hierarchical ，分层模型，如果表有一个主键，这个模型将生成一个主键类，另一个类保存表中的任何 BLOB 列，另一个类保存剩余的字段。类之间存在适当的继承关系。</li>
</ul>
</li>
<li><p>targetRuntime ，用于指定运行时目标，是会影响其他子元素的配置，（Kotlin的内容暂时不记录）</p>
<ul>
<li>MyBatis3DynamicSql ， 这是默认值，生成的代码会支持 Java8 和一些其他特性，有几个特点，<ol>
<li>直接使用<strong>FLAT</strong>模式，无论 <code>defaultModelType</code>配置什么值；</li>
<li>无论 <code>&lt;javaClientGenerator&gt;</code>子元素的<code>type</code>配置什么值，mapper 都会生成带注解的mapper；</li>
<li>无视<code>&lt;sqlMapGenerator&gt;</code> 子元素的配置，不生成  XML 文件；</li>
<li>支持在查询时配置 table 别名，而不是固定不变的别名；</li>
</ol>
</li>
<li>MyBatis3 ，特点：<code>by example</code> 方法支持各种动态的 where 子句 （dynamic where clauses）。</li>
<li>MyBatis3Simple ，特点：是 MyBatis3 的简化版，只生成点单的 <code>CRUD</code> 操作和很少的动态 SQL，不生成 <code>by example</code> 方法；</li>
</ul>
</li>
</ul>
<h4 id="lt-property-gt-一些常用元素"><a href="#lt-property-gt-一些常用元素" class="headerlink" title="[&lt;property&gt;](# 一些常用元素)"></a>[<code>&lt;property&gt;</code>](# 一些常用元素)</h4><p><a href="http://mybatis.org/generator/configreference/context.html">支持的各种属性</a> ，详细查看官方文档</p>
<ul>
<li>常用的三个如下，</li>
<li>beginningDelimiter , SQL 表字段的分隔符的开始字符，其他同下；</li>
<li>endingDelimiter , SQL 表字段的分隔符的结束字符，默认 <code>&quot;</code> 双引号 ，有时可能需要为 “&#96;” 反引号，例如 hive 里使用反引号就可以规避保留字</li>
<li>javaFileEncoding ，指定Java文件的编码方式，参考 <code>java.nio.charset.Charset</code></li>
</ul>
<h4 id="lt-plugin-gt-一些常用元素"><a href="#lt-plugin-gt-一些常用元素" class="headerlink" title="[&lt;plugin&gt;](# 一些常用元素)"></a>[<code>&lt;plugin&gt;</code>](# 一些常用元素)</h4><p>生成代码时提供的插件，插件将按照配置中列出的顺序调用。<a href="http://mybatis.org/generator/reference/plugins.html">支持的插件</a> ，具体查看官方文档。</p>
<ul>
<li><p>下面列举几个可能常用的插件</p>
</li>
<li><p>org.mybatis.generator.plugins.ToStringPlugin</p>
</li>
<li><p>org.mybatis.generator.plugins.SerializablePlugin</p>
</li>
<li><p>org.mybatis.generator.plugins.RowBoundsPlugin  （对 targetRuntime&#x3D;MyBatis3DynamicSql 时无效）</p>
</li>
<li><p>org.mybatis.generator.plugins.FluentBuilderMethodsPlugin （生成builder 方法，方便进行链式赋值）</p>
</li>
<li><p>org.mybatis.generator.plugins.EqualsHashCodePlugin</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-commentGenerator-gt-一些常用元素"><a href="#lt-commentGenerator-gt-一些常用元素" class="headerlink" title="[&lt;commentGenerator&gt;](# 一些常用元素)"></a>[<code>&lt;commentGenerator&gt;</code>](# 一些常用元素)</h4><p><a href="http://mybatis.org/generator/configreference/commentGenerator.html">官方文档部分</a> , 用于控制生成的java 代码中field，method ，等内容的注释。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. type 为可选 attribute，可以指定用户自定义的 CommentGenerator，具体参考官方文档</span><br><span class="line">2. 常用的 property 属性都列在了下面</span><br><span class="line"></span><br><span class="line">// 这里type指定的为用户自定义的 CommentGenerator 类,为了与 Swagger 文档结合</span><br><span class="line"><span class="tag">&lt;<span class="name">commentGenerator</span> <span class="attr">type</span>=<span class="string">&quot;com.macro.mall.tiny.mbg.CommentGenerator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--这里的remark是指利用table的中文名生成代码注释--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addRemarkComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="lt-connectionFactory-gt-一些常用元素"><a href="#lt-connectionFactory-gt-一些常用元素" class="headerlink" title="[&lt;connectionFactory&gt;](# 一些常用元素)"></a>[<code>&lt;connectionFactory&gt;</code>](# 一些常用元素)</h4><p><connectionFactory> (either connectionFactory or jdbcConnection is Required)</p>
<ul>
<li>用于获取自省表所需的数据库连接。每个 <context> 元素都需要一个，<connectionFactory> 或 <jdbcConnection> 二选一。</li>
</ul>
<h4 id="lt-jdbcConnection-gt-一些常用元素"><a href="#lt-jdbcConnection-gt-一些常用元素" class="headerlink" title="[&lt;jdbcConnection&gt;](# 一些常用元素)"></a>[<code>&lt;jdbcConnection&gt;</code>](# 一些常用元素)</h4><p><jdbcConnection> (either connectionFactory or jdbcConnection is Required)</p>
<ul>
<li><p>driverClass ，JDBC driver 的全限定类名，必须的属性</p>
</li>
<li><p>connectionURL ，连接数据库用的 JDBC 连接 url，必须的属性</p>
</li>
<li><p>userId ，数据库用户名，可选</p>
</li>
<li><p>password ， 数据库密码，可选</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--connectionFactory 与 jdbcConnection 作用一样，连接数据库用，且使用的参数也一样--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--区别，写法不一样，详见样例--&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">connectionFactory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionURL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:hsqldb:mem:aname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sa&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">connectionFactory</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!--与上面的作用一样，根据需要不同，userId，与 password 是可选的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;COM.ibm.db2.jdbc.app.DB2Driver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:db2:MBGTEST&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">userId</span>=<span class="string">&quot;db2admin&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">password</span>=<span class="string">&quot;db2admin&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="lt-javaTypeResolver-gt-一些常用元素"><a href="#lt-javaTypeResolver-gt-一些常用元素" class="headerlink" title="[&lt;javaTypeResolver&gt;](# 一些常用元素)"></a>[<code>&lt;javaTypeResolver&gt;</code>](# 一些常用元素)</h4><h4 id="lt-javaModelGenerator-gt-一些常用元素"><a href="#lt-javaModelGenerator-gt-一些常用元素" class="headerlink" title="[&lt;javaModelGenerator&gt;](# 一些常用元素)"></a>[<code>&lt;javaModelGenerator&gt;</code>](# 一些常用元素)</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">用于作JavaModel代码生成的配置</span><br><span class="line"></span><br><span class="line">1. targetPackage 是 targetProject 的子目录，两者合起来是生成代码存放的具体位置。</span><br><span class="line">2. 常用的两个property列在了下面，也可以都不用。</span><br><span class="line"><span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;test.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;\MyProject\src&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="lt-sqlMapGenerator-gt-一些常用元素"><a href="#lt-sqlMapGenerator-gt-一些常用元素" class="headerlink" title="[&lt;sqlMapGenerator&gt;](# 一些常用元素)"></a>[<code>&lt;sqlMapGenerator&gt;</code>](# 一些常用元素)</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  每个内省的表构建一个 MyBatis 格式的 SQL 映射 XML 文件。</span><br><span class="line"><span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;test.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;\MyProject\src&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>仅当您选择的 <javaClientGenerator> 需要 XML 时，此元素才是 <context> 元素的必需子元素。</p>
</blockquote>
<h4 id="lt-javaClientGenerator-gt-一些常用元素"><a href="#lt-javaClientGenerator-gt-一些常用元素" class="headerlink" title="[&lt;javaClientGenerator&gt;](# 一些常用元素)"></a>[<code>&lt;javaClientGenerator&gt;</code>](# 一些常用元素)</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">用于指定生成 Java 客户端接口和类，如果不配置，则不生成。</span><br><span class="line">1. type 属性，如果  <span class="tag">&lt;<span class="name">context</span>&gt;</span> targetRuntime 是 MyBatis3DynamicSql,则是可选的，因为它会生成带注解的接口，不会生成 SQL mapper XML 文件；</span><br><span class="line"></span><br><span class="line">2. 如果 <span class="tag">&lt;<span class="name">context</span>&gt;</span> targetRuntime 是 MyBatis3，则需要通过指定type为 ANNOTATEDMAPPER,MIXEDMAPPER,XMLMAPPER 来判断如何生成 </span><br><span class="line"></span><br><span class="line">  3. 其中 MIXEDMAPPER，简单的SQL会生成注解，复杂的动态SQL会生成 XML 文件。其他两个就简单了。</span><br><span class="line">  <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;test.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;\MyProject\src&quot;</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="lt-table-gt-一些常用元素"><a href="#lt-table-gt-一些常用元素" class="headerlink" title="[&lt;table&gt;](# 一些常用元素)"></a>[<code>&lt;table&gt;</code>](# 一些常用元素)</h4><ul>
<li>很多内容<ul>
<li><generatedKey> ，是 <table> 的子元素 ，用于映射 <insert> 元素时生成合适的 <selectKey> 元素</li>
</ul>
</li>
</ul>
<h2 id="运行-MyBatis-Generator"><a href="#运行-MyBatis-Generator" class="headerlink" title="运行 MyBatis Generator"></a>运行 MyBatis Generator</h2><ul>
<li><p>命令行运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar mybatis-generator-core-x.x.x.jar -configfile \temp\generatorConfig.xml -overwrite</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-overwrite 覆盖已存在的Java 同名文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Maven Plugin (mybatis-generator-maven-plugin)</p>
<ul>
<li><a href="http://mybatis.org/generator/running/runningWithMaven.html">官方maven使用样例</a></li>
<li>mvn mybatis-generator:generate  <ul>
<li>默认需要手动执行该命令才能生存，或者也可以配置 maven goal 和 execution 在 mvn 时自动生成</li>
</ul>
</li>
<li>${basedir}&#x2F;src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml 默认 XML 配置文件位置</li>
</ul>
</li>
<li><p>Eclipse Plugin</p>
</li>
<li><p>Java 编程方式触发 generator 的生成</p>
<ul>
<li><p>支持通过解析 generatorConfig.xml 配置文件的形式生成代码；（XML 配置文件方式更常用)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; warnings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;generatorConfig.xml&quot;</span>);</span><br><span class="line"><span class="type">ConfigurationParser</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warnings);</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> cp.parseConfiguration(configFile);</span><br><span class="line"><span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);</span><br><span class="line"><span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(config, callback, warnings);</span><br><span class="line">myBatisGenerator.generate(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果在配置文件中指定了一个属性并且未解析，则转义的属性字符串将“按原样”传递到生成的代码中。</p>
</blockquote>
</li>
<li><p>支持基于java代码配置（在java代码中构建Configuration对象） 的形式生成代码；（样例，略，查看官方文档）</p>
</li>
</ul>
</li>
<li><p>ant task</p>
</li>
</ul>
<h1 id="运行-MyBatis-Generator-后的任务"><a href="#运行-MyBatis-Generator-后的任务" class="headerlink" title="运行 MyBatis Generator 后的任务"></a>运行 MyBatis Generator 后的任务</h1><p>更新 MyBatis 3.x 中的 <code>MapperConfig.xml</code> 文件</p>
<ul>
<li><p>必须列出 MBG 生成的 XML mapper 文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- XML mapper files should be listed here --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;test/xml/MyTable_SqlMap.xml&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 如果有多个都列在这里 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考文件</p>
<p><a href="http://mybatis.org/generator/running/runningWithMaven.html">MBG 官方文档</a></p>
<p><a href="https://mybatis.org/generator/apidocs/org/mybatis/generator/api/ProgressCallback.html">MBG 代码主要涉及步骤</a></p>
<h1 id="MBG-运行遇到的问题"><a href="#MBG-运行遇到的问题" class="headerlink" title="MBG 运行遇到的问题"></a>MBG 运行遇到的问题</h1><ol>
<li><p>配置完 generatorConfig.xml 文件之后，通过 java 代码运行没有生成预期的 model ，mapper interface，和 mapper XML文件，而且什么报错也没有。</p>
<p>解决：1. 与配置文件中的 <code>targetProject</code> 和 <code>targetPackage</code> 两个属性有关系，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;spoonli.data.mybatis.mbg.model&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">targetProject</span>=<span class="string">&quot;./src/main/java&quot;</span>&gt;</span></span><br><span class="line">1. targetProject 这个目录一样要存在，且配置正确，可以配置全路径，也可以配置相对路径（建议，这样就不用频繁修改了）</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置的generatorConfig.xml 文件，在 Spring Boot 中使用内嵌 h2 数据库自动创建表，然后通过 MyBatisGenerator 生成代码的过程中，发现 h2 数据库没有自动创建写好的 resources&#x2F;schema.xml 文件中的表。</p>
<p>解决：暂时没有解决，换了 MySQL 数据库配置后自动生成没有问题，同时通过debug generate 方法发现，程序在数据库自省的过程中没有在内嵌的 h2 数据库中找到指定的表，在源码这行<code>List&lt;IntrospectedTable&gt; tables = databaseIntrospector.introspectTables(tc);</code> tables变量为 null，说明配置的 Spring Boot 内嵌 h2 数据库没有自动执行创建语句。</p>
</li>
</ol>
<hr>
<h2 id="Mapper文件"><a href="#Mapper文件" class="headerlink" title="Mapper文件"></a>Mapper文件</h2><p>MyBatis 中 Mapper 接口引用 XML 配置</p>
<blockquote>
<p>mapper interfaces that reference an XML configuration for MyBatis.</p>
</blockquote>
<p>在<code>编写Mapping文件</code>时，需要注意</p>
<ul>
<li><p>默认情况下，Mapper文件名于Map接口名一样，一般以<code>*Mapper.xml</code>结尾</p>
</li>
<li><p>Mapper文件中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">&quot;xxx&quot;</span>&gt;  <span class="comment">//要检查xxx是否与xml文件坐在package包名一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Mapper文件中的SQL语句中，</p>
<ol>
<li><p><code>id</code>要与Mapper接口文件中的方法名一样</p>
</li>
<li><p><code>parameterType</code>是参数的类型，一个参数时可以如果要指定，需要与方法中参数的数据类型一直，<em>可以省略不写</em></p>
</li>
<li><p>SQL语法中传入的参数要与方法中参数名一样，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// applyId是方法参数中的参数名称，这里要一致</span><br><span class="line">&lt;select id=&quot;getTaskID&quot; parameterType=&quot;String&quot;&gt;</span><br><span class="line">	select business_id from apply where id=#&#123;applyId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般如果需要对传入的参数做判断，String !&#x3D;null and String !&#x3D;’’, Number !&#x3D;null 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这是一个update操作</span><br><span class="line">&lt;!--update apply set apply_status=? where id=?--&gt;</span><br><span class="line">&lt;update id=&quot;updateApplyStatus&quot;&gt;</span><br><span class="line">	update apply</span><br><span class="line">	&lt;set&gt;</span><br><span class="line">		&lt;if test=&quot;applyStatus!=null&quot;&gt; //判断传入的数字参数applyStatus是否为null</span><br><span class="line">			apply_status=#&#123;applyStatus,jdbcType=DECIMAL&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">	&lt;/set&gt;</span><br><span class="line">	&lt;where&gt;</span><br><span class="line">		&lt;if test=&quot;applyId !=null and applyId!=&#x27;&#x27;&quot;&gt;  //String类型的，判断!=null,!=&quot;&quot;</span><br><span class="line">			id=#&#123;applyId,jdbcType=VARCHAR&#125;</span><br><span class="line">		&lt;/if&gt;</span><br><span class="line">	&lt;/where&gt;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p>​       </p>
<h2 id="Mybatis运行报错"><a href="#Mybatis运行报错" class="headerlink" title="Mybatis运行报错"></a>Mybatis运行报错</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.yo....</span><br></pre></td></tr></table></figure>

<p>运行时遇到上面的错误，找到了下面的内容，一般也就按照下面的提示内容检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先，给定的异常提示信息并不精准，有多个错误原因都会抛出该异常。mybatis出现这个问题，通常是由Mapper interface和对应的xml文件的定义对应不上引起的，这时就需要仔细检查对比包名、xml中的namespace、接口中的方法名称等是否对应。我之前就因为称忘记在xml标签的id属性中添加方法名或写错方法名而出现这个错误。</span><br><span class="line">出现这个错误时，按以下步骤检查一般就会解决问题：</span><br><span class="line">1：检查xml文件所在package名称是否和Mapper interface所在的包名一一对应；</span><br><span class="line">2：检查xml的namespace是否和xml文件的package名称一一对应；</span><br><span class="line">3：检查方法名称是否对应；</span><br><span class="line">4：去除xml文件中的中文注释；</span><br><span class="line">5：随意在xml文件中加一个空格或者空行然后保存。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p>学习的过程中参考了下面的博客内容，</p>
<p>附上地址链接：</p>
<p><a href="http://blog.csdn.net/yzllz001/article/details/54312929">http://blog.csdn.net/yzllz001/article/details/54312929</a><br><a href="http://www.cnblogs.com/softidea/p/5884772.html">http://www.cnblogs.com/softidea/p/5884772.html</a><br><a href="http://www.jianshu.com/p/800fe918cc7a">http://www.jianshu.com/p/800fe918cc7a</a></p>
<h1 id="20210421添加"><a href="#20210421添加" class="headerlink" title="20210421添加"></a>20210421添加</h1><p>问题：</p>
<ol>
<li>mybatis-config.xml中mapper对应的文件可以是classpath中的相对路径吗？如何是，需要如何配置？</li>
<li>mapper.xml文件中，SQL语句返回的resultType如果是自定义的，是否需要在哪里注册？</li>
<li>mapper.xml中，多张表配置多个xml文件</li>
</ol>
<p>在Mybatis的config.xml配置文件中<br>properties的优先级如下：<br>    Thus, the highest priority properties are those passed in as a method parameter, followed by resource&#x2F;url attributes and finally the properties specified in the body of the properties element.</p>
<p>如果配置多个environment，每个SqlSessionFactory实例只能使用一个<br>    （While you can configure multiple environments, you can only choose ONE per SqlSessionFactory instance. ）<br>所以，如果需要连接两个数据库，那么就需要两个SqlSessionFactory实例<br>    - One SqlSessionFactory instance per database </p>
<p>数据库连接池<br>org.apache.commons.dbcp：<br>ali的Druid：<br>上面两个好像都可以生成DataSource，有什么不同吗？</p>
<p>Druid的两种DataSourceFactory在与Mybatis一同使用时有什么不同吗？<br>为什么抄来的代码中要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下，要通过Druid的pool的DataSource来创建ibatis的DataSource然后再用到mybatis-config.xml的datasource中，</span></span><br><span class="line"><span class="comment">// 而不是直接使用Druid的support.ibatis的DataSource？是应为这个无法使用pool连接池吗？</span></span><br><span class="line"><span class="comment">// Druid中这两个datasource的区别是什么？</span></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.datasource.DataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDruidDSFactory</span> <span class="keyword">implements</span> <span class="title class_">DataSourceFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mybatis的mapper文件中，如何对sql传递多个参数？</p>
<p>不明白，migrate程序中为什么开始show database时，和后面insertdata时的connection 要用两种连接方式？为什么不能全都使用连接池？<br>    - 一种通过jdbc的方式直接创建<br>    - 一种通过common.dbcp连接池创建？</p>
<p>利用Mybatis如何连接华为平台，使用kerbose认证的情况？<br>    配置文件让配置kerbose的url？也是可能的，但是没有migrate程序中将重要属性分开设置，程序拼接url友好</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习</title>
    <url>//SpringBoot%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p>总体需要学习掌握哪些？</p>
<p>怎么用？</p>
<p>什么场景使用？</p>
<p>特性是什么？</p>
<p>有没有什么注意点？</p>
<p>原理是什么？</p>
<ol>
<li>sprint boot 如何快速开始一个任务？</li>
</ol>
<p>1.1. 看一下pom的内容<br>    需要有自己这个moudle的名字，group和artifactid<br>    有父类依赖的，需要有parent，没有的则不需要<br>    默认的pom至少有出去开头部分，至少有两块<br>        dependencies   –用于引入依赖<br>    和  build.plugins   –用于编包<br>        spring-boot-maven-plugin  –这个plugin可以做什么？</p>
<p>1.2. 不使用自带的parent dependency，应该如何写？</p>
<ol start="2">
<li>如何操作数据？</li>
</ol>
<p>2.1. 如何配置一个数据源？</p>
<p>2.2. 如果需要多个数据源，应该如何配置？</p>
<p>2.3. 如何使用数据库连接池？好处是什么？</p>
<p>2.4. spring 中如何操作数据库的事务？</p>
<p>2.5. 怎么判断回滚？<br>    在transaction注解中可以设置当遇到指定异常类时才回滚</p>
<hr>
<h1 id="SpringBoot注解annotation总结"><a href="#SpringBoot注解annotation总结" class="headerlink" title="SpringBoot注解annotation总结"></a>SpringBoot注解annotation总结</h1><p>&#x2F;&#x2F; 用在class上，<br>&#x2F;&#x2F; 意味着，这个class可以用于spring boot的web request请求<br>@RestController</p>
<p>&#x2F;&#x2F; 用在method上<br>&#x2F;&#x2F; 意味着，@RequestMapping(“xxx”) 这个后面的xxx与标记的方法是对应的，当通过浏览器或者curl访问<br>这个url时，就是在调用这个方法<br>@RequestMapping</p>
<p>because @RestController combines @Controller and @ResponseBody, two annotations that results in web requests returning data rather than a view.</p>
<p>@SpringBootApplication</p>
<p>@Configuration</p>
<p>@EnableAutoConfiguration</p>
<p>@ComponentScan</p>
<p>@Component</p>
<blockquote>
<p>spring发现该注解后，会自动将有该注解的类变成Bean注册到容器中</p>
</blockquote>
<p>有两个很常用的词<br>configure</p>
<p>注入型的注解</p>
<ul>
<li>@Autowired</li>
<li></li>
</ul>
<p>Bean是Spring容器中成员的最小组成部分，它也是普通的JavaBean</p>
<h1 id="spring的事务"><a href="#spring的事务" class="headerlink" title="spring的事务"></a>spring的事务</h1><p>编程式事务</p>
<p>声明式事务</p>
<h1 id="Spring数据访问"><a href="#Spring数据访问" class="headerlink" title="Spring数据访问"></a>Spring数据访问</h1><ul>
<li>jdbc</li>
<li>ORM</li>
<li>NoSQL</li>
<li>Reactive</li>
</ul>
<h1 id="12-spring的jdbc异常抽象"><a href="#12-spring的jdbc异常抽象" class="headerlink" title="12 spring的jdbc异常抽象"></a>12 spring的jdbc异常抽象</h1><p>无论使用何种数据访问方式，都能使用一样的异常</p>
<p>spring是怎么识别那些错误码的？</p>
<p>spring-error-code.xml 将各个数据库常见的数据码和错误定义在该文件中</p>
<p>也支持自定义错误码</p>
<h1 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h1><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p>可以使Mybatis更好用的工具</p>
<ul>
<li>Mybatis Generator<ul>
<li>一些内嵌子工具</li>
</ul>
</li>
<li>Mybatis PageHelper<ul>
<li>帮助更好的处理分页的</li>
<li>支持多种数据库</li>
<li>支持多种分页形式</li>
</ul>
</li>
</ul>
<p>注意：如果既要使用组件自动生成的部分，又需要对它做一个手动的微调</p>
<p>把手动处理的部分和自动生成的部分放在不同的位置</p>
<p>有两套model，mapper，xml，这样下次自动生成时就会仅覆盖自动成的部分，不会干扰手动处理的部分</p>
<p>尽管Mybatis Genertor有合并的逻辑，但是并不是很靠谱。</p>
<h1 id="分库分表的中间件"><a href="#分库分表的中间件" class="headerlink" title="分库分表的中间件"></a>分库分表的中间件</h1><p> TDDL、Cobar、MyCAT、Sharding-Shpere</p>
<h1 id="SpringApplicationContext"><a href="#SpringApplicationContext" class="headerlink" title="SpringApplicationContext"></a>SpringApplicationContext</h1><p>上下文和切面增强</p>
<p>FooConfig.java：父上下文（parent application context）。<br>applicationContext.xml：子上下文（child application context）。</p>
<p>FooConfig.java 中定义两个 testBean，分别为 testBeanX(foo) 和 testBeanY(foo)。<br>applicationContext.xml 定义了一个 testBeanX(bar)。</p>
<p>委托机制：在自己的 context 中找不到 bean，会委托父 context 查找该 bean。</p>
<hr>
<p>代码解释：<br>fooContext.getBean(“testBeanX”)，在父上下文查找 testBeanX，命中直接返回 testBeanX(foo)。<br>barContext.getBean(“testBeanX”)，在子上下文查找 testBeanX，命中直接返回 testBeanX(bar)。<br>barContext.getBean(“testBeanY”)，在子上下文查找 testBeanY，未命中；委托父上下文查找，命中，返回 testBeanY(foo)。</p>
<hr>
<p>场景一：<br>父上下文开启 @EnableAspectJAutoProxy 的支持<br>子上下文未开启 &lt;aop: aspectj-autoproxy &#x2F;&gt;<br>切面 fooAspect 在 FooConfig.java 定义（父上下文增强）</p>
<p>输出结果：<br>testBeanX(foo) 和 testBeanY(foo) 均被增强。<br>testBeanX(bar) 未被增强。</p>
<p>结论：<br>在父上下文开启了增强，父的 bean 均被增强，而子的 bean 未被增强。</p>
<hr>
<p>场景二：<br>父上下文开启 @EnableAspectJAutoProxy 的支持<br>子上下文开启 &lt;aop: aspectj-autoproxy &#x2F;&gt;<br>切面 fooAspect 在 applicationContext.xml 定义（子上下文增加）</p>
<p>输出结果：<br>testBeanX(foo) 和 testBeanY(foo) 未被增强。<br>testBeanX(bar) 被增强。</p>
<p>结论：<br>在子上下文开启增强，父的 bean 未被增强，子的 bean 被增强。</p>
<hr>
<p>根据场景一和场景二的结果，有结论：“各个 context 相互独立，每个 context 的 aop 增强只对本 context 的 bean 生效”。如果想将切面配置成通用的，对父和子上下文的 bean 均支持增强，则：</p>
<ol>
<li>切面 fooAspect 定义在父上下文。</li>
<li>父上下文和子上下文，均要开启 aop 的增加，即 @EnableAspectJAutoProxy 或&lt;aop: aspectj-autoproxy &#x2F;&gt; 的支持。</li>
</ol>
<h1 id="SringMV的请求处理流程"><a href="#SringMV的请求处理流程" class="headerlink" title="SringMV的请求处理流程"></a>SringMV的请求处理流程</h1><p>官方文档中有流程解析图</p>
<p>一个请求的大致处理流程</p>
<p>SpringMVC 中的 DispatcherServlet</p>
<blockquote>
<p>render，如果是在图形相关内容，可以翻译为，“渲染”</p>
<p>但是在Sring中，目前选择翻译为 <code>“呈现”</code> </p>
</blockquote>
<p>idea中发起request请求的插件</p>
<p>handler与mapping</p>
<p>如何寻找合适的handler？</p>
<p>charset 字符集</p>
<h1 id="如何定义Controller？和Controller中的一些方法？"><a href="#如何定义Controller？和Controller中的一些方法？" class="headerlink" title="如何定义Controller？和Controller中的一些方法？"></a>如何定义Controller？和Controller中的一些方法？</h1><h2 id="如何定义映射关系"><a href="#如何定义映射关系" class="headerlink" title="如何定义映射关系"></a>如何定义映射关系</h2><p>@Controller</p>
<p>@RequestMapping</p>
<ul>
<li>path &#x2F; method 指定映射路径与http方法</li>
<li>params &#x2F; headers 限定参数映射范围</li>
<li>consumes &#x2F; produces 限定只包含特定Content-Type的请求，&#x2F; 限定特定响应格式，需要加特定accept头</li>
</ul>
<p>一些快捷方式</p>
<ul>
<li>@RestController  （@Controller 与 @ResponseBody结合到一起）</li>
<li>@GetMapping &#x2F; @PostMapping &#x2F; @PutMapping &#x2F; @DeleteMapping &#x2F; @PatchMapping</li>
</ul>
<p>定义处理方法的常用注解</p>
<ul>
<li>@RequestBody 请求正文&#x2F; @ResponseBody 响应正文&#x2F; @ResponseStatus  Http响应的返回码&#x2F;状态码</li>
<li>下面是定义参数时使用的</li>
<li>@PathVariable URL路径中的变量&#x2F; @RequestParam 请求的参数&#x2F; @RequestHeader 请求的HTTP头</li>
<li>参数中可以接受 HttpEntity &#x2F; 响应的时候可以为 ResponseEntity</li>
</ul>
<p>很多参数与返回类型可供选择<br>具体参考SpringMVC官方网站文档<br>1.3.3 Handler Methods<br>Method Arguments<br>Return Values</p>
<p>@Controller的方法能够接受的参数与返回值<br>mvc-ann-arguments  方法参数<br>mvc-ann-return-types  方法返回值</p>
<p>问题：<br>@Controller与@RestController具体有什么区别？请求上有什么区别？仅仅是@RestController&#x3D;@Controller+@ResponseBody??</p>
<p>样例：</p>
<h2 id="定义类型转换"><a href="#定义类型转换" class="headerlink" title="定义类型转换"></a>定义类型转换</h2><ol>
<li>自己实现WebMvcConfigurer<ul>
<li>SpringBoot 在WebMvcAutoConfiguration（自动配置类）中实现了一个<ul>
<li>需要关注 addFormatter这个实现方法，分别获取Converter，GenericConverter,Formatter</li>
</ul>
</li>
<li>添加自定义的Converter</li>
<li>添加自定义的Formatter</li>
</ul>
</li>
</ol>
<h2 id="定义校验"><a href="#定义校验" class="headerlink" title="定义校验"></a>定义校验</h2><ul>
<li>通过Validator 对绑定结果进行校验<ul>
<li>Hibernate Validator， 如果有这个就使用</li>
</ul>
</li>
<li>在绑定的对象上添加一个， @Valid 注解</li>
<li>BindingResult ， 绑定的检查结果，在参数中通过BindingResult传递进去<ul>
<li>当不希望SpringMvc处理绑定报错，想自己处理报错内容时使用，参考43节，第6章，more-complex代码</li>
</ul>
</li>
</ul>
<h2 id="Multipart-上传"><a href="#Multipart-上传" class="headerlink" title="Multipart 上传"></a>Multipart 上传</h2><ul>
<li>配置MultipartResolver<ul>
<li>SpringBoot 自动配置 MultipartAutoconfiguration</li>
</ul>
</li>
<li>支持类型 multipart&#x2F;form-data</li>
<li>MultipartFile 类型</li>
</ul>
<p>org.apache.commons-lang3 类库<br>NumberUtils<br>StringUtils.split()</p>
<p>处理表单？？？<br>    - 可以不适用@RequestBody?<br>    - 在@PostMapping中使用consumes&#x3D;MediaType.application_form_urlencoded_value就可以？<br>    - 这就涉及到@RequestBody与@RequestParam两个注解的区别了<br>        - 可以看一下Spring中这两个注解的注释<br>        - @RequestBody注解，是把整个请求的Body传给参数<br>        - @RequestParam注解，是可以把Body里的对应部分却出来传给参数</p>
<p>postman中，form-data 与x-www-form-urlencoded有啥区别？</p>
<h1 id="SprigMVC中的视图解析机制"><a href="#SprigMVC中的视图解析机制" class="headerlink" title="SprigMVC中的视图解析机制"></a>SprigMVC中的视图解析机制</h1><h2 id="视图解析的基本实现"><a href="#视图解析的基本实现" class="headerlink" title="视图解析的基本实现"></a>视图解析的基本实现</h2><p>ViewResolver与view接口<br>用的比较多的ViewResolver</p>
<h2 id="DispatcherServlet-中的视图解析逻辑"><a href="#DispatcherServlet-中的视图解析逻辑" class="headerlink" title="DispatcherServlet 中的视图解析逻辑"></a>DispatcherServlet 中的视图解析逻辑</h2><p>针对有ModelAndView返回的解析过程</p>
<ul>
<li>初始化DispatcherServlet的时候，会初始化所有的ViewResolver，这里它会把Spring上下文当中所有的ViewResolver都加载进来（一般建议不改动，也可以选择只加载对应的某一个viewResolver）</li>
<li>具体请求时，会在doDispatch()中对我们处理的ModelAndView的结果去做processDispatchResult()的时候，会去做从视图名到具体视图的一个解析，当解析出View对象的时候，会做一个视图的呈现。<ul>
<li>如果没有返回视图的话，使用RequestToViewNameTrnaslater去做一个尝试解析一个View的名字</li>
</ul>
</li>
</ul>
<p>转发（forword）与重定向(redirect)的区别</p>
<ul>
<li>forword是服务器的跳转，浏览器是感知不到的，浏览器地址不会改变</li>
<li>redirect是客户端的跳转，浏览器地址会改变</li>
</ul>
<h1 id="45-SpringMVC中的视图解析机制（下）"><a href="#45-SpringMVC中的视图解析机制（下）" class="headerlink" title="45 SpringMVC中的视图解析机制（下）"></a>45 SpringMVC中的视图解析机制（下）</h1><h2 id="加了-ResponseBody注解的请求，它的结果是如何输出到Response当中去的"><a href="#加了-ResponseBody注解的请求，它的结果是如何输出到Response当中去的" class="headerlink" title="加了@ResponseBody注解的请求，它的结果是如何输出到Response当中去的"></a>加了@ResponseBody注解的请求，它的结果是如何输出到Response当中去的</h2><h1 id="SpringMVC中的常用视图"><a href="#SpringMVC中的常用视图" class="headerlink" title="SpringMVC中的常用视图"></a>SpringMVC中的常用视图</h1><ul>
<li>查看spring官方文档，支持的视图列表</li>
<li>最常用的Jackson-based JSON&#x2F;XML</li>
<li>支持的模板引擎<ul>
<li>最常用的Thymeleaf &amp; FreeMarker</li>
</ul>
</li>
</ul>
<h2 id="配合MessageConverter-类型到视图的转换"><a href="#配合MessageConverter-类型到视图的转换" class="headerlink" title="配合MessageConverter, 类型到视图的转换"></a>配合MessageConverter, 类型到视图的转换</h2><h2 id="SpringBoot对Jackson的支持"><a href="#SpringBoot对Jackson的支持" class="headerlink" title="SpringBoot对Jackson的支持"></a>SpringBoot对Jackson的支持</h2><p>Spring自动配置相关内容：</p>
<ol>
<li>需要支持我们需要配置什么？</li>
<li>SpringBoot帮我们处理了什么？</li>
</ol>
<p>SpringBoot会自动处理一下在classpath中出现的，需要处理转换的类型，</p>
<ul>
<li>我们只需要将依赖放到dependency中就可以</li>
<li>当然我们也可以自己做这些Bean的配置</li>
</ul>
<h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>java模板引擎</p>
<p>模板如何写？可以参考Thymeleaf官方文档</p>
<p>（我个人理解，使用场景是web页面）</p>
<h1 id="48-静态资源和缓存"><a href="#48-静态资源和缓存" class="headerlink" title="48 静态资源和缓存"></a>48 静态资源和缓存</h1><blockquote>
<p>有比java程序更合适提供静态资源的工具，比如使用nginx（lzy就是这样）</p>
</blockquote>
<p>通常关于用户的静态资源一般放在CDN上，由CDN提供静态资源的访问，当CDN回源时，有一组专门提供静态资源服务的服务器，来提供CND回源所需要的的服务。<br>也可以有一个CMS的服务，由后台配置该资源的访问，同时静态资源本身还可以添加一些缓存（例如，Squid，Varnish）</p>
<p>另一方面，应用的请求，可以通过Gateway进入到我们的后台系统来，在Gateway中可以设置特定路径的Cache-controller的配置。<br>也可以通过nginx设置对缓存的控制</p>
<h1 id="Spring-MVC的异常解析"><a href="#Spring-MVC的异常解析" class="headerlink" title="Spring MVC的异常解析"></a>Spring MVC的异常解析</h1><p>核心接口</p>
<ul>
<li>HandlerExceptionResolver</li>
</ul>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><p>DispatcherServlet中doService方法中处理异常的代码</p>
<h2 id="如何写异常处理方法"><a href="#如何写异常处理方法" class="headerlink" title="如何写异常处理方法"></a>如何写异常处理方法</h2><p>处理方法</p>
<ul>
<li>@ExceptionHandler</li>
</ul>
<p>添加位置</p>
<ul>
<li>@Controller &#x2F; @RestController</li>
<li>@ControllerAdvice &#x2F; @RestControllerAdvice (优先级会低于上面的两个)</li>
</ul>
<p>官方文档 1.3.6 Exceptions</p>
<h1 id="在Spring-MVC-如何使用-x2F-实现-拦截器"><a href="#在Spring-MVC-如何使用-x2F-实现-拦截器" class="headerlink" title="在Spring MVC 如何使用&#x2F;实现 拦截器"></a>在Spring MVC 如何使用&#x2F;实现 拦截器</h1><p>核心接口</p>
<ul>
<li>HandlerInterceptor<ul>
<li>boolean preHandler()  true -&gt; 继续处理，false -&gt; 停止处理</li>
<li>void postHandler()</li>
<li>void afterCompletion()</li>
</ul>
</li>
</ul>
<p>针对 @ResponseBody 和 ResponseEntity 的情况</p>
<ul>
<li>提供了 ResponseBodyAdvice</li>
</ul>
<p>针对异步请求的接口</p>
<ul>
<li>AsyncHandlerInterceptor<ul>
<li>void afterConcurrentHandlingStarted()</li>
<li>如果是异步操作，是不会执行postHandler() 和 afterCompletion()方法的</li>
</ul>
</li>
</ul>
<p>看一下在DispatcherServlet()方法中如何处理的<br>    - doDispath<br>    - applyPreHandle()<br>    - handle<br>    - applyPostHandle()</p>
<h2 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h2><p>常规方法</p>
<ul>
<li>WebMvcConfigurer.addInterceptors()<ul>
<li>各种Interceptor 添加的动作</li>
</ul>
</li>
</ul>
<p>Spring Boot中的配置</p>
<ul>
<li>创建一个带@Configuraion注解的类，让这个类去实现(implements) WebMvcConfigurer 配置类，然后自己去实现当中的 addInterceptors 的方法</li>
<li>不能带 @EnableWebMvc (想彻底自己控制MVC配合除外)</li>
</ul>
<p>参考 第6章的springbucket代码</p>
<h1 id="52-课程答疑"><a href="#52-课程答疑" class="headerlink" title="52 课程答疑"></a>52 课程答疑</h1><ol>
<li>使用MySQL代替H2</li>
<li>示例中使用到的一些Java语言特性说明</li>
<li>MyBatis Generator 生成代码时的一些说明</li>
<li>MyBatis-Plus 介绍</li>
</ol>
<p>第7章</p>
<h1 id="通过-RestTemplate-访问-Web-资源"><a href="#通过-RestTemplate-访问-Web-资源" class="headerlink" title="通过 RestTemplate 访问 Web 资源"></a>通过 RestTemplate 访问 Web 资源</h1><p>SpringBoot中的RestTemplate</p>
<ul>
<li>SpringBoot 中没有自动配置 RestTemplate</li>
<li>SpringBoot 提供了 RestTemplateBuilder<ul>
<li>RestTemplateBuilder.build()</li>
</ul>
</li>
</ul>
<p>RestTemplate 中常用的方法</p>
<p>它提供了与http 的Method 对应的方法</p>
<p>GET请求</p>
<ul>
<li>getForObject() &#x2F; getForEntity()</li>
</ul>
<p>Post请求</p>
<ul>
<li>postForObject() &#x2F; postForEntity()</li>
</ul>
<p>Put请求</p>
<ul>
<li>put()</li>
</ul>
<p>Delete 请求</p>
<ul>
<li>delete()</li>
</ul>
<p>提供了构造URI 的一些 方法</p>
<p>构造URI</p>
<ul>
<li>UriComponentsBuilder<br>构造相对于当前请求的URI</li>
<li>ServletUriComponentsBuilder<br>构造指向Controller 的 URI</li>
<li>MvcUriComponentsBuilder</li>
</ul>
<h1 id="RestTemplate-的高阶用法"><a href="#RestTemplate-的高阶用法" class="headerlink" title="RestTemplate 的高阶用法"></a>RestTemplate 的高阶用法</h1><p>传递 Http Header</p>
<ul>
<li>RestTemplate.exchange() + RequestEntity<T> &#x2F; ResponseEntity<T></li>
</ul>
<p>类型转换</p>
<ul>
<li>@JsonComponent + JsonSerializer &#x2F; JsonDeserializer</li>
</ul>
<p>解析泛型类型</p>
<ul>
<li>RestTemplate.exchange() +  ParameterizedTypeReference<T></li>
<li>ParameterizedTypeReference<T><ul>
<li>帮助定义泛型的类型</li>
</ul>
</li>
</ul>
<h1 id="简单定义RestTemplate"><a href="#简单定义RestTemplate" class="headerlink" title="简单定义RestTemplate"></a>简单定义RestTemplate</h1><p>RestTemplate 支持的HTTP 库</p>
<p>通用接口</p>
<ul>
<li>clientHttpRequestFactory<br>默认实现 (默认是JDK自带的)</li>
<li>SimpleClientHttpRequestFactory</li>
</ul>
<h2 id="优化底层请求策略"><a href="#优化底层请求策略" class="headerlink" title="优化底层请求策略"></a>优化底层请求策略</h2><p>连接管理</p>
<ul>
<li>PoolingHttpClientConnectionManager</li>
<li>KeepAlive 策略<br>超时设置</li>
<li>connectTimeout &#x2F; readTimeout</li>
</ul>
<p>SSL校验</p>
<ul>
<li>证书检查策略</li>
</ul>
<p>apache HttpComponents 提供了默认的KeepAlived 策略，同时，它的官网上提供了一个定制方式。</p>
<h1 id="通过WebClient-访问Web-资源"><a href="#通过WebClient-访问Web-资源" class="headerlink" title="通过WebClient 访问Web 资源"></a>通过WebClient 访问Web 资源</h1><blockquote>
<p>通过 Reactive 的方式访问HTTP 资源</p>
</blockquote>
<h2 id="了解-WebClient"><a href="#了解-WebClient" class="headerlink" title="了解 WebClient"></a>了解 WebClient</h2><ul>
<li>一个以 Reactive 方式处理 Http 请求的非阻塞式的客户端</li>
</ul>
<p>支持的底层 HTTP 库</p>
<ul>
<li>Reactive Netty - ReactorClientHttpConnector  (使用的更多)</li>
<li>Jetty ReactiveStream HttpClient - JettyClientHttpConnector</li>
</ul>
<p>WebClient 的基本使用</p>
<p>创建 WebClient</p>
<p>在Spring Boot 中没有自动配置，需要自己创建</p>
<ul>
<li>WebClient.create()</li>
<li>WebClient.buidler()</li>
</ul>
<p>发起请求</p>
<ul>
<li>get() &#x2F; post() &#x2F; put() &#x2F; delete() &#x2F; patch()</li>
</ul>
<p>获取结果</p>
<ul>
<li>retrieve() &#x2F; exchange()</li>
</ul>
<p>处理 HTTP Status</p>
<ul>
<li>onStatus()</li>
</ul>
<p>响应正文</p>
<ul>
<li>bodyToMono() &#x2F; bodyToFlux()</li>
</ul>
<blockquote>
<p>个人理解，是一种处理 http 请求的客户端，所以需要有 创建连接，发起请求，获取请求结果，处理请求结果和状态 的过程</p>
<p>特色是使用 Reactive 的方式处理。</p>
</blockquote>
<p>第7章样例中，main方法中没有启用web，为什么？</p>
<p><strong>注意：</strong><br>Reactive ，我们不能根据代码的书写顺序来决定它的执行顺序</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>如果使用 WebFlux，那么请求处理过程中需要访问其他 http 服务时，就可以使用 WebClient。</li>
<li>在通用一点，如果你希望通过异步线程来访问 HTTP 服务时，，就可以考虑使用 WebClient。Reactor 可以简化你的多线程代码</li>
</ol>
<h4 id="关于-Spring-中各种-xxxTemplate-的优点"><a href="#关于-Spring-中各种-xxxTemplate-的优点" class="headerlink" title="关于 Spring 中各种 xxxTemplate 的优点"></a>关于 Spring 中各种 xxxTemplate 的优点</h4><p>Spring 中的 xxxTempalte 都是对一些常见的操作做了统一的封装，屏蔽了底层的各种实现差异（即，底层依赖上可以更换各种支持的库，上层操作基本不用变），对上提供统一的操作。<br>RestTemplate 封装了各种 http 客户端，底层可以使用 JDK 内置的 HTTP 操作，也可以使用 HttpClient (apache 的 HTTPComponent 的 http 客户端)，和 OKHttp，同时还提供了与 Spring MVC 一致的格式转换能力，这是单纯的 http 客户端无法比拟的能力。</p>
<h1 id="设计好的-RESTful-Web-Service"><a href="#设计好的-RESTful-Web-Service" class="headerlink" title="设计好的 RESTful Web Service"></a>设计好的 RESTful Web Service</h1><p>什么是 REST？</p>
<p>Roy Thomas Fielding 博士的论文：<br><a href="https://www.infoq.cn/article/web-based-apps-archit-design">https://www.infoq.cn/article/web-based-apps-archit-design</a></p>
<p>不全面的理解：RESTful 是一种风格，但也可以暂时把它理解为一种 http uri 的表现形式。</p>
<p>Richardson 成熟度模型 - Glory of REST</p>
<h2 id="如何实现-RESTful-Web-Service"><a href="#如何实现-RESTful-Web-Service" class="headerlink" title="如何实现 RESTful Web Service"></a>如何实现 RESTful Web Service</h2><ul>
<li>识别资源</li>
<li>选择合适的资源粒度</li>
<li>设计 URI</li>
<li>选择合适的 HTTP 方法和返回码</li>
<li>设计资源的表述 （JSON &#x2F; XML &#x2F; …）</li>
</ul>
<h3 id="识别资源"><a href="#识别资源" class="headerlink" title="识别资源"></a>识别资源</h3><ul>
<li>找到领域名词<ul>
<li>能用 CRUD 操作的名词  ？？？</li>
</ul>
</li>
<li>将资源组合为集合（即集合资源） ，如，将所有coffee 放到一起成为 coffee 的集合，订单放到一起成为订单集合</li>
<li>将资源合并为复合资源， 如，将 coffee + order 一起返回，即组成了一个复合资源</li>
<li>计算或处理函数， 例如：从上海到北京的距离，是一种计算，没有领域名词，但也可以处理成为一种资源</li>
</ul>
<h3 id="设计资源的粒度"><a href="#设计资源的粒度" class="headerlink" title="设计资源的粒度"></a>设计资源的粒度</h3><p>站在服务端的角度，要考虑</p>
<ul>
<li>网络效率， 在一次网络交互传输多少？</li>
<li>表述的多少？？？</li>
<li>客户端的易用程度</li>
</ul>
<p>站在客户端的角度，要考虑</p>
<ul>
<li>可缓存性</li>
<li>修改频率</li>
<li>可变性</li>
</ul>
<h3 id="如何构建更好的-URI"><a href="#如何构建更好的-URI" class="headerlink" title="如何构建更好的 URI"></a>如何构建更好的 URI</h3><ul>
<li>使用域及子域对资源进行合理的分组或者划分</li>
<li>在 URI 的路径部分，使用斜杠分隔符（&#x2F;）来表示资源之间的层次关系</li>
<li>在 URI 的路径部分，使用逗号（,）和分号（;）来表示非层次元素 （不同的库，使用的分隔符不一定一致，,和; 用的并不是很多）？？？</li>
<li>使用连字符（-）和下划线（_）来改善长路径中名称的可读性</li>
<li>在 URI 的查询部分，使用“与”符号（&amp;）来分隔参数</li>
<li>在 URI 中避免出现文件扩展名（如，.php, .aspx 和 .jsp）</li>
</ul>
<h3 id="认识-HTTP-的方法"><a href="#认识-HTTP-的方法" class="headerlink" title="认识 HTTP 的方法"></a>认识 HTTP 的方法</h3><ul>
<li>安全，它不会改变我们资源中的各种内容</li>
<li>幂等，不管请求多少次结果都是一样的</li>
</ul>
<p>get<br>post<br>delete<br>put<br>head<br>options<br>trace</p>
<h3 id="认识-HTTP-状态码"><a href="#认识-HTTP-状态码" class="headerlink" title="认识 HTTP 状态码"></a>认识 HTTP 状态码</h3><p>200<br>201<br>202<br>301<br>303<br>304<br>307<br>400<br>401<br>403<br>404<br>410<br>500<br>503</p>
<p>具体可以参考 <a href="https://www.runoob.com/http/http-status-codes.html">https://www.runoob.com/http/http-status-codes.html</a></p>
<h3 id="选择合适的表述"><a href="#选择合适的表述" class="headerlink" title="选择合适的表述"></a>选择合适的表述</h3><ul>
<li>JSON<ul>
<li>各种子类</li>
</ul>
</li>
<li>XML</li>
<li>HTML</li>
<li>ProtoBuf</li>
</ul>
<h1 id="什么是-HATEOAS"><a href="#什么是-HATEOAS" class="headerlink" title="什么是 HATEOAS"></a>什么是 HATEOAS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="与传统的服务契约的区别"><a href="#与传统的服务契约的区别" class="headerlink" title="与传统的服务契约的区别"></a>与传统的服务契约的区别</h2><h1 id="使用-Spring-Data-REST-实现简单的超媒体服务"><a href="#使用-Spring-Data-REST-实现简单的超媒体服务" class="headerlink" title="使用 Spring Data REST 实现简单的超媒体服务"></a>使用 Spring Data REST 实现简单的超媒体服务</h1><h2 id="认识-HAL"><a href="#认识-HAL" class="headerlink" title="认识 HAL"></a>认识 HAL</h2><p>全称：Hypertext Application Language</p>
<ul>
<li>基于 JSON 的扩展</li>
<li>HAL 是一种简单的格式，为 API 中的资源提供简单一致的链接</li>
</ul>
<p>HAL 帮助我们定义了一个模型，模型中包含下面几部分</p>
<ul>
<li>链接，我们所有的这种链接资源</li>
<li>内嵌资源， embedded 的 resource</li>
<li>状态</li>
</ul>
<h2 id="Spring-Data-REST"><a href="#Spring-Data-REST" class="headerlink" title="Spring Data REST"></a>Spring Data REST</h2><p>Spring Boot 依赖</p>
<ul>
<li>spring-boot-starter-data-rest</li>
</ul>
<p>Spring Boot 做了自动配置</p>
<p>常用注解和类</p>
<ul>
<li>@RepositoryRestResource   ，使用了该接口时，当我们有了一个 Repository ，那么Spring Data REST 会自动将该 Repository 变成一个 RESTful 的接口，把它变成一个资源</li>
<li>Resource<T></li>
<li>PageResource<T></li>
</ul>
<h1 id="63-分布式环境中，如何解决-Session-的问题"><a href="#63-分布式环境中，如何解决-Session-的问题" class="headerlink" title="63 分布式环境中，如何解决 Session 的问题"></a>63 分布式环境中，如何解决 Session 的问题</h1><p>问题：使用场景是什么？</p>
<p>使用spring session 实现简单的分布式会话管理</p>
<p>使用第三方数据库进行session存储</p>
<h1 id="64-使用-WebFlux-代替-Spring-MVC"><a href="#64-使用-WebFlux-代替-Spring-MVC" class="headerlink" title="64 使用 WebFlux 代替 Spring MVC"></a>64 使用 WebFlux 代替 Spring MVC</h1><p>什么是 WebFlux？</p>
<ul>
<li>基于 Reactive 技术栈之上的，用于构建 Web 应用程序</li>
<li>基于 Reactive Stream API ，运行在非阻塞服务器（Netty，Jetty，并不是指物理上的服务器，应该是指服务容器）上</li>
</ul>
<p>为什么会有 WebFlux?</p>
<ul>
<li>对于非阻塞 Web 应用的需要</li>
<li>函数式编程的需要及普及</li>
</ul>
<p>关于 WebFlux 的性能</p>
<ul>
<li>单次请求的耗时并不会很大的改善，改善的是并行操作</li>
<li>仅需要少量固定数量的线程和较少的内存即可实现扩展</li>
</ul>
<p>Spring MVC v.s. WebFlux ，如何做取舍？</p>
<ul>
<li>已有 Spring MVC 应用，运行正常，就别改了</li>
<li>依赖了大量阻塞式持久化 API 和网络 API，建议使用 Spring MVC</li>
<li>已经使用了非阻塞技术栈，可以考虑使用 WebFlux</li>
<li>想要使用 Java8 Lambda 结合轻量级函数式框架，可以考虑 WebFlux</li>
</ul>
<p>问题：哪些是阻塞式持久化？mysql是的？redis，mongodb不是？</p>
<h1 id="重新认识-Spring-Boot-的组成部分"><a href="#重新认识-Spring-Boot-的组成部分" class="headerlink" title="重新认识 Spring Boot 的组成部分"></a>重新认识 Spring Boot 的组成部分</h1><p>Spring Boot 用于构建应用程序</p>
<p>Spring Boot 不是什么？</p>
<ul>
<li><p>不是应用服务器</p>
<blockquote>
<p>这里是指，不是 Tomcat 或 Jetty 这样的东西，在 Spring Boot 的应用程序中，可以囊括 Tomcat&#x2F;Jetty，或者可以将应用打成 war 包，部署在这些上面</p>
</blockquote>
</li>
<li><p>不是 JavaEE 之类的规范</p>
</li>
<li><p>不是代码生成器</p>
</li>
<li><p>不是 Spring Framework 的升级版</p>
<blockquote>
<p>是为了帮助大家更好的使用 Spring Framework 的</p>
</blockquote>
</li>
</ul>
<p>Spring Boot 的特性</p>
<ul>
<li><p>方便地创建可独立运行的 Spring 应用程序</p>
</li>
<li><p>直接内嵌 Tomcat,Jetty 或者 Undertow</p>
</li>
<li><p>简化了项目的构建配置</p>
<blockquote>
<p>简化了 mvn , gradle 这样的配置</p>
</blockquote>
</li>
<li><p>为 Spring 及第三方库提供自动配置</p>
</li>
<li><p>提供生产级特性 ？？</p>
<ul>
<li>例如，监控</li>
</ul>
</li>
<li><p>无需生成代码或进行 XML 配置</p>
<ul>
<li>可直接使用 Java Configuration 等</li>
</ul>
</li>
</ul>
<p>Spring Boot 的四大特性</p>
<ul>
<li>自动配置 - Auto Configuration</li>
<li>起步依赖 - Starter Dependency</li>
<li>命令行界面 - Spring Boot CLI</li>
<li>Actuator</li>
</ul>
<h1 id="了解自动配置的实现原理"><a href="#了解自动配置的实现原理" class="headerlink" title="了解自动配置的实现原理"></a>了解自动配置的实现原理</h1><p>自动配置</p>
<ul>
<li>基于添加的 JAR 依赖（在 ClassPath 中出现的类,application.properties,等），自动对 Spring Boot 应用程序进行配置</li>
<li>在 spring-boot-autoconfiguration jar包中</li>
</ul>
<p>开启自动配置</p>
<ul>
<li><p>@EnableAutoConfiguration</p>
<ul>
<li><p>exclude&#x3D;Class&lt;?&gt;[]</p>
<blockquote>
<p>如果希望排除掉一些自动配置的类，可以使用 exclude 这个属性排除掉指定的类即可</p>
</blockquote>
</li>
</ul>
</li>
<li><p>@SpringBootApplication</p>
<blockquote>
<p>这个注解中包含了 @EnableAutoConfiguration 注解，同时这个注解也可以使用 @EnableAutoConfiguration 注解的属性，如，exclude</p>
</blockquote>
</li>
</ul>
<p>@EnableAutoConfiguration 的实现原理</p>
<ul>
<li><p>自动帮忙我们 import AutoConfigurationImportSelector</p>
<blockquote>
<p>这个类会自动帮助我们加载 META-INF&#x2F;spring.factories 中的特定属性，即 org.springframework.boot.autoconfigure.EnableAutoConfiguration</p>
</blockquote>
</li>
</ul>
<p>条件注解</p>
<ul>
<li>@Conditional</li>
<li>@ConditionalOnClass</li>
<li>@ConditionalOnBean  –有指定bean时的操作</li>
<li>…OnMissBean  –没有指定bean时的操作</li>
<li>…OnProperty</li>
<li>…</li>
</ul>
<p>观察自动配置的判断结果，了解哪些自动配置生效了，哪些没有生效</p>
<ul>
<li>在命令行中添加 “–debug” 这个参数</li>
</ul>
<p>会有完整的输出，哪些匹配了match，哪些没有匹配，哪些exclude 没有加载，哪些是无条件配置的…</p>
<p>问题：初始化加载顺序，注解加载的优先级</p>
<h1 id="动手实现自己的自动配置"><a href="#动手实现自己的自动配置" class="headerlink" title="动手实现自己的自动配置"></a>动手实现自己的自动配置</h1><p>自动配置部分是，当我们在主程序中没有提供自己的配置&#x2F;代码，那么 Spring Boot 会自动加载内置的&#x2F;已有的自动配置好的配置&#x2F;代码</p>
<p>当我们希望 Spring 可以自动加载我们的定制功能，我们可以通过实现自己的自动配置集成到Spring Boot中让其来加载</p>
<h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><ol>
<li>首先我们需要自己写一个 Configuration 的配置类，</li>
<li>然后在配置类中做我们需要的自动配置，<ul>
<li>主要通过一些条件注解来实现的</li>
</ul>
</li>
<li>与内置的自动配置类一样，在我们的 spring.factories 当中去声明一下我们的自动配置类，让 Spring Boot 可以找到我们的自动配置</li>
</ol>
<p>这个过程分别对应下面三个部分：</p>
<p>编写 Java Config</p>
<ul>
<li>@Configuration</li>
</ul>
<p>添加条件</p>
<ul>
<li>@Conditional</li>
</ul>
<p>定位自动配置</p>
<ul>
<li>META-INF&#x2F;spring.factories</li>
</ul>
<h3 id="条件注解大家庭"><a href="#条件注解大家庭" class="headerlink" title="条件注解大家庭"></a>条件注解大家庭</h3><p>条件注解</p>
<ul>
<li>@Conditional</li>
<li>所有的条件注解都是基于这个注解，它是 Spring 4 引入的新的注解，（在 Spring 3 中没有@Conditional 这个注解，后面会提交如何在 Spring 3.x版本当中如何实现自动配置）</li>
</ul>
<p>类条件</p>
<ul>
<li>@ConditionalOnClass  存在指定Class时怎么样</li>
<li>@ConditionalOnMissingClass   不存在指定Class时怎么样</li>
</ul>
<p>属性条件</p>
<ul>
<li>@ConditionalOnProperty</li>
</ul>
<p>Bean 条件</p>
<ul>
<li>@ConditionalOnBean</li>
<li>@ConditionalOnMissingBean</li>
<li>@ConditionalOnSingleCandidate</li>
</ul>
<p>资源条件</p>
<ul>
<li>@ConditionalOnResource</li>
</ul>
<p>Web 应用条件</p>
<ul>
<li>@ConditionalOnWebApplication</li>
<li>@ConditionalOnNotWebApplication</li>
</ul>
<p>其他条件</p>
<ul>
<li>@ConditionalOnExpression</li>
<li>@ConditionalOnJava</li>
<li>@ConditionalOnJndi</li>
</ul>
<h3 id="自动配置的执行顺序"><a href="#自动配置的执行顺序" class="headerlink" title="自动配置的执行顺序"></a>自动配置的执行顺序</h3><p>执行顺序</p>
<ul>
<li>@AutoConfigureBefore</li>
<li>@AutoConfigureAfter</li>
<li>@AutoConfigureOrder</li>
</ul>
<h1 id="Spring-Boot-提供的错误分析机制"><a href="#Spring-Boot-提供的错误分析机制" class="headerlink" title="Spring Boot 提供的错误分析机制"></a>Spring Boot 提供的错误分析机制</h1><blockquote>
<p>在 Spring Boot 官方文档中的 Spring Boot Features 章节  1.1. Startup Failure 中有涉及这部分的内容</p>
</blockquote>
<p>FailureAnalysis.class</p>
<p>三个组成部分</p>
<ul>
<li>description 失败的描述</li>
<li>action  失败后的动作</li>
<li>Throwable cause  失败后的异常</li>
</ul>
<h1 id="70-如何在低版本-Spring-中快速实现类似自动配置的功能"><a href="#70-如何在低版本-Spring-中快速实现类似自动配置的功能" class="headerlink" title="70 如何在低版本 Spring 中快速实现类似自动配置的功能"></a>70 如何在低版本 Spring 中快速实现类似自动配置的功能</h1><p>需求与问题</p>
<ol>
<li><p>核心诉求</p>
<ul>
<li>现存系统，不打算重构</li>
<li>Spring 版本3.x，不打算升级版本和引入 Spring Boot</li>
<li>期望能够在少改代码的前提下实现一些功能增强</li>
</ul>
</li>
<li><p>面临问题</p>
<ul>
<li>3.x 的 Spring 没有条件注解</li>
<li>无法自动定位需要加载的自动配置</li>
</ul>
</li>
</ol>
<h3 id="核心解决思路"><a href="#核心解决思路" class="headerlink" title="核心解决思路"></a>核心解决思路</h3><p>解决加载加载条件判断的问题</p>
<p>条件判断</p>
<ul>
<li>通过 BeanFactoryPostProcessor 进行判断<ul>
<li>在bean定义完成之后，初始化之前，对我们的这些 bean 的定义做一些后置的处理</li>
</ul>
</li>
</ul>
<p>配置加载</p>
<ol>
<li>编写 Java Config 类<ul>
<li>使用 @Configuration</li>
</ul>
</li>
<li>引入配置类<ul>
<li>通过 component-scan， 让 component-scan中包含我们写的 Java Config</li>
<li>通过 XML 文件 import，如果原有系统是使用 XML的方式，就通过 XML来加载我们的配置<blockquote>
<p>如果需要被扫描类所属 package 是带有 @SpringBootApplication 注解类所在 package以下的所有package里面所有的配置，所以即使即使没有通过 component-scan 或者XML做明确定义，也能扫描到我们提供的配置类；</p>
<p>但是如果提供的配置类与 @SpringBootApplication 所在 package 不是上下级关系，需要增加 component-scan 扩展扫描范围。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="Spring-的两个扩展点"><a href="#Spring-的两个扩展点" class="headerlink" title="Spring 的两个扩展点"></a>Spring 的两个扩展点</h3><ol>
<li>BeanPostProcessor<ul>
<li><p>在 Bean 初始化之后，可以针对 Bean 实例进行一些处理</p>
<blockquote>
<p>比如对 bean 做一些增强，处理一些逻辑</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ul>
<li>在 Bean创建后提供定制逻辑回调</li>
</ul>
<ol start="2">
<li>BeanFactoryPostProcessor 接口<ul>
<li>针对 Bean 定义</li>
<li>在容器创建 Bean 前获取配置元数据</li>
<li>Java Config 中需要定义为 static 方法<ul>
<li>如果不定义为 static 那么，spring 在启动的时候会报一个 warning</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="与-Bean-定制相关的一些内容"><a href="#与-Bean-定制相关的一些内容" class="headerlink" title="与 Bean 定制相关的一些内容"></a>与 Bean 定制相关的一些内容</h2><ol>
<li><p>生命周期的Callback</p>
<ul>
<li>初始化相关， 在 Bean创建之后对它做一些定制（创建之后调用特定的方法），一共有三种方式 <ul>
<li>实现 InitializingBean 接口</li>
<li>使用 @PostConstruct 注解</li>
<li>用我的Bean 定义的 XML文件里面指定一个 init-method， 或者在我的Bean 注解里面指定 init-method</li>
</ul>
</li>
<li>在 Bean 回收&#x2F;销毁的时候做一些操作<ul>
<li>实现 DisposableBean 接口，spring会调用指定方法</li>
<li>使用 @PreDestroy 注解，当Bean销毁的时候，Spring 会进行一个调用</li>
<li>在Bean定义的XML文件中 配置一个 destroy-method ，指定Bean销毁时调用哪个方法， 或者在Bean的注解中指定</li>
</ul>
</li>
</ul>
</li>
<li><p>xxxAware 接口 （注入相关内容）</p>
<ul>
<li>ApplicationContextAware， 把整个ApplicationContext 通过接口注入到Bean中，这样在Bean中就可以取得整个 ApplicationContext</li>
<li>BeanFactoryAware， 类似 ApplicationContext ???</li>
<li>BeanNameAware ，把Bean 的名字注入到实例中</li>
</ul>
</li>
</ol>
<p>AbstractBeanFactory.java</p>
<ul>
<li>getBean()</li>
</ul>
<p>AbstractAutowireCapableBeanFactory.java</p>
<ul>
<li>hasDestoryMethod()<blockquote>
<p>即使我们的 Bean 不是 DisposableBean 或者 AutoCloseableBean，只要有一个Close或者Shutdown的方法，Spring 也会在销毁 Bean 的时候去调用它们</p>
</blockquote>
</li>
</ul>
<h2 id="Bean-的一些其他常用操作"><a href="#Bean-的一些其他常用操作" class="headerlink" title="Bean 的一些其他常用操作"></a>Bean 的一些其他常用操作</h2><p>判断类是否存在</p>
<ul>
<li>ClassUtils.isPresent()， 用于判断一个类是否存在于ClassPath中</li>
</ul>
<p>判断 Bean 是否已定义</p>
<ul>
<li>ListableBeanFactory.containsBeanDefinition()</li>
<li>ListableBeanFactory.getBeanNamesForType()</li>
</ul>
<p>注册 Bean 定义</p>
<ul>
<li>如果是 BeanDefinitionRegistry， 使用 BeanDefinitionRegistry.registerBeanDefinition() 方法注册<ul>
<li>注册前要先利用 GenericBeanDefinition 去setBeanClass</li>
</ul>
</li>
<li>如果不是上面的类型，就使用 BeanFactory.registerSingleton() 方法注册，并传入实例</li>
</ul>
<p><strong>注</strong><br>如果使用 Spring4.x以上版本，即Spring支持自动配置后，尽管我们的定义的配置类不在 @SpringBootApplication 默认packge 下，SpringBoot 也会扫描到，<br>因为在 spring.factories 文件中默认配置了 org.springframework.boot.autoconfigure.EnableAutoConfiguration, SpringBoot 就会找到我们的自动配置类。</p>
<h1 id="71-了解起步依赖及其原理"><a href="#71-了解起步依赖及其原理" class="headerlink" title="71 了解起步依赖及其原理"></a>71 了解起步依赖及其原理</h1><p>Spring Boot 的特色功能之一，Starter Dependency</p>
<p>问题，SpringBoot 为什么会提供Starter Dependency 这样的功能，其背后是如何实现的</p>
<blockquote>
<p>需要关注的就是 Maven 如何管理依赖</p>
</blockquote>
<p>没有 Starter Dependency 之前的时候</p>
<ul>
<li>传统maven项目，需要我们自己管理依赖问题</li>
<li>要实现一个功能， 需要引入哪些依赖</li>
<li>多个依赖项目之间是否会有兼容问题<ul>
<li>当多个版本的包被引入到依赖，Classpath中同package同方法时就可能出现依赖冲突</li>
</ul>
</li>
</ul>
<h2 id="关于-Maven-依赖管理的一些小技巧"><a href="#关于-Maven-依赖管理的一些小技巧" class="headerlink" title="关于 Maven 依赖管理的一些小技巧"></a>关于 Maven 依赖管理的一些小技巧</h2><p>了解你的依赖</p>
<ul>
<li>mvn dependency:tree , 打印工程所有的maven依赖</li>
<li>IDEA Maven Helper 插件</li>
<li>使用 duplicate-finder 这个mvn插件来找到可能冲突的类</li>
</ul>
<p>排除特定依赖</p>
<ul>
<li>exclusion ， 在pom.xml中排除指定依赖</li>
</ul>
<p>统一管理依赖</p>
<ul>
<li>dependencyManagement ， 当项目是多module的时候，在parent的pom.xml中统一管理部分依赖</li>
<li>Bill of Materials - bom， Maven提供的一种功能，具体去搜一下</li>
</ul>
<h2 id="SprigBoot-的起步依赖（Starter-Dependency）"><a href="#SprigBoot-的起步依赖（Starter-Dependency）" class="headerlink" title="SprigBoot 的起步依赖（Starter Dependency）"></a>SprigBoot 的起步依赖（Starter Dependency）</h2><p>Starter Dependencies</p>
<ul>
<li>直接面向功能， 即我们只需要知道自己要什么功能，去SpringBoot 中找到相关功能的Starter Dependency， 然后剩下的该功能有哪些依赖，SpringBoot会帮我们处理这个功能所需要的的所有的相关依赖。</li>
<li>好处，一站获得所有相关依赖，不再复制粘贴</li>
</ul>
<p>官方的 Starters</p>
<blockquote>
<p>从官方文档的 Starters 章节中，我们可以看到它帮我们制作提供了很多功能模块的 starters， 我们需要时，只要做一个指定 starter的引入即可</p>
</blockquote>
<ul>
<li>spring-boot-starter-*</li>
</ul>
<p>问题：引入多个 Starter 依赖，它们里面有重复的依赖，或者不同版本的依赖时，SpringBoot 是如何解决的？</p>
<ul>
<li>Spring Boot 同一个版本中统一处理了所有支持的第三方依赖的版本，所以在使用同版本的starter时，会不出现jar冲突问题。</li>
</ul>
<h1 id="72-定制自己的起步依赖"><a href="#72-定制自己的起步依赖" class="headerlink" title="72 定制自己的起步依赖"></a>72 定制自己的起步依赖</h1><p>主要内容</p>
<ol>
<li>自动配置相关模块，即 autoconfigure 模块，包含自动配置代码。 如果你的依赖需要做自动配置，可以在该模块中写下自己的自动配置。<blockquote>
<p><strong>注：</strong> 这个模块不是必须的，</p>
<p>如果我们的模块不需要自动配置，就不需要 autoconfigure 模块。<br>如果我们的模块依赖了 spring-boot-starter ，因为 SpringBoot 的自动配置都集中在 SpringBoot的autoconfigure中，所以也会自动加载SpringBoot的自动配置</p>
</blockquote>
</li>
<li>starter 模块， 包含指向自动配置模块的依赖及其他相关依赖</li>
</ol>
<p>命名方式</p>
<ul>
<li>xxx-spring-boot-autoconfigure</li>
<li>xxx-spring-boot-starter<blockquote>
<p>通过加前缀的方式，来与官方的依赖做区分。</p>
</blockquote>
</li>
</ul>
<p>一些注意事项</p>
<ul>
<li><code>不要使用 spring-boot 作为依赖的前缀</code>，这样容易与 Spring 官方的混淆在一起</li>
<li><code>不要使用 spring-boot 的配置命名空间</code>， 同上</li>
<li>starter 中仅添加必要的依赖，减少最终打出来的包的依赖</li>
<li>（非必须）声明对 spring-boot-starter 的依赖<ul>
<li>主要是为了加载一些 SpringBoot 的自动配置，如果上层项目引入了 spring-boot-starter 的依赖，也就不需要了，因为大部分SpringBoot项目都会有该依赖</li>
</ul>
</li>
</ul>
<h1 id="73-深挖-Spring-Boot-的配置加载机制"><a href="#73-深挖-Spring-Boot-的配置加载机制" class="headerlink" title="73 深挖 Spring Boot 的配置加载机制"></a>73 深挖 Spring Boot 的配置加载机制</h1><p>SpringBoot是如何加载配置文件和配置项的？</p>
<p>根据 SpringBoot 的官方文档 24 章节 外置配置的内容</p>
<p>外化配置加载顺序，按照先后出现顺序加载</p>
<ol>
<li>开启 DevTools 时，~&#x2F;.spring-boot-devtools.properties</li>
<li>测试类上的 @TestPropertySource 注解</li>
<li>@SpringBootTest#properties 属性</li>
<li><code>命令行参数 （例如，--server.port=9000）</code> 优先加载</li>
<li>SPRING_APPLICATION_JSON 中的属性</li>
<li>ServletConfig 初始化参数</li>
<li>ServletContext 初始化参数</li>
<li>java:comp&#x2F;env 中的 JNDI 属性</li>
<li><code>System.getProperties()</code>  java -D 参数指定的属性，在命令行中可以通过 -D 参数来指定一些系统属性</li>
<li><code>操作系统环境变量</code></li>
<li>random.* 涉及到的 RandomValuePropertySource</li>
<li>jar包外部的 application-{profile}.properties 或者 .yml</li>
<li>jar包内部的 application-{profile}.properties 或者 .yml</li>
<li>jar包外部的 appliaction.properties 或者 .yml</li>
<li>jar包内部的 application.properties 或者 .yml</li>
<li>@Configuration 类上的 @PropertySource</li>
<li>SpringApplication.setDefaultProperties() 设置的默认属性</li>
</ol>
<p>application[-profile].properties 文件的默认位置</p>
<ul>
<li>.&#x2F;config</li>
<li>.&#x2F;</li>
<li>CLASSPATH 中的 &#x2F;config</li>
<li>CLASSPATH 中的 &#x2F;</li>
</ul>
<p>通过命令行参数，修改名字或者路径</p>
<ul>
<li>spring.config.name  修改配置文件的名字，比如不叫做application.properties，改为env.properties</li>
<li>spring.config.location</li>
<li>spring.config.additional-location</li>
</ul>
<h3 id="Relaxed-Binding"><a href="#Relaxed-Binding" class="headerlink" title="Relaxed Binding"></a>Relaxed Binding</h3><p>什么是<code>Relaxed Binding</code></p>
<table>
<thead>
<tr>
<th>命令风格</th>
<th>使用范围</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>短划线分隔 (优先使用)</td>
<td>properties 文件 &#x2F; YAML文件 &#x2F; 系统属性</td>
<td>geektime.spring-boot.first-demo</td>
</tr>
<tr>
<td>驼峰式</td>
<td>同上</td>
<td>geektime.springBoot.firstDemo</td>
</tr>
<tr>
<td>下划线分隔</td>
<td>同上</td>
<td>geektime.spring_boot.first_demo</td>
</tr>
<tr>
<td>全大写，下划线分隔</td>
<td>环境变量</td>
<td>GEEKTIME_SPRINGBOOT_FIRSTDEMO</td>
</tr>
</tbody></table>
<h1 id="74-理解配置背后的-PropertySource-抽象"><a href="#74-理解配置背后的-PropertySource-抽象" class="headerlink" title="74 理解配置背后的 PropertySource 抽象"></a>74 理解配置背后的 PropertySource 抽象</h1><p>添加 PropertySource</p>
<ul>
<li>使用XML文件的时候，通过 <a href="context:property-placeholder">context:property-placeholder</a> 这个标签来声明配置文件 ？？？</li>
<li>PropertySourcesPlaceholderConfigurer  Spring 3.1开始使用这个类来处理，为了兼容之前的版本，下面的类也依然存在<ul>
<li>PropertyPlaceholderConfigurer</li>
</ul>
</li>
<li>如果使用的是 Java Config 配置的形式，那么只需要在Config类上添加下面的注解即可<ul>
<li>@PropertySource</li>
<li>@PropertySources  多个数据源就使用这个</li>
</ul>
</li>
</ul>
<p>如果是使用 SpringBoot，SpringBoot 提供了 @ConfigurationProperties 注解更方便使用</p>
<ul>
<li>可以将属性绑定到结构化对象上</li>
<li>支持 Relaxed Binging</li>
<li>支持安全的类型转换</li>
<li>@EnableConfigurationProperties</li>
</ul>
<h2 id="定制-PropertySource"><a href="#定制-PropertySource" class="headerlink" title="定制 PropertySource"></a>定制 PropertySource</h2><p>主要步骤</p>
<ol>
<li>实现 PropertySource<T></li>
<li>将 PropertySource 注册到 Environment中<ol>
<li>实现下面的接口<ul>
<li>EnvironmentPostProcessor</li>
<li>BeanFactoryPostProcessor</li>
</ul>
</li>
<li>从 Environment 对象中获取 PropertySources</li>
<li>将自己的 PropertySource 添加到合适的位置</li>
</ol>
</li>
</ol>
<h1 id="79-如果定制Web容器的运行参数"><a href="#79-如果定制Web容器的运行参数" class="headerlink" title="79 如果定制Web容器的运行参数"></a>79 如果定制Web容器的运行参数</h1><p>SpringBoot支持的Web容器</p>
<ul>
<li>spring-boot-starter-tomcat</li>
<li>spring-boot-starter-jetty</li>
<li>spring-boot-starter-undertow</li>
<li>spring-boot-starter-reactor-netty</li>
</ul>
<p>通过选择不同的 starter-dependency 来实现不同Web容器的替换</p>
<h2 id="修改容器配置"><a href="#修改容器配置" class="headerlink" title="修改容器配置"></a>修改容器配置</h2><p>端口</p>
<ul>
<li>server.port</li>
<li>server.address</li>
</ul>
<p>压缩相关内容</p>
<ul>
<li>server.compression.enabled</li>
<li>server.compression.min-response-size</li>
<li>server.compression.mime-types</li>
</ul>
<p>Tomcat 特定配置</p>
<ul>
<li>server.tomcat.max-connections&#x3D;10000</li>
<li>server.tomcat.max-http-post-size&#x3D;2MB</li>
<li>server.tomcat.max-swallow-size&#x3D;2MB</li>
<li>server.tomcat.max-threads&#x3D;200</li>
<li>server.tomcat.min-spare-threads&#x3D;10</li>
</ul>
<p>其他Web容器，分别在不同的 <code>server.xxx</code>下面</p>
<p>错误处理</p>
<ul>
<li>server.error.path&#x3D;&#x2F;error</li>
<li>server.error.include-exception&#x3D;false</li>
<li>server.error.include-stacktrace&#x3D;never</li>
<li>server.error.whitelabel.enabled&#x3D;true</li>
</ul>
<p>其他</p>
<ul>
<li>server.use-forward-headers</li>
<li>server.servlet.session.timeout</li>
</ul>
<p>通过编程的方式实现容器的配置</p>
<ul>
<li>WebServerFacotoryCustomizer<T><ul>
<li>TomcatServletWebServerFactory</li>
<li>JettyServletWebServerFactory</li>
<li>UndertowServletWebServerFactory<br>官方文档也提供了其他的编程方式来处理</li>
</ul>
</li>
</ul>
<h1 id="82-编写命令行运行的程序"><a href="#82-编写命令行运行的程序" class="headerlink" title="82 编写命令行运行的程序"></a>82 编写命令行运行的程序</h1><h2 id="关闭-Web-容器"><a href="#关闭-Web-容器" class="headerlink" title="关闭 Web 容器"></a>关闭 Web 容器</h2><p>有以下几种方式</p>
<ol>
<li><p>控制依赖</p>
<ul>
<li>不添加 Web相关依赖</li>
</ul>
</li>
<li><p>通过修改配置的方式</p>
<blockquote>
<p>如果代码中有一些与Web服务接口调用等相关的交互，或者很难完全去除Web相关依赖，可以使用修改配置的方式，关闭Web 容器的支持</p>
</blockquote>
<ul>
<li>spring.main.web-application-type&#x3D;none</li>
</ul>
</li>
<li><p>编程的方式</p>
<ul>
<li>SpringApplication<ul>
<li>setWebApplicationType() 方法，将 <code>webApplicationType</code> 类型设置为<code>none</code></li>
</ul>
</li>
<li>SpringApplicationBuilder<ul>
<li>Web()</li>
</ul>
</li>
<li>在调用 SpringApplication 的 run() 方法前设置 WebApplicationType</li>
</ul>
</li>
</ol>
<h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><p>不同的Runner， 功能上类似，在程序启动的时候执行一段代码， 区别在于参数不同</p>
<ul>
<li>ApplicationRunner<ul>
<li>参数是 ApplicationArguments</li>
</ul>
</li>
<li>CommandLineRunner<ul>
<li>参数是 String[]</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果有多个Runner，可以通过添加 @Order 注解，或者实现 Order 接口来指定运行顺序</p>
</blockquote>
<p>返回码</p>
<ul>
<li>ExitCodeGenerator</li>
</ul>
<h1 id="83-了解可执行-Jar包背后的秘密"><a href="#83-了解可执行-Jar包背后的秘密" class="headerlink" title="83 了解可执行 Jar包背后的秘密"></a>83 了解可执行 Jar包背后的秘密</h1><h2 id="认识可执行-Jar"><a href="#认识可执行-Jar" class="headerlink" title="认识可执行 Jar"></a>认识可执行 Jar</h2><p>其中包含4部分</p>
<ul>
<li><p>Jar 描述，META-INF&#x2F;MANIFEST.MF</p>
<blockquote>
<p>manifest 翻译为 程序集清单，装配件清单</p>
</blockquote>
</li>
<li><p>SpringBoot Loader，org&#x2F;springframework&#x2F;boot&#x2F;loader&#x2F;<spring boot loader classes></p>
</li>
<li><p>项目内容， BOOT-INF&#x2F;classes&#x2F;xxx&#x2F;yourclass.class</p>
</li>
<li><p>项目依赖， BOOT-INF&#x2F;lib&#x2F;dependency1.jar,dependency2.jar…</p>
</li>
</ul>
<p>其中不包含</p>
<ul>
<li>jdk &#x2F; jre</li>
</ul>
<h2 id="如何找到程序的入口"><a href="#如何找到程序的入口" class="headerlink" title="如何找到程序的入口"></a>如何找到程序的入口</h2><p>jar的启动类</p>
<ul>
<li>MANIFEST.MF<ul>
<li>Main-Class: org.springframework.boot.loader.JarLauncher<blockquote>
<p>在这里指定 jar -jar xxx.jar 要运行需要的启动类，因为是jar包，所以是JarLuncher，如果是war包，则换成 WarLauncher</p>
<p>指定之后，java就会找到这个类运行。那么JarLauncher又是怎样找到SpringBoot的应用程序的呢？通过下面的Start-Class指定的类去执行</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>项目的主类</p>
<ul>
<li>MANIFEST.MF<ul>
<li><p>Start-Class: xxx.yyy.zzz</p>
<blockquote>
<p>这里是我们添加了 <code>@SpringApplication</code> 注解的类的全限定类名</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="如何创建可直接执行的jar（无需-java-jar来引导执行，直接通过-x2F-xxx-jar即可执行）"><a href="#如何创建可直接执行的jar（无需-java-jar来引导执行，直接通过-x2F-xxx-jar即可执行）" class="headerlink" title="如何创建可直接执行的jar（无需 java -jar来引导执行，直接通过 .&#x2F;xxx.jar即可执行）"></a>如何创建可直接执行的jar（无需 java -jar来引导执行，直接通过 .&#x2F;xxx.jar即可执行）</h2><p>通过plugin，org.springframework.boot.spring-boot-maven-plugin，在<configuration>属性添加为true的<executable>属性</p>
<ul>
<li>打包后的jar可直接运行，无需java命令，即不需要 java -jar的命令来引导执行，是可以直接再命令行中运行。</li>
<li>可以在 <code>&lt;jar文件的同名文件&gt;.conf</code> 的文件中配置程序需要的参数</li>
</ul>
<table>
<thead>
<tr>
<th>配置项</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>CONF_FOLDER</td>
<td>放置.conf的目录位置</td>
<td>只能放置环境变量中</td>
</tr>
<tr>
<td>JAVA_OPTS</td>
<td>JVM启动时的参数</td>
<td>比如 JVM的内存Xms,Xmx，和GC</td>
</tr>
<tr>
<td>RUN_ARGS</td>
<td>传给程序执行的参数</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注：因为是可以直接实行，所以在linux 中也可以放在init.d,或system目录下作为一个服务来操作。</p>
</blockquote>
<p>通过less 或者more命令，直接查看这个可独自运行的jar文件，可以知道该文件的开头是一个 SpringBoot生成的执行脚本。如果不是可独自运行的jar，jar文件头没有改可执行脚本。</p>
<blockquote>
<p>为什么可以在jar文件头放一个可执行脚本？</p>
<p>利用了shell文件是从上向下读，zip文件是从尾部向前读的特性。</p>
</blockquote>
<p>这段内容可以打出来看看，学习一下。</p>
<h1 id="84-如何将-SpringBoot应用，打包成Docker镜像文件"><a href="#84-如何将-SpringBoot应用，打包成Docker镜像文件" class="headerlink" title="84 如何将 SpringBoot应用，打包成Docker镜像文件"></a>84 如何将 SpringBoot应用，打包成Docker镜像文件</h1><p>什么是Docker镜像？</p>
<ul>
<li>镜像是静态的只读模板</li>
<li>镜像中包含构建Docker容器的指令</li>
<li>镜像是分层的 （利用了一个叫做，<code>联合文件系统</code> 的技术来处理）</li>
<li>通过Dockerfile 来创建镜像</li>
</ul>
<p>Dockerfile中常用的指令</p>
<blockquote>
<p>可以通过官方文档了解</p>
</blockquote>
<h2 id="通过Maven构建-Docker-镜像"><a href="#通过Maven构建-Docker-镜像" class="headerlink" title="通过Maven构建 Docker 镜像"></a>通过Maven构建 Docker 镜像</h2><p>准备工作</p>
<ul>
<li>提供一个Dockerfile</li>
<li>配置 dockerfile-maven-plugin 插件<ul>
<li>到官网查看一下这个插件如何使用</li>
</ul>
</li>
</ul>
<p>构建执行</p>
<ul>
<li>mvn package</li>
<li>mvn dockerfile:build</li>
</ul>
<p>检查结果</p>
<ul>
<li>docker images</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringData-JPA学习</title>
    <url>//SpringData-JPA%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p>Spring Data JPA</p>
<p>您必须直接创建 <code>LocalContainerEntityManagerFactoryBean</code> 而不是 <code>EntityManagerFactory</code>，因为前者除了创建 <code>EntityManagerFactory</code> 外还参与异常转换机制。</p>
<h5 id="Bootstrap-Mode-引导模式"><a href="#Bootstrap-Mode-引导模式" class="headerlink" title="Bootstrap Mode 引导模式"></a>Bootstrap Mode 引导模式</h5><ul>
<li><code>DEFAULT</code> (default) </li>
<li><code>LAZY</code></li>
<li><code>DEFERRED</code></li>
</ul>
<p><strong>Recommendations</strong></p>
<ol>
<li>如果不是用异步引导模式，就坚持默认引导模式；</li>
<li>如果使用异步引导模式，<code>DEFERRED</code> 是很好的选择，它能保证只有 <code>EntityManagerFactory</code> 的初始化时间比其他组件长，同时当应用程序发出信号之间，正确初始化和验证 repositories。</li>
<li><code>LAZY</code> 模式比较适合测试场景或者本地开发，有选择的进行初始化。</li>
</ol>
<h4 id="5-1-2-Persisting-Save-Entities"><a href="#5-1-2-Persisting-Save-Entities" class="headerlink" title="5.1.2. Persisting(Save) Entities"></a>5.1.2. Persisting(Save) Entities</h4><p>Spring Data JPA 如何保存实体</p>
<p>可以使用 <code>CrudRepository.save(...)</code> 方法保存实体。 它通过使用底层 JPA <code>EntityManager</code> 来持久化或合并给定的实体。 如果实体尚未持久化，Spring Data JPA 会通过调用 <code>entityManager.persist(...)</code> 方法来保存实体。 否则，它会调用 <code>entityManager.merge(...)</code> 方法。</p>
<p>实体状态检测策略</p>
<blockquote>
<p>Entity State-detection Strategies</p>
</blockquote>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringData</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringData学习</title>
    <url>//SpringData%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p>Spring Data 为数据访问提供熟悉且一致的基于 Spring 的编程模型，同时仍保留底层数据存储的特殊特征。</p>
<p>包含许多基于特定数据库的子项目，类似于面向接口编程，Spring Data 提供了统一接口，然后各种关系型和非关系型数据库，MapReduce 框架自行提供实现。</p>
<p>特性：（我关注的几个特性）</p>
<ul>
<li><p>Powerful repository and custom object-mapping abstractions</p>
<blockquote>
<p>强大的 repository 和自定义对象映射抽象</p>
</blockquote>
</li>
<li><p>Dynamic query derivation from repository method names</p>
<blockquote>
<p>基于 repository 的方法名称派生出动态查询   <strong>掌握 repository 中查询方法名的命名规则非常重要</strong></p>
</blockquote>
</li>
<li><p>Implementation domain base classes providing basic properties</p>
<blockquote>
<p>可以提供基本属性的实现 domain 基类</p>
</blockquote>
</li>
<li><p>Possibility to integrate custom repository code</p>
<blockquote>
<p>可以集成自定义 repository 存储库代码</p>
</blockquote>
</li>
<li><p>Easy Spring integration via JavaConfig and custom XML namespaces</p>
<blockquote>
<p>通过 JavaConfig 和自定义 XML 命名空间轻松集成 Spring</p>
</blockquote>
</li>
</ul>
<p>主要模块</p>
<ul>
<li><p><a href="https://github.com/spring-projects/spring-data-commons">Spring Data Commons</a> - 支撑每个 Spring Data 模块的核心 Spring 概念。</p>
<blockquote>
<p>Spring Data Commons 是 Spring Data 项目的一部分，该项目提供跨 Spring Data 项目的共享基础架构。它包含技术中立的存储库接口以及用于持久化 Java 类的元数据模型。</p>
</blockquote>
</li>
<li><p>其他 Spring Data 模块分别对应各种不同的数据访问实现。</p>
</li>
</ul>
<p><strong>注意：</strong>这些模块都是单独发布，所以会出现各种不同的版本号，使用时需要注意不同版本的兼容性。</p>
<p>找到兼容版本的最简单方法是依赖我们随定义的兼容版本一起提供的 Spring Data Release Train BOM。（这个东西在哪里？）</p>
<h1 id="Spring-Data-Commons"><a href="#Spring-Data-Commons" class="headerlink" title="Spring Data Commons"></a>Spring Data Commons</h1><p>我认为这部分对重要的两个内容就是</p>
<ul>
<li><p>创建对象映射，（这部分是将 Java 对象与底层数据库中的表映射到一起，为后面查询代码提供表信息）</p>
</li>
<li><p>创建 repository 的查询方法，（这部分是将查询方法名与底层数据库的查询语句基本规则进行映射，两者结合可以动态生成查询语句所需要的所有信息）</p>
</li>
</ul>
<p>下面的内容上面两个点来展开。</p>
<h2 id="3-Object-Mapping-Fundamentals"><a href="#3-Object-Mapping-Fundamentals" class="headerlink" title="3. Object Mapping Fundamentals"></a>3. Object Mapping Fundamentals</h2><p>对象映射基本原则&#x2F;基本知识</p>
<p>本节涵盖 Spring Data 对象映射、对象创建、字段和属性访问、可变性和不变性的基础知识。</p>
<blockquote>
<p>This section covers the fundamentals of Spring Data object mapping, object creation, field and property access, mutability and immutability.</p>
</blockquote>
<p>因为不同数据库实现提供的<em>解析规则</em>会有些不同，所以实际使用时，需要查看 Spring Data 支持的这些数据存储实现文档中这部分对应的规则。例如，对象映射，例如索引、自定义列或字段名称等。</p>
<p>Spring Data 对象映射的<strong>核心职责</strong>是创建域对象的实例并将存储原生（store-native）数据结构映射到这些实例上。这意味着我们需要两个基本步骤：</p>
<ol>
<li>使用公开的构造函数之一<strong>创建实例</strong>。</li>
<li><strong>实例填充</strong>以具体化所有公开的属性。</li>
</ol>
<h3 id="3-1-Object-creation"><a href="#3-1-Object-creation" class="headerlink" title="3.1. Object creation"></a>3.1. Object creation</h3><p>对象创建</p>
<p>Spring Data 会自动尝试检测（要用于具体化该类型对象的持久化）实体entity的构造函数。解析算法的工作原理如下：</p>
<blockquote>
<p>Spring Data automatically tries to detect a persistent entity’s constructor to be used to materialize objects of that type.</p>
</blockquote>
<ol>
<li>如果只有单个构造函数，直接使用；</li>
<li>如果有无参构造函数，直接使用无参构造函数，忽略其他构造函数；</li>
<li>如果有多个构造函数，且存在 <code>@PersistenceConstructor</code> 注解，使用被注解标注的构造函数；</li>
</ol>
<p>关于值解析？</p>
<p>值解析假定构造函数参数名称与实体的属性名称匹配，即解析将被执行，就像要填充属性一样，包括映射中的所有自定义（不同的数据存储列或字段名称等）。这还需要类文件中可用的参数名称信息或构造函数中存在的 @ConstructorProperties 注释。</p>
<p>值解析可以通过使用 Spring Framework 的 @Value 值注释使用特定存储的 SpEL 表达式进行自定义。有关更多详细信息，请参阅有关存储特定映射的部分。</p>
<p>这部分应该放在属性填充部分吧？</p>
<p>为了避免反射的开销，Spring Data 的对象创建，默认使用运行时生成的工厂类，它会直接调用域类（domain classes）的构造函数。（这比反射提高了大约 10% 的性能）</p>
<blockquote>
<p>To avoid the overhead of reflection</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  Person(String firstname, String lastname) &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring Data 将在运行时创建一个语义上等同于这个的工厂类：直接调用 Person 的构造函数创建对象实例。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonObjectInstantiator</span> <span class="keyword">implements</span> <span class="title class_">ObjectInstantiator</span> &#123;</span><br><span class="line"></span><br><span class="line">  Object <span class="title function_">newInstance</span><span class="params">(Object... args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>((String) args[<span class="number">0</span>], (String) args[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有资格进行此类优化的域类（domain class），需要满足以下几个条件：</p>
<ul>
<li>domain class 不能是 private 的；</li>
<li>如果有内部类，该内部类必须是 static 的；</li>
<li>它不能是 CGLib 代理类（proxy class）；</li>
<li>Spring Data 使用的构造函数不能是 private 的</li>
</ul>
<p>如果不满足上面任一条件，Spring Data 就会改为使用反射进行对象创建。</p>
<h3 id="3-2-Property-population"><a href="#3-2-Property-population" class="headerlink" title="3.2. Property population"></a>3.2. Property population</h3><p>属性填充</p>
<p>当实例创建之后，Spring Data 会填充（这个类剩余的所有需要持久化的）属性。</p>
<ul>
<li>一旦创建了实体的实例，Spring Data 就会填充该类的所有剩余持久属性。除非实体的构造函数已经填充（即通过其构造函数参数填充），否则将首先填充标识符属性（用 <strong>@Id</strong> 注解标注的属性）以允许<a href="Spring%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.md">循环对象引用</a>的解析。之后，所有尚未由构造函数填充的非瞬态属性（non-transient properties）都在实体实例上设置。</li>
</ul>
<p>属性填充使用下面的算法规则：</p>
<ol>
<li>如果属性是不可变的（immutable）（有 final 修饰），但公开（expose） 了 <code>with...</code> 方法（见下文），我们使用 <code>with...</code> 方法创建一个具有新属性值的新实体实例（a new entity instance）。</li>
<li>如果定义了属性访问（即通过 getter 和 setter 访问），我们将调用 setter 方法。</li>
<li>如果属性是可变的（mutable）（没有 final 修饰），我们直接设置字段。</li>
<li>如果属性是不可变的，我们将使用构造函数在创建实例时填充。</li>
<li>默认情况下，我们直接设置字段值。</li>
</ol>
<p>与在对象构造中的优化类似，我们也使用 Spring Data <strong>运行时生成的访问器类</strong>来填充实体实例中的属性。</p>
<p>这使我们比反射提高了大约 25% 的性能。对于有资格进行此类优化的域类（domain class），它需要遵守一组约束：</p>
<ul>
<li><p>类型（types）不得位于默认值或 java 包下；–这里不太懂，从英文表述上，（感觉是属性的类型必须是项目的子目录下，不能在项目的根目录下，即不能在<code>src/main/java</code> 这个目录下，需要在其下的某个包内。）</p>
<blockquote>
<p>Types must not reside in the default or under the <code>java</code> package.</p>
</blockquote>
</li>
<li><p>类型及其构造函数必须是 public 的；</p>
</li>
<li><p>作为内部类的类型必须是静态的（static）；</p>
</li>
<li><p>使用的 Java 运行时（Java Runtime）必须允许在原始 ClassLoader 中声明类。 Java 9 和更新版本施加了某些限制。</p>
</li>
</ul>
<p>默认情况下，Spring Data 会尝试使用生成的属性访问器（property accessors），并在检测到超出限制时回退到基于反射的访问器。</p>
<p>问题：如何查看 Spring Data 是否使用了 运行时生成的实例化器或者属性访问器？而不是反射？查一下</p>
<p>问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> String firstname;</span><br><span class="line"><span class="comment">// TODO(SLi): 这个注解的作用是什么？Type.FIELD 和 Type.PROPERTY 的区别是什么？</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@AccessType(Type.PROPERTY)</span> String lastname;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setLastname</span><span class="params">(String lastname)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lastname = lastname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodHandle firstname; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;firstname&quot;</span>.equals(name)) &#123;</span><br><span class="line">      firstname.invoke(person, (String) value); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;lastname&quot;</span>.equals(name)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.person.setLastname((String) value);              </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我的理解：</p>
<ul>
<li><p>Spring Data 默认使用 @AccessType(Type.FIELD) 字段访问类型，进行属性值的读写，这个时候，如果是 <code>private</code> 类型的，由于可见性规则，填充属性值时，需要在运行时生成的属性访问器中使用 <code>MethodHandles</code>与该字段进行交互；</p>
</li>
<li><p>使用 <code>@AccessType(Type.PROPERTY)</code> 注解后，则允许直接调用方法，而无需使用 <code>MethodHandles</code>。</p>
</li>
<li><p>但是不对啊，firstname如果也添加一个 setter 方法不是也可以直接使用了？在属性填充的算法规则中，如果属性定义了  setter 访问器，会直接使用 setter。</p>
</li>
</ul>
<h3 id="3-3-General-recommendations"><a href="#3-3-General-recommendations" class="headerlink" title="3.3. General recommendations"></a>3.3. General recommendations</h3><p>官方一般建议</p>
<ul>
<li><strong>尽量坚持使用不可变对象</strong> — 不可变对象很容易创建，因为实现对象只需调用其构造函数即可。仅构造函数实现比属性填充快 30%。同时可以避免域对象（domain object）被 setter 方法影响。</li>
<li><strong>提供一个全参数构造函数</strong> — 这允许对象映射以跳过属性填充的方式获得最佳性能。</li>
<li><strong>使用工厂方法</strong>而不是重载构造函数，避免使用 <code>@PersistenceConstructor</code>注解 — 为了获得最佳性能需要一个全参数构造函数，我们通常希望公开更多应用程序用例特定的构造函数，这些构造函数省略自动生成的标识符等内容。使用静态工厂方法来公开全参构造函数的这些变体是一种既定的模式。<ul>
<li>??? 这里不太明白，使用工厂方法，避免重载构造函数，避免使用<code>@PersistenceConstructor</code> 注解，到这里我明白，但是之后的内容我就不太理解，可能是翻译的不太对。</li>
</ul>
</li>
<li>确保遵守允许使用生成的实例化器和属性访问器类的约束；</li>
<li>对于要生成的标识符，仍然使用 final 字段与全参数持久性构造函数（首选）或 with… 方法结合使用；</li>
<li>可以选择使用 Lombok 避免大量模板代码，Lombok’s <code>@AllArgsConstructor</code> 可以代替全参构造函数。（这部分可选，根据情况。）</li>
</ul>
<h2 id="4-Working-with-Spring-Data-Repositories"><a href="#4-Working-with-Spring-Data-Repositories" class="headerlink" title="4. Working with Spring Data Repositories"></a>4. Working with Spring Data Repositories</h2><p>使用 Spring Data 的 repository</p>
<p>Spring Data repository 抽象的目标是，减少为各种持久性存储（实现数据访问层）所需的样板代码量。</p>
<p>问题：</p>
<ol>
<li><p>Spring Data 的特性之一：基于 repository 的方法名称派生出动态查询，</p>
<ol>
<li><p>使用这条特性，需要哪些规则？怎样自定义&#x2F;派生才能生效？</p>
<p>例如：下面这个例子，countByLastname这个方法名称的规则是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="title function_">countByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>它的原理是怎样的？怎样实现的？</p>
</li>
</ol>
</li>
</ol>
<p>我的理解：</p>
<ol>
<li><p>要达到简单使用框架的目的，需要：</p>
<ul>
<li>了解知道要用的模块&#x2F;部分的<strong>使用规则</strong>，然后按照规则一步步执行。例如，使用 repository 接口需要按照官方文档按照4个步骤依次实现并填充相关接口，剩下的交给框架就可以。再如，使用 Spark 时，知道依赖什么jar包，先创建什么，然后创建什么，方法怎样传入，怎样打包运行，剩下的就交给框架就好了。</li>
<li>快速上手的过程是把 example 内容跑起来，然后抄一下改一改，接着就要把基本规则了解一下，深入时就需要更全面了解规则。</li>
</ul>
</li>
<li><p>了解原理或者实现细节的目的 ：</p>
<ul>
<li>当现有框架提供的基本方法无法满足你的某个需求时，通过了解框架某部分的实现原理，可以知道它的工作流程，例如，它一共做了5步，你可以通过重写第三部的内容，让框架运行时加载你的实现方法，从而满足你的这个需求的。</li>
<li>可以需要哪里看哪里，也可以全部都看一遍都掌握。</li>
</ul>
</li>
<li><p>[Defining Repository Interfaces](# 4.3. Defining Repository Interfaces)</p>
</li>
<li><p>[Defining Query Methods](# 4.4. Defining Query Methods)</p>
</li>
<li><p>[Creating Repository Instances](# 4.5. Creating Repository Instances)</p>
</li>
<li><p>[Custom Implementations for Spring Data Repositories](# 4.6. Custom Implementations for Spring Data Repositories)</p>
</li>
</ol>
<h3 id="4-1-Core-concepts"><a href="#4-1-Core-concepts" class="headerlink" title="4.1. Core concepts"></a>4.1. Core concepts</h3><p>核心概念</p>
<p>underlying datastore 底层数据存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Repository</span>&lt;T, ID&gt;</span><br></pre></td></tr></table></figure>

<p>关于核心接口 <code>Repository</code></p>
<ol>
<li><p>Spring Data repository 抽象的中心接口是 <code>Repository</code> 。它将要管理&#x2F;处理的域类（domain class）以及域类的 ID 类型作为类型参数。</p>
</li>
<li><p>Repository 接口的主要作用是标记，一是获取传入的 domain class 信息，二是用于判断满足 <code>instance of Repository</code> 条件的接口，用于创建 bean。</p>
</li>
<li><p>通常创建完映射的表对象后，会创建相应的 repository 接口用来执行查询语句。这些自定义的 domain repository 会继承 repository 或者其子接口。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt;</span><br></pre></td></tr></table></figure>

<p> <code>CrudRepository </code> 接口</p>
<ul>
<li>Repository 有几个子接口（具体可以在源码中查看），我们最常用的是 <code>CrudRepository </code> 接口。</li>
<li>为正在管理的实体类提供了复杂的 <code>CRUD</code> 功能。</li>
<li>其他特定存储模块都是继承并扩展了 <code>CrudRepository</code> 接口，并基于自己特定的底层持久化技术做相关实现然后对外提供相关接口方法。例如，JpaRepository 和 MongoRepository</li>
<li><strong>分页访问</strong>，在 <code>CrudRepository</code> 之上，有一个 <code>PagingAndSortingRepository</code> 抽象，它添加了额外的方法来简化对实体的<strong>分页访问</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PagingAndSortingRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;</span><br><span class="line"></span><br><span class="line">  Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每页20，查询 user 的第二页数据</span></span><br><span class="line">PagingAndSortingRepository&lt;User, Long&gt; repository = <span class="comment">// … get access to a bean</span></span><br><span class="line">Page&lt;User&gt; users = repository.findAll(PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure>





<h3 id="4-3-Defining-Repository-Interfaces"><a href="#4-3-Defining-Repository-Interfaces" class="headerlink" title="4.3. Defining Repository Interfaces"></a>4.3. Defining Repository Interfaces</h3><ul>
<li><p>Defining a domain class-specific Repository Interfaces （定义一个特定的域类 repository 接口）</p>
<ul>
<li><p>要定义一个特定的domain class Repository 接口，首先是扩展 Repository 或其子接口，同时将要处理的域类（domain class） 和域类的 ID 字段的类型，当做参数传入。如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">样例<span class="number">1</span>，</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span>，我们实现了一个所有 domain 的公共基类 repository 接口，同时提供了 findById 和 save 功能，然后所有domain calss继承这个 base repository 接口即可。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，所有不需要运行时实例化的中间repository 标记 `@NoRepositoryBean` 注解即可。查看源码我们可知，CrudRepository 和 PagingAndSortingRepository 这两个中间 repository 也都有这个注解。</span></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span>;</span><br><span class="line"></span><br><span class="line">  &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">  User <span class="title function_">findByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>通常我们可以继承3种公共接口和各种特定存储实现的接口，</p>
<ul>
<li><code>Repository</code> , 最基础的接口，如果希望继承该接口但是又觉得功能不够，可以将 CrudRepository 或者 其他子接口中的部分方法 copy 到我们定义的 domain repository 接口中；</li>
<li><code>CrudRepository</code> , 提供复杂的 CRUD 功能的 repository 接口；</li>
<li><code>PagingAndSortingRepository</code> ，除了提供 CRUD 功能外，还提供了分页查询功能；</li>
<li>以上是公共接口，同时还可以继承各种特定数据存储模块实现的独特接口，例如 JpaRepository，MongoRepository …</li>
</ul>
</li>
<li><p><strong>当使用了多种数据存储模块时</strong>，如既有 JPA，也有MongoDB，此时需要严格区分 repository 定义与 Spring Data 模块的绑定。因为定义 repository 时需要指定 domain class ，所以：</p>
<ol>
<li>要么定义的 domain repository 是继承自特定模块实现的接口 ；</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>要么是 domain class 使用了特定模块的注解做标注；（最好不要同一个 domain class 复用不同数据存储模块的注解，Spring Data 不容易区分它绑定到哪个模块的 repository 上。）</p>
</li>
<li><p>区分 repository 的最后一种方法是对存储库基础包进行范围界定。基本包决定了扫描 <code>repository interface definitions</code> (存储库接口定义）的起点。</p>
<blockquote>
<p>这点与 Spring Boot 配置普通 Bean 时一样，都是在配置类上用独特的注解进行标注，且通过 <code>basePackages</code> 进行基本包扫描范围的限制。</p>
</blockquote>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  正确样例：</span><br><span class="line">  样例<span class="number">1</span>，继承自特定模块的repository</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">MyRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@NoRepositoryBean</span></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;T, ID&gt; &#123; … &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepository</span>&lt;User, Long&gt; &#123; … &#125;</span><br><span class="line">  </span><br><span class="line">  样例<span class="number">2</span>，定义的repository 接口使用了标注了特定模块的注解</span><br><span class="line">  <span class="comment">// 这里虽然定义的两个 repository 都继承了公共的 Repository，但是使用的 domain class 已经有明确归属。</span></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line">  <span class="comment">// 这个注解是 JPA 的，所以使用了它定义的 PersonRepository 很显然属于 Spring Data JPA。</span></span><br><span class="line">  <span class="meta">@Entity</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Person</span> &#123; … &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;User, Long&gt; &#123; … &#125;</span><br><span class="line">  <span class="comment">// 这个注解是 MongoDB的，所以 UserRepository 自然属于 Spring Data MongoDB。</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">User</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>  错误样例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下面定义的两个 repository ，当使用单个Spring Data 模块时，没有问题。但是当使用多个 Spring Data 模块时，是无法正确分区他们与哪个模块绑定的。</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AmbiguousRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;User, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AmbiguousUserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepository</span>&lt;User, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面这个例子，Person 即使用了 JPA 的注解标注，又使用了 MongoDB 的注解标注，同时使用了公共接口，导致在多模块时也是无法区分绑定到哪个模块。</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JpaPersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MongoDBPersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>  通过定义扫描 repository 时的 basePackages 值，限定了扫描的范围，同时也达到了区分不同实现的目的。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Configuration</span> &#123; … &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>中间</p>
<ul>
<li><p>Defining Query Methods （定义查询方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123;</span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>通过 <a href="https://docs.spring.io/spring-data/commons/docs/2.5.4/reference/html/#repositories.create-instances.java-config">JavaConfig</a> 或者 <a href="https://docs.spring.io/spring-data/commons/docs/2.5.4/reference/html/#repositories.create-instances">XML configuration</a> 配置 Spring 来为接口创建代理实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使用了 JPA 的样例</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>Inject the repository instance and use it</p>
</li>
</ul>
<p>@NoRepositoryBean </p>
<ul>
<li>所有不需要运行时实例化的中间repository 标记 <code>@NoRepositoryBean</code> 注解即可。查看源码我们可知，<code>CrudRepository</code> 和 <code>PagingAndSortingRepository </code>这两个中间 repository 也都有这个注解。这样 Spring Data 在运行时就不会将这些有标记的 repository 类注册为 Bean。</li>
</ul>
<h3 id="4-4-Defining-Query-Methods"><a href="#4-4-Defining-Query-Methods" class="headerlink" title="4.4. Defining Query Methods"></a>4.4. Defining Query Methods</h3><p>定义查询方法</p>
<p>repository 代理有两种方法可以从方法名称派生特定存储的查询：</p>
<ol>
<li>通过直接从方法名称派生查询。</li>
<li>通过使用手动定义的查询。</li>
</ol>
<p>创建查询必须有一个策略来决定创建什么实际查询。</p>
<h4 id="4-4-1-Query-查找策略"><a href="#4-4-1-Query-查找策略" class="headerlink" title="4.4.1. Query 查找策略"></a>4.4.1. Query 查找策略</h4><p>Query Lookup Strategies</p>
<p>声明查找策略的方式：</p>
<ul>
<li><p>使用 XML Configuration ， 可以配置命名空间的  <code>query-lookup-strategy</code> 属性；</p>
</li>
<li><p>使用 Java Configuration ，可以配置 <code>Enable$&#123;store&#125;Repositories</code> 注解中的 <code>queryLookupStrategy</code> 属性；</p>
<blockquote>
<p>例如，@EnableMongoRepositories</p>
</blockquote>
</li>
</ul>
<p>具体策略：（涉及方法创建的部分，查看下面 Query Creation 的内容）</p>
<ul>
<li><code>CREATE</code> ， 尝试从查询方法名称构造特定储存的查询。一般的方法是从方法名称中删除一组给定的前缀，然后解析方法的其余部分。</li>
<li><code>USE_DECLARED_QUERY</code>  ， 尝试寻找已定义的查询，找不到就抛异常，这个需要查看具体存储在其文档中的可用项。</li>
<li><code>CREATE_IF_NOT_FOUND</code>（<strong>默认值</strong>），结合了 <code>CREATE</code> 和 <code>USE_DECLARED_QUERY</code>。它首先查找声明的查询，如果没有找到声明的查询，它会创建一个自定义的基于方法名称的查询。这是默认的查找策略，因此，如果您没有明确配置任何内容，就会使用它。它允许按方法名称快速定义查询，还允许通过根据需要引入声明的查询来自定义这些查询。</li>
</ul>
<h4 id="4-4-2-Query-创建"><a href="#4-4-2-Query-创建" class="headerlink" title="4.4.2. Query 创建"></a>4.4.2. Query 创建</h4><p>Query Creation</p>
<p>从方法名创建查询</p>
<p>Spring Data 存储库基础结构中内置的查询构建器机制 对于构建 对 repository 实体有约束的查询非常有用。</p>
<ul>
<li>内置查询构建器机制，作用：构建查询</li>
</ul>
<p><strong>解析查询方法名称：</strong></p>
<p>解析查询方法名称，分为主语和谓语。第一部分（<code>find...By</code>，<code>exists...By</code>）定义查询的主语，第二部分形成谓词。介绍从句（这里指主语）可以包含进一步的表达。 <code>find</code>（或其他引入关键字）和 <code>By</code> 之间的任何文本都被认为是描述性的，除非使用<em>结果限制关键字</em>之一，例如 <code>Distinct</code> 在要创建的查询上设置不同的标志或使用 <code>Top</code>&#x2F;<code>First</code> 来限制查询结果。</p>
<blockquote>
<p>The introducing clause (subject) can contain further expressions. Any text between find (or other introducing keywords) and By is considered to be descriptive。 这里的 introducing 怎么翻译比较合理？</p>
</blockquote>
<p><strong>了解查询方法支持的主语和条件谓语的关键字是重点</strong></p>
<p>附录包含 查询方法主语关键字（<a href="https://docs.spring.io/spring-data/commons/docs/2.5.4/reference/html/#appendix.query.method.subject">query method subject keywords</a> ）和查询方法谓词关键字（<a href="https://docs.spring.io/spring-data/commons/docs/2.5.4/reference/html/#appendix.query.method.predicate">query method predicate keywords including sorting and letter-casing modifiers</a>）的完整列表，包括排序和字母大小写修饰符。但是，第一个 By 充当分隔符表明实际标准谓词的开始。在非常基础的层面上，您可以在实体属性上定义条件并将它们与 And 和 Or 连接起来。</p>
<blockquote>
<p>查询语句中的<strong>谓语</strong>，是指，条件（conditions）或条件表达式（将多个条件语句使用 AND 或 OR 连接一起）</p>
</blockquote>
<p>定义查询方法的常规注意事项：</p>
<blockquote>
<p>虽然解析方法的实际结果取决于您创建查询时所使用的持久化存储。但是也有一些常规注意事项。</p>
</blockquote>
<ul>
<li>表达式通常是将属性（property）与操作符（operator）连接在一起。多个属性表达式可以使用 <code>AND</code> 和 <code>OR</code> 结合使用。一个属性表达式可以使用的操作符例如，<code>Between</code>, <code>LessThan</code>, <code>GreaterThan</code>, 和 <code>Like</code>，可以使用的操作符因数据存储而异，具体需要查看对应文档的对应部分。</li>
<li>方法解析器支持设置 <code>IgnoreCase</code> 标志，为单个属性（例如 <code>findByLastnameIgnoreCase(…)</code>）或支持忽略大小写的类型的所有属性（通常是 <code>String</code> 实例，例如 <code>findByLastnameAndFirstnameAllIgnoreCase(…)</code>）。是否支持忽略大小写可能因数据存储而异，因此请参阅参考文档中的相关部分以了解数据存储特定的查询方法。</li>
<li>您可以通过将 <code>OrderBy</code> 子句进行<strong>静态排序</strong>，并提供排序方向（<code>Asc</code> 或 <code>Desc</code>）。要创建支持动态排序的查询方法，请参阅“特殊参数处理”（“<a href="https://docs.spring.io/spring-data/commons/docs/2.5.4/reference/html/#repositories.special-parameters">Special parameter handling</a>”）.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enables the distinct flag for the query</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling ignoring case for an individual property</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span>;</span><br><span class="line">  <span class="comment">// Enabling ignoring case for all suitable properties</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling static ORDER BY for a query</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span>;</span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-3-嵌套属性解析-x2F-处理方式"><a href="#4-4-3-嵌套属性解析-x2F-处理方式" class="headerlink" title="4.4.3. 嵌套属性解析&#x2F;处理方式"></a>4.4.3. 嵌套属性解析&#x2F;处理方式</h4><p>Property Expressions</p>
<p>属性表达式只能引用被管理实体的直接属性，例如前面样例所示，通常在创建实例类时已经确定了。但是，当遇到含有嵌套属性时，需要额外注意（可能会产生解析歧义，参考样例1）。</p>
<p>最佳实践是当实体类中包含嵌套类作为属性，且该属性用于创建查询方法时，使用<code>_</code> 手动定义遍历分割点，即将这个嵌套属性与该属性中涉及的子属性名分开。（参考样例2）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 样例希望处理Person类中有一个 Address 嵌套类作为属性，Address中有一个 ZipCode 属性字段。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 样例1：</span></span><br><span class="line"><span class="comment">// 这样写大多数情况可以，但是根据属性解析算法，当实体类中包含 addressZip 属性时，就会解析错误。</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">findByAddressZipCode</span><span class="params">(ZipCode zipCode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样例2：</span></span><br><span class="line"><span class="comment">// 最好的处理方式：</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">findByAddress_ZipCode</span><span class="params">(ZipCode zipCode)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子中，是假设 Person 类有一个带有 <code>ZipCode</code> 的<code>Address</code> 属性。 在这种情况下，该方法会创建 <code>x.address.zipCode</code> 属性遍历。 解析算法首先将整个部分 (<code>AddressZipCode</code>) 解释为属性并检查具有该名称（未大写）的属性的域类。 如果算法成功，它将使用该属性。 如果不是，则算法将来自右侧的驼峰式部分的源拆分为头和尾，并尝试找到相应的属性 — 在我们的示例中为 <code>AddressZip</code> 和 <code>Code</code>。 如果算法找到具有该头部的属性，它会取尾部并继续从那里向下构建树，以刚才描述的方式将尾部拆分。 如果第一个拆分不匹配，则算法<strong>将拆分点向左移动</strong>（<code>Address</code>、<code>ZipCode</code>）并继续。</p>
</blockquote>
<p>因为 Spring Data 将<strong>下划线（_）</strong>视为<strong>保留字符</strong>，所以强烈建议遵循标准的 Java 命名约定（即，要使用驼峰式大小写，不要在属性名称中使用下划线）。</p>
<p>问题：什么是 the managed entity，或 the managed domain class ？</p>
<blockquote>
<p>答：在定义 repository 接口时，当做参数传入其中的 实体类，就是被 repository 接口管理的 entity。</p>
</blockquote>
<h4 id="4-4-4-查询方法的动态分页和排序"><a href="#4-4-4-查询方法的动态分页和排序" class="headerlink" title="4.4.4. 查询方法的动态分页和排序"></a>4.4.4. 查询方法的动态<code>分页</code>和<code>排序</code></h4><p>Special parameter handling</p>
<p><strong>Using</strong> <code>Pageable</code><strong>,</strong> <code>Slice</code><strong>, and</strong> <code>Sort</code> <strong>in query methods</strong></p>
<p>动态进行<code>分页</code>和<code>排序</code>查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页</span></span><br><span class="line">Page&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">Slice&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Sort sort)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个方法允许我们将 <code>org.springframework.data.domain.Pageable</code> 实例传递给查询方法，可以将分页动态添加到静态定义的查询中。<code>Page</code> 知道可用元素和页面的总数。它通过基础结构触发计数查询（count query）来计算总数。由于这可能开销比较大（取决于所使用的存储），我们可以改为返回 <code>Slice</code>。 <code>Slice</code> 只知道下一个 <code>Slice</code> 是否可用（不触发计数查询的消耗），这在遍历更大的结果集时可能就足够了，例如第二个方法。</p>
<p>排序也通过 <code>Pageable</code> 实例处理。如果只需要排序，请将 <code>org.springframework.data.domain.Sort</code> 参数添加到方法中。如您所见，返回一个 <code>List</code> 也是可能的。在这种情况下，不会创建构建实际 <code>Page</code> 实例所需的附加元数据（不会触发额外的计数查询（count query））。相反（这里应该是指除了排序还需要分页），它限制查询仅查找给定范围的实体。</p>
<blockquote>
<p>要了解整个查询获得了多少页，必须触发额外的计数查询。默认情况下，此查询来自实际触发的查询。</p>
</blockquote>
<h5 id="Paging-and-Sorting"><a href="#Paging-and-Sorting" class="headerlink" title="Paging and Sorting"></a>Paging and Sorting</h5><p>定义排序表达式更类型安全的方法是，先定义排序表达式的类型，然后使用方法引用来定义排序的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义排序表达式</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;firstname&quot;</span>).ascending()</span><br><span class="line">  .and(Sort.by(<span class="string">&quot;lastname&quot;</span>).descending());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型安全 API 定义排序表达式</span></span><br><span class="line">TypedSort&lt;Person&gt; person = Sort.sort(Person.class);</span><br><span class="line"><span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> person.by(Person::getFirstname).ascending()</span><br><span class="line">  .and(person.by(Person::getLastname).descending());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TypedSort.by(…) 通过（通常）使用 CGlib 来使用运行时代理，这可能会在使用 Graal VM Native 等工具时干扰本机图像编译。？？什么意思？有缺点？</p>
</blockquote>
<p>如果您的存储实现支持 <code>Querydsl</code>，您还可以使用生成的元模型类型来定义排序表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Querydsl API 定义排序表达式</span></span><br><span class="line"><span class="type">QSort</span> <span class="variable">sort</span> <span class="operator">=</span> QSort.by(QPerson.firstname.asc())</span><br><span class="line">  .and(QSort.by(QPerson.lastname.desc()));</span><br></pre></td></tr></table></figure>



<h4 id="4-4-5-Limiting-Query-Results"><a href="#4-4-5-Limiting-Query-Results" class="headerlink" title="4.4.5. Limiting Query Results"></a>4.4.5. Limiting Query Results</h4><ul>
<li>Top  &#x2F; TopN，例如：Top5，默认 Top 表示1；</li>
<li>First &#x2F; FirstN，例如：First5，默认 First 表示1；</li>
</ul>
<p>您可以通过使用 <code>first</code> 或 <code>top</code> 关键字来限制查询方法的结果，这两个关键字可以互换使用（作用相同）。您可以将可选数值附加到 top 或 first 以指定要返回的最大结果大小。如果忽略该数字，则假定结果大小为 1。以下示例显示了如何限制查询大小：</p>
<p><strong>Limiting the result size of a query with</strong> <code>Top</code> <strong>and</strong> <code>First</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">findFirstByOrderByLastnameAsc</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">User <span class="title function_">findTopByOrderByAgeDesc</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Page&lt;User&gt; <span class="title function_">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">Slice&lt;User&gt; <span class="title function_">findTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; <span class="title function_">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; <span class="title function_">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-6-处理集合类返回值"><a href="#4-4-6-处理集合类返回值" class="headerlink" title="4.4.6. 处理集合类返回值"></a>4.4.6. 处理集合类返回值</h4><p>Repository Methods Returning Collections or Iterables</p>
<blockquote>
<p> 返回集合或可迭代对象的存储库方法</p>
</blockquote>
<p><strong>支持集合的返回值类型</strong></p>
<ul>
<li>Java Iterable</li>
<li>List</li>
<li>Set</li>
<li>Steamable （Spring Data 支持的）</li>
<li>Iterable 的自定义扩展（Spring Data 支持的）</li>
<li>Vavr 提供的集合类型</li>
</ul>
<p>返回多个结果的查询方法可以使用标准的 <code>Java Iterable</code>、<code>List</code> 和 <code>Set</code>。除此之外，我们支持返回 Spring Data 的 <code>Streamable</code>，<code>Iterable 的自定义扩展</code>，以及 <code>Vavr 提供的集合类型</code>。请参阅解释所有可能的查询方法返回类型的附录。</p>
<h5 id="Using-Streamable-as-Query-Method-Return-Type"><a href="#Using-Streamable-as-Query-Method-Return-Type" class="headerlink" title="Using Streamable as Query Method Return Type"></a>Using Streamable as Query Method Return Type</h5><p>在 Spring Data 中，可以使用 <code>Streamable</code> 作为 <code>Iterable</code> 或任何集合类型的代替方案。</p>
<ul>
<li>提供了访问非并行 Stream 的方法；</li>
<li>可以直接在元素上调用 <code>filter()</code>,<code>map()</code>方法；</li>
<li>支持将多个结果使用例如 and 方法连接到一起返回。如下面的样例1。</li>
</ul>
<p>使用Streamable合并查询方法结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 样例1：</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123;</span><br><span class="line">  Streamable&lt;Person&gt; <span class="title function_">findByFirstnameContaining</span><span class="params">(String firstname)</span>;</span><br><span class="line">  Streamable&lt;Person&gt; <span class="title function_">findByLastnameContaining</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Streamable&lt;Person&gt; result = repository.findByFirstnameContaining(<span class="string">&quot;av&quot;</span>)</span><br><span class="line">  .and(repository.findByLastnameContaining(<span class="string">&quot;ea&quot;</span>));</span><br></pre></td></tr></table></figure>



<h5 id="Returning-Custom-Streamable-Wrapper-Types"><a href="#Returning-Custom-Streamable-Wrapper-Types" class="headerlink" title="Returning Custom Streamable Wrapper Types"></a>Returning Custom Streamable Wrapper Types</h5><blockquote>
<p>返回自定义流包装器类型</p>
</blockquote>
<p>TODO，这部分先跳过，用到时再看</p>
<h4 id="4-4-7-Null-Handling-of-Repository-Methods"><a href="#4-4-7-Null-Handling-of-Repository-Methods" class="headerlink" title="4.4.7. Null Handling of Repository Methods"></a>4.4.7. Null Handling of Repository Methods</h4><p>存储库方法的空处理</p>
<p><strong>两种方法处理 null</strong>：</p>
<ol>
<li>返回值使用包装类，保证不会返回null；</li>
<li>使用与null 有关的注解标注，进行检查参数和结果；</li>
</ol>
<p>如果repository 方法返回单个实例，可以使用 java 8 的 <code>Optional</code> 来代替返回null 值，同时 Spring Data 支持使用下面几种包装器作为返回值：</p>
<ul>
<li><code>com.google.common.base.Optional</code></li>
<li><code>scala.Option</code></li>
<li><code>io.vavr.control.Option</code></li>
</ul>
<p>如果不使用包装器，那么可以直接返回 null 值来表示没有查询结果。</p>
<p>返回集合、集合替代、包装器和流的 repository 方法保证永远不会返回 null 而是返回相应的空表示没有查询结果。</p>
<h5 id="Nullability-Annotations"><a href="#Nullability-Annotations" class="headerlink" title="Nullability Annotations"></a>Nullability Annotations</h5><ul>
<li><code>@NonNullApi</code>: 在包级别（package level）用于声明参数和返回值的默认行为是既不接受也不产生空值。</li>
<li><code>@NonNull</code>：用在不能为空的参数或返回值处（设置了<code>@NonNullApi</code>的参数和返回值不需要再设置）。</li>
<li><code>@Nullable</code>：用在可以为 null 的参数或返回值。</li>
</ul>
<p>Spring 注释使用 JSR 305 注释（一种休眠但广泛使用的 JSR）进行元注释。 JSR 305 元注释让工具供应商（如 IDEA、Eclipse 和 Kotlin）以通用方式提供空安全支持，而无需对 Spring 注释进行硬编码支持。要为查询方法启用可空性约束的运行时检查，您需要通过在 package-info.java 中使用 Spring 的 @NonNullApi 在包级别激活非可空性，如下例所示：</p>
<p><strong>Declaring Non-nullability in</strong> <code>package-info.java</code></p>
<blockquote>
<p>在 package-info.java 中声明不可为空</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.lang.NonNullApi</span><br><span class="line"><span class="keyword">package</span> com.acme;</span><br></pre></td></tr></table></figure>



<p>一旦非空默认设置到位，存储库查询方法调用将在运行时验证为可空性约束。如果查询结果违反了定义的约束，则抛出异常。当该方法将返回 null 但被声明为不可为 null 时会发生这种情况（默认情况下，在存储库所在的包上定义了注释）。如果您想再次选择可空结果，请有选择地对各个方法使用 @Nullable。使用本节开头提到的结果包装器类型继续按预期工作：空结果被转换为表示不存在的值。</p>
<p><strong>Using different nullability constraints</strong></p>
<p>使用不同的可空性约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.acme;      <span class="comment">// 参考上面的例子，已经定义了 non-null（非空） 行为                                                 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  User <span class="title function_">getByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span>;  <span class="comment">// 当查询未产生结果时抛出 EmptyResultDataAccessException。当传递给方法的 emailAddress 为 null 时，抛出 IllegalArgumentException。</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  User <span class="title function_">findByEmailAddress</span><span class="params">(<span class="meta">@Nullable</span> EmailAddress emailAdress)</span>;   <span class="comment">// 当查询未产生结果时返回 null。还接受 null 作为 emailAddress 的值。       </span></span><br><span class="line"></span><br><span class="line">  Optional&lt;User&gt; <span class="title function_">findOptionalByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span>;  <span class="comment">// 当查询未产生结果时返回 Optional.empty()。当传递给方法的 emailAddress 为 null 时，抛出 IllegalArgumentException。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-8-Streaming-Query-Results"><a href="#4-4-8-Streaming-Query-Results" class="headerlink" title="4.4.8. Streaming Query Results"></a>4.4.8. Streaming Query Results</h4><p>流式查询结果</p>
<p>关于流，除了使用 Spring Data 支持的 Streamable 作为返回结果外，还可以使用 Java8 支持的 <code>Stream&lt;T&gt;</code> 作为返回结果。</p>
<p>但是在实际调用时，因为 Stream 可能包装底层数据存储特定的资源，因此必须在<strong>使用后关闭</strong>。您可以使用 <code>close()</code> 方法或使用 Java 7 <code>try-with-resources</code> 块关闭 Stream，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</span><br><span class="line">  stream.forEach(…);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：并非所有 Spring Data 模块当前都支持 Stream<T> 作为返回类型。具体需要参考实现模块文档。</p>
</blockquote>
<h4 id="4-4-9-异步查询结果"><a href="#4-4-9-异步查询结果" class="headerlink" title="4.4.9. 异步查询结果"></a>4.4.9. 异步查询结果</h4><p>Asynchronous Query Results</p>
<p>Spring 中关于异步方法执行的具体内容参考官方文档：<a href="https://docs.spring.io/spring-framework/docs/5.3.9/reference/html/integration.html#scheduling">Spring’s asynchronous method running capability</a>.</p>
<p>使用 <code>@Async</code> 注解执行方法的异步查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 java.util.concurrent.Future 作为返回值；</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line">Future&lt;User&gt; <span class="title function_">findByFirstname</span><span class="params">(String firstname)</span>;               </span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8 中的 java.util.concurrent.CompletableFuture 作为返回值；</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line">CompletableFuture&lt;User&gt; <span class="title function_">findOneByFirstname</span><span class="params">(String firstname)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 org.springframework.util.concurrent.ListenableFuture 作为返回值；</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line">ListenableFuture&lt;User&gt; <span class="title function_">findOneByLastname</span><span class="params">(String lastname)</span>;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring 的异步方法运行功能异步运行存储库查询。这意味着该方法<strong>在调用时立即返回</strong>，而实际查询发生在已提交给 Spring <code>TaskExecutor</code> 的任务中。异步查询不同于反应式查询，不应混合使用。有关反应式支持的更多详细信息，请参阅特定存储的文档。</p>
</blockquote>
<h3 id="4-5-Creating-Repository-Instances"><a href="#4-5-Creating-Repository-Instances" class="headerlink" title="4.5. Creating Repository Instances"></a>4.5. Creating Repository Instances</h3><p>如何为已定义的 repository 接口创建实例和 bean 定义？</p>
<ul>
<li>使用 XML 中的命名空间</li>
<li>Java配置 （Java Configuration）（推荐）<ul>
<li>通过在 Java 配置类上使用特定存储的 <code>@Enable$&#123;store&#125;Repositories</code> 注解来触发存储库基础结构。</li>
</ul>
</li>
</ul>
<p>Spring 容器（Spring container）基于 Java 的配置（ Java-based configuration）的详细内容参考官方文档， <a href="https://docs.spring.io/spring-framework/docs/5.3.9/reference/html/core.html#beans-java">JavaConfig in the Spring reference documentation</a>.</p>
<h3 id="4-6-Custom-Implementations-for-Spring-Data-Repositories"><a href="#4-6-Custom-Implementations-for-Spring-Data-Repositories" class="headerlink" title="4.6. Custom Implementations for Spring Data Repositories"></a>4.6. Custom Implementations for Spring Data Repositories</h3><p>Spring Data Repositories 的自定义实现 ？</p>
<p>暂时理解为当按照提供的规则无法创建需要的 查询方法时，可以利用自定义方式来处理。</p>
<p>以下示例显示了一个使用默认后缀的存储库和一个为后缀设置自定义值的存储库：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span> /&gt;</span>  // 默认是 Impl，尝试查找名为 com.acme.repository.CustomizedUserRepositoryImpl 的类</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span> <span class="attr">repository-impl-postfix</span>=<span class="string">&quot;MyPostfix&quot;</span> /&gt;</span> // 尝试查找名为 com.acme.repository.CustomizedUserRepositoryMyPostfix 的类</span><br><span class="line"></span><br><span class="line">Java Configuration 配置类似</span><br><span class="line">@EnableElasticsearchRepositories(repositoryImplementationPostfix = &quot;xxx&quot;)</span><br></pre></td></tr></table></figure>



<p><strong>Resolution of Ambiguity</strong></p>
<p>解决歧义</p>
<p>如果在不同的包中找到多个能匹配类名的实现，Spring Data 使用 bean 名称来标识使用哪个。</p>
<p>与普通的 Bean 相同，</p>
<ol>
<li>默认情况下，使用首字母小写的类名作 Bean 名称，默认匹配用<strong>接口名+Impl 后缀</strong> 来匹配 Bean 名称。</li>
<li>可以使用注解来自定义 Bean 名称，例如，使用 <code>@Component(&quot;specialCustomImpl&quot;)</code> 来标注后，就会使用自定义的名称代替默认 Bean 名称。 –需要测试验证。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个包中使用默认的</span></span><br><span class="line"><span class="keyword">package</span> com.acme.impl.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">CustomizedUserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Your custom implementation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个包中使用自定义的。</span></span><br><span class="line"><span class="keyword">package</span> com.acme.impl.two;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;specialCustomImpl&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">CustomizedUserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Your custom implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Manual Wiring</strong></p>
<p>手动接线</p>
<h4 id="4-6-2-Customize-the-Base-Repository"><a href="#4-6-2-Customize-the-Base-Repository" class="headerlink" title="4.6.2. Customize the Base Repository"></a>4.6.2. Customize the Base Repository</h4><h3 id="4-7-Publishing-Events-from-Aggregate-Roots"><a href="#4-7-Publishing-Events-from-Aggregate-Roots" class="headerlink" title="4.7. Publishing Events from Aggregate Roots"></a>4.7. Publishing Events from Aggregate Roots</h3><p>从聚合根发布事件</p>
<p>什么是 aggregate root ？？？</p>
<p>Entities managed by repositories are aggregate roots. In a Domain-Driven Design application, these aggregate roots usually publish domain events.</p>
<blockquote>
<p>存储库管理的实体是聚合根。在域驱动设计应用程序中，这些聚合根通常发布域事件。</p>
</blockquote>
<p>每次调用 Spring Data 存储库 <code>save(…)</code>、<code>saveAll(…)</code>、<code>delete(…)</code> 或 <code>delete All(…)</code> 方法之一时都会调用这些方法。</p>
<h2 id="5-Projections"><a href="#5-Projections" class="headerlink" title="5. Projections"></a>5. Projections</h2><p>类似 Select 语句中 选择指定字段输出</p>
<p>基础处理中，我们在 repository 的查询方法中只返回整个实体类，高级处理时，我们有返回 repository 管理的实体类中部分属性的需求，就像 select 部分字段一样。</p>
<p>此时，使用基于接口的投影。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单使用时返回被管理的实体 Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span> UUID id;</span><br><span class="line">  String firstname, lastname;</span><br><span class="line">  Address address;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    String zipCode, city, street;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, UUID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  Collection&lt;Person&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>The aggregate root  多次出现这个概念，需要回去看一下表达的是什么。</p>
<p><strong>default</strong> ，Java 8 中出现在 interface 中的新方法，表达什么意思呢？</p>
<h3 id="5-1-Interface-based-Projections"><a href="#5-1-Interface-based-Projections" class="headerlink" title="5.1. Interface-based Projections"></a>5.1. Interface-based Projections</h3><p>当我们想要返回被管理实体中的指定字段时，最简单的方法是，重新定义一个新的接口（interface），然后将需要返回的属性字段的方法暴露出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个仅返回名称属性的接口，然后再 PersonRepository 中用于查询方法的返回值。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NamesOnly</span> &#123;</span><br><span class="line"></span><br><span class="line">  String <span class="title function_">getFirstname</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getLastname</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, UUID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  Collection&lt;NamesOnly&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实体类有内部嵌套类属性，嵌套类也选择字段返回，那么与外部类也一样处理，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 样例2：这里新接口 PersonSummary 仅返回 名字和地址 三个字段，且地址字段是嵌套类作为属性仅有 city 属性返回，那么嵌套类也要新建接口，如下：</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonSummary</span> &#123;</span><br><span class="line"></span><br><span class="line">  String <span class="title function_">getFirstname</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getLastname</span><span class="params">()</span>;</span><br><span class="line">  AddressSummary <span class="title function_">getAddress</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">AddressSummary</span> &#123;</span><br><span class="line">    String <span class="title function_">getCity</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>下面这部分内容等实际用到时再参考，<a href="https://docs.spring.io/spring-data/commons/docs/2.5.4/reference/html/#projections">Spring Data Commons - Reference Documentation</a></p>
</blockquote>
<h4 id="5-1-1-Closed-Projections"><a href="#5-1-1-Closed-Projections" class="headerlink" title="5.1.1. Closed Projections"></a>5.1.1. Closed Projections</h4><p>新建的接口中涉及的属性与实体属性完全一致时，我们称这种投影接口为 <code>closed projects</code>，否则为 <code>open projects</code>。</p>
<h4 id="5-1-2-Open-Projections"><a href="#5-1-2-Open-Projections" class="headerlink" title="5.1.2. Open Projections"></a>5.1.2. Open Projections</h4><h4 id="5-1-3-Nullable-Wrappers"><a href="#5-1-3-Nullable-Wrappers" class="headerlink" title="5.1.3. Nullable Wrappers"></a>5.1.3. Nullable Wrappers</h4><h3 id="5-2-Class-based-Projections-DTOs"><a href="#5-2-Class-based-Projections-DTOs" class="headerlink" title="5.2. Class-based Projections (DTOs)"></a>5.2. Class-based Projections (DTOs)</h3><h3 id="5-3-Dynamic-Projections"><a href="#5-3-Dynamic-Projections" class="headerlink" title="5.3. Dynamic Projections"></a>5.3. Dynamic Projections</h3><p>将需要返回的类型当做查询方法的一个参数传入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">样例<span class="number">1</span>：</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, UUID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; Collection&lt;T&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname, Class&lt;T&gt; type)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">(PersonRepository people)</span> &#123;</span><br><span class="line"></span><br><span class="line">  Collection&lt;Person&gt; aggregates =</span><br><span class="line">    people.findByLastname(<span class="string">&quot;Matthews&quot;</span>, Person.class);</span><br><span class="line"></span><br><span class="line">  Collection&lt;NamesOnly&gt; aggregates =</span><br><span class="line">    people.findByLastname(<span class="string">&quot;Matthews&quot;</span>, NamesOnly.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-Query-by-Example"><a href="#6-Query-by-Example" class="headerlink" title="6. Query by Example"></a>6. Query by Example</h2><p>JPA 和 MyBatis 中都有涉及 example，什么是 query by example？什么是动态查询</p>
<h3 id="Appendix-C-Repository-query-keywords"><a href="#Appendix-C-Repository-query-keywords" class="headerlink" title="Appendix C: Repository query keywords"></a>Appendix C: Repository query keywords</h3><table>
<thead>
<tr>
<th align="left">Keyword</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>find…By</code>, <code>read…By</code>, <code>get…By</code>, <code>query…By</code>, <code>search…By</code>, <code>stream…By</code></td>
<td align="left">General query method returning typically the repository type, a <code>Collection</code> or <code>Streamable</code> subtype or a result wrapper such as <code>Page</code>, <code>GeoResults</code> or any other store-specific result wrapper. Can be used as <code>findBy…</code>, <code>findMyDomainTypeBy…</code> or in combination with additional keywords.</td>
</tr>
<tr>
<td align="left"><code>exists…By</code></td>
<td align="left">Exists projection, returning typically a <code>boolean</code> result.</td>
</tr>
<tr>
<td align="left"><code>count…By</code></td>
<td align="left">Count projection returning a numeric result.</td>
</tr>
<tr>
<td align="left"><code>delete…By</code>, <code>remove…By</code></td>
<td align="left">Delete query method returning either no result (<code>void</code>) or the delete count.</td>
</tr>
<tr>
<td align="left"><code>…First&lt;number&gt;…</code>, <code>…Top&lt;number&gt;…</code></td>
<td align="left">Limit the query results to the first <code>&lt;number&gt;</code> of results. This keyword can occur in any place of the subject between <code>find</code> (and the other keywords) and <code>by</code>.</td>
</tr>
<tr>
<td align="left"><code>…Distinct…</code></td>
<td align="left">Use a distinct query to return only unique results. Consult the store-specific documentation whether that feature is supported. This keyword can occur in any place of the subject between <code>find</code> (and the other keywords) and <code>by</code>.</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringData</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring循环引用</title>
    <url>//Spring%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="Spring-中的循环依赖"><a href="#Spring-中的循环依赖" class="headerlink" title="Spring 中的循环依赖"></a>Spring 中的循环依赖</h1><p>循环依赖，多个对象之间相互引用，形成环形，在创建对象过程中谁都创建。</p>
<p>主要发生在 bean 实例化的过程中。</p>
<p>参考 <a href="https://juejin.cn/post/6995478733528236039">Spring源码解析之循环依赖</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注解学习</title>
    <url>//Spring%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="了解spring的启动顺序和过程"><a href="#了解spring的启动顺序和过程" class="headerlink" title="了解spring的启动顺序和过程"></a>了解spring的启动顺序和过程</h1><p>Spring 初始化顺序</p>
<ol>
<li><p>如果在spring的配置文件中配置bean，然后加载spring配置文件的情况下，spring会按照配置文件中bean的顺序，依次初始化xml中所有bean</p>
</li>
<li><p>如果某个类的头上，使用@Component&#x2F;@Repository&#x2F;@Service&#x2F;@Controller注解，spring会将这个对象作为Bean注册近spring容器中。</p>
</li>
<li><p>如果通过实现ApplicationContextAware接口来加载spring上下文环境，</p>
<ul>
<li>spring会在初始化bean后，调用setApplicationContext()方法</li>
</ul>
</li>
<li><p>如果实现了InitializingBean接口，spring会在初始化bean后，并在setApplicationContext（如果有）执行完后, 调用afterPropertiesSet()方法</p>
</li>
</ol>
<p>使用spring管理的bean时，无需对调用的对象进行new操作，是需要在使用时，加上@Autowired，spring会将对应的bean注入本类中。</p>
<blockquote>
<p>以上是旧时写的内容</p>
</blockquote>
<hr>
<blockquote>
<p>以下是 20210813 写的内容</p>
</blockquote>
<h1 id="几个常用概念理解"><a href="#几个常用概念理解" class="headerlink" title="几个常用概念理解"></a>几个常用概念理解</h1><ol>
<li>“装配”，是把类转为由spring容器管理的bean。</li>
<li>“注入”，是把spring容器管理的bean赋值给类中的成员变量，即属性。（也可以赋值给 set 方法，构造函数，效果一样）</li>
</ol>
<p>常见用词搭配，自动装配，依赖注入</p>
<p>目的，解决对象间相互依赖协作创建新对象的问题。例如一个类A可以作为另一个类B中的一个属性，如果实例化B，就需要实例化A</p>
<p>在一个Bean中调用另外一个Bean，就需要依赖注入。</p>
<p>集成 Spring 时的两个常用名词</p>
<ul>
<li>JavaConfig ，就是 <code>@Configuration</code> 的形式</li>
<li>XML  ，就是使用使用 XML 的形式，把所有内容写再在 XML 中解析成 java object 。</li>
</ul>
<p>Spring 官方文档中常提及的几个含义类似的单词</p>
<p>下面都是指一个实体类 ，它们在 Spring 中都可以通过添加相关注解被注册为一个 Bean 。</p>
<ul>
<li><p>虽然表达的含义有些许不同，但是在理解文档时可以粗略的把它们理解为一类东西。</p>
</li>
<li><p>entity &#x2F; entity class</p>
</li>
<li><p>domain</p>
<ul>
<li>instances of domain objects</li>
<li>domain class</li>
</ul>
</li>
<li><p>POJO</p>
</li>
</ul>
<p>在上下文提到的是 class &#x2F; object 中出现的，都是指类中的字段</p>
<ul>
<li>property</li>
<li>property names of the entity</li>
<li>field</li>
<li>attribute</li>
</ul>
<h1 id="Spring-的-Bean-创建以及注入"><a href="#Spring-的-Bean-创建以及注入" class="headerlink" title="Spring 的 Bean 创建以及注入"></a>Spring 的 Bean 创建以及注入</h1><p>下面是关于 Spring 中 Bean 的创建，注入，已经与其相关的常用注解的说明整理。</p>
<h2 id="什么是-Bean-？-为什么交给-Spring-管理-？"><a href="#什么是-Bean-？-为什么交给-Spring-管理-？" class="headerlink" title="什么是 Bean ？ 为什么交给 Spring 管理 ？"></a>什么是 Bean ？ 为什么交给 Spring 管理 ？</h2><p>在 Spring 中创建，并交由 Spring 管理的对象，称为 Bean。</p>
<p>Spring 会对注册到其容器中的 Bean 做管理，包括 Bean 的配置信息，依赖关系，初始化，作用域，生命周期等方面集中做判断处理。</p>
<p>可以理解为是 Spring 框架的要求，也可以理解为是它的特性。</p>
<blockquote>
<p>使用spring管理的bean时，无需对调用的对象进行new操作，只需要在使用时，加上@Autowired，spring会将对应的bean注入本类中。</p>
</blockquote>
<h2 id="与-Bean-有关，常用的注解有哪些？分别怎么用？"><a href="#与-Bean-有关，常用的注解有哪些？分别怎么用？" class="headerlink" title="与 Bean 有关，常用的注解有哪些？分别怎么用？"></a>与 Bean 有关，常用的注解有哪些？分别怎么用？</h2><p>从 Bean 的装配和注入两个角度看。</p>
<h3 id="Bean-的装配（-x2F-创建）相关注解-（IoC-的体现）"><a href="#Bean-的装配（-x2F-创建）相关注解-（IoC-的体现）" class="headerlink" title="Bean 的装配（&#x2F;创建）相关注解 （IoC 的体现）"></a>Bean 的装配（&#x2F;创建）相关注解 （IoC 的体现）</h3><p>bean配置有三种方法：</p>
<ul>
<li>基于 xml 配置 Bean 【不推荐】</li>
<li>使用注解定义 Bean 【推荐】</li>
<li>基于 Java 类提供 Bean 的定义信息 【推荐】</li>
</ul>
<p>从作用对象上分类</p>
<ul>
<li>@Component ，作用于类</li>
<li>@Bean ， 作用于方法</li>
</ul>
<h4 id="与-Component-相关的内容"><a href="#与-Component-相关的内容" class="headerlink" title="与 @Component 相关的内容"></a>与 @Component 相关的内容</h4><p>Spring 提供了多个与 <code>@Component</code> 注解功能类似，但是含义略有不同的注解，都可以实现将标注的类注册为 Spring 管理的 Bean。</p>
<p>以下内容主要参考 <a href="https://blog.csdn.net/lipinganq/article/details/79155072">Spring Boot常用注解（一） - 声明Bean的注解</a></p>
<p><strong>总结：</strong></p>
<p>@Component, @Service, @Repository, @Controller, @RestController 这 5 个注解的区别</p>
<ol>
<li>从源码级别来看，@Service, @Repository, @Controller, @RestController 都是 @Component 注解的别名，效果都一样。Spring 会将被这 5 个注解标注的类加载到 Spring 上下文中。</li>
<li>从业务分层使用的角度来看，他们用于标注不同的业务层。具体看下面介绍。<ul>
<li>在项目中，却建议你严格按照除 @Component 外的其余几个注解的含义使用在项目各层中。这对分层结构的 web 架构很有好处。</li>
</ul>
</li>
</ol>
<p>本节主要介绍注解：</p>
<ul>
<li>@Component ， 没有明确角色的组件，当暂时不知道或不确定某个类该分为哪一层时，使用。</li>
<li>@Service ， 与 <code>@Component</code> 作用一样，在业务逻辑层（service 层）使用。</li>
<li>@Repository ， 作用同上，在数据访问层（dao 层）使用。</li>
<li>@Controller ， 作用同上，在访问控制层（web 层） 使用</li>
<li>@RestController ， 是 <code>@Controller</code> + <code>@ResponseBody</code> 的组合</li>
<li>@Scope ， 主要作用是在注册时，提供修改 Bean 的作用域。</li>
</ul>
<p>下面几个是与 @Controller&#x2F;@RestController 结合使用的注解，放在 Web 章节中可能更好</p>
<ul>
<li>@RequestMapping</li>
<li>@PathVariable</li>
<li>@ResponseBody</li>
</ul>
<h5 id="Component-注解"><a href="#Component-注解" class="headerlink" title="@Component 注解"></a>@Component 注解</h5><ol>
<li>作用在类上</li>
<li>作用域默认为 <code>singleton</code></li>
<li>使用注解配置和类路径扫描时，被 <code>@Component</code> 注解标注的类，会被 Spring 扫描并注册为 Bean 。</li>
<li>@Component 注解，一般在不确定 Bean 为哪一层的时候使用，可以作用在任何层次，把普通 POJO 注册到 Spring 容器。</li>
<li>不推荐使用 @Component 注解，而应该使用它的扩展，如，@Service，@Repository …，它们的功能虽然一样，但后者职能更清晰，利于维护。</li>
</ol>
<p>使用特点：</p>
<p>Spring 提供 @Component 注解两种使用方式，</p>
<ul>
<li>@Component<blockquote>
<p>没有传参数时，Bean 名称默认为当前类的类名，首字母小写。<br>@Component(value&#x3D;”xxx”) &#x2F; @Component(“xxx)<br>使用参数时，xxx 作为 Bean 名称</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(SLi): 添加测试说明代码</span></span><br></pre></td></tr></table></figure>

<h5 id="Service-注解"><a href="#Service-注解" class="headerlink" title="@Service 注解"></a>@Service 注解</h5><ol>
<li>@Service 是 @Component 注解的一个特例，作用在类上</li>
<li>默认作用域为 singleton</li>
<li>使用注解配置和类路径扫描时，被 <code>@Service</code> 注解标注的类，会被 Spring 扫票并注册为 Bean 。</li>
<li>@Service 用于标注业务层组件，表示定义一个 Bean 。</li>
<li>@Service 使用时没有传参数时，Bean 名称默认为当前类的名称，首字母小写。</li>
<li>@Service(“xxx”) 或 @Service(“xxx”) 使用时传参数，使用 xxx 作为 Bean 名称</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(SLi): 添加测试说明代码</span></span><br></pre></td></tr></table></figure>

<h5 id="Scope-注解"><a href="#Scope-注解" class="headerlink" title="@Scope 注解"></a>@Scope 注解</h5><ol>
<li>@Scope 注解作用在类上和方法上；</li>
<li>@Scope 注解用来配置 Spring Bean 的作用域默认为单例模式）；</li>
<li>@Scope 与 其他<code>类@Component 注解</code>(例如，@Component，@Service，@Repository，@Controller )组合使用可以修改 Bean 的作用域；</li>
</ol>
<p>@Scope 有 5 种取值：</p>
<p>基本作用域：</p>
<ol>
<li><p>“singleton” 单例模式，Spring 容器中有且只有一个 Bean 实例，只要 Spring 容器不销毁或退出，该 Bean 实例初始化后就会一直存活。所有调用处的对象地址都一样。</p>
<blockquote>
<p>singleton 模式 每次得到的 Bean 对象相同，单例</p>
<p>prototype 模式，每次得到的 Bean 对象是不同的。</p>
</blockquote>
</li>
<li><p>“prototype” 原型模式， 每次获取 Bean 的时候，就会创建一个新的实例，实例创建后，Spring 可以对其初始化，但不负责销毁，即不对该模式下的 Bean 实例的整个生命周期负责。</p>
</li>
</ol>
<p>Web 作用域，下面三个只适用于 Web 程序：</p>
<ol start="3">
<li>“request” request 模式，每次 HTTP 请求都会产生一个新的 Bean，同时该 Bean 仅在当前 HTTP request 内有效，当请求结束后，该对象的生命周期即结束。</li>
<li>“session” session 模式，也是 每次 HTTP 请求都会产生一个新的 Bean，同时该 Bean 仅在当前 HTTP session 内有效。</li>
<li>“application” application 模式，全局作用域。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(SLi): 添加测试说明代码</span></span><br><span class="line"><span class="meta">@Service</span> 与 <span class="meta">@Scope</span> 一起使用，测试两种基本作用域的使用，通过比较两种作用域生成的对象的地址来对比效果的不同。</span><br></pre></td></tr></table></figure>

<h5 id="Repository-注解"><a href="#Repository-注解" class="headerlink" title="@Repository 注解"></a>@Repository 注解</h5><ol>
<li>@Repository 注解作用在类上</li>
<li>作用域默认是 singleton</li>
<li>使用注解配置和类路径扫描时，被 @Repository 注解标注的类会被 Spring 扫描并注解为 Bean；</li>
<li>@Repository 注解用于标注数据访问层（组件），即 DAO 组件；</li>
<li>@Repository 注解的作用不只是将类注册为 Bean ，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(SLi): 添加测试说明代码</span></span><br></pre></td></tr></table></figure>

<h5 id="Controller-注解"><a href="#Controller-注解" class="headerlink" title="@Controller 注解"></a>@Controller 注解</h5><ol>
<li>作用在类上</li>
<li>使用注解配置和类路径扫描时，被 @Controller 注解标注的类会被 Spring 扫描并注册为 Bean ；</li>
<li>@Controller 用于标注 Web 中控制层组件；</li>
<li>被 @Controller 注解标注的类，负责处理由 DispatcherServlet 分发的请求，它把用户请求的数据经过业务层处理之后封装为一个 Model，然后再把该 Model 返回给对应的 View 进行展示。</li>
<li>@Controller 和 @RequestMapping、@RequestParam 等一些注解共同处理 URL 的映射。</li>
</ol>
<h5 id="RestController-注解"><a href="#RestController-注解" class="headerlink" title="@RestController 注解"></a>@RestController 注解</h5><ol>
<li>是一个组合注解，@RestController&#x3D;@Controller + @ResponseBody</li>
<li>@RestController 注解注解将返回的对象输出到客户端；</li>
<li>如果返回字符串，直接返回</li>
<li>如果返回的不是字符串，默认使用 Jackson 将对象序列化成 JSON 字符串后输出。</li>
</ol>
<p>@Controller 和 @RestController 的详细内容参考 <a href=""></a></p>
<h4 id="与-Bean-相关的内容"><a href="#与-Bean-相关的内容" class="headerlink" title="与 @Bean 相关的内容"></a>与 @Bean 相关的内容</h4><p>Spring Boot 同样推荐使用 Java 配置完全代替 XML 配置，Java 配置是通过 <code>@Configuration</code> 和 <code>@Bean</code> 注解实现的。</p>
<ul>
<li>@Configuration 注解声明当前<strong>类</strong>是一个配置类，相当于 Spring 中的一个 XML 文件 <beans>;</li>
<li>@Bean 注解作用在<strong>方法</strong>上，声明当前<code>方法的返回值</code>是一个 Bean ，相当于 Spring XML 文件中的 <bean>;</li>
</ul>
<h5 id="Bean-注解"><a href="#Bean-注解" class="headerlink" title="@Bean 注解"></a>@Bean 注解</h5><ol>
<li>作用在方法上；</li>
<li>表示方法的返回值是一个 Spring 容器管理的 Bean ；</li>
<li>@Bean 注解一般和 @Component 或者 @Configuration 一起使用</li>
<li>@Bean 注解默认作用域为单例 singleton, 同样可以通过 @Scope(“prototype”) 设置为原型模式作用域</li>
</ol>
<p><strong>Bean 名称</strong></p>
<ul>
<li>@Bean 注解标注的方法的 Bean 名称，<strong>默认为方法名</strong>，首字母小写；</li>
<li>@Bean 注解可以使用 value 属性或者别名 name 重新定义 Bean 名称；</li>
<li>@Bean 注解接受一个 String 数组，允许为一个 Bean 配置多个名称（包含一个主名称和一个或多个别名）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">demo</span><span class="params">(CustomerRepository repository)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> args -&gt; &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;custRepository&quot;)</span> <span class="comment">// 此时 Bean 的名字为 custRepository，而不是默认的 demo</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">demo</span><span class="params">(CustomerRepository repository)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> args -&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 context 中所有的 Bean 名称可以知道，上面代码的 Bean 名称分别为 demo, custRepository</span></span><br><span class="line">Iterator&lt;String&gt; iterator = context.getBeanFactory().getBeanNamesIterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Bean 与其他注解一起使用</strong></p>
<ul>
<li>@Profile 注解为在不同环境下使用不同的配置提供了支持，如开发环境和生产环境的数据库配置用不同的；</li>
<li>@Scope 注解将 Bean 的作用域从单例模式改变为指定的作用域；</li>
<li>@Lazy 注解只有在默认单例作用域的 情况下才有效；</li>
<li>@DependsOn 注解表示在当前 Bean 实例化之前需要先实例化依赖的其他 Bean；</li>
<li>@Primary 注解，如果需要注入单个目标组件但多个 bean 按类型匹配，@Primary 是一种在注入点级别解决歧义的机制。（这样相当于当没有指定Bean名称，且存在多个相同类型的 bean 时，默认取被 @Primary 标注的 bean）</li>
</ul>
<p><strong>Bean 的初始化和销毁</strong><br>在实际开发中，经常会遇到在 Bean 使用之前或使用之后需要做一些必要的操作，Spring 对 Bean 的生命周期的操作提供了支持。</p>
<ul>
<li>Java 配置方式： 使用 Bean 的 <code>initMethod</code> 和 <code>destrodMethod</code></li>
<li>注解方法： 利用 JSR-250 的 <code>@ConstConstruct</code> 和 <code>@PreDestroy</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(SLi): 添加测试说明代码</span></span><br><span class="line">  <span class="comment">// 定义该 Bean 的名称为 yourBean，同时调用初始化方法 init()，</span></span><br><span class="line">  <span class="meta">@Bean(value = &quot;yourBean&quot;, initMethod = &quot;init&quot;)</span></span><br><span class="line">  <span class="comment">// 依赖一个名称为 myBean 的 Bean</span></span><br><span class="line">  <span class="meta">@DependsOn(&quot;myBean&quot;)</span></span><br><span class="line">  <span class="meta">@Lazy</span></span><br><span class="line">  <span class="keyword">public</span> MyBean <span class="title function_">myBean2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(<span class="string">&quot;yourBean&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>proxyBeanMethods这个参数简单来说就是<br>当在 @Configuration 类中使用 @Bean 注解时</p>
<ol>
<li><p>proxyBeanMethods&#x3D;true，<br>@Bean Methods in @Configuration Classes</p>
<ul>
<li>默认支持AOP拦截，进行方法增强，</li>
<li>同时支持 “inter-bean references”(bean 间引用)，即同一个 @Configuration 类中的 @Bean 方法可以不通过 @Autowired等方法注入，像普通java方法那样直接调用，但同时能确保调用的Bean是增强后的（应该不同 @Configuration 间的 Bean也能直接调用，这个需要测试）</li>
</ul>
</li>
<li><p>proxyBeanMethods&#x3D;false<br>@Bean Lite Mode</p>
<ul>
<li>不支持 “inter-bean references”(bean 间引用)</li>
<li>此时</li>
</ul>
</li>
</ol>
<p>当在例如 @Component 这些其他 Bean 注解标注的类中使用 @Bean 注解时<br>是true 或者 false ，没有影响。在这些类中使用 @Bean 时，本身就不支持 “inter-bean references”(bean 间引用) ，即需要通过 @Autowired 等注解来注入 Bean ，而不能直接调用 @Bean 标注的方法。</p>
<p>@Bean Lite Mode 的翻译：<br><a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/context/annotation/Bean.html">https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/context/annotation/Bean.html</a></p>
<p>@Bean 方法也可以在没有用 @Configuration 注释的类中声明。例如，bean 方法可以在 @Component 类中声明，甚至可以在普通的旧类中声明。在这种情况下，@Bean 方法将以所谓的“精简”模式进行处理。</p>
<p>精简模式下的 Bean 方法将被容器视为普通工厂方法（类似于 XML 中的工厂方法声明），并正确应用范围和生命周期回调。在这种情况下，包含类保持不变，并且包含类或工厂方法没有异常约束。</p>
<p>与@Configuration 类中 bean 方法的语义相反，精简模式不支持“bean 间引用”。相反，当一个@Bean-method 在精简模式下调用另一个 @Bean-method 时，该调用是标准的 Java 方法调用；Spring 不会通过 CGLIB 代理拦截调用。这类似于 @Transactional 间的方法调用，在代理模式下，Spring 不会拦截调用——Spring 只在 AspectJ 模式下这样做。</p>
<h5 id="关于-Component-和-Bean-一些总结性的内容："><a href="#关于-Component-和-Bean-一些总结性的内容：" class="headerlink" title="关于 @Component 和 @Bean 一些总结性的内容："></a>关于 <code>@Component</code> 和 <code>@Bean</code> 一些总结性的内容：</h5><p>关于 <code>@Component</code> 和 <code>@Bean</code> 一些总结性的内容：</p>
<ol>
<li>@Component 作用对象是类(class)，这个是 <code>a type-level annotation</code> 类级别的注解；@Bean 作用对象是方法（method），是<code>a method-level annotation</code> 方法级别的注解；</li>
<li>Bean 的类型，从这个角度看，@Component 标注的类，即为Bean的类型，xxx.class；@Bean 标注的方法的返回值为 Bean 的类型；</li>
<li>Bean 的名称，@Component 默认不用参数时，@Component 标注的<strong>类名首字母小写</strong>即为 Bean 的名称；@Component 使用参数时，@Component(“xxx”) 或 @Component(value&#x3D;”xxx”) 效果一样，此时，xxx 即为 Bean 的名称；</li>
<li>Bean 的名称，@Bean 默认不用参数时，@Bean 标注的方法的<strong>方法名</strong>即为 Bean 的名称；@Bean 使用参数时，@Bean(“xxx”) 或 @Bean(value&#x3D;”xxx”) 效果一样，此时，xxx即为 Bean 的名称；同时，@Bean 还支持指定多个名字，@Bean({“xxx1”,”xxx2”,…})；</li>
<li>注册到 Spring 容器中的方式不同；<ul>
<li><code>@Component</code> 通常是通过路径扫描(用<code>@ComponentScan</code>注解定义要扫描的路径，从中找出标识了需要装配的类，并自动装配到 Spring 的 Bean 容器中)来自动侦测已经自动装配到 Spring 容器中；</li>
<li><code>@Bean</code> 注解通常是在需要定义产生一个Bean 的方法上标注该注解，@Bean 告诉 Spring 这是某个类的实例，当我们需要使用它的时候还给我。</li>
</ul>
</li>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强。当某些场景 <code>@Component</code> 注解无法定义我们需要的 Bean 时，我们就只能通过 <code>@Bean</code> 注解来实现，例如，当我们引用第三方库中的类装配到 Spring 中时，只能通过 <code>@Bean</code>来实现；</li>
</ol>
<h5 id="Configuration-注解"><a href="#Configuration-注解" class="headerlink" title="@Configuration 注解"></a>@Configuration 注解</h5><p>以下内容主要参考<br><a href="https://blog.csdn.net/lipinganq/article/details/79303309">Spring Boot常用注解（三） - 实现Java配置的注解</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/context/annotation/Configuration.html?is-external=true">Annotation Type Configuration</a></p>
<p>Spring 提供的 @Configuration 注解，可以用来配置多个 Bean ，</p>
<p>@Configuration 与 @Bean 两个注解的关系，就像 XML 中 <beans> 与 <bean> 的关系</p>
<ol>
<li>@Configuration 注解作用在类、接口（包含注解）上；</li>
<li>用于定义配置类，可替换 XML 配置文件；</li>
<li>@Configuration 注解标注的类中可以声明一个或多个 @Bean 方法；</li>
<li>@Configuration 注解标注的类<code>不能是 final</code> 类型；（意味着能被继承extends，可以有子类）</li>
<li>嵌套的（nested） @Configuration 类必须是 <code>static</code> 的；<ul>
<li>因为是嵌套类，所以 嵌套的被 @Configuration 标注的类中被 @Bean 标注的方法，会被<strong>自动注册</strong>（will be registered automatically）为 Bean。</li>
</ul>
</li>
<li>可以单独使用，也可以结合 Enviroment 这个 Bean APi，@PropertySource,@Value,@Profile 等注解一起使用；<ul>
<li>如果与 @Lazy 注解结合使用，表明这个类中所有被 @Bean 标记的方法都将延迟实例化</li>
<li>同时，@Lazy 可以与每个 @Bean 标注的方法单独结合使用。</li>
<li>与 <code>@Profile</code> 结合使用，用于不同的环境中， 当然 @Bean 也可以单独与 @Profile 结合使用</li>
</ul>
</li>
<li>@Configuration 注解从源码上看也是 <code>@Component</code> 注解的别名，所以配置组件扫描（@ComponentScan）时也能被扫到。</li>
<li>@Configuration 注解标注的类也可以利用 <code>@ComponentScan</code> 配置自己的组件扫描；</li>
<li>也可以像任何常规 @Component 一样利用 @Autowired</li>
</ol>
<p>下面这句话，是 @Configuration 注解 API 中的内容，表明了 Bean 是何时被实例化(或者初始化)的，<code>be eagerly instantiated at container bootstrap time</code> 在IoC 容器启动时就实例化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">By default, @Bean methods will be eagerly instantiated at container bootstrap time. To avoid this, @Configuration may be used in conjunction with the @Lazy annotation to indicate that all @Bean methods declared within the class are by default lazily initialized. Note that @Lazy may be used on individual @Bean methods as well. </span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(SLi): 添加测试说明代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="comment">// define a class</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfigration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 Bean 的名称为 方法名 myBean，类型是 MyBean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// instantiate, configure and return bean ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是在说 第5点，嵌套类必须为 static</span></span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Autowired</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(dataSource);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Configuration</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;</span><br><span class="line">         <span class="meta">@Bean</span></span><br><span class="line">         DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>().build();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 @ComponentScan 配置自己的组件扫描   问题，当什么情况会配置多个组件扫描？</span></span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@ComponentScan(&quot;com.acme.app.services&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">     <span class="comment">// various @Bean definitions ...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>@Configuration + @Bean + Environment</p>
<p>通过使用@Autowired}注释将org.springframework.core.env.Environment注入 @Configuration类，可以查找外部值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring 内置的包含所有配置属性的 Bean </span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;myEnvBean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">        myBean.setPort(environment.getProperty(<span class="string">&quot;server.port&quot;</span>, <span class="string">&quot;8080&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> myBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Configuration + @Bean + Environment + @PropertySource</p>
<p>@PropertySource 注解可以读取自定义的 properties 配置文件，自定义的 properties 文件放在 <code>src/main/resources</code> 文件路径下 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:properties/app.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPropertySourceConfigration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;myPSBean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(environment.getProperty(<span class="string">&quot;jdbc.username&quot;</span>, <span class="string">&quot;请设置用户名&quot;</span>), environment.getProperty(<span class="string">&quot;jdbc.password&quot;</span>, <span class="string">&quot;请设置密码&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> myBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>也可以结合 @Value 获取 Environment 中的属性值。样例略</p>
<h6 id="TODO-proxyBeanMethods"><a href="#TODO-proxyBeanMethods" class="headerlink" title="TODO proxyBeanMethods"></a>TODO proxyBeanMethods</h6><p>这个在 Spring 5.2加入的新参数什么意思？后面再研究一下<br>内容参考 <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/context/annotation/Configuration.html?is-external=true">官方 API</a></p>
<p>public abstract boolean proxyBeanMethods</p>
<p>Specify whether @Bean methods should get proxied in order to enforce bean lifecycle behavior, e.g. to return shared singleton bean instances even in case of direct @Bean method calls in user code. This feature requires method interception, implemented through a runtime-generated CGLIB subclass which comes with limitations such as the configuration class and its methods not being allowed to declare final.</p>
<p>The default is true, allowing for ‘inter-bean references’ via direct method calls within the configuration class as well as for external calls to this configuration’s @Bean methods, e.g. from another configuration class. If this is not needed since each of this particular configuration’s @Bean methods is self-contained and designed as a plain factory method for container use, switch this flag to false in order to avoid CGLIB subclass processing.</p>
<p>Turning off bean method interception effectively processes @Bean methods individually like when declared on non-@Configuration classes, a.k.a. “@Bean Lite Mode” (see @Bean’s javadoc). It is therefore behaviorally equivalent to removing the @Configuration stereotype.</p>
<p>问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication</span><br><span class="line">        .run(ComponentApplication.class, args);</span><br><span class="line">    ... <span class="comment">// others</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = context.getBeanFactory().getBeanNamesIterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码扫描获取的 Bean ，为什么包含主类本身？@SpringBootApplication &#x3D; @Configuration + @EnableAutoConfiguration + @ComponentScan ，但是类中并没有哪里标注 <code>ComponentApplication</code> 这个类，为什么会扫描到？</p>
<p>componentApplication</p>
<p>根包目录下的另一个 Application 中的方法为什么也会一起执行？能扫描到我能理解，但是不理解被 @Bean 标注的方法为什么会执行？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">demo</span><span class="params">(CustomerRepository repository)</span> &#123;</span><br></pre></td></tr></table></figure>


<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h3><p>下面内容主要参考 <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/context/annotation/ComponentScan.html">Annotation Type ComponentScan</a></p>
<p>用于配置 @Configuration 类的组件扫描指令。一般会在主配置类上配置。</p>
<p>可以指定 basePackageClasses() 或 basePackages()（或其别名 value()）来定义要扫描的特定包。</p>
<p>如果没有定义特定的包，将从声明该注解的类所在包开始扫描。</p>
<p>只有能被@ComponentScan扫描的包及包下的被 @Component 或其扩展注解 标记的类才能识别为 Bean 。</p>
<p>使用:</p>
<p>@ComponentScan(“包”)    指定哪个包，就扫描哪个包下的注解并识别。</p>
<h4 id="属性-value"><a href="#属性-value" class="headerlink" title="属性 value"></a>属性 value</h4><p>是 basePackages 的别名</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;org.my.pkg&quot;)</span> instead of <span class="meta">@ComponentScan(basePackages = &quot;org.my.pkg&quot;)</span></span><br></pre></td></tr></table></figure>



<h4 id="属性-basePackageClasses"><a href="#属性-basePackageClasses" class="headerlink" title="属性 basePackageClasses"></a>属性 basePackageClasses</h4><p>basePackages() 的类型安全（type-safe）替代方案，用于指定要扫描带注解组件的包。</p>
<p>将扫描指定的每个类的包。</p>
<blockquote>
<p>The package of each class specified will be scanned.</p>
</blockquote>
<p>define 定义</p>
<p>declare 声明</p>
<p>declarations </p>
<h2 id="Bean-的注入-（DI-的体现）"><a href="#Bean-的注入-（DI-的体现）" class="headerlink" title="Bean 的注入 （DI 的体现）"></a>Bean 的注入 （DI 的体现）</h2><p>除 XML 注入外，使用注解的注入方式有</p>
<ol>
<li>字段注入</li>
<li>set 方法注入</li>
<li>构造函数注入<br>上面的三种注入方式效果一样，无需同时存在</li>
</ol>
<p>可以使用下面的注解：</p>
<ul>
<li>@Autowired</li>
<li>@Resource</li>
</ul>
<p>相同点：</p>
<ol>
<li>@Resource 和 @Autowired 都是做 bean 的注入时使用</li>
<li>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter 方法。</li>
</ol>
<p>不同点，详见后面介绍。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>下面内容主要参考 <a href="https://blog.csdn.net/lipinganq/article/details/79167982">Spring Boot常用注解（二） - 注入Bean的注解</a></p>
<p><a href="https://blog.csdn.net/qq_38861828/article/details/100598469">spring框架-bean的装配与注入</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">Annotation Type Autowired</a></p>
<ol start="0">
<li><p>这是 JSR-330 @Inject 注解的替代方法；</p>
</li>
<li><p>@Autowired 注解是按照类型（byType）注入依赖对象</p>
</li>
<li><p>@Autowired 注解作用在构造函数，方法，方法参数，类字段以及注解上</p>
<blockquote>
<p>@Target(value&#x3D;{CONSTRUCTOR,METHOD,PARAMETER,FIELD,ANNOTATION_TYPE})</p>
</blockquote>
</li>
<li><p>默认情况下，它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。</p>
</li>
<li><p>如果想要使用按照名称（byName）来注入，可以结合 @Qualifier 注解一起使用。</p>
</li>
</ol>
<p>样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IService</span> &#123;</span><br><span class="line">  <span class="comment">// 下面这两种 @Autowired 只要使用一种即可</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserDaoImpl userDao;  <span class="comment">// 用于字段上</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDaoImpl userDao)</span> &#123;  <span class="comment">// 用于属性的 set 方法上</span></span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>@Autowired 注解原理</p>
<p>在Spring Boot 应用启动时，Spring 容器会自动装载一个 org.springframework.beans.factory.annonation.AutowiredAnnotationBeanPostProcessor 处理器，当容器扫描器扫描到 <code>@Autowired</code> 注解时，就会在 IoC 容器就会找到相应类型的 Bean，并实现注入。</p>
<p><strong>总结：</strong><br>在使用@Autowired注解时，首先在容器中查询对应类型的bean</p>
<ol>
<li>如果查询结果Bean刚好为一个，自动注入</li>
<li>如果查询结果Bean不止一个，通过 <code>@Qualifier</code> 注解按照名称指定自动注入的Bean</li>
<li>如果没有查询到对应类型的Bean，由于默认@Autowired(required&#x3D;true)，会抛出常，解决方法是使用@Autoiwired(quired&#x3D;false)</li>
<li>@Autowired(quired&#x3D;true)意味着依赖是必须的</li>
<li>@Autowired(quired&#x3D;false)等于告诉 Spring：在找不到匹配 Bean 时也不报错</li>
</ol>
<h5 id="Autowired-用在构造函数上"><a href="#Autowired-用在构造函数上" class="headerlink" title="@Autowired 用在构造函数上"></a>@Autowired 用在构造函数上</h5><ol>
<li>一般情况，任何给定的 bean 类只有一个构造函数可以声明这个注解，并将 required() 属性设置为 true，构造函数在用作 Spring bean 时会自动装配。</li>
</ol>
<blockquote>
<p> the constructor to autowire when used as a Spring bean.</p>
</blockquote>
<ol start="2">
<li><p>此外，如果 required 属性设置为 true，则只能使用 @Autowired 注释单个构造函数。</p>
</li>
<li><p>如果注解标注了多个非必需的构造函数，则这些构造函数将被视为自动装配的候选者。将选择通过匹配 Spring 容器中的 bean 可以满足的依赖项数量最多的构造函数。如果没有一个候选可以满足，那么将使用主&#x2F;默认构造函数（如果存在）。</p>
</li>
<li><p>类似地，如果一个类声明了多个构造函数，但没有一个用 @Autowired 标注，则将使用主&#x2F;默认构造函数（如果存在）。</p>
</li>
<li><p>如果一个类只声明一个构造函数，那么它的 @Autowired 注解可以省略。</p>
</li>
<li><p>带注解的构造函数不必是 public 的。</p>
</li>
</ol>
<h5 id="用在字段上"><a href="#用在字段上" class="headerlink" title="用在字段上"></a>用在字段上</h5><ol>
<li>标注 @Autowired 注解的字段不必是 public 的；</li>
</ol>
<h5 id="Autowired-用在-method-上"><a href="#Autowired-用在-method-上" class="headerlink" title="@Autowired 用在 method 上"></a>@Autowired 用在 method 上</h5><ol>
<li><p>配置方法（methods）可以有任意名称和任意数量的参数；</p>
</li>
<li><p>每个参数都将被 Spring container（容器）中匹配的 bean 自动装配。 </p>
<blockquote>
<p>each of those arguments will be autowired with a matching bean in the Spring container.</p>
</blockquote>
</li>
<li><p>Bean 属性 setter 方法（setter methods）实际上只是这种通用配置方法的一个特例。</p>
</li>
<li><p>这样的配置方法不必是 public 的。</p>
</li>
</ol>
<h5 id="Autowired-Parameters"><a href="#Autowired-Parameters" class="headerlink" title="Autowired Parameters"></a>Autowired Parameters</h5><p>主要用在单元测试中<br>the JUnit Jupiter support in the spring-test module (see the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-junit-jupiter-di">TestContext framework</a> reference documentation for details). </p>
<h5 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h5><p>下面两部分后面需要再研究，主要涉及 在Arrays,Collection 和 Maps 中的注入，还有不支持的部分。</p>
<ol>
<li>Autowiring Arrays, Collections, and Maps</li>
</ol>
<p>In case of an array, Collection, or Map dependency type, the container autowires all beans matching the declared value type. For such purposes, the map keys must be declared as type String which will be resolved to the corresponding bean names. Such a container-provided collection will be ordered, taking into account Ordered and @Order values of the target components, otherwise following their registration order in the container. Alternatively, a single matching target bean may also be a generally typed Collection or Map itself, getting injected as such.</p>
<ol start="2">
<li>Not supported in BeanPostProcessor or BeanFactoryPostProcessor</li>
</ol>
<p>Note that actual injection is performed through a BeanPostProcessor which in turn means that you cannot use @Autowired to inject references into BeanPostProcessor or BeanFactoryPostProcessor types. Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor class (which, by default, checks for the presence of this annotation).</p>
<h4 id="1-Qualifier-注解"><a href="#1-Qualifier-注解" class="headerlink" title="1. @Qualifier 注解"></a>1. @Qualifier 注解</h4><p>@Autowired + @Qualifier &#x3D; @Resource</p>
<p>解释：</p>
<ol>
<li>Spring 容器中如果有多个相同类型的 Bean，这时如果直接通过 @Autowired 注解标注获取该类型 Bean，就会报错，这时需要结合 @Qualifier 注解来限定，即指定需要自动装配的 Bean 名称。</li>
</ol>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><ol>
<li>@Resource 注解可以指定 name 和 type，默认按照名称（byName）自动注入，由J2EE 提供，需要导入包 <code>javax.annonation.Resource</code>。</li>
<li>有两个属性，所以，<ul>
<li>如果使用 name 属性，那么就是按照 Bean 的名称注入，</li>
<li>如果使用 type 属性，就是按照 Bean 的类型注入 （此时就与 @Autowired 一样）</li>
</ul>
</li>
</ol>
<hr>
<p>&#x2F;&#x2F; IService 的实现类 UserServiceImpl 缺少 @Service 注解，所以启动 Spring Boot 的时候会报错<br>Field userService in com.example.accessingdatajpa.controller.AutowiredController required a bean of type ‘com.example.accessingdatajpa.service.IService’ that could not be found.</p>
<p>The injection point has the following annotations:<br>    - @org.springframework.beans.factory.annotation.Autowired(required&#x3D;true)</p>
<p>&#x2F;&#x2F; IDao 的实现类有两个，在 Service 实现类中 @Autowired 标注的 IDao 无法获得唯一的 Bean ，从提示中可以得知，使用 @Qualifier 来限定<br>Description:</p>
<p>Field userDao in com.example.accessingdatajpa.service.UserServiceImpl required a single bean, but 2 were found:<br>    - adminDaoImpl: defined in file [C:\Tableware\codes\spring-study-test\accessing-data-jpa\target\classes\com\example\accessingdatajpa\dao\AdminDaoImpl.class]<br>    - userDaoImpl: defined in file [C:\Tableware\codes\spring-study-test\accessing-data-jpa\target\classes\com\example\accessingdatajpa\dao\UserDaoImpl.class]</p>
<p>Action:</p>
<p>Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>学习过程中额外知识点记录</title>
    <url>//%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="额外知识点记录"><a href="#额外知识点记录" class="headerlink" title="额外知识点记录"></a>额外知识点记录</h1><ol>
<li><p>spring-boot-cli-2.5.3-bin.zip<br>第3章节中，spring-boot-cli 中提供的 spring 脚本，关于获取相关参数，设置环境变量的方式很好，之后学习一下，记录并应用到我的程序中。</p>
</li>
<li><p>在 <code>start.spring.io</code> 中创建的新项目，会自带一个 mvnw ，看一下。</p>
</li>
<li><p>maven 的 <code>&lt;dependencyManagement&gt;</code> 需要看一下，什么时候需要使用它，即其作用。</p>
</li>
<li><p>maven 查看 依赖 <code>mvn dependency:tree</code></p>
</li>
</ol>
<h2 id="Executable-jars-and-Java"><a href="#Executable-jars-and-Java" class="headerlink" title="Executable jars and Java"></a>Executable jars and Java</h2><ol start="5">
<li>Executable jars (sometimes called “fat jars”) <blockquote>
<p>are archives containing your compiled classes along with all of the jar dependencies that your code needs to run.<br>是包含你的编译类以及你的代码运行所需的所有jar依赖项的存档。</p>
</blockquote>
</li>
</ol>
<p>Java 没有提供加载嵌套 jar 文件(jar 中本身包含的 jar 文件)的标准方法。所以目前一般由两种处理方式</p>
<ul>
<li>uber jar ， 普通 java 程序打包处理方式</li>
<li>sprint boot 的 executable jars</li>
</ul>
<ol start="6">
<li><p>许多开发者使用 “uber” jar。uber jar将所有应用程序依赖的所有类打包成一个单一的存档。</p>
<blockquote>
<p>缺点：<br>这种方法的问题在于，很难查看应用程序中包含哪些库。如果在多个jar中使用相同的文件名（但内容不同），也会产生问题。</p>
</blockquote>
</li>
<li><p>Spring Boot 采用了不同于 “uber” jar 的方式，创建 executable jars。可以实际上直接将 jar 嵌套在一个jar文件中。</p>
</li>
</ol>
<p>Maven 打包</p>
<p>在 Spring Boot 的 测试样例中，打包一个 可执行 jar，需要添加下面的内容，但是由于 <code>spring-boot-starter-parent</code> POM 中包含了 <executions> 配置已绑定了repackage目标，所以这里不需要了，但是如果没哟依赖 <code>spring-boot-starter-parent</code> 则需要自己添加 <executions> 配置<br>  <build><br>    <plugins><br>      <plugin><br>        <groupId>org.springframework.boot</groupId><br>        <artifactId>spring-boot-maven-plugin</artifactId><br>      </plugin><br>    </plugins><br>  </build></p>
<p>没有依赖 <code>spring-boot-starter-parent</code> 时需要 下面的内容，即添加 <execution> 这部分内容<br>    <plugin><br>      <groupId>org.springframework.boot</groupId><br>      <artifactId>spring-boot-maven-plugin</artifactId><br>      <version>2.1.1.RELEASE</version><br>      <executions><br>        <execution><br>          <goals><br>            <goal>repackage</goal><br>          </goals><br>        </execution><br>      </executions><br>    </plugin></p>
<ol start="8">
<li><p>我们建议您遵循 Java 建议的<code>包命名约定</code>，并使用反向域名（例如，com.example.project）</p>
<ul>
<li>package</li>
</ul>
</li>
<li><p>标准的 <code>$&#123;name&#125;</code> 属性占位符语法</p>
</li>
<li><p>Spring Boot 特性章节中，外化配置<br>问题： </p>
</li>
<li><p>lower order property sources , 这里的 lower order 是在哪里定义的？</p>
</li>
<li><p>The list is ordered by precedence (with values from lower items overriding earlier ones). 列表按优先级排序（较低项目的值覆盖较早项目的值）</p>
<ul>
<li>这里也是，这个 lower items 是怎么定义的？ a,b,c 这三个值，a低？还是c低？ 这是国外固有的顺序？还是哪里定义的顺序？</li>
<li>从上下文来看，a&gt;b&gt;c,但是还是对官方文档中使用 lower 这个词有疑惑。</li>
</ul>
</li>
</ol>
<p>问题：<br>加载的文件被作为 PropertySources 添加到Spring的 Environment 中。</p>
<p>@PropertySource 注解 与 properties 配置文件 和 PropertySource 三者之间的关系？</p>
<ol start="11">
<li><p>joda-time  看到好多项目都在用这个 jar ，查一下它的作用和优点。</p>
</li>
<li><p>目前来说，json 转换 的 jar，推荐使用 jackson 的，更稳定，alibaba 的 fastjson 不能用，bug 太多。</p>
</li>
<li><p>antlr 是个很有意思的工具，美团关于 hiveql 解析成 MapReduce 任务的文章中有提到。spark 等也有使用。</p>
</li>
<li><p>这意味着诸如 <code>&quot;GET /projects/spring-boot.json&quot;</code> 之类的请求将不会与 <code>@GetMapping(&quot;/projects/spring-boot&quot;)</code> 映射相匹配。</p>
</li>
</ol>
<ul>
<li>为什么？不用后缀模式匹配不是反而能匹配到吗？</li>
</ul>
<ol start="15">
<li><p>API中endpoints是什么意思？</p>
</li>
<li><p>Spring 的命名特点，作为源，命名方式为 xxxSource 。<br>例如：</p>
</li>
</ol>
<ul>
<li>DataSource</li>
<li>PropertySource</li>
<li></li>
</ul>
<ol start="17">
<li>为什么 Tomcat，Jboss等这些称为 服务器？<br>硬件层面上，<br>软件层面上，</li>
</ol>
<p>我们用Java开发的Web应用只是一个半成品，类似于一个插件，而服务器则像一个收发器<br>我们开发的Web 程序，不需要考虑如何接收HTTP请求和响应HTTP请求<br>软件层面的服务器，帮我们接收和响应 HTTP 请求</p>
<ol start="18">
<li><p>spring 中是如何做到集成 tomcat 和我们的 web 代码的？我们写 spring 应用时，入口是有 main方法的，tomcat 自身启动也有main方法，他们怎么处理到一起的？</p>
</li>
<li><p><strong>@Autowired</strong> 进行构造函数注入，标记你希望 Spring 使用的哪个构造函数。（没用@Autowired 标注的构造函数怎么用？通过 new 实例的方式？还是有其他方式调用？）</p>
</li>
</ol>
<p>为什么要用？什么时候用？怎么用？实际生产过程中怎么组合使用？</p>
<p>用作 Spring Bean 时自动装配 ？ 自动装配是什么意思？自动创建实例？new ？</p>
<p>JPA 中 没有 @Table 的注解，所以 @Entity 实体，就代表着这是一张表，会映射到 同名的表中</p>
<p>demo() 方法返回一个 CommandLineRunner bean，该 bean 在应用程序启动时自动运行代码。</p>
<p>@Configuration可理解为用spring的时候xml里面的<beans>标签</p>
<p>@Bean可理解为用spring的时候xml里面的<bean>标签</p>
<hr>
<p>将构造函数、字段、setter 方法或配置方法标记为由 Spring 的依赖注入工具自动装配。</p>
<p>这是 JSR-330 Inject 注释的替代方法，添加了 required-vs-optional 语义。 </p>
<p>Autowired Constructors<br>任何给定的 bean 类只有一个构造函数可以声明这个 annotation，并将 required() 属性设置为 true，指示构造函数在用作 Spring bean 时自动装配。</p>
<p>此外，如果 required 属性设置为 true，则只能使用 @Autowired 注释单个构造函数。</p>
<p>如果多个非必需构造函数声明了注解，它们将被视为自动装配的候选者。</p>
<p>将选择通过匹配 Spring 容器中的 bean 可以满足的依赖项数量最多的构造函数。</p>
<p>如果没有一个候选可以满足，那么将使用主&#x2F;默认构造函数（如果存在）。</p>
<p>类似地，如果一个类声明了多个构造函数，但没有一个用 @Autowired 注释，则将使用主&#x2F;默认构造函数（如果存在）。</p>
<p>如果一个类只声明一个构造函数开始，它将始终被使用，即使没有注释。</p>
<p>带注释的构造函数不必是公共的。 </p>
<p>Autowired Fields<br>字段在构建 bean 之后立即注入，在调用任何配置方法之前。<br>这样的配置字段不必是公开的。 </p>
<blockquote>
<p>(问题：什么是配置方法config methods?)</p>
</blockquote>
<p>Autowired Methods<br>配置方法可以有任意名称和任意数量的参数；</p>
<p>这些参数中的每一个都将使用 Spring 容器中的匹配 bean 自动装配。 </p>
<p>Bean 属性 setter 方法实际上只是这种通用配置方法的一个特例。</p>
<p>这样的配置方法不必是公开的。</p>
<p>Autowired Parameters<br>尽管从 Spring Framework 5.0 开始，@Autowired 可以在技术上在单个方法或构造函数参数上声明，但框架的大多数部分都忽略了此类声明。</p>
<p>核心 Spring Framework 中唯一主动支持自动装配参数的部分是 spring-test 模块中的 JUnit Jupiter 支持（有关详细信息，请参阅 TestContext 框架参考文档）。</p>
<p>Multiple Arguments and ‘required’ Semantics<br>在多参数构造函数或方法的情况下， required() 属性适用于所有参数。</p>
<p>单个参数可以声明为 Java-8 样式 Optional，或者从 Spring Framework 5.0 开始，也可以声明为 @Nullable 或 Kotlin 中的非空参数类型，覆盖基本的“必需”语义。</p>
<p>Autowiring Arrays, Collections, and Maps自动装配数组、集合和映射 </p>
<p>对于数组、集合或映射依赖类型，容器自动装配与声明的值类型匹配的所有 bean。</p>
<p>为此，必须将映射键(the map keys)声明为 String 类型，该类型将解析为相应的 bean 名称。</p>
<p>这样一个容器提供的集合将被排序，考虑目标组件的 Ordered 和 @Order 值，否则按照它们在容器中的注册顺序。</p>
<p>或者，单个匹配的目标 bean 也可能是一般类型的 Collection 或 Map 本身，因此被注入。 </p>
<p>BeanPostProcessor 或 BeanFactoryPostProcessor 不支持<br>请注意，实际注入是通过 BeanPostProcessor 执行的，这反过来意味着您不能使用 @Autowired 将引用注入 BeanPostProcessor 或 BeanFactoryPostProcessor 类型。</p>
<p>请查阅 AutowiredAnnotationBeanPostProcessor 类的 javadoc（默认情况下，它会检查是否存在此注释）。</p>
<ol>
<li>在创建&#x2F;声明 Bean</li>
<li>扫描 Bean，对 Bean 进行初始化，配置和依赖管理。</li>
<li>注入</li>
</ol>
<p>大体了解了 @Component 与 @Bean 之间的区别，</p>
<p>还有一个问题，为什么要定义 Bean 并注册到 Spring 容器中？</p>
<p>问题，@Autowired 在 字段，set方法，构造函数中标注有什么区别？</p>
<hr>
<h1 id="关于-Bean-的-DependsOn-Lazy-Scope"><a href="#关于-Bean-的-DependsOn-Lazy-Scope" class="headerlink" title="关于 Bean 的 @DependsOn , @Lazy , @Scope"></a>关于 Bean 的 @DependsOn , @Lazy , @Scope</h1><p>2021-08-18 18:39:47.519  INFO 4960 — [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit ‘default’<br>myBean, Bean开始初始化…<br>yourBean, Bean开始初始化…<br>theirBean2, Bean开始初始化…<br>2021-08-18 18:39:48.607  INFO 4960 — [           main] c.e.accessingdatajpa.BeansApplication    : Started BeansApplication in 10.314 seconds (JVM running for 11.611)<br>myBean, Bean开始初始化…<br>myBean, MyBean使用…<br>theirBean, MyBean使用…</p>
<p>2021-08-18 18:44:02.168  INFO 16008 — [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit ‘default’<br>myBean, Bean开始初始化…<br>yourBean, Bean开始初始化…<br>theirBean2, Bean开始初始化…<br>theirBean, Bean开始初始化…<br>2021-08-18 18:44:03.176  INFO 16008 — [           main] c.e.accessingdatajpa.BeansApplication    : Started BeansApplication in 8.581 seconds (JVM running for 10.016)<br>myBean, Bean开始初始化…<br>myBean, MyBean使用…<br>theirBean, MyBean使用…</p>
<p>2021-08-18 18:47:49.593  INFO 9840 — [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit ‘default’<br>myBean, Bean开始初始化…<br>yourBean, Bean开始初始化…<br>theirBean2, Bean开始初始化…<br>theirBean, Bean开始初始化…<br>2021-08-18 18:47:50.817  INFO 9840 — [           main] c.e.accessingdatajpa.BeansApplication    : Started BeansApplication in 10.624 seconds (JVM running for 12.203)<br>theirBean, MyBean使用…</p>
<p>Object的hashCode()默认是返回内存地址的，但是hashCode()可以重写，所以hashCode()不能代表内存地址的不同</p>
<p>System.identityHashCode(Object)方法可以返回对象的内存地址,不管该对象的类是否重写了hashCode()方法。</p>
<p>问题，当什么情况会在多个 @Configuration 配置多个组件扫描？</p>
<p>对于是否需要写接口：</p>
<p>对于是否需要写接口：</p>
<p>写接口的理由：</p>
<ol>
<li>使用接口更多的是一种规范吧，好的代码是让初学者都明白代码逻辑。</li>
<li>GCLIB代理不需要接口，但是JDK动态代理, 需要接口。</li>
<li>有了接口层可以快速知道有哪些方法，而直接写impl的话，肯定会有一些杂七杂八的方法啥的影响阅读体验。代码永远是用来阅读的，不方便阅读，会不方便维护。</li>
<li>写interface可以比较快的找到可以用的方法。上面可以注释。不用在impl里翻找需要的逻辑。（与理由3类似）</li>
<li>使用接口的另一个原因，提高代码可测性，这也是为什么后面spring推荐构造器注入的原因。 当service调用远程网络，依赖不同环境时。我们可以使用mock实现替换当前service实现，实现对环境依赖的解耦，返回mock数据。</li>
<li>小项目没有多实现，可以不写，但是当需求增加后，service 层需要多种不同的实现后，就感受到面向接口开发的好处了。</li>
</ol>
<p>不写接口的理由：</p>
<ol>
<li>小项目，没有多实现的情况下，多写一个接口，增加工作量，麻烦。</li>
</ol>
<p>@Scope 注解源码注释中有一段内容可以使用：</p>
<p>as a type-level annotation,  instances of the annotated type。</p>
<p>as a method-level annotation, the instance returned from the method.</p>
<p>annotation 注解 源码中，对注解可作用的类型的表述，Type表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Class, interface (including annotation type), or enum declaration */ </span><br><span class="line">TYPE,</span><br></pre></td></tr></table></figure>


<p>根据类型获取 Bean 的局限和扩展方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// SpringApplication 根据类型获取 Bean</span></span><br><span class="line">	<span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(AccessDemo.class, args);</span><br><span class="line">	<span class="type">CommandLineRunner</span> <span class="variable">commandLineRunner</span> <span class="operator">=</span> context.getBean(CommandLineRunner.class);</span><br><span class="line">    System.out.println(commandLineRunner.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前 context 中有两个 CommandLineRunner 接口实现的 Bean，所以遇到如下报错，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type <span class="string">&#x27;org.springframework.boot.CommandLineRunner&#x27;</span> available: expected single matching bean but found <span class="number">2</span>: CLRunner,demoBefore</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:<span class="number">1262</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:<span class="number">494</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:<span class="number">349</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:<span class="number">342</span>)</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:<span class="number">1172</span>)</span><br><span class="line">	at com.spoonli.demo.AccessDemo.main(AccessDemo.java:<span class="number">52</span>)</span><br></pre></td></tr></table></figure>

<p>从上面报错可以知道，当使用默认的 <code>getBean()</code> 方法获取 Bean 时，采用根据类型获取，只能在当前类型的 Bean 在 Spring Context 中只存在一个的情况下才行，如果同一类型同时存在多个不同名称的 Bean 时，则会报错</p>
<p>操作方法：</p>
<ol>
<li>改用<strong>名称</strong>来获取；</li>
<li>如果是使用 <code>@Autowired</code>来自动装配时，与 <code>@Qualify</code> 注解一起使用，获取指定类型指定名称的 Bean；</li>
<li><code>context.getBeansOfType(CommandLineRunner.class).values()</code> 使用这个方法来获取指定类型所有的 Bean ，然后循环处理。</li>
</ol>
<p>maven 项目已 project 导入 和 已module形式导入有什么不同？</p>
<p>确认一下 Spring Boot 外部配置文件的通配符含义</p>
<p>Runnable 的 poll 和 take 有什么区别？</p>
<p>通过创建 Thread 去执行 Runnable 的task ？所有的 task 都是 Runnable 的，那么怎么体现 线程池中的线程运行的 task ？不是 task.run() 自己执行的run() 吗？</p>
<ul>
<li>是通过一次运行固定资源个task 执行来达到所谓的控制线程数的效果的吗？</li>
</ul>
<p>没有理解什么是线程？ 当 new Thread 的时候，是在做什么？</p>
<p>mybatis-generator-core-.pom.lastUpdated<br>这个文件很可能导致了本地无法直接解决依赖问题，先删掉看看</p>
<p>POST _analyze<br>{<br>  “text”: “美国留给伊拉克的是一个烂摊子吗？”,<br>  “analyzer”: “ik_max_word”<br>}</p>
<p>Docker 中水平伸缩只能用于无状态计算服务，具有数据状态的都不适合直接放在 Docker 里面，如果 Docker 中安装数据库，存储服务需要单独提供。</p>
<p>Docker 推荐服务挂掉，自动启动新容器，而不是继续重启容器服务。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实践过程</title>
    <url>//%E6%89%8B%E5%8A%A8%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="20210723"><a href="#20210723" class="headerlink" title="20210723"></a>20210723</h1><ol>
<li>目标，常规使用<ol>
<li>搭建</li>
<li>数据库</li>
<li>常用注解说明</li>
</ol>
</li>
</ol>
<p>一共有以下简便学习步骤：</p>
<ol>
<li>运行样例，先跑起来</li>
<li>使用其开发&#x2F;写代码</li>
<li>运行，测试代码</li>
<li>打包上线</li>
<li>高级操作</li>
</ol>
<blockquote>
<p>这次主要学习 Spring 相关内容，中间遇到的一些其他知识点，先记录到另外的文件中，然后回头学习。</p>
</blockquote>
<p>首先要明白，<br>Spring Boot 是创建基于 Spring 的应用程序的工具</p>
<blockquote>
<p>下面两句话，可以说明：在 官方文档 Getting Started 章节</p>
<p>Spring Boot 帮助我们创建可独立运行的，生产级的基于 Spring 的应用程序</p>
<p>大多数 Spring Boot 应用程序只需要很少的 Spring 配置，</p>
</blockquote>
<p>Spring Boot的依赖项使用org.springframework.boot groupId。通常，你的Maven POM文件继承自spring-boot-starter-parent项目，并声明对一个或多个”Starters”的依赖。Spring Boot还提供了一个可选的Maven插件来创建可执行的jar。</p>
<h1 id="spring-io网站上-Spring-Boot-的-“入门”-指南-的作用"><a href="#spring-io网站上-Spring-Boot-的-“入门”-指南-的作用" class="headerlink" title="spring.io网站上 Spring Boot 的 “入门” 指南 的作用"></a>spring.io网站上 Spring Boot 的 “入门” 指南 的作用</h1><p>spring.io网站上有许多使用Spring Boot的 “入门” 指南。如果你需要解决一个特定的问题，请先在那里查看。</p>
<ol start="2">
<li>核心原则</li>
</ol>
<p>mvn 项目</p>
<ul>
<li>compile，所有编译（compile）后的class文件，都在target&#x2F;classes 目录下</li>
<li>package， 会执行编译，运行test，打包文件 放在 target 目录下</li>
<li>install，会执行compile，test，package，然后copy target目录下的jar&#x2F;war包到本地repo下，可供其他程序使用。</li>
</ul>
<p>问题：</p>
<p><code>&lt;dependencyManagement&gt;</code>标签在pom中的作用是什么？<br>为什么不依赖 <code>spring-boot-starter-parent</code> 就需要向 <code>&lt;dependencyManagement&gt;</code> 这个依赖管理添加内容？</p>
<p>Spring Boot Reference Document 官方参考文档</p>
<p>Using Spring Boot 	Build Systems, Structuring Your Code, Configuration, Spring Beans and Dependency Injection, DevTools, and more.</p>
<p>Spring Boot Features 	Profiles, Logging, Security, Caching, Spring Integration, Testing, and more.</p>
<p>官方文档写的特定，与自学视频中总结的不太一样，看看是不是出发点不同</p>
<p>Spring Boot 的四大特性</p>
<ul>
<li>自动配置 - Auto Configuration</li>
<li>起步依赖 - Starter Dependency</li>
<li>命令行界面 - Spring Boot CLI</li>
<li>Actuator</li>
</ul>
<p>第一个样例程序，注解说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/hello&quot;)</span>  <span class="comment">// 告诉 Spring 使用 hello() 方法响应发送到 xxx/hello 这个地址的请求</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Hello %s!&quot;</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>  <span class="comment">// 告诉 Spring 使用 hello() 方法响应发送到 xxx/hello 这个地址的请求。</span></span><br><span class="line"><span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span>  <span class="comment">// 告诉 Spring 允许在 hello 这个请求后面添加 ?name=xxx 的参数，因为是 Get 请求，所以参数前需要使用 ? 符号将请求路径与参数分隔。</span></span><br></pre></td></tr></table></figure>



<p><code>spring-boot-starter-parent</code> 本身没有提供任何依赖</p>
<p>在我们 Sprint Boot 项目的POM文件中，The <code>spring-boot-starter-parent</code> is a special <strong>starter</strong> that provides useful Maven defaults. It also provides a <code>dependency-management</code> section so that you can omit <code>version</code> tags for “blessed” dependencies.</p>
<blockquote>
<p>总的来说就是，<code>spring-boot-starter-parent</code> 也是一个starter，只不过他本身没有提供具体的依赖包，而是提供了一个用来管理版本号的内容，依赖它的POM文件中就可以省掉 spring 相关的版本号了。</p>
</blockquote>
<p>具体的依赖都在 <code>spring-boot-starter-xxx</code> 中，例如 spring-boot-starter-web, 那么问题：如果有多个starter中依赖了相同版本的包，是自动排除多余的吗？如果依赖了同一个包的不同版本，会怎么样？还是 spring 中同一个版本的starter 中依赖的包都是同一个版本？这需要测试一下。</p>
<h1 id="常用注解说明："><a href="#常用注解说明：" class="headerlink" title="常用注解说明："></a>常用注解说明：</h1><p>被称为stereotype注解</p>
<p>它为阅读代码的人和Spring提供了提示，说明这个类扮演了一个特定的角色。</p>
<h2 id="类级注解"><a href="#类级注解" class="headerlink" title="类级注解"></a>类级注解</h2><p><strong>@SpringBootApplication</strong> 用在Main方法类上，包含三个功能，(所以当不想使用 <code>@SpringBootApplication</code> 注解时，也可以使用下面三个注解的组合代替)</p>
<ul>
<li><p>@EnableAutoConfiguration ，启用Spring Boot 的自动配置机制</p>
</li>
<li><p>@ComponentScan ，对应用程序所在的软件包启用@Component扫描，最佳实践是将主Main类放到根包下（即包的根目录下），然后即可以对该类所在的包目录，及其子目录进行 Bean 扫描。</p>
</li>
<li><p>@SpringBootConfiguration ，允许在上下文中注册额外的 bean 或导入其他配置类</p>
<blockquote>
<p>这是 Spring 标准 <code>@Configuration</code> 的替代方案，有助于在你的集成测试中进行配置检测。在 Spring Boot-2.1.1RELEASE 即之前的版本中，使用的是 <code>@Configuration</code> 。</p>
</blockquote>
</li>
</ul>
<p>样例参考 <a href="#%E4%BD%BF%E7%94%A8-SpringBootApplication-%E6%B3%A8%E8%A7%A3">使用 SpringBootApplication 注解</a></p>
<p> <strong>@Controller</strong> 告诉 Spring 这是一个 Web 的endpoint（端点），处理传入的 Web 请求时，会解析这个注解标注的类</p>
<p> <strong>@RestController</strong> 注解告诉Spring将结果字符串直接呈现给调用者。</p>
<blockquote>
<p>The <code>@RestController</code> annotation tells Spring to render the resulting string directly back to the caller.</p>
<p>render 用在前端，一般指<code>渲染</code>的意思，但是在 Spring 中翻译为 <code>呈现</code>更合适。</p>
</blockquote>
<p><strong>@ComponentScan</strong>  查找项目配置的 bean</p>
<p><strong>@Autowired</strong> 进行构造函数注入，标记你希望 Spring 使用的哪个构造函数。（没用@Autowired 标注的构造函数怎么办？）</p>
<p><strong>@Component</strong> </p>
<p>如果按照上面的建议构造代码(将应用程序类放在根包中)，则可以添加 <code>@ComponentScan</code> 而没有任何参数。您的所有应用程序组件( <code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code> 等)都会自动注册为 Spring Bean。</p>
<p><strong>@EnableAutoConfiguration</strong>  注解</p>
<ul>
<li>参考笔记中的<code>了解自动配置的实现原理</code>章节内容，知道自动配置做了哪些事情？怎么做得？如何定制化我们自己的自动配置，并让 Spring Boot 来加载</li>
</ul>
<h2 id="方法级注解"><a href="#方法级注解" class="headerlink" title="方法级注解"></a>方法级注解</h2><p><strong>@RequestMapping</strong> 注解，提供了 “路由”信息。它告诉Spring，任何带有 <code>xxx</code> 路径的HTTP请求都应该被映射到它标注的方法中。</p>
<h2 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h2><h1 id="第六章，使用-Spring-Boot"><a href="#第六章，使用-Spring-Boot" class="headerlink" title="第六章，使用 Spring Boot"></a>第六章，使用 Spring Boot</h1><p>@RequestMapping 注解，提供了 “路由”信息。它告诉Spring，任何带有 <code>xxx</code> 路径的HTTP请求都应该被映射到它标注的方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span>   <span class="comment">// 这里表示任何带有 / 路径的http请求都应该被映射到 home() 方法中</span></span><br><span class="line">String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@RestController和@RequestMapping注解是Spring MVC注解（它们不是Spring Boot特有的）。</p>
<p>为什么 main 方法中需要传入 main 方法所在的类名？</p>
<blockquote>
<p>答： We need to pass <code>MyApplication.class</code> as an argument to the <code>run</code> method to tell <code>SpringApplication</code> which is the <code>primary Spring component</code>.</p>
<p>我们需要将MyApplication.class作为参数传递给run方法，以告诉SpringApplication哪个是主要的Spring组件。</p>
</blockquote>
<h2 id="Spring-Boot-的-Dependency-Management"><a href="#Spring-Boot-的-Dependency-Management" class="headerlink" title="Spring Boot 的 Dependency Management"></a>Spring Boot 的 Dependency Management</h2><p>每个 Spring Boot 版本都提供了它支持的精选依赖列表。</p>
<blockquote>
<p>您仍然可以指定版本，并在需要时覆盖 Spring Boot 的建议。</p>
</blockquote>
<p>精选列表包含了所有可以在Spring Boot中使用的Spring模块，以及第三方库列表。该列表以标准材料清单的形式提供（<code>spring-boot-dependencies</code>），可用于Maven和Gradle。</p>
<blockquote>
<p><code>spring-boot-dependencies</code> 在 <code>spring-boot-starter-parent</code> POM 中作为 parent 部分被依赖，所以当使用 <code>spring-boot-starter-parent</code> 依赖时，这些都会被我们的项目自动继承。</p>
</blockquote>
<p>如果要修改某个依赖库的版本，直接再 pom.xml 中添加 相关依赖版本的 <properties> 属性 </p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注： 在 <code>spring-boot-dependencies</code> pom上查看受支持的属性的列表。</p>
</blockquote>
<p>关于在 Maven 中配置并使用 Spring Boot 相关内容总结：</p>
<ul>
<li>使用 <code>spring-boot-starter-parent</code> 依赖的时候</li>
<li>不适用 <code>spring-boot-starter-parent</code> 依赖的时候</li>
</ul>
<ol>
<li>一般情况，自己项目的 POM 中可以直接依赖 <code>spring-boot-starter-parent</code> 项目的 POM，这样会继承很多 Spring Boot 处理好的默认项，</li>
<li>但是如果有其他 父级 POM 需要依赖，或者不想直接依赖 <code>spring-boot-starter-parent</code>，为了保留 Spring Boot 的依赖管理的好处，可以在 项目的 POM 中添加 <dependencyManagement> ，然后将 <code>spring-boot-dependencies</code> 依赖进来，并且设置 <code>scope=import</code> 。</li>
<li>当需要修改或者覆盖 <code>spring-boot-dependencies</code> 提供的默认依赖版本时，将新版本的信息，添加到 <dependencyManagement> 中，并且放在 <code>spring-boot-dependencies</code> 依赖信息之前即可。</li>
</ol>
<p>样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;!-- Override Spring Data release train provided by Spring Boot --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;Fowler-SR2&lt;/version&gt;</span><br><span class="line">			&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">			&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">			&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">			&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>


<h2 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h2><p>Starters 是一组方便在项目中引用的依赖描述符（ dependency descriptors），通过 starter ，我们可以方便的获取 Spring 和相关技术的一站式服务。</p>
<p>Starters 的背景，为什么会存在 Starters ？</p>
<p>传统 Maven 项目的缺点：</p>
<h2 id="构建代码-Struct-code"><a href="#构建代码-Struct-code" class="headerlink" title="构建代码 Struct code"></a>构建代码 Struct code</h2><h3 id="1-命名-Java-软件包（package）"><a href="#1-命名-Java-软件包（package）" class="headerlink" title="1. 命名 Java 软件包（package）"></a>1. 命名 Java 软件包（package）</h3><pre><code>- 使用 Java 建议的包命令约定，并使用反向域名（例如：`com.example.project`）
</code></pre>
<h3 id="2-Main-方法类的位置"><a href="#2-Main-方法类的位置" class="headerlink" title="2. Main 方法类的位置"></a>2. Main 方法类的位置</h3><pre><code>- 通常将包含 Main 方法的类，放在包的根目录下
    &gt; 通常我们会将 `@SpringBootApplication` 注解放在有 main 方法的主类上，放在根包中（包的根目录），有利于程序进行组件扫描。
</code></pre>
<p>下面列出了一个典型的布局。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- MyApplication.java   // 包含 main 方法的主类</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure>

<h3 id="3-Configuration-类"><a href="#3-Configuration-类" class="headerlink" title="3. Configuration 类"></a>3. Configuration 类</h3><p>从官方文档中暂时还不太懂这部分，这部分具体怎么使用需要看后面的文档</p>
<p>这里涉及一个 <code>@Configuration</code> 注解</p>
<p>Spring Boot 支持 Java-based 配置（基于 Java 的配置），同时也支持将 <code>SpringApplication</code> 与 XML 源一起使用，但是建议我们的主源为单个 <code>@Configuration</code> 类</p>
<p>支持导入其他配置类</p>
<blockquote>
<p>您无需将所有@Configuration都放在一个类中。 @Import注解可用于导入其他配置类。另外，您可以使用@ComponentScan自动拾取所有 Spring 组件，包括@Configuration类。</p>
</blockquote>
<p>支持导入 XML 配置</p>
<blockquote>
<p>如果绝对必须使用基于 XML 的配置，我们建议您仍然从@Configuration类开始。然后，您可以使用@ImportResource注解来加载 XML 配置文件。</p>
</blockquote>
<h3 id="4-Auto-configuration"><a href="#4-Auto-configuration" class="headerlink" title="4. Auto-configuration"></a>4. Auto-configuration</h3><blockquote>
<p>这部分内容可以参考 极客时间的视频+笔记 69,70 课</p>
</blockquote>
<p>Spring Boot自动配置试图根据你所添加的jar依赖项自动配置你的Spring应用程序。</p>
<p>例如，如果HSQLDB在你的classpath上，而且你没有手动配置任何数据库连接Bean，那么Spring Boot就会自动配置内存数据库。</p>
<h4 id="1-使用自动配置"><a href="#1-使用自动配置" class="headerlink" title="1. 使用自动配置"></a>1. 使用自动配置</h4><p>你只需要在<strong>主</strong> <code>@Configuration</code> 类中，添加 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 两个注解中的一个即可，从而选择加入自动配置。</p>
<h4 id="2-定制自己的自动配置并替换"><a href="#2-定制自己的自动配置并替换" class="headerlink" title="2. 定制自己的自动配置并替换"></a>2. 定制自己的自动配置并替换</h4><h4 id="3-禁用指定的-Auto-configuration"><a href="#3-禁用指定的-Auto-configuration" class="headerlink" title="3. 禁用指定的 Auto-configuration"></a>3. 禁用指定的 Auto-configuration</h4><p>如果发现正在应用不需要的特定自动配置类，</p>
<ol>
<li>可以通过使用 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 注解的 <code>exclude</code> 属性，指定自动配置类的类名，来禁用它</li>
<li>如果该类不在 classpath 上，你可以使用注解的 <code>excludeName</code> 属性并指定完全合格的名称来代替。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Spring-Bean-和依赖注入"><a href="#Spring-Bean-和依赖注入" class="headerlink" title="Spring Bean 和依赖注入"></a>Spring Bean 和依赖注入</h2><p>问题：依赖注入的目的是什么？与使用普通的 import 方式有什么不同？</p>
<p>我们建议使用 <code>@ComponentScan</code> (查找您的 bean)和使用 <code>@Autowired</code> (进行构造函数注入)。</p>
<p>如果按照上面的建议构造代码(将应用程序类放在根包中)，则可以添加 <code>@ComponentScan</code> 而没有任何参数。您的所有应用程序组件( <code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code> 等)都会自动注册为 Spring Bean。</p>
<p>注：</p>
<ol>
<li>如果一个 Bean 有多个构造函数，你需要用 <code>@Autowired</code> 来标记你希望 Spring 使用的哪个。如果只有一个构造函数，则可以省略 <code>@Autowired</code> 注解</li>
</ol>
<p>例如：下面的例子显示了一个 <code>@ServiceBean</code>，它使用构造函数注入来获得一个所需的 RiskAssessorBean 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAccountService</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果一个 Bean 有多个构造函数，你需要用 <code>@Autowired</code> 来标记你希望 Spring 使用的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAccountService</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">        <span class="built_in">this</span>.out = System.out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAccountService</span><span class="params">(RiskAssessor riskAssessor, PrintStream out)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">        <span class="built_in">this</span>.out = out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用-SpringBootApplication-注解"><a href="#使用-SpringBootApplication-注解" class="headerlink" title="使用 SpringBootApplication 注解"></a>使用 SpringBootApplication 注解</h2><p>参考 <a href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E">常用注解说明</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// same as @SpringBootConfiguration @EnableAutoConfiguration</span></span><br><span class="line">                        <span class="comment">// @ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的样例中 <code>@SpringBootApplication</code> 注解也可以用三个单一功能的注解的组合代替</p>
<p>所以具体如何使用完全自由决定，，</p>
<p>如果你不希望在你的应用程序中使用组件扫描（component scan）或配置属性扫描（configuration properties scan）。</p>
<p>也可以使用向下面例子用的组合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration(proxyBeanMethods = false)</span>  <span class="comment">// 在之前版本中这里使用 `@Configuration` ， `@ConfigurationProperties`-注解的类可以被自动检测到</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@Import(&#123; SomeConfiguration.class, AnotherConfiguration.class &#125;)</span>  <span class="comment">// 这里使用了 `@Import` 显示导入指定 Bean，代替了 `@ComponentScan` 自动检测所有` @Component`-annotated 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，Application 就像其他任何 Spring Boot 应用程序一样，除了不会自动检测到标有 <code>@Component</code>-注解的类和<code>@ConfigurationProperties</code>-注解的类，并且显式导入用户定义的 Bean (请参阅 <code>@Import</code>)。</p>
</blockquote>
<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>几种方式</p>
<ul>
<li>IDE 中导入并运行</li>
<li>打成 jar 包执行<ul>
<li>可执行 jar 包，通过 java -jar xxx&#x2F;xxx.jar<blockquote>
<p>同时执行开启远程调式功能</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> $ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=<span class="number">8000</span>,suspend=n \</span><br><span class="line">-jar target/myapplication-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>使用普通的 classpath + jar 的方式运行</li>
</ul>
</li>
<li>使用 maven 和 gradle 插件运行</li>
<li>热插拔<blockquote>
<p>由于Spring Boot应用程序是普通的Java应用程序，JVM热部署应该可以开箱即用。JVM热部署所能替换的字节码有一定的限制。要获得更完整的解决方案，可以使用 <code>JRebel</code> 。</p>
<p><code>spring-boot-devtools</code> 模块还包括对快速重启应用程序的支持。详情请见 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.hotswapping">“How-to”章节的热插拔</a>。</p>
</blockquote>
</li>
</ul>
<h2 id="Developer-Tools"><a href="#Developer-Tools" class="headerlink" title="Developer Tools"></a>Developer Tools</h2><p>这部分之后再回来重新看</p>
<p>有以下几个功能</p>
<ol>
<li>属性默认值</li>
<li>自动重启<ol>
<li>记录条件评估中的更改</li>
<li>排除资源</li>
<li>注意其他路径</li>
<li>禁用重启</li>
<li>使用触发文件</li>
<li>自定义重启类加载器</li>
<li>已知限制</li>
<li></li>
</ol>
</li>
<li>LiveReload</li>
<li>全局设置</li>
<li>远程应用程序</li>
</ol>
<h1 id="Spring-Boot-Features"><a href="#Spring-Boot-Features" class="headerlink" title="Spring Boot Features"></a>Spring Boot Features</h1><h2 id="1-1-启动失败"><a href="#1-1-启动失败" class="headerlink" title="1.1. 启动失败"></a>1.1. 启动失败</h2><p>如果你的应用程序启动失败，注册的 <code>FailureAnalyzers</code> 有机会提供专门的错误信息和具体的行动来解决这个问题。 </p>
<p>如果你通过使用java -jar运行你的应用程序，你可以启用debug属性，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar myproject-0.0.1-SNAPSHOT.jar --debug</span></span><br></pre></td></tr></table></figure>

<h2 id="1-7-应用程序事件和侦听器"><a href="#1-7-应用程序事件和侦听器" class="headerlink" title="1.7. 应用程序事件和侦听器"></a>1.7. 应用程序事件和侦听器</h2><p>在内部，Spring Boot 使用事件来处理各种任务。你通常不需要使用应用程序事件，但知道它们的存在会很方便。</p>
<p>当你的应用程序运行时，应用程序事件按以下顺序发送：</p>
<blockquote>
<p>这部分也查看官方文档</p>
</blockquote>
<p>Application events是通过使用Spring框架的事件发布机制来发送的。</p>
<h2 id="1-8-Web-环境"><a href="#1-8-Web-环境" class="headerlink" title="1.8. Web 环境"></a>1.8. Web 环境</h2><p><code>SpringApplication</code> 试图帮你创建正确类型的 <code>ApplicationContext</code> 。用于确定 <code>WebApplicationType</code> 的算法如下:</p>
<ul>
<li>如果 Spring MVC 存在，就会使用 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li>
<li>如果 Spring MVC 不存在而 Spring WebFlux 存在，则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code>。</li>
<li>否则，将使用 <code>AnnotationConfigApplicationContext</code>。</li>
</ul>
<p>这意味着，如果你在同一个应用程序中使用 Spring MVC 和 Spring WebFlux 的新 WebClient，<strong>将默认使用 Spring MVC</strong>。你可以通过调用 <code>setWebApplicationType(WebApplicationType)</code> 轻松覆盖。</p>
<p>也可以通过调用 <code>setApplicationContextClass(..)</code> 来完全控制使用的 <code>ApplicationContext</code> 类型。</p>
<blockquote>
<p>当在 JUnit 测试中使用 <code>SpringApplication</code> 时，通常需要调用 <code>setWebApplicationType(WebApplicationType.NONE)</code>。</p>
</blockquote>
<h2 id="1-9-访问-Application-参数"><a href="#1-9-访问-Application-参数" class="headerlink" title="1.9. 访问 Application 参数"></a>1.9. 访问 Application 参数</h2><p>&#x2F;&#x2F; do something…</p>
<h2 id="1-10-使用-ApplicationRunner-或者-CommandLineRunner"><a href="#1-10-使用-ApplicationRunner-或者-CommandLineRunner" class="headerlink" title="1.10. 使用 ApplicationRunner 或者 CommandLineRunner"></a>1.10. 使用 ApplicationRunner 或者 CommandLineRunner</h2><p><strong>使用场景：</strong>当你需要在 <code>SpringApplication</code> 启动后，但在其开始接受访问之前运行一些代码&#x2F;任务，可以使用下面的接口定义 Runner Bean：</p>
<ul>
<li><p>ApplicationRunner</p>
<ul>
<li><code>run(ApplicationArguments args)</code>  ，参数为 ApplicationArguments</li>
</ul>
</li>
<li><p>CommandLineRunner</p>
<ul>
<li><code>run(String... args)</code>  ，参数为 String[]</li>
</ul>
</li>
</ul>
<p><strong>异同：</strong></p>
<ul>
<li>相同点：两个接口，工作方式相同，</li>
<li>不同点：接受参数方式不同，参考上面 run 的传参</li>
</ul>
<p><strong>使用方式：</strong></p>
<ul>
<li><p>实现接口提供的 <code>run</code> 方法，并定义为 Bean (交给 Spring 管理)</p>
<blockquote>
<p>该方法会在 <code>SpringApplication.run(...)</code> 完成之前被调用。</p>
<p>注：在 SpringApplication 的 <code>public ConfigurableApplicationContext run(String... args)</code> 方法中 </p>
<p><code>callRunners(context, applicationArguments);</code> &#x2F;&#x2F; 调用 所有的 Runner 接口实现</p>
</blockquote>
</li>
<li><p>这就有两种方式，一种使用 <code>@Component</code> 作用在实现接口的类上，定义为 Bean，</p>
</li>
<li><p>另一种，使用 <code>@Bean</code> 注解，在配置类中定义返回 Bean 的方法。</p>
</li>
</ul>
<p>如果定义了多个Runner <strong>Bean</strong> （CommandLineRunner 或 ApplicationRunner），可以通过添加 @Order 注解，或者实现 <code>org.springframework.core.Ordered</code> 接口来指定运行顺序</p>
<p>样例：方法一，创建实现接口的类，并标注为 Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>样例2：使用 @Bean ，定义返回 Bean 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">demo2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandLineRunner</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里也可以使用 lambda表达式来处理</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">demo2</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line"> <span class="comment">// do something...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="1-11-程序退出"><a href="#1-11-程序退出" class="headerlink" title="1.11. 程序退出"></a>1.11. 程序退出</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.spring-application.application-exit">https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.spring-application.application-exit</a></p>
<p>从1.8~1.11 这四个子章节的内容与 极客时间的《82 编写命令行运行的程序》内容差不多，再看时，可以考虑两个集合在一起。</p>
<h2 id="1-13-应用程序启动跟踪"><a href="#1-13-应用程序启动跟踪" class="headerlink" title="1.13. 应用程序启动跟踪"></a>1.13. 应用程序启动跟踪</h2><p>在应用启动期间，<code>SpringApplication</code> 和 <code>ApplicationContext</code> 执行许多与应用生命周期、Bean 生命周期，甚至处理应用事件有关的任务。通过 <code>ApplicationStartup</code>，Spring 框架允许你用 <code>StartupStep</code> 对象跟踪应用程序的启动顺序。这些数据可以为分析目的而收集，或者只是为了更好地了解应用程序的启动过程。</p>
<blockquote>
<p>具体使用参考官方文档 <a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.spring-application.startup-tracking">应用程序启动跟踪</a></p>
</blockquote>
<h2 id="2-外化配置"><a href="#2-外化配置" class="headerlink" title="2. 外化配置"></a>2. 外化配置</h2><p>极客时间的 73,74两节内容，与这部分有关联，再深入看时，可以结合在一起看。</p>
<blockquote>
<p>2.5.3 版本，这部分写的顺序更容易理解，2.1.1-RELEASE 版本中写的可能让新手容易混淆。</p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.external-config">https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.external-config</a></p>
</blockquote>
<p>Spring Boot让你将配置外部化，这样你就可以在不同的环境中使用相同的应用程序代码。你可以使用各种外部配置源，包括Java properties文件、YAML文件、环境变量和命令行参数。</p>
<p>属性值可以通过使用 <code>@Value</code> 注解直接注入你的Bean，通过Spring的 <code>Environment</code> 抽象访问，或者通过 <code>@ConfigurationProperties</code> <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties">绑定到结构化对象</a>。</p>
<h3 id="PropertySource-加载和生效顺序"><a href="#PropertySource-加载和生效顺序" class="headerlink" title="PropertySource 加载和生效顺序"></a>PropertySource 加载和生效顺序</h3><p>Spring Boot 的 <code>PropertySource</code> 顺序，旨在合理的覆盖值。属性是按照以下顺序考虑。</p>
<blockquote>
<p>（后面读取的项目值会覆盖前面读取的相同项目值）</p>
</blockquote>
<ol>
<li><p>默认属性（通过设置 <code>SpringApplication.setDefaultProperties</code> 指定）。</p>
</li>
<li><p><code>@Configuration</code> 类上的 <a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/context/annotation/PropertySource.html">@PropertySource</a> 注解。请注意，这样的属性源直到 application context 被刷新时才会被添加到环境中。这对于配置某些属性来说已经太晚了，比如 <code>logging.*</code> 和 <code>spring.main.*</code> ，它们在刷新开始前就已经被读取了。</p>
</li>
<li><p>配置文件（如 <code>application.properties</code> 文件）。</p>
<ol>
<li>打包在你的 jar 里面(application.properties 和 YAML 变体 .yml)。</li>
<li>打包在你的jar中（application-{profile}.properties和YAML变量）。</li>
<li>在你打包的jar之外(application.properties和YAML变体)。</li>
<li>在你打包的jar之外（application-{profile}.properties和YAML变体）。<blockquote>
<p>建议你在整个应用程序中坚持使用一种格式。如果你在同一地点有 <code>.properties</code> 和<code>.yml</code>格式的配置文件，<code>.properties</code>优先。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>一个 <code>RandomValuePropertySource</code> ，它的属性只有 <code>random.*</code> 。</p>
</li>
<li><p>操作系统环境变量。</p>
</li>
<li><p>Java 系统属性（<code>System.getProperties()</code>），java -D 参数指定的属性，在命令行中可以通过 -D 参数来指定一些系统属性。</p>
</li>
<li><p>来自 <code>java:comp/env</code> 的 JNDI 属性。</p>
</li>
<li><p><code>ServletContext</code> 初始参数。</p>
</li>
<li><p><code>ServletConfig</code> 初始参数。</p>
</li>
<li><p>来自 <code>SPRING_APPLICATION_JSON</code> 的属性（嵌入环境变量或系统属性中的内联 JSON ）。</p>
</li>
<li><p>命令行参数，（例如，–server.port&#x3D;9000， <code>SpringApplication</code> 会将任何命令行选项参数转换为 propert y并将其添加到 Spring 的 <code>Environment</code> 中。）</p>
<ul>
<li>如果你不希望命令行属性被添加到 <code>Environment</code> 中，你可以通过使用 <code>SpringApplication.setAddCommandLineProperties(false)</code> 来禁用它们。</li>
</ul>
</li>
<li><p><code>properties</code> 属性在你的 <code>tests</code> 上。在 <a href="https://docs.spring.io/spring-boot/docs/2.5.3/api/org/springframework/boot/test/context/SpringBootTest.html">@SpringBootTest</a> 和用于测试你的应用程序的特定片断的测试注释上可用。</p>
</li>
<li><p><a href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/test/context/TestPropertySource.html">@TestPropertySource</a> 对你的测试进行注解。</p>
</li>
<li><p>当 devtools 处于活动状态时，在 <code>$HOME/.config/spring-boot</code> 目录下的 Devtools 全局设置属性。</p>
</li>
</ol>
<p>以上内容需要亲自使用测试，来掌握具体内容。</p>
<p>例如：</p>
<p>在你的应用程序的classpath（例如，在你的 jar 中），你可以有一个 application.properties 文件，为 name 提供一个合理的默认属性值。当在一个新的环境中运行时，可以在 jar 之外提供一个 application.properties 文件，覆盖 name 。</p>
<p>注：</p>
<blockquote>
<p><code>env</code>和<code>configprops</code>端点在确定一个属性为什么有一个特定的值时很有用，具体可以参考  <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints">Production ready features</a> 章节</p>
</blockquote>
<blockquote>
<p>个人理解：文档中的 <code>优先</code>(takes precedence)，应该是使用的优先级，当存在a属性时，先使用a，当a不存在时，使用b。而属性加载的顺序更好相反，这样后面读取的才能更好地覆盖前面的读取的值。</p>
</blockquote>
<p>问题： </p>
<ol>
<li>lower order property sources , 这里的 lower order 是在哪里定义的？</li>
<li>The list is ordered by precedence (with values from lower items overriding earlier ones). 列表按优先级排序（较低项目的值覆盖较早项目的值）<ul>
<li>这里也是，这个 lower items 是怎么定义的？ a,b,c 这三个值，a低？还是c低？ 这是国外固有的顺序？还是哪里定义的顺序？</li>
<li>从上下文来看，a&gt;b&gt;c,但是还是对官方文档中使用 lower 这个词有疑惑。</li>
</ul>
</li>
</ol>
<h3 id="外部配置详细说明"><a href="#外部配置详细说明" class="headerlink" title="外部配置详细说明"></a>外部配置详细说明</h3><h3 id="2-1-访问命令行属性"><a href="#2-1-访问命令行属性" class="headerlink" title="2.1 访问命令行属性"></a>2.1 访问命令行属性</h3><h3 id="2-2-JSON-Application-Properties"><a href="#2-2-JSON-Application-Properties" class="headerlink" title="2.2 JSON Application Properties"></a>2.2 JSON Application Properties</h3><h3 id="2-3-External-Application-Properties-（外部-application-properties-属性配置文件）"><a href="#2-3-External-Application-Properties-（外部-application-properties-属性配置文件）" class="headerlink" title="2.3 External Application Properties  （外部 application.properties 属性配置文件）"></a>2.3 External Application Properties  （外部 application.properties 属性配置文件）</h3><h4 id="2-3-1-加载使用-application-properties-配置文件"><a href="#2-3-1-加载使用-application-properties-配置文件" class="headerlink" title="2.3.1 加载使用 application.properties 配置文件"></a><strong>2.3.1 加载使用 <code>application.properties</code> 配置文件</strong></h4><p>当你的应用程序启动时，Spring Boot 会自动从以下位置找到并加载 <code>application.properties</code> 和 <code>application.yaml</code> 文件。</p>
<ol>
<li>classpath<ol>
<li>classpath的根路径</li>
<li>classpath <code>/config</code> 包</li>
</ol>
</li>
<li>当前目录<ol>
<li>当前目录根路径</li>
<li>当前目录下的 <code>/config</code> 子目录</li>
<li><code>/config</code> 子目录的直接子目录。<blockquote>
<p>列表按优先级排序（在列表较低位置定义的属性会覆盖在较高位置定义的属性）。<br>加载的文件被作为 <code>PropertySources</code> 添加到 Spring 的 <code>Environment</code> 中。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>修改默认名字或者路径：</p>
<ul>
<li>spring.config.name</li>
<li>spring.config.location</li>
<li>spring.config.extra-location （Spring Boot 2.5.3 版本使用）<ul>
<li>spring.config.additional-location (Spring Boot 2.1.1-RELEASE 版本使用)<blockquote>
<p>通过将上述参数定义为环境属性(通常是 OS 环境变量（操作系统环境变量），系统属性或命令行参数)。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>**<code>spring.config.name</code>**， 如果您不喜欢 <code>application.properties</code> 作为配置文件名，则可以通过指定 <code>spring.config.name</code> 环境属性来切换到另一个文件名。例如：改为 myproject.properties 和 myproject.yaml 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar myproject.jar --spring.config.name=myproject</span></span><br></pre></td></tr></table></figure>

<p>**<code>spring.config.location</code>**， 您还可以使用 <code>spring.config.location</code> 环境属性(这是目录位置或文件路径的<code>逗号分隔</code>列表)来引用显式位置。下面的示例演示如何指定其他文件名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar myproject.jar --spring.config.location=\</span></span><br><span class="line"><span class="language-bash">    optional:classpath:/default.properties,\</span></span><br><span class="line"><span class="language-bash">    optional:classpath:/override.properties</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果位置是可选的并且你不介意它们不存在，请使用前缀 <code>optional:</code> 。</p>
</blockquote>
<p><strong>注：</strong> 通过使用 <code>spring.config.location</code> 配置的位置将取代默认位置。如果你想添加额外的位置，而不是替换它们，你可以使用 <code>spring.config.extra-location</code> 。从附加位置加载的属性可以覆盖默认位置的属性。</p>
<blockquote>
<p>具体样例参考官方文档：<a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.external-config.files">外部 application.properties</a></p>
</blockquote>
<h4 id="2-3-2-配置文件特定属性-（Profile-Specific-Files）"><a href="#2-3-2-配置文件特定属性-（Profile-Specific-Files）" class="headerlink" title="2.3.2 配置文件特定属性 （Profile Specific Files）"></a><strong>2.3.2 配置文件特定属性 （Profile Specific Files）</strong></h4><p>除了 <code>application.properties</code> 文件之外，Spring Boot 还将尝试使用命名惯例 <code>application-&#123;profile&#125;</code>加载特定配置文件(profile-specific files)。例如，如果你的应用程序激活了名为 <code>prod</code> 的配置文件并使用 YAML 文件，那么 <code>application.yml</code> 和<code>application-prod.yml</code> 都将被考虑。</p>
<p>特定配置文件与标准的<code>application.properties</code>的位置相同，特定配置文件总是优先于非特定文件。如果指定了几个配置文件，则采用最后胜出的策略。例如，如果配置文件 <code>prod,live</code> 是由<code>spring.profiles.active</code>属性指定的，<code>application-prod.properties</code>中的值可以被<code>application-live.properties</code>中的值覆盖。</p>
<p>如何设置&#x2F;激活，特定配置文件，结合 </p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.profiles">Profiles 章节</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.properties-and-configuration.set-active-spring-profiles">How-to 章节中 Set the Active Spring Profiles 章节</a></li>
</ul>
<h4 id="2-3-3-属性中的占位符（Property-Placeholders）"><a href="#2-3-3-属性中的占位符（Property-Placeholders）" class="headerlink" title="2.3.3 属性中的占位符（Property Placeholders）"></a><strong>2.3.3 属性中的占位符（Property Placeholders）</strong></h4><p><code>application.properties</code>和<code>application.yml</code>中的值在使用时通过现有的 <code>Environment</code> 过滤，所以你可以参考以前定义的值（例如，从系统属性）。标准的 <code>$&#123;name&#125;</code> 属性占位符语法可以在一个值的任何地方使用。</p>
<p>例如，下面的文件将把<code>app.description</code>设置为 “MyApp is a Spring Boot application”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app:</span><br><span class="line">  name: &quot;MyApp&quot;</span><br><span class="line">  description: &quot;$&#123;app.name&#125; is a Spring Boot application&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>您还可以使用此技术来创建现有 Spring Boot 属性的“简短”变体。详细参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.properties-and-configuration.short-command-line-arguments">How-to章节的使用短命令行参数章节</a></p>
</blockquote>
<h3 id="2-4-加密配置属性"><a href="#2-4-加密配置属性" class="headerlink" title="2.4 加密配置属性"></a>2.4 加密配置属性</h3><h3 id="2-5-使用YAML-（使用-yaml-代替-properties-配置文件）"><a href="#2-5-使用YAML-（使用-yaml-代替-properties-配置文件）" class="headerlink" title="2.5 使用YAML （使用 yaml 代替 properties 配置文件）"></a>2.5 使用YAML （使用 yaml 代替 properties 配置文件）</h3><p>具体参考官方文档</p>
<p><code>YAML</code>是 JSON 的超集，因此是一种用于指定<em>层次结构</em>配置数据的便捷格式。</p>
<ol>
<li><p>使用条件，</p>
<ul>
<li>只要在 Classpath 上具有 <code>SnakeYAML</code>库，<code>SpringApplication</code> 类就会自动支持 YAML 作为属性的替代方法。<blockquote>
<p>如果您使用“Starter”，则 <code>spring-boot-starter</code>自动提供 SnakeYAML。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>如何加载 YAML ？</p>
</li>
<li><p>YAML 缺点</p>
<ul>
<li>YAML文件不能通过使用 <code>@PropertySource</code> 或 <code>@TestPropertySource</code> 注解来加载。所以，在你需要以这种方式加载值的情况下，你需要使用一个properties文件。</li>
</ul>
</li>
</ol>
<h3 id="2-6-配置随机值-（Ramdom）"><a href="#2-6-配置随机值-（Ramdom）" class="headerlink" title="2.6 配置随机值 （Ramdom）"></a>2.6 配置随机值 （Ramdom）</h3><h3 id="2-7-配置系统环境属性-（Configuring-System-Environment-Properties）"><a href="#2-7-配置系统环境属性-（Configuring-System-Environment-Properties）" class="headerlink" title="2.7 配置系统环境属性 （Configuring System Environment Properties）"></a>2.7 配置系统环境属性 （Configuring System Environment Properties）</h3><h3 id="2-8-类型安全的配置属性-（-Type-safe-Configuration-Properties）"><a href="#2-8-类型安全的配置属性-（-Type-safe-Configuration-Properties）" class="headerlink" title="2.8 类型安全的配置属性 （ Type-safe Configuration Properties）"></a>2.8 类型安全的配置属性 （ Type-safe Configuration Properties）</h3><p>该章节主要介绍 <code>@ConfigurationProperties</code> 注解相关内容，具体参考官方文档，<a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.external-config.typesafe-configuration-properties">Type-safe Configuration Properties</a>。</p>
<p>背景：</p>
<p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 注解来注入配置属性有时会很麻烦，特别是当你要处理多个属性或你的数据是分层的。Spring Boot提供了一种处理属性的替代方法，让强类型的 Bean 管理和验证你的应用程序的配置。</p>
<p>Spring Boot提供了绑定 <code>@ConfigurationProperties</code> 类型并将其注册为Bean的基础设施。</p>
<p>另请参见 <a href="#2.8.10-@ConfigurationProperties-vs.-@Value">@Value和类型安全配置属性的区别</a>。</p>
<h4 id="2-8-1-JavaBean-属性绑定"><a href="#2-8-1-JavaBean-属性绑定" class="headerlink" title="2.8.1 JavaBean 属性绑定"></a>2.8.1 JavaBean 属性绑定</h4><h4 id="2-8-2-构造函数绑定"><a href="#2-8-2-构造函数绑定" class="headerlink" title="2.8.2 构造函数绑定"></a>2.8.2 构造函数绑定</h4><h4 id="2-8-3-启用-Enabling-ConfigurationProperties-annotated-类型"><a href="#2-8-3-启用-Enabling-ConfigurationProperties-annotated-类型" class="headerlink" title="2.8.3 启用(Enabling) @ConfigurationProperties-annotated 类型"></a>2.8.3 启用(Enabling) @ConfigurationProperties-annotated 类型</h4><h4 id="2-8-4-使用-Using-ConfigurationProperties-annotated-类型"><a href="#2-8-4-使用-Using-ConfigurationProperties-annotated-类型" class="headerlink" title="2.8.4 使用(Using) @ConfigurationProperties-annotated 类型"></a>2.8.4 使用(Using) @ConfigurationProperties-annotated 类型</h4><h4 id="2-8-5-第三方配置"><a href="#2-8-5-第三方配置" class="headerlink" title="2.8.5 第三方配置"></a>2.8.5 第三方配置</h4><h4 id="2-8-6-宽松绑定"><a href="#2-8-6-宽松绑定" class="headerlink" title="2.8.6 宽松绑定"></a>2.8.6 宽松绑定</h4><h4 id="2-8-7-合并复杂类型"><a href="#2-8-7-合并复杂类型" class="headerlink" title="2.8.7 合并复杂类型"></a>2.8.7 合并复杂类型</h4><h4 id="2-8-8-属性转换"><a href="#2-8-8-属性转换" class="headerlink" title="2.8.8 属性转换"></a>2.8.8 属性转换</h4><h4 id="2-8-9-ConfigurationProperties-验证"><a href="#2-8-9-ConfigurationProperties-验证" class="headerlink" title="2.8.9 @ConfigurationProperties 验证"></a>2.8.9 @ConfigurationProperties 验证</h4><h4 id="2-8-10-ConfigurationProperties-vs-Value"><a href="#2-8-10-ConfigurationProperties-vs-Value" class="headerlink" title="2.8.10 @ConfigurationProperties vs. @Value"></a>2.8.10 @ConfigurationProperties vs. @Value</h4><p><code>@Value</code> 注解是一个核心的容器功能，它不提供与 <em>类型安全的配置属性(<code>@ConfigurationProperties</code>)</em> 相同的功能。下表总结了 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 所支持的功能。</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>@ConfigurationProperties</th>
<th>@Value f</th>
</tr>
</thead>
<tbody><tr>
<td>Relaxed binding</td>
<td>Yes</td>
<td>Limited (see note below)</td>
</tr>
<tr>
<td>Meta-data support</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>SpEL evaluation</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<h2 id="3-Profiles"><a href="#3-Profiles" class="headerlink" title="3. Profiles"></a>3. Profiles</h2><p>具体参考 <a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.profiles">官方文档</a></p>
<p>我个人理解，它的功能就是根据配置的参数，支持在不同的环境中使用参数指定的配置文件。</p>
<h3 id="3-1-利用-Profile-指定应用程序配置何时被加载"><a href="#3-1-利用-Profile-指定应用程序配置何时被加载" class="headerlink" title="3.1 利用 @Profile 指定应用程序配置何时被加载"></a>3.1 利用 <code>@Profile</code> 指定应用程序配置何时被加载</h3><p>Spring Profiles提供了一种方法来隔离你的应用程序配置的一部分，使其只在某些环境下可用。任何 <code>@Component</code>、<code>@Configuration</code> 或 <code>@ConfigurationProperties</code> 都可以用 <code>@Profile</code> 来标记，以限制它何时被加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 <code>@ConfigurationProperties</code> Bean 是通过 <code>@EnableConfigurationProperties</code> 注册的，而不是<code>自动扫描</code>，则需要在具有 <code>@EnableConfigurationProperties</code> 注解的 <code>@Configuration</code> 类上指定 <code>@Profile</code> 注解。在 <code>@ConfigurationProperties</code> 被扫描的情况下，<code>@Profile</code> 可以在 <code>@ConfigurationProperties</code> 类本身指定。</p>
</blockquote>
<h3 id="3-2-如何-启用-x2F-激活-不同的配置文件"><a href="#3-2-如何-启用-x2F-激活-不同的配置文件" class="headerlink" title="3.2 如何 启用&#x2F;激活 不同的配置文件"></a>3.2 如何 启用&#x2F;激活 不同的配置文件</h3><p>使用 <code>spring.profiles.active</code> 这个<code>Environment</code>属性来指定哪些配置文件是活动的。可以将这个属性添加到配置文件中，同样也可以使用命令行参数的形式替换。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spring.profiles.active=dev,hsqldb</span><br></pre></td></tr></table></figure>
<p>或者使用命令行的形式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--spring.profiles.active=dev,hsqldb</span><br></pre></td></tr></table></figure>

<p>注：如果没有配置 active 状态的配置文件(profile)，Spring 就会启用一个默认的配置文件，例如：<code>application-default.properties</code>。<br>当然我们也可以通过 <code>spring.profiles.default</code> 这个 <code>Environment</code> 属性，来做调整， 例如： <code>spring.profiles.default=none</code></p>
<p><code>spring.profiles.active</code> 属性的生效覆盖方式，与其他普通属性一样，加载生效顺序，参考 <a href="#PropertySource-%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%94%9F%E6%95%88%E9%A1%BA%E5%BA%8F">外化配置</a></p>
<p>例如：可以在application.properties中指定活动配置文件，然后通过使用命令行开关替换它们。</p>
<p>有时，有一些属性可以添加到活动配置文件中，而不是替换它们。参见<a href="https://docs.spring.io/spring-boot/docs/2.5.3/api/org/springframework/boot/SpringApplication.html">SpringApplication API</a>中的setAdditionalProfiles()方法。</p>
<h2 id="4-Logging"><a href="#4-Logging" class="headerlink" title="4. Logging"></a>4. Logging</h2><p>详细内容参考 官方文档<a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.logging">logging</a></p>
<p>一般来说，你不需要改变你的日志依赖，Spring Boot的默认值就很好用。</p>
<blockquote>
<p>如果你使用 “Starter”，Logback被用来做日志记录</p>
</blockquote>
<h3 id="4-1-日志格式"><a href="#4-1-日志格式" class="headerlink" title="4.1. 日志格式"></a>4.1. 日志格式</h3><p>日志级别: ERROR, WARN, INFO, DEBUG, 或TRACE.</p>
<blockquote>
<p>Logback没有FATAL级别。它被映射到 ERROR。</p>
</blockquote>
<h3 id="4-3-输出到文件"><a href="#4-3-输出到文件" class="headerlink" title="4.3. 输出到文件"></a>4.3. 输出到文件</h3><p>默认情况下，Spring Boot只向控制台记录日志，不写日志文件。</p>
<p>如果你想在控制台输出之外写日志文件，你需要设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性（例如，在你的 <code>application.properties</code>）。</p>
<p>下表显示了 <code>logging.*</code> 属性如何被一起使用。</p>
<table>
<thead>
<tr>
<th>logging.file.name</th>
<th>logging.file.path</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>(none)</td>
<td>(none)</td>
<td></td>
<td>只在控制台进行记录。</td>
</tr>
<tr>
<td>指定文件</td>
<td>(none)</td>
<td>my.log</td>
<td>写到指定的日志文件。名称可以是准确的位置，也可以是与当前目录的相对位置。</td>
</tr>
<tr>
<td>(none)</td>
<td>指定目录</td>
<td>&#x2F;var&#x2F;log</td>
<td>将spring.log写到指定目录。名称可以是准确的位置，也可以是与当前目录的相对位置。</td>
</tr>
</tbody></table>
<blockquote>
<p>日志文件在达到 10MB 时就会轮换，与控制台输出一样，默认情况下会记录 ERROR-级、WARN-级和 INFO-级的信息。</p>
</blockquote>
<p>其他的如，日志文件轮询策略等参考官方文档。</p>
<h3 id="4-8-自定义日志配置"><a href="#4-8-自定义日志配置" class="headerlink" title="4.8. 自定义日志配置"></a>4.8. 自定义日志配置</h3><p>根据你的日志系统，会加载以下文件。</p>
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody><tr>
<td>Logback</td>
<td>logback-spring.xml , logback-spring.groovy , logback.xml , or logback.groovy</td>
</tr>
<tr>
<td>Log4j2</td>
<td>log4j2-spring.xml or log4j2.xml</td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td>logging.properties</td>
</tr>
</tbody></table>
<h2 id="7-开发-Web-Applications"><a href="#7-开发-Web-Applications" class="headerlink" title="7. 开发 Web Applications"></a>7. 开发 Web Applications</h2><p>大多数Web应用程序使用 <code>spring-boot-starter-web</code> 模块来快速启动和运行。</p>
<p>使用 <code>spring-boot-starter-webflux</code> 模块来构建 reactive Web 应用。</p>
<h3 id="7-1-Spring-Web-MVC-框架"><a href="#7-1-Spring-Web-MVC-框架" class="headerlink" title="7.1. Spring Web MVC 框架"></a>7.1. Spring Web MVC 框架</h3><p>创建特殊的 <code>@Controller</code> 或 <code>@RestController</code> bean 来处理 HTTP 请求。</p>
<p>控制器中的方法通过使用 <code>@RequestMapping</code> 注解被映射到 HTTP。</p>
<p>Spring MVC是Spring框架核心的一部分，详细的信息可以在 <a href="https://docs.spring.io/spring-framework/docs/5.3.9/reference/html/web.html#mvc">参考文档</a> 中找到</p>
<h4 id="7-1-1-Spring-MVC自动配置"><a href="#7-1-1-Spring-MVC自动配置" class="headerlink" title="7.1.1. Spring MVC自动配置"></a>7.1.1. Spring MVC自动配置</h4><h4 id="7-1-2-HttpMessageConverters"><a href="#7-1-2-HttpMessageConverters" class="headerlink" title="7.1.2. HttpMessageConverters"></a>7.1.2. HttpMessageConverters</h4><p>Spring MVC 使用 <code>HttpMessageConverter</code> 接口来转换 HTTP 请求和响应。</p>
<p>它支持一些开箱即用的默认值，<br>例如：</p>
<ol>
<li><p>对象可以自动转换为 JSON（通过使用 Jackson 库）或 XML（通过使用 Jackson XML 扩展，如果可用的话，或通过使用 JAXB，如果 Jackson XML扩展不可用）。</p>
</li>
<li><p>默认情况下，字符串是以 UTF-8 编码的。</p>
</li>
</ol>
<p>你可以使用 Spring Boo t的 <code>HttpMessageConverters</code> 类，添加或定制转换器。</p>
<p>任何存在于上下文中的 <code>HttpMessageConverter</code> bean都会被添加到转换器的列表中。</p>
<h4 id="7-1-3-自定义-JSON-Serializers-和-Deserializers"><a href="#7-1-3-自定义-JSON-Serializers-和-Deserializers" class="headerlink" title="7.1.3. 自定义 JSON Serializers 和 Deserializers"></a><strong>7.1.3. 自定义 JSON Serializers 和 Deserializers</strong></h4><p>如果你使用 Jackson 来序列化和反序列化 JSON 数据，你可能想编写自己的 JsonSerializer 和 JsonDeserializer 类。</p>
<p>自定义序列化器通常是<a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers">通过模块与Jackson注册</a>，但 Spring Boot 提供了一个替代性的 <code>@JsonComponent</code> 注解，使直接注册 Spring Beans 更容易。</p>
<p>关于 <code>@JsonComponent</code> 注解使用场景</p>
<ol>
<li>你可以直接在 <code>JsonSerializer</code> 、<code>JsonDeserializer</code> 或 <code>KeyDeserializer</code> 实现上使用 <code>@JsonComponent</code> 注解。</li>
<li>也可以在那些包含序列化器&#x2F;反序列化器作为内部类(inner classes)的类上使用它。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.ObjectCodec;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.DeserializationContext;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.jackson.JsonComponent;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJsonComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Serializer</span> <span class="keyword">extends</span> <span class="title class_">JsonSerializer</span>&lt;MyObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(MyObject value, JsonGenerator jgen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            jgen.writeStringField(<span class="string">&quot;name&quot;</span>, value.getName());</span><br><span class="line">            jgen.writeNumberField(<span class="string">&quot;age&quot;</span>, value.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Deserializer</span> <span class="keyword">extends</span> <span class="title class_">JsonDeserializer</span>&lt;MyObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MyObject <span class="title function_">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext ctxt)</span></span><br><span class="line">                <span class="keyword">throws</span> IOException, JsonProcessingException &#123;</span><br><span class="line">            <span class="type">ObjectCodec</span> <span class="variable">codec</span> <span class="operator">=</span> jsonParser.getCodec();</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">tree</span> <span class="operator">=</span> codec.readTree(jsonParser);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> tree.get(<span class="string">&quot;name&quot;</span>).textValue();</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> tree.get(<span class="string">&quot;age&quot;</span>).intValue();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(name, age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ApplicationContext</code> 中的所有 <code>@JsonComponent</code> Bean 都会自动向 Jackson 注册。因为 <code>@JsonComponent</code> 是用 <code>@Component</code> 元注释的，所以通常的组件扫描规则适用。</p>
</blockquote>
<p>Spring Boot还提供了 <code>JsonObjectSerializer</code> 和 <code>JsonObjectDeserializer</code> 基类，在序列化对象时提供了标准 Jackson 版本的有用替代品。详情见 Javadoc 中的 <a href="https://docs.spring.io/spring-boot/docs/2.5.3/api/org/springframework/boot/jackson/JsonObjectSerializer.html">JsonObjectSerializer</a> 和<a href="https://docs.spring.io/spring-boot/docs/2.5.3/api/org/springframework/boot/jackson/JsonObjectDeserializer.html">JsonObjectDeserializer</a>。</p>
<h4 id="7-1-5-静态内容"><a href="#7-1-5-静态内容" class="headerlink" title="7.1.5. 静态内容"></a>7.1.5. 静态内容</h4><p>默认情况下，Spring Boot从 classpath 中的 <code>/static</code> （或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/resources</code> ）目录或 <code>ServletContext</code> 的根中提供静态内容。它使用了 Spring MVC 中的 <code>ResourceHttpRequestHandler</code> ，因此你可以通过添加你自己的 <code>WebMvcConfigurer</code> 并重写 <code>addResourceHandlers</code> 方法来修改该行为。</p>
<p>具体参考<a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.spring-mvc.static-content">官方文档</a></p>
<h4 id="7-1-7-路径匹配和内容协商"><a href="#7-1-7-路径匹配和内容协商" class="headerlink" title="7.1.7. 路径匹配和内容协商"></a><strong>7.1.7. 路径匹配和内容协商</strong></h4><p><a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.spring-mvc.content-negotiation">https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.spring-mvc.content-negotiation</a></p>
<p>Spring MVC 可以通过查看请求路径并将其与应用程序中定义的映射（例如，控制器方法上的 <code>@GetMapping</code> 注解）相匹配，将传入的 HTTP 请求映射到处理程序。</p>
<p>Spring Boot 默认选择禁用后缀模式匹配，这被认为是一个 <a href="https://docs.spring.io/spring-framework/docs/5.3.9/reference/html/web.html#mvc-ann-requestmapping-suffix-pattern-match">Spring MVC应用的最佳实践</a>。</p>
<p>这意味着诸如 <code>&quot;GET /projects/spring-boot.json&quot;</code> 之类的请求将不会与 <code>@GetMapping(&quot;/projects/spring-boot&quot;)</code> 映射相匹配。</p>
<ul>
<li>为什么？不用后缀模式匹配不是反而能匹配到吗？</li>
</ul>
<p>背景：</p>
<p>过去，此功能主要用于未发送正确的“ Accept”请求 Headers 的 HTTP Client 端。我们需要确保将正确的 <code>Content Type</code> 发送给 Client 端。如今，内容协商(Content Negotiation)已变得更加可靠。</p>
<p><strong>注：</strong> 后缀模式匹配已被废弃，并将在未来的版本中被删除。如果你了解这些注意事项，并且仍然希望你的应用程序使用后缀模式匹配，则需要进行以下配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-path-extension=true</span><br><span class="line">spring.mvc.pathmatch.use-suffix-pattern=true</span><br></pre></td></tr></table></figure>


<h4 id="7-1-8-ConfigurableWebBindingInitializer"><a href="#7-1-8-ConfigurableWebBindingInitializer" class="headerlink" title="7.1.8. ConfigurableWebBindingInitializer"></a>7.1.8. ConfigurableWebBindingInitializer</h4><h4 id="7-1-9-模板引擎"><a href="#7-1-9-模板引擎" class="headerlink" title="7.1.9. 模板引擎"></a>7.1.9. 模板引擎</h4><p>作用：</p>
<ul>
<li>提供动态 HTML 内容</li>
</ul>
<p>Spring Boot包括对以下模板引擎的自动配置支持。</p>
<ul>
<li>FreeMarker</li>
<li>Groovy</li>
<li><a href="https://www.thymeleaf.org/">Thymeleaf</a></li>
<li>Mustache</li>
</ul>
<blockquote>
<p>当你使用这些默认配置的模板引擎之一时，你的模板会自动从 <code>src/main/resources/templates</code> 中获取。</p>
</blockquote>
<p>模板引擎具体该怎么用，请参考各个模板引擎的官网</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据您运行应用程序的方式，IntelliJ IDEA 对 Classpath 的排序方式不同。与使用 Maven 或 Gradle 或从打包的 jar 运行应用程序时，从 IDE 的 Main 方法运行应用程序的顺序会有所不同。这可能会导致 Spring Boot 无法在 Classpath 上找到模板。如果遇到此问题，则可以在 IDE 中重新排序 Classpath，以首先放置模块的类和资源。另外，您可以配置模板前缀以搜索 Classpath 上的每个templates目录，如下所示：classpath*:/templates/。</span><br></pre></td></tr></table></figure>


<h4 id="7-1-12-跨域支持-（CORS-支持）"><a href="#7-1-12-跨域支持-（CORS-支持）" class="headerlink" title="7.1.12. 跨域支持 （CORS 支持）"></a>7.1.12. 跨域支持 （CORS 支持）</h4><p>Cross-origin resource sharing (CORS) 是一个由大多数浏览器实现的 W3C 规范，它让你以灵活的方式指定什么样的跨域请求是被授权的。而不是使用一些不太安全、不太强大的方法，如 IFRAME 或 JSONP。</p>
<p>从 4.2 版本开始，Spring MVC 支持 CORS。</p>
<h3 id="7-2-Spring-WebFlux框架"><a href="#7-2-Spring-WebFlux框架" class="headerlink" title="7.2 Spring WebFlux框架"></a>7.2 Spring WebFlux框架</h3><p>详细内容，参考官方文档 <a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.spring-webflux">The “Spring WebFlux Framework”</a></p>
<p>Spring WebFlux 是 Spring Framework 5.0 中引入的新的响应式 Web 框架。</p>
<p>与 Spring MVC 不同，它不需要 Servlet API，是完全异步和非阻塞的，并通过 Reactor 项目实现了 Reactive Streams 规范。</p>
<p>在你的应用程序中同时添加 <code>spring-boot-starter-web</code> 和 <code>spring-boot-starter-webflux</code> 模块，Spring Boot 会自动配置 <code>Spring MVC</code>，而不是 WebFlux。</p>
<h3 id="7-4-嵌入式-Servlet-容器支持"><a href="#7-4-嵌入式-Servlet-容器支持" class="headerlink" title="7.4. 嵌入式 Servlet 容器支持"></a>7.4. 嵌入式 Servlet 容器支持</h3><p>更多内容参考官方文档 <a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.embedded-container">Embedded Servlet Container Support</a></p>
<p>Spring Boot 包含对嵌入式 Tomcat，Jetty 和 Undertow 服务器的支持。</p>
<p>使用适当的 “Starter”来获得一个完全配置的实例。</p>
<p>默认情况下，嵌入式服务器在端口 <code>8080</code> 上监听 HTTP 请求。</p>
<h3 id="7-5-嵌入式Reactive务器支持"><a href="#7-5-嵌入式Reactive务器支持" class="headerlink" title="7.5. 嵌入式Reactive务器支持"></a>7.5. 嵌入式Reactive务器支持</h3><p>Spring Boot 对以下嵌入式反应式Web服务器的支持。</p>
<ul>
<li>Reactor Netty</li>
<li>Tomcat</li>
<li>Jetty</li>
<li>Undertow</li>
</ul>
<h2 id="11-使用SQL数据库"><a href="#11-使用SQL数据库" class="headerlink" title="11. 使用SQL数据库"></a>11. 使用SQL数据库</h2><h3 id="11-1-配置数据源"><a href="#11-1-配置数据源" class="headerlink" title="11.1. 配置数据源"></a>11.1. 配置数据源</h3><p>详细内容，参考官方文档 <a href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.sql.datasource">Configure a DataSource</a></p>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-access">Data Access</a><br><a href="https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-data-access.html#howto-configure-a-datasource">2.1.1.RELEASE 有汉化版本</a></p>
<h3 id="11-2-使用JdbcTemplate"><a href="#11-2-使用JdbcTemplate" class="headerlink" title="11.2. 使用JdbcTemplate"></a>11.2. 使用JdbcTemplate</h3><h3 id="11-3-JPA-和-Spring-Data-JPA"><a href="#11-3-JPA-和-Spring-Data-JPA" class="headerlink" title="11.3. JPA 和 Spring Data JPA"></a>11.3. JPA 和 Spring Data JPA</h3><h3 id="11-4-Spring-Data-JDBC"><a href="#11-4-Spring-Data-JDBC" class="headerlink" title="11.4. Spring Data JDBC"></a>11.4. Spring Data JDBC</h3><h3 id="11-5-使用H2的Web-Console"><a href="#11-5-使用H2的Web-Console" class="headerlink" title="11.5. 使用H2的Web Console"></a>11.5. 使用H2的Web Console</h3><h3 id="11-6-使用-jOOQ"><a href="#11-6-使用-jOOQ" class="headerlink" title="11.6. 使用 jOOQ"></a>11.6. 使用 jOOQ</h3><h3 id="11-7-使用-R2DBC"><a href="#11-7-使用-R2DBC" class="headerlink" title="11.7. 使用 R2DBC"></a>11.7. 使用 R2DBC</h3>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>WindowsServer使用遇到问题</title>
    <url>//WindowsServer%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>Windows Server 使用遇到问题</p>
<h2 id="问题1：Windows-Server-2012开启远程桌面服务及授权多终端用户同时登录的详细教程"><a href="#问题1：Windows-Server-2012开启远程桌面服务及授权多终端用户同时登录的详细教程" class="headerlink" title="问题1：Windows Server 2012开启远程桌面服务及授权多终端用户同时登录的详细教程"></a>问题1：<a href="https://blog.csdn.net/zhuge_Spring/article/details/107005114?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control">Windows Server 2012开启远程桌面服务及授权多终端用户同时登录的详细教程</a></h2><hr>
<h2 id="问题2：安装完office2016之后，打开word时报错，提示如下"><a href="#问题2：安装完office2016之后，打开word时报错，提示如下" class="headerlink" title="问题2：安装完office2016之后，打开word时报错，提示如下"></a>问题2：安装完office2016之后，打开word时报错，提示如下</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">api-ms-win-crt**.dll 缺失</span><br></pre></td></tr></table></figure>
<p>处理方法参考下面的链接：<br><a href="https://blog.csdn.net/gangeqian2/article/details/79307416?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.base">api-ms-win-crt-process-l1-1-0.dll 丢失的处理，个人觉得完美</a></p>
<p>主要是到微软下载中心下载安装下面的两个更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KB2999226、 KB3118401</span><br><span class="line">KB2999226 微软下载链接 https://support.microsoft.com/en-us/help/2999226/update-for-universal-c-runtime-in-windows</span><br><span class="line">KB3118401 微软下载链接 https://support.microsoft.com/en-us/help/3118401/update-for-universal-c-runtime-in-windows</span><br></pre></td></tr></table></figure>
<p><strong>重要</strong>：下载安装KB2999226时，请查看前提条件，需要先按照顺序安装几个<a href="https://support.microsoft.com/zh-cn/topic/windows-rt-8-1-windows-8-1-%E5%92%8C-windows-server-2012-r2-%E6%9B%B4%E6%96%B0-2014-%E5%B9%B4-4-%E6%9C%88-3c9d820b-7079-359d-8660-21de648fa31d">依赖更新</a>。这在下载前都有说明，要记得看</p>
<p><strong>重要2</strong>：安装KB2919355更新之前，还需要安装KB2919442，这个在KB2919355下载页面也是有说明的</p>
<p><strong>总结</strong>： 安装KB2999226之前，需要先安装安装顺序依次安装以下几个更新：</p>
<ul>
<li>clearcompressionflag.exe</li>
<li>KB2919442</li>
<li>KB2919355</li>
<li>KB2932046</li>
<li>KB2959977</li>
<li>KB2937592</li>
<li>KB2938439</li>
<li>KB2934018<blockquote>
<p>说明：除KB2919442需要单独下载外，其他几个文件都是在KB2919355下载页面一起提供的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果无法在下载中心搜索，那么可以利用上面提供的下载地址，修改一下后面的更新文件名称来下载。<br><a href="https://support.microsoft.com/en-us/help/3118401/update-for-universal-c-runtime-in-windows%EF%BC%8C">https://support.microsoft.com/en-us/help/3118401/update-for-universal-c-runtime-in-windows，</a> 将链接中<code>3118401</code>修改为<code>2919442</code>即可访问KB2919442的下载页面了。</p>
</blockquote>
<hr>
<h2 id="问题3：windows-server-2012-r2-打补丁时提示此“更新不适用于您的计算机”"><a href="#问题3：windows-server-2012-r2-打补丁时提示此“更新不适用于您的计算机”" class="headerlink" title="问题3：windows server 2012 r2 打补丁时提示此“更新不适用于您的计算机”"></a>问题3：windows server 2012 r2 打补丁时提示此“更新不适用于您的计算机”</h2><p>原因是安装的补丁有依赖补丁，需要先安装依赖补丁后才可以安装这个补丁。例如安装KB2999226补丁前，需要安装KB2919355及其依赖补丁才可以，这些都在补丁下载的页面有说明，下载更新前要仔细查看。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Windows Server 2012</tag>
      </tags>
  </entry>
  <entry>
    <title>批处理用过的命令及遇到的问题</title>
    <url>//%E6%89%B9%E5%A4%84%E7%90%86%E7%94%A8%E8%BF%87%E7%9A%84%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>注意：</p>
<p>遇到命令不熟悉，可以通过 cmd 命令行中使用 <code>命令 /?</code> 来查看具体命令的帮助</p>
<h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="comment">rem 需要提供一个文件  # rem 开头表示改行是注释行</span></span><br><span class="line">echo Hello</span><br></pre></td></tr></table></figure>



<h2 id="2-打印"><a href="#2-打印" class="headerlink" title="2. 打印"></a>2. 打印</h2><blockquote>
<p>关于<strong>回显</strong></p>
<p>批处理中默认是开<strong>回显</strong>的，即命令本身和命令的执行结果都会打印</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例如我们的脚本 test.bat文件如下</span><br><span class="line"><span class="built_in">echo</span> 123</span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">C:\Codes\work&gt;test.bat</span><br><span class="line">执行结果：</span><br><span class="line">C:\Codes\work&gt;<span class="built_in">echo</span> 123</span><br><span class="line">123</span><br><span class="line">会将命令本身和命令的执行结果都打印在命令行中</span><br></pre></td></tr></table></figure>

<p>所以如果我们仅希望打印出命令的执行结果，不需要命令本身，则可以通过<strong>关闭回显</strong>,来完成。</p>
<p>echo [on&#x2F;off]， on 打开命令的回显状态；off 关闭命令的回显状态。</p>
<p>echo 前面加<code>@</code>与否。 作用：加**@<strong>代表</strong>不显示当前行命令自身**；否则反之。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> 123</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> 456</span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">C:\Codes\work&gt;test.bat</span><br><span class="line">执行结果：</span><br><span class="line">C:\Codes\work&gt;<span class="built_in">echo</span> off</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line"></span><br><span class="line">从上面结果可得，``@<span class="built_in">echo</span> off` 这句命令本身没有显示</span><br></pre></td></tr></table></figure>

<p>所以通常批处理脚本中习惯在脚本的一开始<strong>关掉回显</strong>，即是用 <code>@echo off</code></p>
<h2 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3. for循环"></a>3. for循环</h2><p>可以在 cmd命令行中查看帮助</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /?</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR %variable IN (set) DO command [command-parameters]</span><br><span class="line"></span><br><span class="line">注意，批处理中，指定变量请使用 %%variable</span><br><span class="line">例如：</span><br><span class="line">for /F %%i in (我的文件) do (</span><br><span class="line">	cmd</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="4-程序返回值"><a href="#4-程序返回值" class="headerlink" title="4. 程序返回值"></a>4. 程序返回值</h2><p>ERRORLEVEL &#x2F; errorlevel 大小写不敏感 与 shell 中的 <code>$?</code> 效果一样</p>
<p>0 表示”成功”、1 表示”失败”，实际上，errorlevel 返回值可以在0~255 之间。</p>
<p><a href="https://www.tutorialspoint.com/batch_script/batch_script_return_code.htm">返回值表示</a> 参考这里</p>
<p><strong>一般</strong>在脚本中使用 <code>%ERRORLEVEL%</code> 这个变量来获取上一条命令的返回值，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd1</span><br><span class="line"><span class="keyword">if</span> %ERRORLEVEL% == 1 &#123;</span><br><span class="line">	cmd2</span><br><span class="line">&#125;</span><br><span class="line">表示 cmd1 执行错误则执行 cmd2</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<p>在<strong>for循环</strong>中或if语句中<strong>多条命令都需要获取返回值</strong>等情况下，<strong>用errorlevel显得无效</strong>，第二条命令开始errorlevel的值都不会变。此处涉及批处理中的<strong>变量延迟问题</strong>，并不是errorlevel无效，而是对errorlevel变量的引用采用的是没开启变量延迟情况下的百分号%。</p>
<p><strong>解决方法：</strong></p>
<p>开启变量延迟的设置：<code>setlocal EnableDelayedExpansion</code> 同时<strong>使用 <code>!errorlevel!</code><strong>变量，注意此时</strong>不能使用</strong> <code>%ERRORLEVEL%</code>变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">cmd1</span><br><span class="line"><span class="keyword">if</span> !ERRORLEVEL! == 1 &#123;</span><br><span class="line">	cmd2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_33811402/article/details/51774287">参考这篇博客</a>_</p>
<h2 id="5-读取文件"><a href="#5-读取文件" class="headerlink" title="5. 读取文件"></a>5. 读取文件</h2><p>读取一个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> 文件路径</span><br></pre></td></tr></table></figure>

<p>在 for循环中读文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /F %%i <span class="keyword">in</span> (我的文件) <span class="keyword">do</span> (</span><br><span class="line">	cmd</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">这里可以通过 <span class="keyword">for</span> /? 命令获取使用方式</span><br></pre></td></tr></table></figure>



<h2 id="6-仅执行命令不打印运行结果"><a href="#6-仅执行命令不打印运行结果" class="headerlink" title="6. 仅执行命令不打印运行结果"></a>6. 仅执行命令不打印运行结果</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd &gt; NUL</span><br></pre></td></tr></table></figure>



<h2 id="7-使用-Ping-命令查看通联性"><a href="#7-使用-Ping-命令查看通联性" class="headerlink" title="7. 使用 Ping 命令查看通联性"></a>7. 使用 Ping 命令查看通联性</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping /?  查看ping 参数的使用</span><br><span class="line"></span><br><span class="line">ping -n 2 -w 60 IP地址   // 发送2个包，设置 60s 超时</span><br><span class="line">ping -n 2 -w 60 %%i | findstr <span class="string">&quot;TTL&quot;</span>  // 有结果的会有 TTL 这个关键内容</span><br><span class="line"></span><br><span class="line">上面两条命令都可以</span><br></pre></td></tr></table></figure>

<p>给一个之前的小脚本作为修改的参考<br>脚本<code>20211130_ping_ip.bat</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">rem ping测试，需要一个ip.txt的附件提供ip列表</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">rem 下面用 %1 表示在命令行中接收第一个参数</span><br><span class="line">rem <span class="keyword">for</span> /F %%i <span class="keyword">in</span> (%1) <span class="keyword">do</span> (</span><br><span class="line"><span class="keyword">for</span> /F %%i <span class="keyword">in</span> (C:\Users\<span class="built_in">test</span>\Desktop\ip.txt) <span class="keyword">do</span> (</span><br><span class="line">    rem <span class="built_in">echo</span> %%i</span><br><span class="line">	rem <span class="built_in">echo</span> ping -n 2 -w 60 %%i</span><br><span class="line">	rem <span class="built_in">echo</span> %ERRORLEVEL%</span><br><span class="line"></span><br><span class="line">    ping -n 2 -w 60 %%i | findstr <span class="string">&quot;TTL&quot;</span> &gt; nul</span><br><span class="line">	rem ping -n 2 -w 60 %%i &gt;nul</span><br><span class="line">	rem <span class="built_in">echo</span> !ERRORLEVEL!</span><br><span class="line">    <span class="keyword">if</span> !ERRORLEVEL! == 0 (</span><br><span class="line">		<span class="built_in">echo</span> !ERRORLEVEL!</span><br><span class="line">        <span class="built_in">echo</span> %%i reachable</span><br><span class="line">        <span class="built_in">echo</span> %%i &gt;&gt; reachable_ip.txt </span><br><span class="line">    ) <span class="keyword">else</span> (</span><br><span class="line">        <span class="built_in">echo</span> !ERRORLEVEL!</span><br><span class="line">        <span class="built_in">echo</span> %%i unreachable</span><br><span class="line">        <span class="built_in">echo</span> %%i &gt;&gt; unreachable_ip.txt</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol>
<li><p>遇到的还没解决的问题</p>
<p>脚本20211130_ping_ip.bat，for循环执行指定文件，通过双击执行没有问题，但是如果使用命令行+传入参数的情况，脚本命令返回值的结果不对，为什么？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">不管执行什么命令会返回下面两个返回值，通过查看返回值结果可知是命令没有正确执行导致的</span><br><span class="line">-1073741510</span><br><span class="line">或者</span><br><span class="line">9009</span><br><span class="line">后面找机会在测试看看</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>批处理</tag>
        <tag>Bat</tag>
      </tags>
  </entry>
  <entry>
    <title>更改远程桌面侦听端口</title>
    <url>//%E6%9B%B4%E6%94%B9%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BE%A6%E5%90%AC%E7%AB%AF%E5%8F%A3.html</url>
    <content><![CDATA[<blockquote>
<p>适用范围：Windows Server 2022、Windows 10、Windows 8.1、Windows 8、Windows Server 2019、Windows Server 2016、Windows Server 2012 R2、Windows Server 2008 R2</p>
</blockquote>
<p>默认情况下为 3389</p>
<p>可以通过修改注册表来更改 Windows 计算机上的侦听端口。</p>
<p>步骤如下：</p>
<ol>
<li>启动注册表编辑器。 （在“搜索”框中键入 regedit。）</li>
<li>导航到以下注册表子项：<strong>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp</strong></li>
<li>查找端口号</li>
<li>单击“编辑”“修改”，然后单击“十进制”。</li>
<li>键入新端口号，然后单击“确定”  。</li>
<li>关闭注册表编辑器，然后重新启动计算机。</li>
</ol>
<p>下次使用远程桌面连接连接到此计算机时，必须键入新端口。 如果正在使用防火墙，请确保将防火墙配置为允许连接到新端口号。</p>
<p>可运行以下 PowerShell 命令来查看当前端口：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&#x27;</span> <span class="literal">-name</span> <span class="string">&quot;PortNumber&quot;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PortNumber   : <span class="number">3389</span></span><br><span class="line">PSPath       : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP<span class="literal">-Tcp</span></span><br><span class="line">PSParentPath : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations</span><br><span class="line">PSChildName  : RDP<span class="literal">-Tcp</span></span><br><span class="line">PSDrive      : HKLM</span><br><span class="line">PSProvider   : Microsoft.PowerShell.Core\Registry</span><br></pre></td></tr></table></figure>

<p>还可运行以下 PowerShell 命令来更改 RDP 端口。 在此命令中，我们会将新的 RDP 端口指定为 3390。</p>
<p>若要向注册表添加新的 RDP 端口：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$portvalue</span> = <span class="number">3390</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&#x27;</span> <span class="literal">-name</span> <span class="string">&quot;PortNumber&quot;</span> <span class="literal">-Value</span> <span class="variable">$portvalue</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">New-NetFirewallRule</span> <span class="literal">-DisplayName</span> <span class="string">&#x27;RDPPORTLatest-TCP-In&#x27;</span> <span class="literal">-Profile</span> <span class="string">&#x27;Public&#x27;</span> <span class="literal">-Direction</span> Inbound <span class="literal">-Action</span> Allow <span class="literal">-Protocol</span> TCP <span class="literal">-LocalPort</span> <span class="variable">$portvalue</span> </span><br><span class="line"><span class="built_in">New-NetFirewallRule</span> <span class="literal">-DisplayName</span> <span class="string">&#x27;RDPPORTLatest-UDP-In&#x27;</span> <span class="literal">-Profile</span> <span class="string">&#x27;Public&#x27;</span> <span class="literal">-Direction</span> Inbound <span class="literal">-Action</span> Allow <span class="literal">-Protocol</span> UDP <span class="literal">-LocalPort</span> <span class="variable">$portvalue</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>RDP</tag>
      </tags>
  </entry>
  <entry>
    <title>本地无法与远程桌面进行粘贴复制交互</title>
    <url>//%E6%9C%AC%E5%9C%B0%E6%97%A0%E6%B3%95%E4%B8%8E%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E7%B2%98%E8%B4%B4%E5%A4%8D%E5%88%B6%E4%BA%A4%E4%BA%92.html</url>
    <content><![CDATA[<p>问题如题，解决办法如下：</p>
<h1 id="1-检查本地远程桌面是否勾选了剪贴板"><a href="#1-检查本地远程桌面是否勾选了剪贴板" class="headerlink" title="1. 检查本地远程桌面是否勾选了剪贴板"></a>1. 检查本地远程桌面是否勾选了剪贴板</h1><ol>
<li><p>打开远程桌面连接，在对话框的左下角找到 <code>显示选项</code> 点开；</p>
</li>
<li><p>找到 <code>本地资源</code> 栏，在 <code>本地设备和资源</code> 处查看 <code>剪贴板</code> 是否勾选。</p>
<ul>
<li>默认应该是勾选的，如果勾选了，则进行下一项检查；</li>
<li>如果没有勾选，则进行勾选。然后测试。</li>
</ul>
<p><img src="/%E6%9C%AC%E5%9C%B0%E6%97%A0%E6%B3%95%E4%B8%8E%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E7%B2%98%E8%B4%B4%E5%A4%8D%E5%88%B6%E4%BA%A4%E4%BA%92/rdp-clip-1.jpg"></p>
</li>
</ol>
<h1 id="2-重启远程主机的rdpclip-exe-服务"><a href="#2-重启远程主机的rdpclip-exe-服务" class="headerlink" title="2. 重启远程主机的rdpclip.exe 服务"></a>2. 重启远程主机的<code>rdpclip.exe</code> 服务</h1><ol>
<li><p>进入远程主机，在其任务栏的随便一块空白处右击鼠标，选择<code>启动任务管理器</code>；</p>
</li>
<li><p>在任务管理器的<code>进程</code> 栏找到 <code>rdpclip.exe</code> （或者是 <code>RDP 剪贴板监视程序</code> ）服务，然后鼠标右击<code>结束任务</code>，或点击右下角的 <code>结束任务</code>；</p>
<blockquote>
<p>注意，如果是 Windows Server 多用户登录，结束进程前注意其所属用户。</p>
</blockquote>
</li>
<li><p>点击任务管理器左上角的<code>文件(F)</code>，选择 <code>运行新任务</code>，在弹出的对话框中，输入 <code>rdpclip.exe</code>  ，然后回车。重新运行一个进程。</p>
</li>
<li><p>测试粘贴复制功能是否ok。</p>
<p><img src="/%E6%9C%AC%E5%9C%B0%E6%97%A0%E6%B3%95%E4%B8%8E%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E7%B2%98%E8%B4%B4%E5%A4%8D%E5%88%B6%E4%BA%A4%E4%BA%92/rdp-clip-2.jpg"></p>
</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/XiaoXiao_RenHe/article/details/86610630">远程桌面无法和本地复制粘贴解决方法——rdpclip.exe进程结束后又重启</a></p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>远程桌面</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记本win10系统禁用自带键盘</title>
    <url>//%E7%AC%94%E8%AE%B0%E6%9C%ACwin10%E7%B3%BB%E7%BB%9F%E7%A6%81%E7%94%A8%E8%87%AA%E5%B8%A6%E9%94%AE%E7%9B%98.html</url>
    <content><![CDATA[<p>找到命令提示符（cmd），并且右键以管理员身份运行。<br>在弹出的窗口中将下面这段代码输入进去，并且回车。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc config i8042prt start= disabled</span><br></pre></td></tr></table></figure>
<p>重启，笔记本自带键盘关闭</p>
<blockquote>
<p>注意 disabled 前的空格</p>
</blockquote>
<p>如果想恢复，只要以同样方法输入下面这个代码，重启即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc config i8042prt start= auto</span><br><span class="line">或者</span><br><span class="line">sc config i8042prt start= demand</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>扩容未分区磁盘文件系统</title>
    <url>//%E6%89%A9%E5%AE%B9%E6%9C%AA%E5%88%86%E5%8C%BA%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<h1 id="Linux系统扩容数据盘时，如何扩展未分区磁盘文件系统"><a href="#Linux系统扩容数据盘时，如何扩展未分区磁盘文件系统" class="headerlink" title="Linux系统扩容数据盘时，如何扩展未分区磁盘文件系统"></a>Linux系统扩容数据盘时，如何扩展未分区磁盘文件系统</h1><h4 id="操作场景"><a href="#操作场景" class="headerlink" title="操作场景"></a>操作场景</h4><p>当数据盘没有创建分区，只在设备上创建了文件系统，您可以参考本节直接扩展文件系统。</p>
<p>如下所示，数据盘<code>/dev/vdb</code>没有创建分区，只在设备上创建了文件系统。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@dataservice ~]# lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">vda    253:0    0  100G  0 disk</span><br><span class="line">└─vda1 253:1    0  100G  0 part /</span><br><span class="line">vdb    253:16   0  2.2T  0 disk /opt</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@dataservice ~]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1       100G   41G   60G  41% /</span><br><span class="line">devtmpfs         16G     0   16G   0% /dev</span><br><span class="line">/dev/vdb        500G  170G  331G  34% /opt</span><br></pre></td></tr></table></figure>

<p>上面的内容是，</p>
<p>操作内容具体参考</p>
<p><a href="https://support.huaweicloud.com/evs_faq/evs_faq_0073.html#evs_faq_0073__zh-cn_topic_0241810111_zh-cn_topic_0240716537_section1248016813484">https://support.huaweicloud.com/evs_faq/evs_faq_0073.html#evs_faq_0073__zh-cn_topic_0241810111_zh-cn_topic_0240716537_section1248016813484</a></p>
<p>涉及内容：</p>
<ul>
<li>扩展 ext* 文件系统<ul>
<li>使用命令：<code>resize2fs 磁盘名称</code></li>
</ul>
</li>
<li>扩展 xfs 文件系统<ul>
<li>使用命令：<code>xfs_growfs 磁盘名称</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>云平台</category>
        <category>磁盘</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展磁盘的分区和文件系统</title>
    <url>//%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E5%8C%BA%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<p>常规磁盘为先做分区，在对分区做文件系统。</p>
<p><a href="https://support.huaweicloud.com/bestpractice-evs/evs_02_0026.html">https://support.huaweicloud.com/bestpractice-evs/evs_02_0026.html</a></p>
]]></content>
      <categories>
        <category>云平台</category>
        <category>磁盘</category>
      </categories>
      <tags>
        <tag>云平台</tag>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>//nginx.html</url>
    <content><![CDATA[<p>找到 nginx 执行程序所在目录</p>
<p>以下样例均使用 <code>/opt/nginx/sbin/nginx</code> 文件路径。</p>
<h1 id="检测配置文件语法是否正确"><a href="#检测配置文件语法是否正确" class="headerlink" title="检测配置文件语法是否正确"></a>检测配置文件语法是否正确</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ioc-nginx ~]# /opt/nginx/sbin/nginx -t /opt/nginx/conf/nginx.conf</span><br><span class="line">结果返回</span><br><span class="line">nginx: the configuration file /opt/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /opt/nginx/conf/nginx.conf test is successful</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果所有文件都是使用默认安装位置，也可以直接 <strong><code>nginx -t</code></strong> ,会自动寻找到默认位置的配置文件。 <code>/usr/local/nginx/conf/nginx.conf</code> 或 <code>/etc/nginx/nginx.conf</code></p>
</blockquote>
<h1 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ioc-nginx ~]# /opt/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代理转发</category>
      </categories>
      <tags>
        <tag>代理转发</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习杂记</title>
    <url>//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9D%82%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="机器学习杂记"><a href="#机器学习杂记" class="headerlink" title="机器学习杂记"></a>机器学习杂记</h1><p>Machine Learning</p>
<h2 id="机器学习需要解决的问题："><a href="#机器学习需要解决的问题：" class="headerlink" title="机器学习需要解决的问题："></a>机器学习需要解决的问题：</h2><p>如何让计算机可以跟人类一样从历史的经验中获取新的知识？</p>
<p>任务T：</p>
<p>经验E：即历史数据&#x2F;训练数据</p>
<p>效果P: 正确率&#x2F;预期效果</p>
<p>特征feature：</p>
<p>从数据中抽取的对<code>分类结果</code>可能有影响的因素，每一个因素成为一个特征</p>
<p>算法：</p>
<p>深度学习解决的核心问题之一：</p>
<p>自动地将简单的特征组合成更加复杂的特征，并使用这些组合特征解决问题。</p>
<p>深度学习是机器学习的一个分支</p>
<p>人工智能，机器学习，深度学习三者之间的关系：</p>
<p>{人工智能，{机器学习，{深度学习}}}</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-compose学习</title>
    <url>//Docker-compose%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="Docker-Compose-文件解释"><a href="#Docker-Compose-文件解释" class="headerlink" title="Docker Compose 文件解释"></a>Docker Compose 文件解释</h1><p>Compose 文件是一个 YAML 格式的文件，</p>
<ul>
<li>后缀可以为 <code>.yml</code> 或 <code>.yaml</code></li>
</ul>
<p>有三个 Top-level 顶级 key ：(其他 key 都是这三个 key 的子主题 sub-topics)</p>
<ul>
<li>services</li>
<li>networks</li>
<li>volumes</li>
</ul>
<p>默认命名文件为： <code>docker-compose.yml</code></p>
<ul>
<li>这样 docker-compose up -d 时，会自动读取所在目录下的该文件；</li>
</ul>
<h2 id="services"><a href="#services" class="headerlink" title="services"></a>services</h2><p>services 的作用：</p>
<p>定义服务启动需要的配置，这些配置作用于服务所在容器上。</p>
<ul>
<li><p>需要自定义一个服务名，可以通过指定服务名来启动特定服务。</p>
</li>
<li><p>可以定义多个 service；</p>
</li>
</ul>
<p>compose 文件中支持使用 环境变量替换</p>
<p>具体查看后面章节</p>
<p><strong>image</strong></p>
<p>指定启动容器需要的镜像</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最新版本</span></span><br><span class="line">image: redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定特定版本的镜像</span></span><br><span class="line">image: ubuntu:22.04</span><br></pre></td></tr></table></figure>



<p><strong>container_name</strong></p>
<p>自定义容器名，而不是默认生成。</p>
<ul>
<li>如果不通过该 key 自定义一个容器名，那么 docker-compose 启动的容器会自动生成一个容器名。</li>
</ul>
<p><strong>command</strong></p>
<p>会覆盖 image 的默认命令，当需要覆盖 container 启动后的默认命令时设置该 key。</p>
<p>语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command: 命令</span><br></pre></td></tr></table></figure>

<p>样例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command: </span><br></pre></td></tr></table></figure>



<p><strong>depends_on</strong></p>
<p>表示服务间的依赖关系。</p>
<ul>
<li><code>docker-compose up</code> 启动时，会根据依赖关系启动服务，例如，<code>db</code> 和 <code>redis</code> 会在 <code>web</code> 之前启动；</li>
<li><code>docker-compose up SERVICE</code> 启动服务时，会自动启动服务的依赖，例如，<code>docker-compose up web</code> 时会自动创建并启动 <code>db</code> 和 <code>redis</code>；</li>
<li><code>docker-compose stop</code> 停止服务时，会根据依赖顺序反向停止服务。例如，<code>web</code> 会先停止，然后才是 <code>db</code> 和 <code>redis</code>；</li>
</ul>
<p>依赖的样例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>labels</strong></p>
<ul>
<li><p>添加 metadata 到指定的image中，用于启动 container 。</p>
<ul>
<li><p>就像是命令行程序及支持配置文件，又支持指定命令行参数一样；</p>
</li>
<li><p>key 推荐使用反向DNS表示法；</p>
</li>
<li><p>有两种书写方式：</p>
<ul>
<li>array</li>
<li>dictionary</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.example.department: <span class="string">&quot;Finance&quot;</span></span><br><span class="line">  xxxx: <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">  </span><br><span class="line">labels:</span><br><span class="line">  - <span class="string">&quot;com.example.department=Finance&quot;</span></span><br><span class="line">  - <span class="string">&quot;xxxx=xxx&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>entrypoint</strong></p>
<p>覆盖 image 的默认 entrypoint，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br><span class="line">或者使用 list 的形式,类似于 Dockerfile 文件格式</span><br><span class="line">entrypoint: [&quot;php&quot;, &quot;-d&quot;, &quot;memory_list=-1&quot;,&quot;vender/bin/entrypoint&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，设置 entrypoint 既可以覆盖 image 在 Dockerfile 设置的默认 entrypoint，又可以清除 image 中设置的所有命令（即当 Dockerfile 中设置了 <code>CMD</code>，如果设置了 entrypoint 这个 key 后，文件中设置的 <code>CMD</code> 命令会被清除）。</p>
</blockquote>
<p><strong>env_file</strong></p>
<p>指定环境变量所在文件，可以是单个文件，也可以是 list。</p>
<blockquote>
<p>注意，当通过 docker-compose -f FILE 指定 compose 文件时，<code>env_file</code> 的文件需要是相对于 compose 文件的相对路径。</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">env_file: .<span class="keyword">env</span></span><br><span class="line"></span><br><span class="line">或者是 list</span><br><span class="line">env_file:</span><br><span class="line">  - ./common.<span class="keyword">env</span></span><br><span class="line">  - ./apps/web.<span class="keyword">env</span></span><br><span class="line">  - /opt/runtime_opts.<span class="keyword">env</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>env 文件的格式为：</p>
<p>KEY&#x3D;value 的形式，一行一个，</p>
<p><code>#</code> 号后的内容为注释，</p>
<p>空行忽略，</p>
<p>注，如果值需要有特殊字符例如<code>#</code>，那么整个 value 需要使用双引号<code>&quot;&quot;</code> 包裹起来。</p>
</blockquote>
<blockquote>
<p>注意： 如果 env_file 的值是一个 list ，那么需要注意文件的加载顺序，从上到下加载，如果不同文件出现相同的 变量 KEY，那么后面出现的值会覆盖前面出现的值。</p>
</blockquote>
<p><strong>environment</strong></p>
<p>与 env_file 的效果一样，添加环境变量，不过这里是通过 map 形式或者 array 形式。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map 的形式 key:value</span></span><br><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  <span class="comment"># 注意，如果是 boolean 值，即 true，false，yes，no，需要使用括号包裹起来，防止 YAML 解析器将其解析成 True 或 False 的形式。</span></span><br><span class="line">  SHOW: <span class="string">&#x27;true&#x27;</span></span><br><span class="line">  SESSION_SECRET:</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># array 的形式 key=value</span></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SHOW=true</span><br><span class="line">  - SESSION_SECRET</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>expose</strong></p>
<p>暴露端口，但是仅用于 linked 服务可以访问，并不对宿主机暴露，仅用于内部端口访问？</p>
<ul>
<li>问题：这与处于相同 network 不对外暴露的区别是什么？</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expose:</span><br><span class="line">  - &quot;3000&quot;</span><br><span class="line">  - &quot;8000&quot;</span><br></pre></td></tr></table></figure>



<p><strong>external_links</strong></p>
<p>链接到在该 docker-compose 之外启动的容器。特别是对于提供共享或公共服务的容器。</p>
<ul>
<li><p>主要作用是<strong>容器间通信</strong>。</p>
</li>
<li><p>与 links 作用类似，作用范围不同。</p>
<ul>
<li>links 是同一个 docker-compose 文件中的 services 之间链接；</li>
<li>external_links 是链接外部容器；</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">external_links:</span><br><span class="line">  - redis_1</span><br><span class="line">  - project_db_1:mysql</span><br><span class="line">  - project_db_1:postgresql</span><br></pre></td></tr></table></figure>



<ul>
<li>如果使用 network，所有主机加入相同的 network，则可以不使用 links 方式了。</li>
</ul>
<p><strong>extra_hosts</strong></p>
<p>在启动容器的 <code>/etc/hosts</code> 文件中添加域名解析映射。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line">  - &quot;somehost:162.242.195.82&quot;</span><br><span class="line">  - &quot;otherhost:50.31.209.229&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>networks</strong></p>
<p>使容器加入指定的网络，使用的 value 为顶级 key <code>networks</code> 中定义的网络。</p>
<ul>
<li>可以添加多个网络；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br></pre></td></tr></table></figure>



<p>ipv4_address,ipv6_address</p>
<p>允许当容器加入到指定 network 时，给容器设定静态 IP 地址。</p>
<p>同时，需要在顶级key networks 章节添加 <code>ipam</code> 块，保证设置的子网包含指定的静态 IP 地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.9&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    networks:</span><br><span class="line">      app_net:</span><br><span class="line">        ipv4_address: 172.16.238.10</span><br><span class="line">        ipv6_address: 2001:3984:3989::10</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  app_net:</span><br><span class="line">    ipam:</span><br><span class="line">      driver: default</span><br><span class="line">      config:</span><br><span class="line">        - subnet: &quot;172.16.238.0/24&quot;</span><br><span class="line">        - subnet: &quot;2001:3984:3989::/64&quot;</span><br></pre></td></tr></table></figure>



<p><strong>ports</strong></p>
<p>对外暴露端口</p>
<blockquote>
<p>注意，端口映射不支持 <code>network_mode: host</code>。</p>
</blockquote>
<blockquote>
<p>运行 <code>docker-compose run</code> 命令时，需要指定 <code>--service-ports</code>， 否则会忽略 <code>ports</code> 参数设置。</p>
</blockquote>
<p>有两种书写形式，short 语法 和 long 语法</p>
<p>short syntax:</p>
<ul>
<li>指定端口（<code>HOST:CONTAINER</code>）;</li>
<li>仅指定容器的端口（此时主机端口是非固定端口）；</li>
<li>指定<code>主机IP地址:端口</code>，<code>IPADDR:HOSTPORT:CONTAINERPORT</code> 。如果<code>HOSTPORT</code> 为空，例如（<code>127.0.0.1::80</code>），此时主机端口也是非固定的。</li>
</ul>
<blockquote>
<p>注意，因为 YAML 解析器的<code>xx:yy</code> 的形式是基于 60 的，端口绑定时 &lt; 60 会出现异常，所以建议所有端口绑定时，使用字符串形式。</p>
</blockquote>
<p>样例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ports:</span><br><span class="line">  - &quot;3000&quot;</span><br><span class="line">  - &quot;3000-3005&quot;</span><br><span class="line">  - &quot;8000:8000&quot;</span><br><span class="line">  - &quot;9090-9091:8080-8081&quot;</span><br><span class="line">  - &quot;49100:22&quot;</span><br><span class="line">  - &quot;127.0.0.1:8001:8001&quot;</span><br><span class="line">  - &quot;127.0.0.1:5000-5010:5000-5010&quot;</span><br><span class="line">  - &quot;127.0.0.1::5000&quot;</span><br><span class="line">  - &quot;6060:6060/udp&quot;</span><br><span class="line">  - &quot;12400-12500:1240&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="Docker-compose-使用默认的-bridge-网络"><a href="#Docker-compose-使用默认的-bridge-网络" class="headerlink" title="Docker compose 使用默认的 bridge 网络"></a>Docker compose 使用默认的 bridge 网络</h1><p><strong>结论</strong>：compose 中的 service <strong>无法使用默认的 bridge</strong> 网络进行通信，<strong>必须使用用户自定义的网络</strong>，外部定义或者 compose 中定义均可。</p>
<p><strong>报错</strong>：compose 中使用 docker 默认的 bridge 网络，会出现如下报错：</p>
<blockquote>
<p>Network-scoped alias is supported only for containers in user defined networks</p>
</blockquote>
<p><strong>原因</strong>：</p>
<ol>
<li>compose 依赖网络范围的别名，如果使用外部的 bridge 网络，compose 仍然会尝试设置别名，但是网络别名只能设置在用户定义的网络上，默认的网络是不能设置别名的，所以会报错。</li>
<li>如果打算设置 <code>network_mode</code>  来关闭 compose 内置的别名功能，也是不行的，因为默认的 bridge 中无法设置别名，同时也不存在默认的别名，service 间的网络通信依赖于别名，所以依然行不通。</li>
</ol>
<h1 id="常用-docker-compose-命令"><a href="#常用-docker-compose-命令" class="headerlink" title="常用 docker-compose 命令"></a>常用 docker-compose 命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@www:/home/spoon/devops/docker-traefik# docker-compose stop</span><br><span class="line">Stopping docker-traefik_whoami_1 ... done</span><br><span class="line">root@www:/home/spoon/devops/docker-traefik# docker-compose rm</span><br><span class="line">Going to remove docker-traefik_reverse-proxy_1, docker-traefik_whoami_1</span><br><span class="line">Are you sure? [yN] y</span><br><span class="line">Removing docker-traefik_reverse-proxy_1 ... done</span><br><span class="line">Removing docker-traefik_whoami_1        ... done</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@www:/home/spoon/devops/docker-outline-main# docker network ls</span><br><span class="line">NETWORK ID     NAME           DRIVER    SCOPE</span><br><span class="line">6d5a02e468d1   bridge         bridge    local</span><br><span class="line">8d594ba232c7   host           host      local</span><br><span class="line">224c32b61f84   none           null      local</span><br><span class="line">cc728494b8a4   traefik_ipv6   bridge    local</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@www:/home/spoon/devops/docker-outline-main# docker network rm traefik_ipv6</span><br><span class="line">traefik_ipv6</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@www:/home/spoon/devops/docker-outline-main# docker network create -d bridge --ipv6 --subnet &quot;fd00:db8:ddee::/80&quot; outline</span><br><span class="line">1acbe0461302b6856c5c1ed79c54fc0f452d4eae16f695c0fc9a3228b2266067</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@www:/home/spoon/devops/docker-outline-main# docker network inspect outline</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;outline&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;1acbe0461302b6856c5c1ed79c54fc0f452d4eae16f695c0fc9a3228b2266067&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-05-05T16:48:48.584158563+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: true,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.21.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.21.0.1&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;fd00:db8:ddee::/80&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-win使用遇到问题</title>
    <url>//Docker-win%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="Windows-Docker-启动容器报端口没有访问权限"><a href="#Windows-Docker-启动容器报端口没有访问权限" class="headerlink" title="Windows Docker 启动容器报端口没有访问权限"></a>Windows Docker 启动容器报端口没有访问权限</h2><p>在 win10 上启动 Docker Desktop 上的 Postgres 容器时，遇到报错，部分内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exposing port TCP 0.0.0.0:5432 -&gt; 0.0.0.0:0: listen tcp 0.0.0.0:5432: bind: An attempt was made to access a socket in a way forbidden by its access permissions.</span><br></pre></td></tr></table></figure>

<p>最近都没有怎么动这环境。</p>
<p>可能解决方法，参考如下<a href="https://github.com/docker/for-win/issues/3171#issuecomment-902533563">此处链接</a>，该链接讨论了多种解决方案，均可尝试。</p>
<p>总结起来大概是因为 Hyper-V 动态的保留了一些端口，导致无法使用，在实际使用中这些端口会动态增加，在预留列表中的端口其他进程就无法使用。</p>
<p>最终我使用了如下方法：</p>
<ol>
<li>在 powershell 中使用如下命令查看本地的保留端口：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 show excludedportrange protocol=tcp</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果需要使用的端口在其中某一段中，那么停止 <code>winnat</code> 服务：</p>
<blockquote>
<p>注意，步骤2-4需要使用管理员权限操作，即右击以管理员身份运行。否则会提示“拒绝访问”，或 “没有权限”。</p>
</blockquote>
</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net stop winnat</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将你需要使用的端口段从保留端口中删除，样例如下：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netsh int ipv4 delete excludedportrange protocol=tcp startport=<span class="number">3273</span> numberofports=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重启 <code>winnat</code> 服务：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net <span class="built_in">start</span> winnat</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>最后可以再查看一下本地的保留端口：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 show excludedportrange protocol=tcp</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意，电脑重启后，重新查看本地保留端口，会发现有新增的端口。</p>
</blockquote>
<h2 id="操作过程可能遇到的问题"><a href="#操作过程可能遇到的问题" class="headerlink" title="操作过程可能遇到的问题"></a>操作过程可能遇到的问题</h2><p>在删除端口段时可能遇到下面报错。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Windows\system32&gt; netsh int ipv4 delete excludedportrange protocol=tcp startport=<span class="number">3928</span> numberofports=<span class="number">100</span></span><br><span class="line">找不到元素。</span><br></pre></td></tr></table></figure>

<p>不受影响，此时会将多余的端口段全部删除，仅保留默认保留的。继续后续操作，因为列表中的端口是预留的，不会有什么影响。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Windows\system32&gt; netsh interface ipv4 show excludedportrange protocol=tcp</span><br><span class="line"></span><br><span class="line">协议 tcp 端口排除范围</span><br><span class="line"></span><br><span class="line">开始端口    结束端口</span><br><span class="line"><span class="literal">----------</span>    <span class="literal">--------</span></span><br><span class="line">      <span class="number">3310</span>        <span class="number">3408</span>     *</span><br><span class="line">     <span class="number">50000</span>       <span class="number">50059</span>     *</span><br><span class="line"></span><br><span class="line">* - 管理的端口排除。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker配置支持IPv6</title>
    <url>//Docker%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81IPv6.html</url>
    <content><![CDATA[<h1 id="开启-IPv6-支持"><a href="#开启-IPv6-支持" class="headerlink" title="开启 IPv6 支持"></a>开启 IPv6 支持</h1><p>默认情况下，docker 默认仅默认开启了 IPv4 支持，如果需要启动 IPv6，配置 docker 守护进程对 IPv6 的支持。</p>
<blockquote>
<p>注意，IPv6 网络仅支持运行在 Linux 主机上。</p>
</blockquote>
<p>配置步骤：</p>
<ol>
<li><p>编辑 <code>/etc/docker/daemon.json</code>，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ipv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  # 开启 IPv6 支持</span><br><span class="line">  <span class="attr">&quot;fixed-cidr-v6&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fd00::/80&quot;</span>  #设置子网范围，可用长度至少为<span class="number">80</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 docker 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://docs.docker.com/config/daemon/ipv6/">官网文档</a> 说 reload 也是可以的，但是我使用时好像有点问题，这个后面再验证。</p>
</blockquote>
</li>
<li><p>查看默认网桥网络状态是否开启了 IPv6 是否有了 gateway 地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure>

<p>重点内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">		&quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: true,   # 确认开启 IPv6</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                # 同时又子网和网关信息</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;fd00::/80&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;fd00::1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="创建自定义-IPv6-网络"><a href="#创建自定义-IPv6-网络" class="headerlink" title="创建自定义 IPv6 网络"></a>创建自定义 IPv6 网络</h1><h1 id="容器的-IPv6-信息"><a href="#容器的-IPv6-信息" class="headerlink" title="容器的 IPv6 信息"></a>容器的 IPv6 信息</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;6bfaa6bcccaf6383bbeb9c4ed2b10951776dee6268455e6830325ea1cc3216fa&quot;: &#123;</span><br><span class="line">    &quot;Name&quot;: &quot;webtest&quot;,</span><br><span class="line">    &quot;EndpointID&quot;: &quot;fbd4d766bba0185c38db930d3902d92b65adf1f9918dd225047c5455d7567908&quot;,</span><br><span class="line">    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">    &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">    &quot;IPv6Address&quot;: &quot;fd00::242:ac11:2/80&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上面的 IPv6Address 和 MacAddress 内容可以看到，docker 容器中的 IPv6 地址的生成方式是通过绑定容器 Mac 地址产生的，避免冲突。</p>
<p>同时也就知道为什么建议是80了，因为 Mac 地址转换为 IPv6 地址正好是 3 段，长度 3 * 16 &#x3D; 48 。</p>
</blockquote>
]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>docker</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker从入门到放弃</title>
    <url>//Docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83.html</url>
    <content><![CDATA[<h1 id="Docker从入门到放弃"><a href="#Docker从入门到放弃" class="headerlink" title="Docker从入门到放弃"></a>Docker从入门到放弃</h1><p>这部分内容，除了搭建docker私有仓库后，可以访问本地image外，默认都是访问了<a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上的镜像</p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><h2 id="docker镜像常用操作"><a href="#docker镜像常用操作" class="headerlink" title="docker镜像常用操作"></a>docker镜像常用操作</h2><h4 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式：详细命令查看docker images --<span class="built_in">help</span> ?</span></span><br><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出本地images</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以使用, 因为image是docker的镜像管理命令，更多命令查看： docker image --<span class="built_in">help</span></span></span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure>



<h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>之前提到 <a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 上有很多高质量镜像可以直接使用。</p>
<p>从Docker镜像仓库获取镜像，使用<code>docker pull</code>,命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]镜像名称[:标签]</span><br></pre></td></tr></table></figure>

<p>具体的选项可以通过<code>docker pull --help</code> 帮助命令查看。具体例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从仓库中获取alpine的最新版本，默认没有标签时，就是最新的lastest</span></span><br><span class="line">docker pull alpine  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从仓库中获取ubuntu 18.04版本</span></span><br><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure>



<h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><p>可以在<a href="https://hub.docker.com/search?q=&type=image">Docker Hub</a> 仓库中搜索需要的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure>

<p>样例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索仓库中Mysql镜像</span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只显示stars&gt;=600的镜像</span></span><br><span class="line">docker search --filter stars=600 mysql</span><br></pre></td></tr></table></figure>



<h4 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h4><p>删除本地镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更具体的命令查看docker rmi --<span class="built_in">help</span></span></span><br><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>

<p>样例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除redis本地镜像</span></span><br><span class="line">docker rmi redis</span><br></pre></td></tr></table></figure>



<h4 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h4><p>这部分内容请查看 <a href="#%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F">制作docker镜像</a> 章节</p>
<h2 id="docker容器常用操作"><a href="#docker容器常用操作" class="headerlink" title="docker容器常用操作"></a>docker容器常用操作</h2><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>有两种启动容器的方法，</p>
<ol>
<li><p>基于镜像新建一个容器并启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用run命令</span></span><br><span class="line">docker run --help</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">docker run alpine /bin/echo &#x27;Hello world&#x27;</span><br><span class="line">等同于 在shell界面执行 echo &#x27;Hello world&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 以交互式模式运行，-t 为容器重新分配一个伪输入终端并绑定到容器的标准输入上，运行/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样容器启动后就会出现一个bash命令行</span></span><br><span class="line">docker run -it mysql /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用docker run来创建容器时,Docker在后台的操作流程包括：</p>
<ol>
<li>检查本地是否存在指定的镜像，不存在就从registry下载；</li>
<li>利用镜像创建并启动一个容器；</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层；</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去；</li>
<li>从地址池配置一个ip地址给容器；</li>
<li>执行用户指定的应用程序；</li>
</ol>
</blockquote>
</li>
<li><p>将在终止状态(<code>exited</code>)的容器重启启动（Exited状态可以通过<code>docker ps -a</code>命令看到）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法一：可以直接使用start/restart 命令来启动，详细使用方法查看<span class="built_in">help</span>帮助</span></span><br><span class="line">docker start/restart --help</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法二：使用docker的container管理命令来启动</span></span><br><span class="line">docker container start --help</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器<span class="built_in">id</span>为a24a4cb23b6d的容器</span></span><br><span class="line">docker restart a24a4cb23b6d</span><br><span class="line"></span><br><span class="line">docker container start a24a4cb23b6d</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="进入-x2F-退出容器"><a href="#进入-x2F-退出容器" class="headerlink" title="进入&#x2F;退出容器"></a>进入&#x2F;退出容器</h4><ol>
<li><p>在创建启动时进入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it &lt;容器ID/容器名&gt; /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明：如果使用<span class="built_in">exit</span>命令，会关闭当前会话并停止容器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用快捷键 Ctrl + p + q , 可以仅退出当前会话，不停掉容器</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>进入一个正在后台运行的容器（推荐）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it &lt;容器ID/容器名&gt; /bin/bash</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">docker exec -it a24a4cb23b6d /bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">说明：使用<span class="built_in">exec</span> -it的形式， 会出现一个shell交互界面，这样即使使用<span class="built_in">exit</span>命令，也仅是退出当前交互页面，并不会停掉容器</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q：为什么<code>attach</code>会卡住？</p>
<p>A：因为-d 守护模式下，container运行的进程不是shell，也没有虚拟终端tty参数，所以进不去</p>
</blockquote>
</li>
</ol>
<h4 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志的详细帮助</span></span><br><span class="line">docker logs --help</span><br><span class="line">--docker version 的1.13.1没有 --until参数，version的20.10.17有参数。</span><br><span class="line"></span><br><span class="line">docker logs [OPTIONS] CONTAINER</span><br><span class="line">  Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow log output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span><br><span class="line">  -n, --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 翻译：</span></span></span><br><span class="line">        --details        显示更多的信息</span><br><span class="line">    -f, --follow         跟踪实时日志</span><br><span class="line">        --since string   显示自某个timestamp (e.g. 2013-01-02T13:23:37Z)之后的日志，或相对时间 (e.g. 42m for 42 minutes)</span><br><span class="line">        --tail string    从日志末尾显示多少行日志， 默认是all</span><br><span class="line">    -t, --timestamps     显示时间戳</span><br><span class="line">        --until string   显示自某个timestamp (e.g. 2013-01-02T13:23:37Z) 之前的日志，或相对时间 (e.g. 42m for 42 minutes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以追加的方式，查看容器a24a4cb23b6d的日志</span></span><br><span class="line">docker logs -f a24a4cb23b6d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定时间后的日志，只显示最后100行</span></span><br><span class="line">docker logs -f -t --since=&quot;2022-09-10&quot; --tail=100 a24a4cb23b6d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看最近30min的日志</span></span><br><span class="line">docker logs --since 30m a24a4cb23b6d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某时间之后的日志</span></span><br><span class="line">docker logs -t --since=&quot;2022-09-10T10:13:37&quot; a24a4cb23b6d</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 常规日志</span></span></span><br><span class="line">2022-09-06T06:00:15.959093Z 221901 [Note] Access denied for user &#x27;root&#x27;@&#x27;172.17.0.1&#x27; (using password: YES)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 添加-t参数后的日志，会多展示一列有时区的时间格式，并不是linux时间戳。</span></span></span><br><span class="line">2022-09-06T06:00:15.959884000Z 2022-09-06T06:00:15.959093Z 221901 [Note] Access denied for user &#x27;root&#x27;@&#x27;172.17.0.1&#x27; (using password: YES)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某时间段的日志</span></span><br><span class="line">docker logs -t --since=&quot;2022-09-09T10:13:37&quot; --until &quot;2022-09-10T12:23:37&quot; a24a4cb23b6d</span><br></pre></td></tr></table></figure>



<h4 id="容器与主机间数据copy"><a href="#容器与主机间数据copy" class="headerlink" title="容器与主机间数据copy"></a>容器与主机间数据copy</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看<span class="built_in">cp</span>的详细帮助</span></span><br><span class="line">docker cp --help</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 a24a4cb23b6d 容器中的文件copy至本地路径</span></span><br><span class="line">docker cp a24a4cb23b6d:/[container_path] [local_path]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将主机文件copy至 a24a4cb23b6d 容器</span></span><br><span class="line">docker cp [local_path] a24a4cb23b6d:/[container_path]/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将主机文件copy至 a24a4cb23b6d 容器，目录重命名为[container_path]（注意与非重命名copy的区别）</span></span><br><span class="line">docker cp [local_path] a24a4cb23b6d:/[container_path]</span><br></pre></td></tr></table></figure>



<h4 id="查看正在运行与历史运行的容器"><a href="#查看正在运行与历史运行的容器" class="headerlink" title="查看正在运行与历史运行的容器"></a>查看正在运行与历史运行的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ps的详细帮助</span></span><br><span class="line">docker ps --help</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看正在运行的所有容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有运行过的容器</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h4 id="查看容器的元信息"><a href="#查看容器的元信息" class="headerlink" title="查看容器的元信息"></a>查看容器的元信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看inspect的详细帮助</span></span><br><span class="line">docker inspcet --help</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看a24a4cb23b6d容器的元信息</span></span><br><span class="line">docker inspect a24a4cb23b6d</span><br></pre></td></tr></table></figure>

<h4 id="获取所有容器名称及其IP地址"><a href="#获取所有容器名称及其IP地址" class="headerlink" title="获取所有容器名称及其IP地址"></a>获取所有容器名称及其IP地址</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect -f &#x27;&#123;&#123; .Name &#125;&#125; - &#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; $(docker ps -aq)</span><br><span class="line"></span><br><span class="line">-f &#x27;xxx&#x27; 与 --format &#x27;xxx&#x27; 效果相同</span><br></pre></td></tr></table></figure>



<h4 id="停止并删除容器"><a href="#停止并删除容器" class="headerlink" title="停止并删除容器"></a>停止并删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop --help</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span></span><br><span class="line">docker rm --help</span><br></pre></td></tr></table></figure>



<h2 id="docker数据存储"><a href="#docker数据存储" class="headerlink" title="docker数据存储"></a>docker数据存储</h2><h2 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h2><h2 id="docker-compose配置及操作"><a href="#docker-compose配置及操作" class="headerlink" title="docker compose配置及操作"></a>docker compose配置及操作</h2><h2 id="制作docker镜像"><a href="#制作docker镜像" class="headerlink" title="制作docker镜像"></a>制作docker镜像</h2><h2 id="docker私有仓库"><a href="#docker私有仓库" class="headerlink" title="docker私有仓库"></a>docker私有仓库</h2>]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox启动虚拟机报错</title>
    <url>//VirtualBox%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%A5%E9%94%99.html</url>
    <content><![CDATA[<p>在Windows 10 机器上安装docker之后，之前安装的 VirtualBox 虚拟机启动不了了。报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VT-x is not available (VERR_VMX_NO_VMX)</span><br></pre></td></tr></table></figure>



<p>通常出现这问题主要有四种原因：</p>
<ol>
<li><p>你的<code>CPU</code>不支持<code>VT-x</code> 或 <code>AMD-V</code> </p>
</li>
<li><p><code>VT-x</code> 或 <code>AMD-V</code>已被禁用（<code>BIOS</code> ）</p>
</li>
</ol>
<ul>
<li>在任务管理器中查看“性能”&#x2F;“Performance” 页，然后找到CPU栏，右下角有“虚拟化&#x2F;“Virtualization“，如果显示”已启用”&#x2F;”Enabled“，表明已经启动，如果不是则需要到BIOS中启动。</li>
</ul>
<ol start="3">
<li><p>你在<code>windows</code>上开启了<code>Hyper-V</code> </p>
<ul>
<li>一般是企业版或专业版有此功能，家庭版没有。</li>
</ul>
</li>
<li><p>开启了，hypervisorlaunchtype</p>
<ul>
<li><p>使用管理员打开<code>cmd</code>或者<code>powershell</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bcdedit</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果查看<code>hypervisorlaunchtype</code>为<code>auto</code>，则需要关闭</p>
</li>
<li><p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后重启</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>VirtualBox</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装步骤</title>
    <url>//docker%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4.html</url>
    <content><![CDATA[<h1 id="在线安装方法"><a href="#在线安装方法" class="headerlink" title="在线安装方法"></a>在线安装方法</h1><p><a href="https://docs.docker.com/engine/install/centos/">CentOS安装</a></p>
<p>Ubuntu 也同样参考相关文档</p>
<h1 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h1>]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10的VMware中虚拟机卡顿</title>
    <url>//Win10%E7%9A%84VMware%E4%B8%AD%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8D%A1%E9%A1%BF.html</url>
    <content><![CDATA[<p>问题：</p>
<p>Win10 系统上启用 Hyper-V 安装 docker 后，VMware 上的windows虚拟机出现卡死现象</p>
<p>解决：</p>
<p><code>编辑虚拟机设置</code> -&gt; <code>选项</code> -&gt; <code>高级</code> -&gt; <code>设置</code> ，勾选 <strong>为其用了 Hyper-V 的主机引用侧通道缓解</strong> ，然后启动虚拟机即可。</p>
]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>如何给已经运行的docker容器动态添加端口映射</title>
    <url>//%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E8%BF%90%E8%A1%8C%E7%9A%84docker%E5%AE%B9%E5%99%A8%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84.html</url>
    <content><![CDATA[<p><strong>背景</strong>：</p>
<p>在主机上运行 gitlab-docker 时，发现已经在本地客户端生成 SSH 秘钥，同时将公钥上传到 gitlab 上了，但是在使用 <code>ssh -T git@gitlab.com</code> 命令验证时，还是提示要求输入 git 密码。想到应该是因为开始启动 docker 时由于gitlab-docker 的镜像会启用 22 端口，占用本机22 端口，所以当时没有做该端口的映射。</p>
<p><strong>需求：</strong></p>
<ol>
<li>给运行中的 docker 容器添加 22 端口映射；</li>
</ol>
<p><strong>遇到的问题：</strong></p>
<ol>
<li>如何给运行中的 docker 容器动态添加端口？</li>
<li>iptables 规则如何查看，添加，删除和修改？</li>
<li>docker 容器涉及的 iptables 规则如何添加后生效？</li>
<li>docker-proxy 直接运行为什么报错？</li>
</ol>
<p>解决过程：</p>
<p>不想改动本机（宿主机）的 22 端口，那么就需要将 gitlab 的 22 端口</p>
]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>解决VM Workstation安装VMware Tools显示灰色的办法</title>
    <url>//%E8%A7%A3%E5%86%B3VM%20Workstation%E5%AE%89%E8%A3%85VMware%20Tools%E6%98%BE%E7%A4%BA%E7%81%B0%E8%89%B2%E7%9A%84%E5%8A%9E%E6%B3%95.html</url>
    <content><![CDATA[<p>处理方法：</p>
<p>选择虚拟机，点击<strong>设置</strong> -&gt; <strong>硬件</strong> -&gt; <code>CD/DVD</code> -&gt; <strong>连接</strong> -&gt; 使用 ISO 映像文件 -&gt; 选择加载 VMware 安装目录下的 <code>windows.iso</code> 。</p>
<p>然后打开虚拟机，进入我的电脑，双击<code>VMware Tools</code>。</p>
]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>认识虚拟化</title>
    <url>//%E8%AE%A4%E8%AF%86%E8%99%9A%E6%8B%9F%E5%8C%96.html</url>
    <content><![CDATA[<p>什么是KVM？</p>
<p>什么是QEMU？</p>
<p>它们的作用是什么？</p>
<p>热迁移，</p>
<p>目的：在不中断业务的情况下完成物理机的一些升级，故障处理等操作。</p>
<p>问题：如何在虚拟机业务不中断的情况下</p>
<h2 id="验证内核是否支持-KVM-虚拟机"><a href="#验证内核是否支持-KVM-虚拟机" class="headerlink" title="验证内核是否支持 KVM 虚拟机"></a>验证内核是否支持 KVM 虚拟机</h2><p>即查看 <code>/dev/kvm</code> 和 <code>/sys/module/kvm</code> 文件是否存在，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ ls -l /dev/kvm</span><br><span class="line">crw-rw----+ 1 root kvm 10, 232 Jan 10 04:56 /dev/kvm</span><br><span class="line">ubuntu@ubuntu:~$ ls /sys/module/kvm/</span><br><span class="line">parameters  uevent</span><br></pre></td></tr></table></figure>

<p>若上述文件存在，说明内核支持 KVM 虚拟化。</p>
<p>若上述文件不存在，则说明内核不支持 KVM 虚拟化，或者硬件不支持。</p>
]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器搜索使用技巧</title>
    <url>//%E6%B5%8F%E8%A7%88%E5%99%A8%E6%90%9C%E7%B4%A2%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<h1 id="浏览器搜索使用技巧"><a href="#浏览器搜索使用技巧" class="headerlink" title="浏览器搜索使用技巧"></a>浏览器搜索使用技巧</h1><p>一般搜索东西我都喜欢先在官网上搜，找不到了再放开搜，所以先这么搜 site:xxx.com key</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在看Dubbo源码时，遇到`ChannelEventRunnable`的一个if分支和switch分支的使用问题，</span><br><span class="line">源码中，把 state == ChannelState.RECEIVED 拎出来独立一个 if，而其他的 state 还是放在 switch 里面判断。答主提供了，上面搜索方式的样例，</span><br><span class="line">site:dubbo.apache.org ChannelEventRunnable</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索引擎搜索技巧使用</category>
      </categories>
      <tags>
        <tag>搜索引擎搜索技巧使用</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样防范文件上传漏洞</title>
    <url>//%E6%80%8E%E6%A0%B7%E9%98%B2%E8%8C%83%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.html</url>
    <content><![CDATA[<h1 id="文件上传漏洞的防御方法"><a href="#文件上传漏洞的防御方法" class="headerlink" title="文件上传漏洞的防御方法"></a>文件上传漏洞的防御方法</h1><p>1.<strong>文件上传的目录设置为不可执行</strong>。</p>
<ul>
<li>只要 web 容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此这一点至关重要。</li>
</ul>
<p>2.判断文件类型。</p>
<ul>
<li>在判断文件类型时，可以结合使用 MIME Type、后缀检查等方式。</li>
</ul>
<p>3.单独设置文件服务器的域名。</p>
<ul>
<li>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传 crossdomain.xml、上传包含 Javascript 的 XSS 利用等问题将得到解决。</li>
</ul>
<p>4.使用安全设备防御。</p>
<ul>
<li>文件上传攻击的本质就是将恶意文件或者脚本上传到服务器，专业的安全设备防御此类漏洞主要是通过对漏洞的上传利用行为和恶意文件的上传过程进行检测。恶意文件千变万化，隐藏手法也不断推陈出新，对普通的系统管理员来说可以通过部署安全设备来帮助防御。</li>
</ul>
<p>5.系统上线后运维人员应有较强的安全意思，积极使用多个安全检测工具对系统进行安全扫描，及时发现潜在漏洞并修复。</p>
<p>6.定时查看系统日志，web 服务器日志以发现入侵痕迹。定时关注系统所使用到的第三方插件的更新情况，如有新版本发布建议及时更新，如果第三方插件被爆有安全漏洞更应立即进行修补。</p>
<p>7.对于整个网站都是使用的开源代码或者使用网上的框架搭建的网站来说，尤其要注意漏洞的自查和软件版本及补丁的更新，上传功能非必选可以直接删除。除对系统自生的维护外，服务器应进行合理配置，非必选一般的目录都应去掉执行权限，上传目录可配置为只读。</p>
]]></content>
      <categories>
        <category>攻防</category>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>攻防</tag>
        <tag>漏洞</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali使用</title>
    <url>//Kali%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="VMware-设置共享目录"><a href="#VMware-设置共享目录" class="headerlink" title="VMware 设置共享目录"></a>VMware 设置共享目录</h1><ol>
<li><p>vmware需要配置共享文件夹</p>
</li>
<li><p>kali系统内配置挂载目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/share</span><br><span class="line"></span><br><span class="line">vmhgfs-fuse .host:/ /mnt/share</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="工具使用篇"><a href="#工具使用篇" class="headerlink" title="工具使用篇"></a>工具使用篇</h1><h2 id="ffuf"><a href="#ffuf" class="headerlink" title="ffuf"></a>ffuf</h2><p>用途广泛，部分功能：</p>
<ul>
<li>目录发现，可选择在 URL 中的任何位置进行模糊测试；</li>
<li>子域名发现；</li>
<li>使用各种 HTTP 方法进行模糊测试；</li>
</ul>
<h3 id="密码爆破-amp-接口-amp-参数模糊测试"><a href="#密码爆破-amp-接口-amp-参数模糊测试" class="headerlink" title="密码爆破&amp;接口&amp;参数模糊测试"></a>密码爆破&amp;接口&amp;参数模糊测试</h3><p>简单的样例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -w /usr/share/seclists/Passwords/500-worst-passwords.txt -X POST -d &quot;username=admin\npassword=FUZZ&quot; -u http://172.17.216.37:8080</span><br></pre></td></tr></table></figure>

<ul>
<li>-w 为使用的密码字典，</li>
<li>-u 为访问的web地址，</li>
<li>-d 参数为用户名 admin，password使用字典中的值遍历，</li>
</ul>
<h1 id="zsh-使用"><a href="#zsh-使用" class="headerlink" title="zsh 使用"></a>zsh 使用</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看zsh可以加载的模块的使用方法</span></span><br><span class="line">man zshmodules</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面模块在命令行中 没有 -h / --<span class="built_in">help</span> / <span class="built_in">help</span> 可以查看帮助信息</span></span><br><span class="line">ztcp</span><br><span class="line"></span><br><span class="line">zmodload</span><br></pre></td></tr></table></figure>



<h2 id="web-目录爆破工具"><a href="#web-目录爆破工具" class="headerlink" title="web 目录爆破工具"></a>web 目录爆破工具</h2><h3 id="dirb"><a href="#dirb" class="headerlink" title="dirb"></a>dirb</h3><h3 id="dirbuster"><a href="#dirbuster" class="headerlink" title="dirbuster"></a>dirbuster</h3><h3 id="ffuf-1"><a href="#ffuf-1" class="headerlink" title="ffuf"></a>ffuf</h3><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol>
<li>web网站目录爆破的作用？为什么要扫描目录？</li>
</ol>
<h1 id="弱口令扫描"><a href="#弱口令扫描" class="headerlink" title="弱口令扫描"></a>弱口令扫描</h1><p>使用 Hydra，可以使用在线</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_46067990/article/details/124095798?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-124095798-null-null.pc_agg_new_rank&utm_term=kali%E5%BC%B1%E5%8F%A3%E4%BB%A4&spm=1000.2123.3001.4430">网络安全 弱口令扫描 使用Hydra</a></p>
]]></content>
      <categories>
        <category>攻防</category>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>攻防</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>//%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>二叉搜索树，是一种特殊形式的二叉树。</p>
<p>二叉搜索树的特性如下：</p>
<ul>
<li><p>每个节点的值，必须大于或等于&gt;&#x3D; 其左子树中的<code>任何值</code>，且小于或等于&lt;&#x3D; 其右子树中的<code>任何值</code>。</p>
<blockquote>
<p>从中序遍历(inorder)遍历的角度看，通过中序遍历得到的是一个<code>递增的</code>有序序列。</p>
<p>例如，[1,2,3,4,5,6,7]</p>
</blockquote>
</li>
<li><p>（上面特性包含这条）所有左子树和右子树自身也必须是二叉搜索树。</p>
</li>
</ul>
<p>学习目的：</p>
<ol>
<li>理解二叉搜索树的特性；</li>
<li>熟悉在二叉搜索树中的基本操作；</li>
<li>理解高度平衡二叉搜索树（height-balanced binary search tree）的概念</li>
</ol>
<p>这是判断是否为BST题目中，solution中的一个讨论里的回答</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap is a BT not a BST.</span><br><span class="line">in Heap, value of each node in lesser than value of its children.</span><br><span class="line">in BST, value of each node is between the values of its children.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>binary search tree</em>(BST), <em>binary tree</em>(BT)</p>
</blockquote>
<p> <a href="https://leetcode.com/problems/validate-binary-search-tree/solution/">98.Validate Binary Search Tree</a></p>
<p><a href="https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/140/introduction-to-a-bst/997/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)">(54) Learn one iterative inorder traversal, apply it to multiple tree questions (Java Solution) - LeetCode Discuss</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>//%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树节点定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p>递归法</p>
<p>迭代法</p>
<p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// iteratively</span></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.left;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; !stack.empty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//preorder</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(current.val);</span><br><span class="line">            <span class="keyword">if</span>(current.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">               stack.push(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(current.left!=<span class="literal">null</span>) &#123;</span><br><span class="line">              stack.push(current.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><blockquote>
<p>leetcode 94. Binary Tree Inorder Traversal</p>
</blockquote>
<p>递归法</p>
<p>迭代法</p>
<p>方法一：依然是将所有点先压入栈中，先将根节点与左子树压入，然后弹出时再根据情况判断有否遍历右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//inorder</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        TreeNode curr=root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr=curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=stack.pop();</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            curr=curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：与前序遍历直接将根节点添加到result中不同，因为中序遍历时先遍历左子树，再访问root节点，所以root节点需要先压入栈中，然后继续遍历左子树，然后弹出时再添加root节点的值，并考虑是否遍历右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">        <span class="keyword">while</span>(root == <span class="literal">null</span> &amp;&amp; !nodes.isEmpty()) &#123;</span><br><span class="line">            root = nodes.pop();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>莫里斯 Morris 遍历法</p>
<p>总体思路： 将二叉树变为单向链表，不借助Stack或队列等外部数据结构，充分利用指针来操作。</p>
<h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><p>迭代法</p>
<p>思路：<br>&#x2F;&#x2F; 因为后续遍历逆序结果等于前序遍历（先右子树）的结果<br>&#x2F;&#x2F; 所以将前序遍历（先右子树）的结果通过栈逆序输出即可</p>
<p>这里有两种做法，</p>
<p>方法一，只选择一侧压入，其他的进行判断处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历时，选择右侧压入，</span></span><br><span class="line"><span class="comment">// 后序遍历时，因为是前序遍历（先右子树）的逆序，所以当做前序遍历右侧优先的方式遍历，选择左侧压入。</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个方法表示，将值插入0索引位置，然后后序再插入值时，</span></span><br><span class="line">        <span class="comment">// 如果0索引点有值，则将所有值向右移动（索引加一），然后将值插入0索引位置。</span></span><br><span class="line">        <span class="comment">// 效果与正常add后，反转一样。Collections.reverse();</span></span><br><span class="line">        result.add(<span class="number">0</span>, root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            nodes.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        root = root.right;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; !nodes.isEmpty()) &#123;</span><br><span class="line">            root = nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，所有节点都压入，只是根据先遍历的顺序，选择先压入左右哪边的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有遍历的点都压入栈中，然后依次弹出，</span></span><br><span class="line"><span class="comment">// 压入的顺序的选择与方法一相同，</span></span><br><span class="line"><span class="comment">// 前序遍历时先压入右侧，在压入左侧，因为要优先遍历左侧，</span></span><br><span class="line"><span class="comment">// 后序遍历因为是前序遍历（先右侧）的结果逆序，所以要先遍历右侧，即先压入左侧。</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result; </span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.isEmpty()) &#123;</span><br><span class="line">        root = nodes.pop();</span><br><span class="line">        <span class="comment">// 这里同样利用该方法达到，反转list的效果，Collections.reverse();</span></span><br><span class="line">        result.add(<span class="number">0</span>, root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            nodes.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            nodes.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二+1：这个方法比方法二更好一些，主要是使用的数据结构更好一些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法贴下来的目的是，它使用了LinkedList,和 addFirst()方法，</span></span><br><span class="line"><span class="comment">// addFirst()方法可以达到从后向前添加元素的效果，同时该方法的时间复杂度为 O(1)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">	</span><br><span class="line">	stack.push(root);</span><br><span class="line">	<span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">		ans.addFirst(cur.val);</span><br><span class="line">		<span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			stack.push(cur.left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			stack.push(cur.right);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就涉及到ArrayList 与 LinkedList 的区别了</p>
<p>ArrayList.add(index, element) 方法，底层是使用了Array的相关操作，数组对于迁移插入数据，时间复杂度为O(n)，<br>LinkedList.addFirst() 方法，实现时使用了双向链表节点，插入的时间复杂度为O(1)，更快一些。</p>
<h2 id="对于上面的遍历方法，这里提供了使用队列的遍历方法"><a href="#对于上面的遍历方法，这里提供了使用队列的遍历方法" class="headerlink" title="对于上面的遍历方法，这里提供了使用队列的遍历方法"></a>对于上面的遍历方法，这里提供了使用队列的遍历方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Pre Order Traverse</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            result.add(p.val);  <span class="comment">// Add before going to children</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            p = node.right;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In Order Traverse</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);  <span class="comment">// Add after all left children</span></span><br><span class="line">            p = node.right;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post Order Traverse</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            result.addFirst(p.val);  <span class="comment">// Reverse the process of preorder</span></span><br><span class="line">            p = p.right;             <span class="comment">// Reverse the process of preorder</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            p = node.left;           <span class="comment">// Reverse the process of preorder</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="前序，中序，后序遍历的Morris解法"><a href="#前序，中序，后序遍历的Morris解法" class="headerlink" title="前序，中序，后序遍历的Morris解法"></a>前序，中序，后序遍历的Morris解法</h2><blockquote>
<p>如果使用的是非递归方式，我们要么需要一个栈，要么需要一个队列来维护节点之间的关系。如果使用Morris遍历就不需要了，</p>
<p>因为一般情况下，二叉树的叶子节点是没有子节点的，也就是说他们是指向空，Morris的实现原理其实就是把叶子节点的指针给利用了起来。</p>
<p>Morris的中序遍历，可以把它看做是把二叉树拉直变成了链表</p>
</blockquote>
<p>关于Morrios更详细的内容，请查看<a href="https://en.wikipedia.org/wiki/Threaded_binary_tree">Threaded binary tree</a> 和 <a href="https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion">Explaination of Morris Method</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参考代码...</span><br></pre></td></tr></table></figure>


<h2 id="层序遍历-（BFS-广度优先）"><a href="#层序遍历-（BFS-广度优先）" class="headerlink" title="层序遍历 （BFS 广度优先）"></a>层序遍历 （BFS 广度优先）</h2><p>通常，我们使用一个叫做queue队列的数据结构来帮助我们做广度优先搜索。</p>
<p>按 <code>层序遍历</code> 得到的节点值。 （即逐层地，<code>从左到右</code>访问所有节点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// 先放入根节点</span></span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="comment">// 队列不为空</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 一次循环一层，所以必然会有一个内部循环</span></span><br><span class="line">        <span class="comment">// 按层放入节点到队列，然后将队列中的一层节点拿出来一次循环</span></span><br><span class="line">        <span class="comment">// 将下一层节点加入到队列中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; size;i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            level.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>树的最大深度 104</p>
<h1 id="练习题集合"><a href="#练习题集合" class="headerlink" title="练习题集合"></a>练习题集合</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">is - start index for inorder array</span><br><span class="line">ie - end index for inorder array</span><br><span class="line"></span><br><span class="line">ps - start index for postorder array</span><br><span class="line">pe - end index for postorder array</span><br><span class="line"></span><br><span class="line">Remember :</span><br><span class="line">InOrder is (left subtree) node (right subtree)</span><br><span class="line">PostOrder is (left subtree)(right subtree) (node)</span><br><span class="line">From post order array we get the root which will be at index pe</span><br><span class="line">while from in order we can get the number of children in the left subtree ie. ri-is</span><br></pre></td></tr></table></figure>

<ol start="105">
<li>Construct Binary Tree from Preorder and Inorder Traversal</li>
</ol>
<p>A tree has a recursive structure because it has subtrees which are trees themselves.<br>一棵树具有递归结构，因为它有子树，而子树本身也是树。</p>
<h4 id="Populating-Next-Right-Pointers-in-Each-Node-116-填充每个节点的下一个右侧节点指针"><a href="#Populating-Next-Right-Pointers-in-Each-Node-116-填充每个节点的下一个右侧节点指针" class="headerlink" title="Populating Next Right Pointers in Each Node (116. 填充每个节点的下一个右侧节点指针)"></a>Populating Next Right Pointers in Each Node (<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a>)</h4><ul>
<li>典型的BFS策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//BFS的迭代解法</span></span><br><span class="line"><span class="comment">// 总体流程是，外层while是，从上到下的遍历，内存while是，对当前层所有节点的遍历。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">// 直接判断下一层是否有值，有值则继续，没值则退出；</span></span><br><span class="line">        <span class="keyword">while</span>(pre.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历当前层的所有节点。访问当前层节点的同时，连接下一层的节点。</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> pre;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.left.next = cur.right;</span><br><span class="line">                <span class="keyword">if</span> (cur.next != <span class="literal">null</span>) cur.right.next = cur.next.left;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前层所有节点遍历完，就遍历下一层。</span></span><br><span class="line">            pre = pre.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Populating-Next-Right-Pointers-in-Each-Node-II（117-填充每个节点的下一个右侧节点指针-II）"><a href="#Populating-Next-Right-Pointers-in-Each-Node-II（117-填充每个节点的下一个右侧节点指针-II）" class="headerlink" title="Populating Next Right Pointers in Each Node II（117. 填充每个节点的下一个右侧节点指针 II）"></a>Populating Next Right Pointers in Each Node II（<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a>）</h4><ul>
<li>这个版本是普通的二叉树（节点可能，或者没有子节点，或者没有left子节点，或者没有right子节点）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// easy to understand solution1</span></span><br><span class="line">    <span class="comment">// two while loops, but the meaning is clearer</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">levelStart</span> <span class="operator">=</span> root; <span class="comment">// 每层的开始节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="comment">// if the  of the traverse layer is not null, then traverse that layer...</span></span><br><span class="line">        <span class="keyword">while</span>(levelStart != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> levelStart;</span><br><span class="line">            <span class="comment">// 开始遍历每一层的每个节点</span></span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = cur.left;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = cur.right;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历下一个节点</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过复制辅助节点的指针，进入下一层</span></span><br><span class="line">            levelStart = dummyNode.next;</span><br><span class="line">            <span class="comment">// 将辅助节点的next指针断掉，方便下一层使用，这样就只需要创建一个辅助节点了</span></span><br><span class="line">            dummyNode.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// p指向辅助节点便于后面操作next指针</span></span><br><span class="line">            p = dummyNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外一个版本，性能是一样的，思路也清晰</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next = cur.left;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                p.next = cur.right;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = dummyNode.next;</span><br><span class="line">                dummyNode.next = <span class="literal">null</span>;</span><br><span class="line">                p = dummyNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供了递归的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123; <span class="comment">// 更新left.next</span></span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123; <span class="comment">// 判断是否存在right，如果不存在就找root.next</span></span><br><span class="line">                root.left.next = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root.left.next = findNext(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新right.next，直接找root.next</span></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) root.right.next = findNext(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里要重点说一下，为什么要先更新right subtree，</span></span><br><span class="line">        <span class="comment">// 因为如果先更新left subtree，因为每次递归只能更新半棵树（每一层右半边会有节点无法被next连接上），</span></span><br><span class="line">        <span class="comment">// 这样会导致往下递归时，会导致下面的节点的next无法连接。</span></span><br><span class="line">        <span class="comment">// 所以先递归right subtree，这样先连接右半边，再连接左半边，可以保证递归完成后每一层所有node都有next连接上。</span></span><br><span class="line">        <span class="comment">// 下面有例子</span></span><br><span class="line">        connect(root.right);</span><br><span class="line">        connect(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 寻找root同层的其他Node</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNext</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            root = root.next;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举例佐证先更新right subtree</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">9</span>]</span><br><span class="line">在这个例子中，如果先更新left subtree，那么由于递归过程总，<span class="number">6</span>与<span class="number">7</span>没有通过next来接上，导致递归到<span class="number">8</span>时，<span class="number">8</span>无法与<span class="number">9</span>连接上。</span><br></pre></td></tr></table></figure>



<h1 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h1><p>递归方法的思路和题解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法思路：</span></span><br><span class="line"><span class="comment">     * 1. 从root节点开始遍历整棵树；</span></span><br><span class="line"><span class="comment">     * 2. 如果发现p,q任何一个节点，就返回；利用root == q || root == p，说明找到了节点</span></span><br><span class="line"><span class="comment">     * 3. 如果当前节点不符合要求，分别查找左右子树；</span></span><br><span class="line"><span class="comment">     * 4. 如果左右子树返回值都不为null，说明p，q分别在左右子树中，则该节点为祖先节点；</span></span><br><span class="line"><span class="comment">     * 5. 如果左子树或者右子树有一个返回了指定节点，另一个为null，说明p,q有一个在其分支中，</span></span><br><span class="line"><span class="comment">     * 特别的，如果返回到顶层后，只有一侧分支有返回值，说明p,q两个节点都在返回值所在的子树中。该返回值就是p,q的祖先。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// search left subtree</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">// search right subtree</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">给定二叉树：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],输入p=<span class="number">2</span>,q=<span class="number">5</span>,</span><br><span class="line"><span class="number">1.</span>在这个二叉树中，从根节点<span class="number">1</span>出发，遍历到<span class="number">1</span>的左子树<span class="number">2</span>时，找到节点p，然后返回，</span><br><span class="line"><span class="number">2.</span>接着遍历<span class="number">1</span>的右子树<span class="number">3</span>，遍历完，右子树返回为<span class="literal">null</span>，因为没有找到q，</span><br><span class="line"><span class="number">3.</span>最终返回<span class="number">2</span>。</span><br><span class="line">说明：在这个二叉树中，<span class="number">2</span>，和<span class="number">5</span>都在<span class="number">2</span>所在的左子树中，当遍历完左右子树时，右子树没有符合条件的节点，左子树<span class="number">2</span>符合其中一点，说明另一点一定在<span class="number">2</span>所在的左子树分支中，此时<span class="number">2</span>就是<span class="number">2</span>和<span class="number">5</span>的最近公共祖先。（节点可以是其本身的祖先的。）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">如果是p,q分别在某个节点的左右子树中，那么对于<span class="string">&quot;该节点&quot;</span>来说返回情况是left！=<span class="literal">null</span>&amp;&amp;right != <span class="literal">null</span>，对于整个树来说，当递归栈返回到顶层后的表现为lef子树或者right子树其中一个的返回值为<span class="string">&quot;该节点&quot;</span>，另一边为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<p>官方解法说明中的思路提挺好的，后面做题时，可以尝试画</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下是递归过程中节点的序列：</span><br><span class="line"></span><br><span class="line">1 --&gt; 2 --&gt; 4 --&gt; 8</span><br><span class="line">BACKTRACK 8 --&gt; 4</span><br><span class="line">4 --&gt; 9 (ONE NODE FOUND, return True)</span><br><span class="line">BACKTRACK 9 --&gt; 4 --&gt; 2</span><br><span class="line">2 --&gt; 5 --&gt; 10</span><br><span class="line">BACKTRACK 10 --&gt; 5</span><br><span class="line">5 --&gt; 11 (ANOTHER NODE FOUND, return True)</span><br><span class="line">BACKTRACK 11 --&gt; 5 --&gt; 2</span><br><span class="line"></span><br><span class="line">2 is the node where we have left = True and right = True and hence it is the lowest common ancestor.</span><br></pre></td></tr></table></figure>





<h1 id="关于递归优化的问题"><a href="#关于递归优化的问题" class="headerlink" title="关于递归优化的问题"></a>关于递归优化的问题</h1><p>如果我们已经在左子树中找到祖先节点，如何避免对剩下右子树不必要的递归检查工作？</p>
<p>首先我们在优化的时候要意识到，</p>
<ol>
<li>the <code>purpose</code> is to stop further unnecessary <code>recursive call</code>. You can’t really terminate the function early without using exception.</li>
</ol>
<blockquote>
<p><code>目的</code>是阻止进一步不必要的<code>递归调用</code>。如果不使用异常，您无法真正提前终止该函数。</p>
</blockquote>
<ol start="2">
<li>In recursion no matter what you return the called stack has to unwind back. So this is not really termination.</li>
</ol>
<blockquote>
<p>在递归中，无论您返回什么，已经调用的栈都必须展开。所以这并不是真正的终止。</p>
</blockquote>
<ol start="3">
<li>整体时间复杂度并不会改变，因为最坏的情况依然是检查整棵树，优化仅会针对祖先在一侧树的情况下，所以也不算真正意义上的优化。</li>
</ol>
<p>【下面这部分内容可看可不看，主要原因是只能在特定查询过程中减少递归调用，整体时间复杂度并没有改变】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归版本，去掉flag部分就是常规版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 这里添加两个flag用于提前判断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">p_found</span> <span class="operator">=</span> <span class="literal">false</span>, q_found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == p.val)&#123;</span><br><span class="line">            p_found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == q.val)&#123;</span><br><span class="line">            q_found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面内容，如果在常规版本中，可以合并一起写</span></span><br><span class="line">        <span class="comment">// if (root == null || root == q || root == p) return root;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两个flag主要用于判断当左子树找到祖先，不进行后面不必要的递归检查。</span></span><br><span class="line">        <span class="keyword">if</span>(p_found &amp;&amp; q_found)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">null</span>? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代思路和解法</p>
<p>遍历p,q的时候，将其父节点都保存下来，然后分别对比两个节点的祖先节点，找到公共祖先。</p>
<p>问题，找最近公共祖先，使用什么数据结构存储父节点和祖先节点？</p>
<ol>
<li>Map来存储每个点和其父节点；</li>
<li>找到p,q点时，利用从p,或q直接父节点一层层向上找的方式，先找到的一定是最近公共祖先。</li>
<li>在循环过程中使用Deque或者Queue都行，都可以实现层序遍历的功能（这题用DFS或者BFS迭代都可以，BFS时，可以按层遍历，倘若要寻找的点p,q在同一层，那么下面层就可以不遍历了。DFS时，如果p,q在同一侧分支，则其他分支不用遍历。）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个效果一般</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;TreeNode, TreeNode&gt; parents = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        parents.put(root, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span>(!parents.containsKey(p) || !parents.containsKey(q))&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                parents.put(node.left, node);</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                parents.put(node.right, node);</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理p的所有祖先节点</span></span><br><span class="line">        Set&lt;TreeNode&gt; ancestors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">            ancestors.add(p);</span><br><span class="line">            p = parents.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过一层层向上查找q的直接父节点，然后与p的祖先节点进行比较，找到最近公共祖先LCA</span></span><br><span class="line">        <span class="keyword">while</span>(!ancestors.contains(q)) &#123;</span><br><span class="line">            q = parents.get(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/995/discuss/74264/Short-and-straight-forward-BFS-Java-code-with-a-queue">https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/995/discuss/74264/Short-and-straight-forward-BFS-Java-code-with-a-queue</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>常用结构</title>
    <url>//%E5%B8%B8%E7%94%A8%E7%BB%93%E6%9E%84.html</url>
    <content><![CDATA[<h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>是一个双端队列。发音与“ArrayDeck”相同</p>
<p>既可以作为Stack（Last-In-First-Out, LIFO）</p>
<p>也可以作为Queue（First-In-First-Out,FIFO）</p>
<p>它的方法中，基本上都有两套实现，</p>
<ul>
<li>一种在操作失败时抛出异常；</li>
<li>一种是返回状态或者值。</li>
</ul>
<p>是非线程安全的</p>
<p>不接受Null</p>
<p>工作速度明显比Stack快（faster than the synchronized Stack）</p>
<ul>
<li>Jdk原生的Stack是使用synchronize来实现的</li>
</ul>
<p>由于更好的引用局部性，是比 LinkedList 更快的队列</p>
<p>ArrayDeque 返回的迭代器是快速失败的（fail-fast）</p>
<p>添加元素时，当头尾指针相遇时，ArrayDeque 自动将数组的大小加倍 ？？？</p>
<h3 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h3><p>底层是Array（数组），初始化的大小为16，维护了两个指针，即head和tail（头和尾）。</p>
<h3 id="ArrayDeque提供的基础API"><a href="#ArrayDeque提供的基础API" class="headerlink" title="ArrayDeque提供的基础API"></a>ArrayDeque提供的基础API</h3><p>每个操作都提供了两种选择</p>
<p>The first group consists of methods that throw exception if the operation fails. The other group returns a status or a value:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Method</th>
<th>Method throwing Exception</th>
</tr>
</thead>
<tbody><tr>
<td>Insertion from Head</td>
<td><em>offerFirst(e)</em></td>
<td><em>addFirst(e)</em></td>
</tr>
<tr>
<td>Removal from Head</td>
<td><em>pollFirst()</em></td>
<td><em>removeFirst()</em></td>
</tr>
<tr>
<td>Retrieval from Head</td>
<td><em>peekFirst()</em></td>
<td><em>getFirst()</em></td>
</tr>
<tr>
<td>Insertion from Tail</td>
<td><em>offerLast(e)</em></td>
<td><em>addLast(e)</em></td>
</tr>
<tr>
<td>Removal from Tail</td>
<td><em>pollLast()</em></td>
<td><em>removeLast()</em></td>
</tr>
<tr>
<td>Retrieval from Tail</td>
<td><em>peekLast()</em></td>
<td><em>getLast()</em></td>
</tr>
</tbody></table>
<p><strong>注：</strong> offerFirst()与offerLast()方法中分别对应调用了addFirst()与addLast()方法，所以当传递参数为Null时，offerFirst()与offerLast()也会像addFirst()和addLast()一样抛出NPE的报错。</p>
<p>以上内容参考：<a href="https://www.baeldung.com/java-array-deque">Introduction to the Java ArrayDeque | Baeldung</a></p>
<h1 id="什么是fail-fast，fail-safe机制？"><a href="#什么是fail-fast，fail-safe机制？" class="headerlink" title="什么是fail-fast，fail-safe机制？"></a>什么是fail-fast，fail-safe机制？</h1><p>fail-fast机制是Java集合（Collection）中的一种错误机制。</p>
<p>在用Iterator（迭代器）遍历一个集合对象时，如果遍历过程中集合对象的结构进行了修改（增加、删除），则会抛出<code>Concurrent Modification Exception(并发修改异常)</code>。</p>
<p>主要目的是尽可能保证数据的一致性。防止在遍历的时候进行修改导致集合前后数据不一致。</p>
<p>使用增强for循环遍历集合和用迭代器实质是一样的。</p>
<p>forEach版本的for循环，其字节码与iterator一样。</p>
<p>阿里巴巴Java开发手册中要求，不要在foreach循环中进行元素的remove&#x2F;add操作。如果有remove的需要，请使用iterator方式，调用iterator中的remove方法。如果并发操作，需要对iterator对象加锁。</p>
<p><img src="https://ligongzhao-pics.oss-cn-hangzhou.aliyuncs.com/imgforeach_dont_remove_element.jpg"></p>
<p>理由：</p>
<ol>
<li>iterator的next()方法中会对modCount与expectedModCount这两个参数判断是否相等，不相等就抛异常。</li>
<li>iterator的remove()方法会复位expectedModCount为modCount使这两个参数相等；</li>
<li>ArrayList中的add()与remove()两个方法只修改了modCount参数，所以当进行next()调用时判断参数相等时就抛出异常了。</li>
</ol>
<p><strong>注意：</strong>代码中，我们不能对Arrays.asList()生成的ArrayList对象进行增删操作，因为asList()生成的ArrayList并没有重写add()和remove()方法，会直接抛出UnsupportedOperationException异常。</p>
<h3 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h3><p>是对原数据copy之后，对新数据修改的操作。</p>
<p>在一些场景中，我们想避免fail-fast机制抛出的异常，这时我们可以将ArrayList替换为fail-safe机制的CopyOnWriteArrayList。</p>
<p>典型的实现是，CopyOnWriteArrayList</p>
<p>写时复制，简单理解就是，当我们向一个容器中添加元素时，先将当前容器复制出一个，然后向新的容器中添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p>
<p>优点很多，这里举一个重要的点：</p>
<p>优点一：可以对CopyOnWriter容器进行并发读，而不需要加锁。因为当前容器不会增删任何元素。添加元素的时候需要加锁。</p>
<p>是一种读写分离的思想，读和写是不同的容器。</p>
<p>缺点 ：占用内存问题和数据一致性问题。</p>
<ul>
<li><p>占用内存问题：因为复制了一份，所以新加对象时会比较占内存；</p>
</li>
<li><p>数据一致性问题：因为读写分离，所以只能保证数据最终的一致性，不能保证实时的一致性。如果希望写入的数据马上能读到，那么不能使用CopyOnWrite容器。</p>
</li>
</ul>
<p>适用场景：用于读多写少的并发场景，比如白名单，黑名单，商品类目的访问和更新场景。</p>
<p>以上内容参考：<a href="https://juejin.cn/post/6879291161274482695#heading-0">一文彻底弄懂fail-fast、fail-safe机制（带你撸源码） (juejin.cn)</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法做题学习</title>
    <url>//%E7%AE%97%E6%B3%95%E5%81%9A%E9%A2%98%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h1><p>第一遍，草稿</p>
<h2 id="整理的大体流程如下："><a href="#整理的大体流程如下：" class="headerlink" title="整理的大体流程如下："></a>整理的大体流程如下：</h2><ul>
<li>题目名称（具体题目内容就不写了，可以查看leetcode网站）</li>
<li>解法思路</li>
<li>涉及到的基础知识点</li>
</ul>
<h1 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h1><ol>
<li>字符串</li>
<li>数组</li>
<li>链表<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
优点：</li>
</ol>
<ul>
<li>结构简单的动态数据结构</li>
<li>创建时，无需知道链表的长度</li>
<li>当插入新节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中。</li>
<li>内存分配不是在创建时一次性分配，（这与数组不同），而是添加节点时，单独给节点分配。（因为没有闲置的内存，所以链表的空间效率比数组高）</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于内存空间不是一次性分配，导致无法保证链表的内存是连续的，因为如果想在链表中查找第i个节点，无法像数组一样使用下标在O(1)时间内找到，只能从头节点开始，沿着指针遍历，时间效率为O(n)</li>
</ul>
<p>《剑指Offer2》对应题目：</p>
<ul>
<li>6 从尾到头打印链表</li>
<li>18 删除链表的节点</li>
<li>22 链表倒数第k个节点</li>
<li>24 反转链表</li>
<li>25 合并两个排序的链表</li>
<li>52 两个链表的第一个公共节点</li>
<li>62 圆圈中最后剩下的数字 （把链表的末尾节点的指针指向头结点，从而形成一个环形链表）</li>
<li>36 二叉搜索数与双向链表 （链表中的节点还可以指向前一个节点，形成双向链表）</li>
<li>35 复杂链表的复制 （链表中的节点，还有指向任意节点的指针）</li>
</ul>
<p>树，常考的是二叉树</p>
<ul>
<li>每个节点最多只能有两个子节点，叶结点，就是最末端的节点，没有子节点，根节点没有父节点</li>
<li>二叉树中最重要的操作是，遍历，按照某一顺序访问树中所有节点<ul>
<li>前序遍历： 先访问根节点，再访问左子节点，最后访问右子节点</li>
<li>中序遍历： 先访问左子节点，再访问根节点，最后访问右子节点</li>
<li>后序遍历： 先左子节点，再右子节点，最后根节点</li>
<li><strong>注意：</strong>，前，中，后序，是根据 根节点的访问位置来定的</li>
<li><strong>注意：</strong>，三种遍历，都有循环和递归，两种不同的访问方式</li>
</ul>
</li>
</ul>
<p>宽度优先遍历：</p>
<ul>
<li>先访问数的第一层节点，再访问树的第二层节点…一直到访问到最下面一层节点。</li>
<li>在同一层节点中，以从左到右的顺序依次访问。</li>
</ul>
<p>二叉树有很多特例：</p>
<ul>
<li>二叉搜索树<ul>
<li>特点：左子节点总&lt;&#x3D; 根节点</li>
<li>右子节点总&gt;&#x3D;根节点</li>
<li>我们可以平均在O(logn)的时间内根据数值在二叉搜索树中找到一个节点</li>
</ul>
</li>
<li>堆<ul>
<li>最大堆 <em>根节点的值最大</em></li>
<li>最小堆 <em>根节点的值最小</em></li>
<li>使用场景：在一些需要 快速找到最大值或者最小值的问题中，可以使用堆来处理</li>
</ul>
</li>
<li>红黑树<ul>
<li>把树中的节点定义为<em>红</em>，<em>黑</em>，两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度&lt;&#x3D;最短路径的2倍</li>
<li>java中hashmap基于红黑树实现的</li>
</ul>
</li>
</ul>
<p>《剑指Offer2》对应题目：</p>
<ul>
<li>考察遍历的具体代码实现<ul>
<li>26 树的子结构</li>
<li>34 二叉树中和为某一值的路径</li>
<li>55 二叉树的深度</li>
</ul>
</li>
<li>考察对遍历特点的理解<ul>
<li>7 重建二叉树</li>
</ul>
</li>
<li>建议：对前序，中序，后序，这三种遍历的6种实现方式掌握到了如指掌的地步</li>
<li>考察宽度优先遍历算法<ul>
<li>32 从上到下打印二叉树</li>
</ul>
</li>
<li>考察二叉搜索树<ul>
<li>36 二叉搜索树与双向链表</li>
<li>68 树中两个节点的 最低公共祖先</li>
</ul>
</li>
<li>考察堆和红黑树<ul>
<li>40 最小的k个数</li>
</ul>
</li>
</ul>
<p>栈</p>
<ul>
<li><p>特点：后进先出，即最后一个被压入push栈的元素会第一个被弹出pop</p>
</li>
<li><p>不考虑排序的数据结构</p>
</li>
<li><p>需要O(n)时间才能找到栈中最大或者最小的元素</p>
</li>
<li><p>31 栈的压入，弹出序列</p>
</li>
<li><p>30 包含min函数的栈</p>
</li>
</ul>
<p>队列</p>
<ul>
<li><p>特点：先进先出，即第一个进入队列的元素将会第一个出来</p>
</li>
<li><p>队列与栈的元素压入弹出顺序相反</p>
</li>
<li><p>32 从上到下打印二叉树</p>
</li>
</ul>
<p>使用java中的Queue方法时的注意事项</p>
<ul>
<li>队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。</li>
<li>LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//add()和remove()方法在失败的时候会抛出异常(不推荐)</span></span><br><span class="line"><span class="comment">// 添加元素使用offer</span></span><br><span class="line">queue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">// 删除元素，使用poll</span></span><br><span class="line">queue.poll(); <span class="comment">// 返回第一个元素，并在队列中删除</span></span><br><span class="line"><span class="comment">//返回第一个元素</span></span><br><span class="line">queue.peek()</span><br><span class="line"></span><br><span class="line">注意：Queue中，方法offer与add，poll与remove，peek与element这三对的区别</span><br><span class="line"><span class="number">1.</span> offer与add:</span><br><span class="line">    - 一些队列有大小限制，因此，如果当一个队列容量满了的时候，再添加元素，多出来的元素会被拒绝。这时，如果调用的是add方法，则会抛出unchecked异常，而offer不会抛出异常，只会返回<span class="literal">false</span>。</span><br><span class="line"><span class="number">2.</span> poll与remove：</span><br><span class="line">    - 两者都是从队列中删除第一个元素，当用空集合调用时，remove()的行为与Collection接口的版本相似，会抛出异常，而poll()只会返回<span class="literal">null</span>，不会抛出异常</span><br><span class="line"><span class="number">3.</span> peek()与element()：</span><br><span class="line">    - 两者都用于在队列的头部查询元素。与remove()方法类似，在队列为空时，element()会抛出异常，而peek()返回<span class="literal">null</span>。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><p>总结：<br>很多算法都可以使用<code>递归</code>和<code>循环</code>两种不同的方式实现。通常基于递归的实现方法代码会比较简洁，但性能不如基于循环的实现方式。实际使用中，需要根据情况选择合适的方法。</p>
<p>通常排序和查找是面试时考查算法的重点。在准备面试的时候，我们应该重点掌握二分查找、归并排序和快速排序，做到能随时正确、完整地写出代码。</p>
<p>如果面试题要求在二维数组（可能具体表现为迷宫或者棋盘等）上搜索路径，那么我们可以尝试用回溯法。通常回溯法很适合用递归的代码实现。<br>    - 只有当面试官限定不可以使用递归实现的时候，我们再考虑用栈来模拟递归的过程。</p>
<ol>
<li>查找和排序</li>
</ol>
<p>排序长度为n的数组，需要O(nlogn)的时间</p>
<p>递归与循环</p>
<p>递归的本质就是一个栈结构，（先进后出）<br>递归的优点：</p>
<p>缺点：</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>常用排序算法：</p>
<ul>
<li>冒泡排序，插入排序，选择排序，快速排序，归并排序，计数排序，基数排序，桶排序</li>
</ul>
<p>复杂度归类</p>
<ul>
<li>O(n^2), 冒泡排序，插入排序，选择排序</li>
<li>O(nlogn), 快速排序，归并排序</li>
<li>O(n), 计数排序，基数排序，桶排序</li>
</ul>
<p>关注排序比较和交换的次数</p>
<p>通用排序函数为什么选择快排？</p>
<ol>
<li>线性排序，时间复杂度为O(n)的三种排序方式，的使用场景特殊，如果要写一个通用的排序函数，不能选择线性排序；</li>
<li>为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数；</li>
<li>同为O(nlogn)的快排和归并排序，归并排序不是原地排序算法</li>
</ol>
<ul>
<li>所以最优的选择是快排</li>
</ul>
<p>如何优化快速排序？</p>
<ol>
<li>导致快速排序时间复杂度降为O(n^2)的原因是分区点选择的不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。</li>
</ol>
<p>优化分区点的选择：</p>
<ol>
<li>随机发：每次从要排序的区间中，随机选择一个元素作为分区点；<ul>
<li>《剑指Offer》中好像有提到</li>
</ul>
</li>
<li>三数区中法（或N数取中法，取决于数据量）<ul>
<li>从区间的首、中、尾分别取一个数，比较大小，取中间值作为分区点</li>
<li>如果要排序的数组较大，可以选择“5数中”，“10数区中”…</li>
</ul>
</li>
</ol>
<p>警惕快排的递归发生堆栈溢出</p>
<ol>
<li>限制递归深度，一旦递归超过了设置的阈值就停止递归</li>
<li>在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制<ul>
<li>方法2更好一些</li>
</ul>
</li>
</ol>
<p>通用排序函数实现技巧</p>
<ol>
<li>数据量不大时，O(n^2)排序算法不一定比O(nlogn)排序算法执行的时间长</li>
<li>数据量大时，优化快排区分点的选择</li>
<li>防止堆栈溢出，可以选择在堆上手动模拟调用栈来解决</li>
<li>在排序区间中，当元素个数小于某个常数量时，可以考虑使用O(n^2)的插入排序</li>
<li>用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致</li>
</ol>
<h1 id="面试提示"><a href="#面试提示" class="headerlink" title="面试提示"></a>面试提示</h1><ol>
<li>面试中，如果我们打算修改输入的数据或者数据结构，最好先问一下面试官是不是允许修改。</li>
</ol>
<h1 id="题目的解法积累"><a href="#题目的解法积累" class="headerlink" title="题目的解法积累"></a>题目的解法积累</h1><h3 id="1-two-sum两数之和"><a href="#1-two-sum两数之和" class="headerlink" title="1. two sum两数之和"></a>1. two sum两数之和</h3><ul>
<li>解法思路<ol>
<li>暴力两层循环</li>
<li>利用哈希表来处理<ul>
<li>利用hash表处理也有两种方式<ol>
<li>先全部放到HashMap中，然后再通过判断差值是否再HashMap中处理；</li>
<li>优化1中的方法，减少依次循环，直接边放入HashMap中，边判断差值是否在HashMap中；</li>
</ol>
</li>
<li>利用将数组值和索引放入哈希表的方法来遍历处理</li>
<li>保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。key-value</li>
<li>特点：利用空间换取速度，空间复杂度会随着hash表中存储元素的数量线性增加</li>
</ul>
</li>
</ol>
</li>
<li>涉及到的基础知识点：<ul>
<li>hash表<ul>
<li>能很好处理key-value对应，</li>
<li>hash表的取值速度较快，在没有hash冲突的情况下，hash的查找时间为O(1)，（有hash冲突时为O(n)）</li>
<li>利用空间换取速度，空间复杂度会随着hash表中存储元素的数量线性增加</li>
<li>扩展：看jdk中关于HashMap的实现，和其常用的api，（可以直接看极客时间中订阅的java面试中的HashMap的分析）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-整数反转"><a href="#2-整数反转" class="headerlink" title="2. 整数反转"></a>2. 整数反转</h3><p>这题主要利用，数学方法中弹出和推入数字，同时进行溢出前检查<br>注意理解一下解法中7，-8的由来，</p>
<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p>关键词：排序数组</p>
<p>主体思想：排除法（减治思想）</p>
<p>应用场景：二分查找相关问题</p>
<p>注意点：</p>
<ol>
<li><p>无条件写上while(left &lt; right) ，表示退出循环的条件时left&#x3D;&#x3D;right，这时不需要考虑返回的左右边界的问题</p>
</li>
<li><p>先写下取中间数取法，然后从如何把mid值排除掉的角度考虑如何写<code>if</code>和<code>else</code>语句</p>
<blockquote>
<p>写的时候把注释写上，1. 把“什么时候不是目标元素”作为注释写下来，提醒自己要判断正确，2. 判读mid分到左边还是右边，写下“下一轮搜索区间范围”作为注释写进代码</p>
</blockquote>
</li>
<li><p>当分支逻辑出现<code>left = mid</code>的时候，要修改取中间数的行为，使其上取整。</p>
</li>
<li><p>理解取中间数的方式</p>
<ul>
<li>普通方式：(a + b)&#x2F;2</li>
<li>利用数学方式变形防止溢出： a + (b - a)&#x2F;2 <blockquote>
<p>这样可以防止a+b整形溢出</p>
</blockquote>
</li>
<li>利用java中的无符号右移： (a + b) &gt;&gt;&gt; 1<blockquote>
<p>注意这里是<code>&gt;&gt;&gt;</code>(无符号右移) 而不是<code>&gt;&gt;</code>(有符号右移),java中二者有区别，涉及到<code>补码</code>的知识点，具体看5</p>
</blockquote>
</li>
</ul>
</li>
<li><p>借鉴java中的无符号右移<code>&gt;&gt;&gt;</code>的特殊语法</p>
<blockquote>
<p>无符号右移 <code>&gt;&gt;&gt;</code> 在对操作数右移以后，不论这个数是正数还是负数，高位一律补 <code>0</code>。使用无符号右移的好处是：<strong>即使在 left + right 整形溢出以后，得到的结果依然正确</strong>。<br>(从JDK的源码中借鉴来的<code>Arrays.binarySearch()</code> 方法)</p>
</blockquote>
</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li><p>二叉树，</p>
</li>
<li><p>二叉搜索树</p>
<p>  遍历方法：</p>
<p>  三种遍历方法，分别有什么特殊作用？</p>
<ul>
<li>前序</li>
<li>中序</li>
<li>后序</li>
</ul>
</li>
</ul>
<p>二叉搜索树的中序遍历，刚好可以输出一个升序数组<br>    - leetcode 98，99</p>
<p>给出一个升序数据，可以还原二叉搜索树</p>
<p>根据中序遍历+前序&#x2F;后序遍历 可以还原一课二叉树</p>
<p>前序&#x2F;后序遍历的作用？提供根节点，根据根节点可以递归生成左右子树</p>
<ul>
<li>递归处理</li>
<li>迭代处理</li>
</ul>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>1. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个内容要验证一下：</span><br><span class="line"></span><br><span class="line">一、取余运算和取模运算的异同</span><br><span class="line"></span><br><span class="line">这个题目最开始，我还是分正负数来考虑的，因为我印象里记得 %</span><br><span class="line">对正数和负数的运算好像有区别。最后去查了一下，补充在这里。</span><br><span class="line">C/C++ 和 Java 一样，% 是取余运算；而 Python 的 % 是取模运算。</span><br><span class="line">取余运算和取模运算的区别：</span><br><span class="line">对于整型数 a，b</span><br><span class="line"></span><br><span class="line">a，b 来说，取余运算或者取模运算的方法都是下面两步：</span><br><span class="line"></span><br><span class="line">    求整数商： c=a/b</span><br><span class="line"></span><br><span class="line">c=a/b</span><br><span class="line">计算余数或者模： r=a−c⋅b</span><br><span class="line"></span><br><span class="line">    r=a−c⋅b</span><br><span class="line"></span><br><span class="line">而两者的区别就在于第一步不同：取余运算在取c</span><br><span class="line">c的值时，向 00 方向舍入，而取模运算在计算cc的值时，则是向负无穷方向舍入。</span><br><span class="line">例如计算：−7%4−7%4</span><br><span class="line">第一步：求整数商，取余运算算出的整数商为c=⌈−74⌉=−1c=⌈4−7​⌉=−1，而取模运算算出的整数商为c=⌊−74⌋=−2c=⌊4−7​⌋=−2</span><br><span class="line">第二步：计算余数和模的公式相同，但因cc的值不同，取余的结果为−7−(−1×4)=−3−7−(−1×4)=−3，取模的结果为−7−(−2×4)=1−7−(−2×4)=1。</span><br><span class="line">归纳：当aa和bb符号一致时，取余运算和取模运算的结果一样。</span><br><span class="line">当符号不一致时，结果不一样。取余运算结果的符号和aa一致，取模运算结果的符号和bb一致。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数学计算中，遇到</span><br><span class="line"></span><br><span class="line">区间 [a,b]的集合，</span><br><span class="line"></span><br><span class="line">b-a+1,  当计算集合中元素的个数时使用</span><br><span class="line">    类似于，有5个点，当计算有几个点时是，b-a+1,</span><br><span class="line">                    当计算这5个点之间有几个段落时，b-a</span><br><span class="line"></span><br><span class="line">b-a，   当计算集合的长度/间隔，时使用</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>什么时候用双指针？什么时候用单指针？</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ICMP</title>
    <url>//ICMP.html</url>
    <content><![CDATA[<p><strong>结论1：</strong> ICMP协议属于网络层（IP层）。ICMP封装在IP报文中。不经过TCP、UDP。ICMP与TCP、UDP都封装在IP报文中，不存在谁包含谁。</p>
<p><strong>结论2：</strong>ping，tracert，traceroute，tracepath，trace工具都是通过利用ICMP协议来分析网络状况的。如果没有开启ICMP，他们最终都不会抵达对端。不过除了ping工具外，其他几个工具可以看到本端到对端中间经过的路由器信息，从而可以帮助判断是哪一段网络出了问题。</p>
<p>ping 使用的是 ICMP 的 echo request 和 echo reply 来完成检测。</p>
<p>traceroute 使用 ICMP 的 TTL 来完成检测。TTL （Time To Live），其值代表还有多少“生存时间”，其实就是还可以被转发处理多少次。</p>
<ul>
<li>每个路由器在转发 ICMP 封包时，会都把 IP header 中的 TTL 的值减1，如果 TTL 的值已经是 0 ，就代表 TTL 已经到期，就这就会传送错误信息给原本发送的路由设备。</li>
<li>traceroute 工具就是使用 TTL 的方式来完成网络检测。</li>
</ul>
<p>具体参考：</p>
<p><a href="https://www.netadmin.com.tw/netadmin/zh-tw/technology/111381F2995A4AB48672E965F63133AE?page=1">https://www.netadmin.com.tw/netadmin/zh-tw/technology/111381F2995A4AB48672E965F63133AE?page=1</a></p>
<p>ICMP消息大体有两类：</p>
<p><strong>1. 双向消息</strong></p>
<p>比如 Ping 去向包是Echo Request （type 8), 回向的Echo Reply（ type 0), 此为双向！</p>
<p>在比如 ICMP Timestamp Request 是去向，而Timestamp Reply是回向，也是双向交互！</p>
<p>这种双向消息，途径防火墙时，可以依据去向的Request来创建一个有状态条目，那么回包回来时，可以匹配已经创建的、有状态条目，可以允许进入。</p>
<p><strong>2. 单向消息</strong></p>
<p>单向消息一般为告警报错消息（type 3)，或Redirect消息（ type 5)，由于单向的消息是通知源主机出错，那么这种单向消息途径防火墙时，防火墙必须知道这个单向消息属于哪个session? 如何知道呢？</p>
<p>以出错消息” Destination Unreachable” 为例，这个ICMP消息体里会包含原始的IP包 + 上层端口号的信息，那什么是原始IP包？ 通俗地说，就是肇事者，哪个IP包触发这个出错消息的！</p>
<p>既然有了<strong>源目IP + 源目端口号</strong>，那么防火墙很容易检查有没有对应的session ID，如果有，放行；如果没有，丢弃！</p>
]]></content>
      <categories>
        <category>网络</category>
        <category>ICMP</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>ICMP</tag>
      </tags>
  </entry>
  <entry>
    <title>IPv6</title>
    <url>//IPv6.html</url>
    <content><![CDATA[<h1 id="浏览器访问-IPv6-地址的-IP-和端口"><a href="#浏览器访问-IPv6-地址的-IP-和端口" class="headerlink" title="浏览器访问 IPv6 地址的 IP 和端口"></a>浏览器访问 IPv6 地址的 IP 和端口</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://[ipv6地址]:端口</span><br></pre></td></tr></table></figure>

<p>样例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://[fe80::42:e1ff:fe80:f313]:8080</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，IPv6 地址两边要有中括号。</p>
</blockquote>
<h1 id="本地计算机配置-IPv6-注意事项"><a href="#本地计算机配置-IPv6-注意事项" class="headerlink" title="本地计算机配置 IPv6 注意事项"></a>本地计算机配置 IPv6 注意事项</h1><p>本地开启 ipv6</p>
<p>开启本地代理后，浏览器访问 IPv6 会出现 502 bad gateway，</p>
<p>同时本地运行 alidns 即解析 IPv6 的 py脚本也会出现问题。</p>
<p>关掉本地代理即可正常。</p>
]]></content>
      <categories>
        <category>网络</category>
        <category>IPv6</category>
      </categories>
      <tags>
        <tag>IPv6</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络性能测试工具</title>
    <url>//Linux%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.html</url>
    <content><![CDATA[<h1 id="speedtest"><a href="#speedtest" class="headerlink" title="speedtest"></a>speedtest</h1><p>speedtest 是一个较为知名的工具，Python 写的。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果配置了 pip 工具，可以通过 pip&#x2F;pip3 来安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install speedtest-cli</span><br></pre></td></tr></table></figure>

<p>也可以直接下载到本地后赋执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要安装 wget ，同时该网址可能需要代理访问</span></span><br><span class="line">wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class="line"></span><br><span class="line">chmod +x speedtest-cli</span><br></pre></td></tr></table></figure>



<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./speedtest-cli --secure</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或利用python来执行文件</span></span><br><span class="line">python speedtest-cli --secure</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里需要添加 <code>--secure</code> 参数，即使用 HTTPS 代替 HTTP 来访问 speedtest.net 网站；</p>
<p>否则会报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cannot retrieve speedtest configuration</span><br><span class="line">ERROR: HTTP Error 403: Forbidden</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样就可以得到一个上下行的速度测试结果。其他参数可以通过 <code>--help</code> 参数来查看帮助信息。</p>
<p>测试样例和结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@zabbix-proxy ~]# ./speedtest-cli --secure</span><br><span class="line">Retrieving speedtest.net configuration...</span><br><span class="line">Testing from China Telecom (xx.xxx.xxx.xx)...</span><br><span class="line">Retrieving speedtest.net server list...</span><br><span class="line">Selecting best server based on ping...</span><br><span class="line">Hosted by China Unicom 5G (ShangHai) [601.81 km]: 31.032 ms</span><br><span class="line">Testing download speed................................................................................</span><br><span class="line">Download: 1.61 Mbit/s</span><br><span class="line">Testing upload speed................................................................................................</span><br><span class="line">Upload: 2.49 Mbit/s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="1-执行时需要添加-secure-参数"><a href="#1-执行时需要添加-secure-参数" class="headerlink" title="1. 执行时需要添加 --secure 参数"></a>1. 执行时需要添加 <code>--secure</code> 参数</h3><p>这里需要添加 <code>--secure</code> 参数，即使用 HTTPS 代替 HTTP 来访问 speedtest.net 网站；</p>
<p>否则会报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cannot retrieve speedtest configuration</span><br><span class="line">ERROR: HTTP Error 403: Forbidden</span><br></pre></td></tr></table></figure>

<h3 id="2-该工具使用-HTTP-协议来进行测试"><a href="#2-该工具使用-HTTP-协议来进行测试" class="headerlink" title="2. 该工具使用 HTTP 协议来进行测试"></a>2. 该工具使用 HTTP 协议来进行测试</h3><p>该工具使用 Python 写的，<code>speedtest-cli</code> 可以直接打开查看，</p>
<p>大概过程是获取测试 IP 附近的几个站点，然后分别<strong>构造 HTTP 请求</strong>来进行上传和下载测试，通过 <code>v=s/t</code> 的方式计算上传和下载的速度。</p>
<p>值得注意的是，如果当前环境中有对 HTTP 协议进行限速，那么会对该测试的结果有影响。</p>
<p>同时，反过来，如果在测试过程中，发现结果与实际情况相差很多，也可以猜测是否有安全设备对 HTTP 协议进行限制。这时可以找其他工具来对比测试。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cyberciti.biz/faq/install-speedtest-cli-on-centos-redhat-fedoa-scientific-to-measure-internetspeed/">Install Speedtest-cli On a CentOS &#x2F; RHEL &#x2F; Fedora Linux To Check Internet Speed</a></p>
<h1 id="iperf3"><a href="#iperf3" class="headerlink" title="iperf3"></a>iperf3</h1><p>iperf 是一个基于 TCP&#x2F;IP 和 UDP&#x2F;IP 的网络性能测试工具，可以测试带宽，网络延迟抖动和数据包丢失率，用一个名词就是 <strong>QoS</strong>（服务质量）。有 TCP 和 UDP 两种模式来测试。</p>
<p>iperf 是服务器&#x2F;客户端模式的应用，所以测试时需要两台服务器，分别安装 iperf&#x2F;iperf3，一台作为服务端，一台作为客户端进行测试。</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>（1）TCP方面</p>
<ol>
<li>测试网络带宽；</li>
<li>报告MSS&#x2F;MTU值的大小，在Windows上不支持；</li>
<li>支持通过套接字缓冲区修改TCP窗口大小；</li>
</ol>
<p>（2）UDP方面（对UDP应用的关注点不是传输数据有多快，而是它的丢包率和延时指标）</p>
<ol>
<li>可以设置指定带宽的UDP数据流；</li>
<li>可以统计网络抖动值、丢包数等；</li>
<li>支持多播测试；</li>
</ol>
<p>这里因为安装的 CentOS7 默认源中只有 iperf3，所以就以该版本来说。</p>
<blockquote>
<p>注意，iperf 和 iperf3 有部分参数不一样，尤其是<strong>双向测试</strong>的参数，客户端与服务端版本不一样时，客户端访问服务端时需要使用服务端支持的参数。</p>
</blockquote>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>基本默认源中都有 iperf&#x2F;iperf3，但是不同的操作系统可能默认带的版本不一样。</p>
<blockquote>
<p>注意：最好服务端和客户端使用版本一致。如果不一致，注意查看两端支持的参数。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CentOS7</span></span><br><span class="line">yum install -y iperf3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Debian</span></span><br><span class="line">apt-get install iperf3</span><br></pre></td></tr></table></figure>

<p>安装完成后，查看版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iperf3 -v</span><br></pre></td></tr></table></figure>

<p>查看参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iperf3 --help</span><br></pre></td></tr></table></figure>



<p>iperf 与 iperf3 各自有一些不同的特性，具体请查看帮助文档和支持的参数。</p>
<h2 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h2><p>主要参数：</p>
<ul>
<li><p>服务端使用参数 <code>-s</code>；</p>
</li>
<li><p>客户端使用参数 <code>-c</code>；</p>
</li>
</ul>
<p>使用上，客户端主要用于发起连接会话。</p>
<p>服务端启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure>

<blockquote>
<p>iperf3 服务端无论使用 TCP 还是 UDP 都仅需要这个一个参数就可以，iperf 启动 UDP 则需要添加 <code>-u</code>，</p>
<p>其他一些参数，请查看帮助。</p>
</blockquote>
<p>客户端启动测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iperf3 -c 10.11.0.20</span><br></pre></td></tr></table></figure>

<blockquote>
<p>10.11.0.20 是服务端 IP 地址。</p>
</blockquote>
<p>如果使用 UDP 协议测试，iperf3 只需要在客户端添加 <code>-u</code> 参数即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iperf3 -c 10.11.0.20 -u</span><br></pre></td></tr></table></figure>



<h2 id="测试网络带宽"><a href="#测试网络带宽" class="headerlink" title="测试网络带宽"></a>测试网络带宽</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端</span></span><br><span class="line">[root@zabbix ~]# iperf3 -c 10.11.0.20</span><br><span class="line">Connecting to host 10.11.0.20, port 5201</span><br><span class="line">[  4] local 10.2.8.9 port 46060 connected to 10.11.0.20 port 5201</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr  Cwnd</span><br><span class="line">[  4]   0.00-1.00   sec  1008 MBytes  8.45 Gbits/sec  299   1.17 MBytes</span><br><span class="line">[  4]   1.00-2.00   sec   926 MBytes  7.77 Gbits/sec  1716   1.18 MBytes</span><br><span class="line">[  4]   2.00-3.00   sec  1006 MBytes  8.44 Gbits/sec  2007   1.09 MBytes</span><br><span class="line">[  4]   3.00-4.00   sec  1.02 GBytes  8.80 Gbits/sec  669   1.25 MBytes</span><br><span class="line">[  4]   4.00-5.00   sec   905 MBytes  7.59 Gbits/sec  3532   1.06 MBytes</span><br><span class="line">[  4]   5.00-6.00   sec  1.05 GBytes  9.01 Gbits/sec  339    967 KBytes</span><br><span class="line">[  4]   6.00-7.00   sec   994 MBytes  8.34 Gbits/sec  1939   1.41 MBytes</span><br><span class="line">[  4]   7.00-8.00   sec  1.00 GBytes  8.60 Gbits/sec  468   1011 KBytes</span><br><span class="line">[  4]   8.00-9.00   sec   971 MBytes  8.15 Gbits/sec  1939   1.39 MBytes</span><br><span class="line">[  4]   9.00-10.00  sec   885 MBytes  7.42 Gbits/sec  4247   1.24 MBytes</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr</span><br><span class="line">[  4]   0.00-10.00  sec  9.61 GBytes  8.26 Gbits/sec  17155             sender</span><br><span class="line">[  4]   0.00-10.00  sec  9.61 GBytes  8.25 Gbits/sec                  receiver</span><br><span class="line"></span><br><span class="line">iperf Done.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端之后服务端也会有结果打印</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端</span></span><br><span class="line">[root@zabbix-proxy ~]# iperf3 -s</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Server listening on 5201</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Accepted connection from 10.11.1.66, port 46058</span><br><span class="line">[  5] local 10.2.8.5 port 5201 connected to 10.11.1.66 port 46060</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-1.00   sec   968 MBytes  8.12 Gbits/sec</span><br><span class="line">[  5]   1.00-2.00   sec   920 MBytes  7.72 Gbits/sec</span><br><span class="line">[  5]   2.00-3.00   sec  1006 MBytes  8.44 Gbits/sec</span><br><span class="line">[  5]   3.00-4.00   sec  1.03 GBytes  8.81 Gbits/sec</span><br><span class="line">[  5]   4.00-5.00   sec   904 MBytes  7.59 Gbits/sec</span><br><span class="line">[  5]   5.00-6.00   sec  1.05 GBytes  9.02 Gbits/sec</span><br><span class="line">[  5]   6.00-7.00   sec   992 MBytes  8.32 Gbits/sec</span><br><span class="line">[  5]   7.00-8.00   sec  1.00 GBytes  8.60 Gbits/sec</span><br><span class="line">[  5]   8.00-9.00   sec   972 MBytes  8.16 Gbits/sec</span><br><span class="line">[  5]   9.00-10.00  sec   887 MBytes  7.44 Gbits/sec</span><br><span class="line">[  5]  10.00-10.04  sec  39.1 MBytes  8.45 Gbits/sec</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec                  sender</span><br><span class="line">[  5]   0.00-10.04  sec  9.61 GBytes  8.22 Gbits/sec                  receiver</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="测试-UDP-丢包和延迟抖动"><a href="#测试-UDP-丢包和延迟抖动" class="headerlink" title="测试 UDP 丢包和延迟抖动"></a>测试 UDP 丢包和延迟抖动</h2><p>对UDP 测试来说的关注点不是传输数据有多快，而是它的丢包率和延时指标。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端添加 -u 参数即可进行简单测试</span></span><br><span class="line">[root@zabbix ~]# iperf3 -c 10.11.0.20 -u</span><br><span class="line">Connecting to host 10.11.0.20, port 5201</span><br><span class="line">[  4] local 10.2.8.9 port 50273 connected to 10.11.0.20 port 5201</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Total Datagrams</span><br><span class="line">[  4]   0.00-1.00   sec   116 KBytes   950 Kbits/sec  82</span><br><span class="line">[  4]   1.00-2.00   sec   129 KBytes  1.05 Mbits/sec  91</span><br><span class="line">[  4]   2.00-3.00   sec   127 KBytes  1.04 Mbits/sec  90</span><br><span class="line">[  4]   3.00-4.00   sec   129 KBytes  1.05 Mbits/sec  91</span><br><span class="line">[  4]   4.00-5.00   sec   127 KBytes  1.04 Mbits/sec  90</span><br><span class="line">[  4]   5.00-6.00   sec   129 KBytes  1.05 Mbits/sec  91</span><br><span class="line">[  4]   6.00-7.00   sec   127 KBytes  1.04 Mbits/sec  90</span><br><span class="line">[  4]   7.00-8.00   sec   129 KBytes  1.05 Mbits/sec  91</span><br><span class="line">[  4]   8.00-9.00   sec   127 KBytes  1.04 Mbits/sec  90</span><br><span class="line">[  4]   9.00-10.00  sec   129 KBytes  1.05 Mbits/sec  91</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams</span><br><span class="line">[  4]   0.00-10.00  sec  1.24 MBytes  1.04 Mbits/sec  0.012 ms  0/897 (0%)</span><br><span class="line">[  4] Sent 897 datagrams</span><br><span class="line"></span><br><span class="line">iperf Done.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虚线下的内容关注后面2个字段 <code>Jitter</code>,<code>Lost/Total</code>。</p>
<ul>
<li><code>Jitter</code> 列表示抖动时间，或者称为传输延迟；</li>
<li><code>Lost/Total</code> 列表示丢失的数据报和总的数据报数量，后面的0%是平均丢包的比率；</li>
</ul>
<p>同时<code>Datagrams</code> 列显示的是总共传输数据报的数量。</p>
<p>同样，服务端也会有结果打印，有更为详细的 UDP丢包和延迟信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------------------</span><br><span class="line">Server listening on 5201</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">Accepted connection from 10.11.1.66, port 49904</span><br><span class="line">[  5] local 10.2.8.5 port 5201 connected to 10.11.1.66 port 50273</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams</span><br><span class="line">[  5]   0.00-1.00   sec   116 KBytes   950 Kbits/sec  0.010 ms  0/82 (0%)</span><br><span class="line">[  5]   1.00-2.00   sec   129 KBytes  1.05 Mbits/sec  0.011 ms  0/91 (0%)</span><br><span class="line">[  5]   2.00-3.00   sec   127 KBytes  1.04 Mbits/sec  0.010 ms  0/90 (0%)</span><br><span class="line">[  5]   3.00-4.00   sec   129 KBytes  1.05 Mbits/sec  0.010 ms  0/91 (0%)</span><br><span class="line">[  5]   4.00-5.00   sec   127 KBytes  1.04 Mbits/sec  0.010 ms  0/90 (0%)</span><br><span class="line">[  5]   5.00-6.00   sec   129 KBytes  1.05 Mbits/sec  0.008 ms  0/91 (0%)</span><br><span class="line">[  5]   6.00-7.00   sec   127 KBytes  1.04 Mbits/sec  0.010 ms  0/90 (0%)</span><br><span class="line">[  5]   7.00-8.00   sec   129 KBytes  1.05 Mbits/sec  0.007 ms  0/91 (0%)</span><br><span class="line">[  5]   8.00-9.00   sec   127 KBytes  1.04 Mbits/sec  0.009 ms  0/90 (0%)</span><br><span class="line">[  5]   9.00-10.00  sec   129 KBytes  1.05 Mbits/sec  0.012 ms  0/91 (0%)</span><br><span class="line">[  5]  10.00-10.04  sec  0.00 Bytes  0.00 bits/sec  0.012 ms  0/0 (0%)</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams</span><br><span class="line">[  5]   0.00-10.04  sec  0.00 Bytes  0.00 bits/sec  0.012 ms  0/897 (0%)</span><br></pre></td></tr></table></figure>



<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="1-iperf3-服务端不支持-bidir"><a href="#1-iperf3-服务端不支持-bidir" class="headerlink" title="1. iperf3 服务端不支持--bidir"></a>1. iperf3 服务端不支持<code>--bidir</code></h3><p>开始测试时，因环境原因，服务端使用的是 CentOS7.6 （iperf 3.1.7），而客户端使用的是 Debian（iperf 3.11），默认安装的 iperf3 小版本不一致，3.11 版本支持双向测试参数 <code>--bidir</code>，但是 3.1.7 版本不支持该参数，开始时没有注意两端支持的参数，客户端直接使用时报错。随后发现服务端不支持该参数。</p>
<p>可以通过 <code>-R</code> 参数进行反向测试。</p>
<h3 id="2-iperf-与-iperf3-的双向测试参数不同"><a href="#2-iperf-与-iperf3-的双向测试参数不同" class="headerlink" title="2. iperf 与 iperf3 的双向测试参数不同"></a>2. iperf 与 iperf3 的双向测试参数不同</h3><p>iperf 双向测试使用的参数为 <code>-d</code> 即 <code>--dualtest</code>;</p>
<p>iperf3 支持的双向测试参数为 <code>--bidir</code>;</p>
<p>注意查看帮助信息。</p>
<h2 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/bingyu9875/article/details/105700655/">网络性能评估工具Iperf详解（可测丢包率）</a></p>
]]></content>
      <categories>
        <category>网络</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议</title>
    <url>//TCP%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>网络</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>英语单词语句</title>
    <url>//%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E8%AF%AD%E5%8F%A5.html</url>
    <content><![CDATA[<p>upper right corner of any page<br>    任何页面的右上角<br>    upper right corner 右上角</p>
<p>retention &#x2F;rɪ’tenʃ(ə)n&#x2F; 保留<br>    retention.ms kafka中日志最大保留时间<br>    retention.bytes kafka中每个分区文件的最大大小</p>
<p>to use up some unused memory on host<br>    用完主机上一些未使用的内存<br>    - use up 用完，耗尽</p>
<p>digest &#x2F;daɪ’dʒest&#x2F;<br>vt. 消化；吸收；融会贯通<br>vi. 消化<br>n. 摘要；文摘</p>
<p>a daily digest of news<br>    每日新闻摘要</p>
<p>add to digest<br>    加精（网络用语）</p>
<p>across a cluster<br>    跨集群</p>
<p>Properties passed as a method parameter are read last</p>
<p>nomenclature &#x2F;nə(ʊ)’meŋklətʃə&#x2F;  术语<br>This nomenclature comes from MapReduce<br>    - 这个术语来自于MapReduce</p>
<p>Spark breaks the computation into tasks<br>    Spark将计算分解为task<br>    break … into …  : 将…分解为…</p>
<p>merely &#x2F;‘mɪəlɪ&#x2F; 仅仅，只不过  (有点类似于only)</p>
<p> fault-tolerance<br> 容错</p>
<p>instruction &#x2F;ɪn’strʌkʃ(ə)n&#x2F;<br>n. 1.命令, 指示<br>   2.讲授, 指导, 教学<br>   3.使用说明书, 操作指南<br>the address of the Java Virtual Machine instruction ：jvm指令地址</p>
<p>compact 压缩</p>
<p>read-write throughput<br>    读写吞吐量</p>
<h1 id="20210423"><a href="#20210423" class="headerlink" title="20210423"></a>20210423</h1><p>It is worth noting that …</p>
<blockquote>
<p>值得注意的是…</p>
</blockquote>
<p>例句：</p>
<p>It is worth noting that when you delete nodes in a tree。</p>
<blockquote>
<p>值得注意的是，当你删除树中的节点时。</p>
</blockquote>
<p>provided no information used in <strong>equals(Object)</strong> comparison on the Object is modified</p>
<blockquote>
<p>前提是没有修改对象的 equals(Object) 比较中使用的信息</p>
</blockquote>
<p>Most of the criteria are <strong>common sense</strong>. </p>
<blockquote>
<p>大多数标准都是<strong>常识</strong>。</p>
</blockquote>
<p>We can <code>resort to</code> a normal tree traversal to search for the two nodes. Once we reach <code>the desired nodes</code> p and q, we can <code>backtrack</code> and find the lowest common ancestor.</p>
<blockquote>
<p>我们可以<code>求助于</code>普通的树遍历来搜索这两个节点。一旦我们到达<code>所需的节点</code> p 和 q，我们就可以<code>回溯</code>并找到最低的共同祖先。</p>
</blockquote>
<p>The <code>approach</code> is pretty <code>intuitive</code></p>
<blockquote>
<p>该<code>方法</code>非常<code>直观</code></p>
</blockquote>
<p>Approach 1: Recursive Approach</p>
<blockquote>
<p>方法1：递归方法</p>
</blockquote>
<p>The API at a Glance</p>
<blockquote>
<p>API 概览</p>
</blockquote>
<p>glance</p>
<p>It includes an introduction to Spring Boot, along with installation instructions</p>
<blockquote>
<p>它包括 Spring Boot 的介绍，以及安装说明。</p>
</blockquote>
<p>Each release of Spring Boot provides a curated list of dependencies that it supports.</p>
<blockquote>
<p>Spring Boot 的每个版本都提供了它支持的依赖项的精选列表。</p>
</blockquote>
<p>a curated list 精选列表</p>
<p>If several profiles are specified, a last-wins strategy applies.</p>
<blockquote>
<p>如果指定了多个配置文件，则采用后赢策略。</p>
</blockquote>
<p> introspection<br> &#x2F;‘ɪntrə’spɛkʃən&#x2F;<br> n. 反省,内省<br> 不懂怎么用什么意思？</p>
<p>When loading the JDBC driver for database introspection</p>
<blockquote>
<p>加载JDBC驱动进行数据库自省时</p>
</blockquote>
<p>There is an appropriate inheritance relationship between the classes.</p>
<blockquote>
<p>类之间存在适当的继承关系。<br>inheritance relationship<br>继承关系</p>
</blockquote>
<p>hierarchical adj. 分等级的</p>
<p>inheritance n. 继承[计]，继承物，遗产</p>
<p>drain vi. 排水，流干，使流出<br>drainQueue 排空队列，（在 Java 线程池ThreadPoolExecutor 中，这个方法时返回队列中剩余的元素，结合中文意思也很合理。）</p>
<p>category &#x2F;‘kætəɡɔri&#x2F; 类别，种类，范畴:</p>
<p>compatible  &#x2F;kəm’pætəbl&#x2F; adj. 可以并存的, 相容的, 协调的</p>
<ul>
<li>compatible versions 兼容版本</li>
</ul>
<p>Object Mapping Fundamentals 对象映射基础</p>
<p>individual properties 单个属性。</p>
<p>convenience methods 方便方法</p>
<p>convenience 方便的</p>
<p>Besides that 除此之外</p>
<p>Alternatively 或者</p>
<p>In the preceding example 在前面的例子中</p>
<p>act as 充当<br>This class then acts as a custom base class for the repository proxies</p>
<blockquote>
<p>该类然后充当存储库代理的自定义基类</p>
</blockquote>
<p>fundamental &#x2F;fʌndə’ment(ə)l&#x2F; 英式，&#x2F;ˌfʌndə’mɛntl&#x2F; 美式<br>    adj. 基本的; 重要的, 必要的<br>    n. 基本原则, 基本法则</p>
<p>i.e.<br>    abbr. (&#x3D;id est) &lt;拉&gt;即,换言之</p>
<p>assume  &#x2F;ə’sjuːm&#x2F; 英式， &#x2F;ə’sum&#x2F; 美式<br>    vt. 假定</p>
<p>The value resolution assumes …  </p>
<blockquote>
<p>值解析假定…</p>
</blockquote>
<p>n. 绕行路线, 绕道, 环状交叉路<br>adj. 绕道的, 不直截了当的</p>
<p>distinguish &#x2F;dɪ’stɪŋɡwɪʃ&#x2F;<br>    vt. &amp; vi. 辨别, 区别</p>
<p>编程语言中声明或定义变量常用到的两个单词</p>
<p>declare  声明</p>
<p>define   定义</p>
<p>approach  &#x2F;ə’protʃ&#x2F; 方法</p>
<p>entry  &#x2F;ˈɛntri&#x2F; n. 入口；进入；登记；条目；</p>
<p>entity  &#x2F;‘ɛntəti&#x2F;  n. 实体</p>
<p>nested 嵌套的<br>inner 内部的<br>在 java 中，有一个概念称为内部类，</p>
<p>flexible  &#x2F;‘flɛksəbl&#x2F;</p>
<ul>
<li>adj. 灵活的；柔韧的；易弯曲的</li>
</ul>
<p>more flexible 更灵活</p>
<p>retention &#x2F;rɪ’tenʃ(ə)n&#x2F; 英式 &#x2F;rɪ’tɛnʃən&#x2F; 美式 n. 保持，保留</p>
<p>retention time 保持时间<br>retention policy 保留策略</p>
<p>derive 英 &#x2F;dɪˈraɪv&#x2F;  美 &#x2F;dɪˈraɪv&#x2F; vt. 获得</p>
<p>xxx describes how the Java Virtual Machine derives symbolic references from …</p>
<blockquote>
<p>xxx 描述了 jvm 如何从… 获得符号引用</p>
</blockquote>
<p>symbolic 英 &#x2F;sɪmˈbɒlɪk&#x2F;  美 &#x2F;sɪmˈbɑːlɪk&#x2F; adj 象征性 象征的 符号的</p>
<p>symbolic references</p>
<blockquote>
<p>符号引用</p>
</blockquote>
<p>exception</p>
<p>expect<br>expectation</p>
<p>It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time.</p>
<blockquote>
<p>它包含几种类型的常量，从编译时已知的数字字面值到必须在运行时解析的方法和字段引用。</p>
</blockquote>
<p>initiate 英 &#x2F;ɪˈnɪʃieɪt&#x2F;  美 &#x2F;ɪˈnɪʃieɪt&#x2F;  v 启动，发起，开始<br>initial 英 &#x2F;ɪˈnɪʃl&#x2F;  美 &#x2F;ɪˈnɪʃl&#x2F; adj 最初的；首字母的<br>initialize 英 &#x2F;ɪˈnɪʃəlaɪz&#x2F;  美 &#x2F;ɪˈnɪʃəlaɪz&#x2F; vt 初始化<br>initialization 英 &#x2F;ɪˌnɪʃəlaɪˈzeɪʃn&#x2F; 美 &#x2F;ɪˌnɪʃələˈzeɪʃn&#x2F; n 初始化，赋初值</p>
<p>denote 英 &#x2F;dɪˈnəʊt&#x2F;  美 &#x2F;dɪˈnoʊt&#x2F; v. 表示；预示</p>
<p>If N denotes a nonarray class or an interface</p>
<blockquote>
<p>如果N表示一个非数组类或接口</p>
</blockquote>
<p>denoted by  用…表示</p>
<p>individually</p>
<p>strategy </p>
<p>policy</p>
<p>involve</p>
<p>concrete 英 &#x2F;ˈkɒŋkriːt&#x2F;  美 &#x2F;ˈkɑːnkriːt&#x2F; adj. 具体的；实在的，有形的；混凝土的；物质的  </p>
<p>concrete values</p>
<blockquote>
<p>具体的值</p>
</blockquote>
<p>nevertheless 英 &#x2F;ˌnevəðəˈles&#x2F; 美 &#x2F;ˌnevərðəˈles&#x2F; adv. 然而，不过；虽然如此</p>
<p>Nevertheless, resolution fails</p>
<blockquote>
<p>然而，解析失败</p>
</blockquote>
<p>procedure 英 &#x2F;prəˈsiːdʒə(r)&#x2F; 美 &#x2F;prəˈsiːdʒər&#x2F; n. 手续，步骤；过程；</p>
<p>The procedure for initializing C is then as follows:</p>
<blockquote>
<p>初始化C的过程如下：</p>
</blockquote>
<p>facility 英 &#x2F;fəˈsɪləti&#x2F;  美 &#x2F;fəˈsɪləti&#x2F; n. 设施，设备；附加功能；天赋</p>
<p>A facility to load implementations of a service. </p>
<blockquote>
<p>用于加载服务实现的工具。</p>
</blockquote>
<p>supplier 英 &#x2F;səˈplaɪə(r)&#x2F;  美 &#x2F;səˈplaɪər&#x2F; n. 供应厂商；供应者</p>
<p>A nested class is a member of its enclosing class.<br>嵌套类是其外围类的成员。</p>
<p>achievement  英 &#x2F;əˈtʃiːvmənt&#x2F;  美 &#x2F;əˈtʃiːvmənt&#x2F;<br>n. 成绩，成就；完成，实现；（纹章）纹章牌</p>
<p>Badges are special achievements</p>
<blockquote>
<p>徽章是特殊的成就</p>
</blockquote>
<p>infinite   英 &#x2F;ˈɪnfɪnət&#x2F;  美 &#x2F;ˈɪnfɪnət&#x2F; adj. 无限的，无穷尽的；</p>
<p>recursive type <code>List</code> has infinite size。</p>
<blockquote>
<p>递归类型 List 有无限的大小。</p>
</blockquote>
<p>Gang    n. （青少年的）帮派，团伙；</p>
<p>gang of four ，四人帮</p>
<p>infer 英 &#x2F;ɪnˈfɜː(r)&#x2F;  美 &#x2F;ɪnˈfɜːr&#x2F;<br>v. 推断，推论；暗示，暗指</p>
<p>the compiler will be able to infer the type of the variable from the context.</p>
<blockquote>
<p>编译器可以从上下文中推断变量的类型。</p>
</blockquote>
<p>prohibit </p>
<p>英 &#x2F;prəˈhɪbɪt&#x2F; 美 &#x2F;prəˈhɪbɪtˌproʊˈhɪbɪt&#x2F;</p>
<ul>
<li>禁止、不准、防止</li>
</ul>
<p>prohibit-password 禁止密码</p>
<p>concise </p>
<p>美*&#x2F;<em>kənˈsaɪs</em>&#x2F;*</p>
<p>adj. 简明的，简洁的</p>
<p>a concise help message.</p>
<blockquote>
<p>简洁的帮助信息。</p>
</blockquote>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习整体方法和思路</title>
    <url>//%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%95%B4%E4%BD%93%E6%96%B9%E6%B3%95%E5%92%8C%E6%80%9D%E8%B7%AF.html</url>
    <content><![CDATA[<h1 id="英语学习整体方法和思路"><a href="#英语学习整体方法和思路" class="headerlink" title="英语学习整体方法和思路"></a>英语学习整体方法和思路</h1><p>前提，不管英式，美式，对于低水平的人来说，先找一套最方便的资料学就完事了，先学起来，能达到学英语的目的就行，注意学英语的初衷，等到水平高了之后，再去细分英式，美式。<br>    - 对于应试考试，英式与美式没有太大区别，重要的是提高英语水平</p>
<p>市面英语课程分析</p>
<h2 id="英语能力"><a href="#英语能力" class="headerlink" title="英语能力"></a>英语能力</h2><p>《新概念英语》 –包含了听说读写，但不适合自学，太枯燥，并且没有扩展内容，适合老师带着学生学，可以找对应的老师讲解的视频配合学，<br>    –适合语法，常见积累量，往读写方向走</p>
<p>《赖世雄美语从头学》<br>    –基础阶段，也是主要是语法，常见积累量，同时三核心也能带到，有非常多的带读，是一个美式体系，三核心的音标用的是美式kk音标，书中所有标注都是美式kk音标，有对应讲解的音频<br>    这套书买回去是可以自学的</p>
<p>外教口语一对一，这类课程，不适合基础不够的人，这种情况下，没有东西输出，效果很差，适合有足够输入的人，比如雅思7，找人联系口语的，  </p>
<p>语境背单词</p>
<p>听力口语课程，类似，看美剧&#x2F;电影学英语  etc<br>    –属于输入阶段，的听说部分，会涉及精听，泛听，同时需要一定的输出，这样才能掌握的更牢固</p>
<p>阅读写作课程， 类似，名著&#x2F;外刊精读，xxx阅读打卡<br>    –属于读写这部分的输入，同上</p>
<h2 id="应试课程"><a href="#应试课程" class="headerlink" title="应试课程"></a>应试课程</h2><p>四六级、雅思托福、应试词汇课<br>    –提供的是应试技巧，如，题型，词语，怎么在短期尽可能给你去拿到更多的分数，</p>
<p>学习资料推荐</p>
<ol>
<li>《》2019版，上海文化出版社</li>
</ol>
<p>材料获取的难度低<br>学习的逻辑要清晰</p>
<h3 id="三核心"><a href="#三核心" class="headerlink" title="三核心"></a>三核心</h3><ul>
<li>音标<ul>
<li>《赖世雄美语音标》</li>
<li>B站昂克英文君的美式kk音标串讲 PartA B</li>
<li>音标学习的注意点：<ol>
<li>一定要录音对比，去提高听力识别度（这样才能在练习的时候知道自己是错的，还是对的）</li>
<li>切勿钻牛角尖，我们和老外声带厚度就不同<ul>
<li>前期的目标一定要是，读正确，读流利，而不是读的多么地道，不现实。</li>
</ul>
</li>
<li>切勿乱，一开始就把体系构建好，后面再精修</li>
</ol>
</li>
</ul>
</li>
<li>连读（所有人必练）<ul>
<li>听力听不懂<ol>
<li>积累量不够（单词，短语，句子）</li>
<li>发音和连读不熟悉</li>
<li>文化背景</li>
</ol>
</li>
<li>训练材料<ul>
<li>B站昂克君“最全英语连读规则”共9课时</li>
</ul>
</li>
<li>注意事项：<ol>
<li>不要钻牛角尖，例如：你算什么男人&#x2F;你三婶摸男人，当遇到无论怎样都分辨不出来的情况，就跳过，不必纠结于特定一两句</li>
<li>个人习惯不同，连读也会不同，知道怎么连读的规则，当一句话有多种方式连读时，选择合适的就可以</li>
<li>必须得大量实战，大量跟读，100篇播客的量起步<ul>
<li>EnglishPod</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>语调<ul>
<li>有需要的可以专门去练</li>
<li>需要在实战中大量练习</li>
<li>训练材料<ul>
<li>《American Accent Training》美语发音秘诀，简称AAT<br>4-12个月不等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>词法<ul>
<li>通过考试，最好能得高分</li>
<li>材料推荐<ol>
<li>梳理框架 语法总框架+语法精讲（B站昂克君视频）+ 旋天佑《语法俱乐部》</li>
<li>大量做题 《Grammar in use》 （可以看B站昂克君视频一起学）</li>
<li>补充，适合有纯粹语法题型考试的同学（英专，初高中）<ul>
<li>赖世雄《赖世雄经典语法》薄 1本</li>
<li>张满胜《英语语法新思维》厚 初&#x2F;中&#x2F;高级  3本教程</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>句法</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>音标学习</title>
    <url>//%E9%9F%B3%E6%A0%87%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h3 id="oo-到底发什么音？"><a href="#oo-到底发什么音？" class="headerlink" title="oo 到底发什么音？"></a>oo 到底发什么音？</h3><p>这个没有规律，只能查字典，别去猜。</p>
<p>可能读 </p>
<p>也可能读</p>
<h1 id="日化元音"><a href="#日化元音" class="headerlink" title="日化元音"></a>日化元音</h1><p>日化元音是一个整体，不要分开读</p>
<p>和 <strong>儿</strong> 的区别</p>
<ol>
<li>汉语是卷舌，美音是后缩；</li>
<li>汉语下放下颌骨，美音不放；</li>
</ol>
<p>当单词中有字母 <code>r</code> 时，美音才会发日化元音。</p>
<ul>
<li>单词中没有 <code>r</code> 的时候，无论英音还是美音，都不会发xx 这个音的</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>服务启动</title>
    <url>//%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8.html</url>
    <content><![CDATA[<p>简单启动web服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python2</span></span><br><span class="line">python -m SimpleHTTPServer 8080</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python3 模块名不一样</span></span><br><span class="line">python -m http.server 8080</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在浏览器打开后，默认是访问启动服务时的目录</span></span><br></pre></td></tr></table></figure>

<p>这样就可以启动一个本地 web 服务，对外提供请求。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>迈普交换机学习</title>
    <url>//%E8%BF%88%E6%99%AE%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p>以下内容，参考 <strong>MyPower S5820系列交换机命令手册</strong></p>
<p><strong>注意：</strong>通过SSH方式远程进入交换机的时候，默认就是特权模式。下面命令无特殊说明都可以直接执行。（注意看命令提示符）</p>
<h1 id="接口相关操作"><a href="#接口相关操作" class="headerlink" title="接口相关操作"></a>接口相关操作</h1><h2 id="逻辑上启用或关闭一个接口"><a href="#逻辑上启用或关闭一个接口" class="headerlink" title="逻辑上启用或关闭一个接口"></a>逻辑上启用或关闭一个接口</h2><p>命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown  关闭接口</span><br><span class="line"></span><br><span class="line">no shutdown  开启接口</span><br></pre></td></tr></table></figure>

<p>样例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">Hostname#</span><span class="language-bash">configure terminal</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">Hostname(config)#</span><span class="language-bash">interface tengigabitethernet 0/1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">Hostname(config-if-tengigabitethernet0/1)#</span><span class="language-bash">shutdown</span></span><br></pre></td></tr></table></figure>



<h2 id="列出端口信息"><a href="#列出端口信息" class="headerlink" title="列出端口信息"></a>列出端口信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show interface &#123; interface-list | switchport [ brief ] &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>interface-list</em>：指定端口列表。端口列表的表示形式可以是单个或多个端口名称，符号“,”用于分隔不连续的端口名称，“-”用于表示连续的端口名称。</p>
<p><strong>switchport</strong>：所有的端口。</p>
<p><strong>brief</strong>：显示所有端口的摘要信息；当省略这个参数时，表示显示所有端口的全部信息。</p>
</blockquote>
<p>样例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示端口tengigabitethernet0/1的全部信息。</span></span><br><span class="line"><span class="meta prompt_">Hostname#</span><span class="language-bash">show interface te0/1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示所有端口的摘要信息。</span></span><br><span class="line"><span class="meta prompt_">Hostname#</span><span class="language-bash">show interface switchport brief</span> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络</category>
        <category>交换机</category>
        <category>迈普</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>交换机</tag>
        <tag>迈普</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadopp-balance数据平衡</title>
    <url>//Hadopp-balance%E6%95%B0%E6%8D%AE%E5%B9%B3%E8%A1%A1.html</url>
    <content><![CDATA[<p>Rebalance Server计算哪些机器需要将数据移动，哪些机器可以接受移动的数据。并且从Name Node中获取需要移动的数据分布情况。<br>    计算规则是什么？ 这块代码在哪里？</p>
<p>切换到hdfs用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su - hdfs</span><br></pre></td></tr></table></figure>
<p>打印hdfs状态信息,会得到磁盘使用状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs dfsadmin -report</span><br></pre></td></tr></table></figure>
<p>balancer 使用帮助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs  balancer  -help</span><br><span class="line">-threshold  10                    \\集群平衡的条件，datanode间磁盘使用率相差阈值，区间选择：0~100 </span><br><span class="line">-policy datanode                  \\默认为datanode，datanode级别的平衡策略</span><br><span class="line">-exclude  -f  /tmp/ip1.txt        \\默认为空，指定该部分ip不参与balance， -f：指定输入为文件</span><br><span class="line">-include  -f  /tmp/ip2.txt        \\默认为空，只允许该部分ip参与balance，-f：指定输入为文件</span><br><span class="line">-idleiterations  5                \\迭代次数，默认为 5</span><br></pre></td></tr></table></figure>

<p>datanode之间数据迁移的带宽设置，可以在平台上修改，需要重启集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.balance.bandwidthPerSec&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;6250000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;备注：6250000 / (1024 * 1024) = 6M/s&gt;</span><br><span class="line">或者设置临时带宽：</span><br><span class="line"># hdfs dfsadmin -setBalancerBandwidth 6250000 </span><br></pre></td></tr></table></figure>

<p>动态增大带宽（不需重启，需要切换到hdfs用户，不可设置太大，会占用mapreduce任务的带宽）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs dfsadmin -fs hdfs://$&#123;active-namenode-hostname&#125;:8020 -setBalancerBandwidth 104857600</span><br></pre></td></tr></table></figure>

<p>balance脚本在满足以下任何一个条件都会自动退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* The cluster is balanced;</span><br><span class="line">* No block can be moved;</span><br><span class="line">* No block has been moved for specified consecutive iterations (5 by default);</span><br><span class="line">* An IOException occurs while communicating with the namenode;</span><br><span class="line">* Another balancer is running.</span><br></pre></td></tr></table></figure>


<p>Hadoop的开发人员在开发Balancer程序的时候，遵循了以下几点原则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在执行数据重分布的过程中，必须保证数据不能出现丢失，不能改变数据的备份数，不能改变每一个rack中所具备的block数量。</span><br><span class="line">2.系统管理员可以通过一条命令启动数据重分布程序或者停止数据重分布程序。</span><br><span class="line">3.Block在移动的过程中，不能占用过多的资源，如网络带宽。</span><br><span class="line">4.数据重分布程序在执行的过程中，不能影响name node的正常工作。</span><br></pre></td></tr></table></figure>

<p>手动执行balancer命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs balancer -threshold 10   #10为各节点存储的浮动比例10%上下浮动</span><br></pre></td></tr></table></figure>

<p>Hadoop Balancer的步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、balancer服务，从namenode获取datanode磁盘的使用情况</span><br><span class="line">2、balancer服务，计算需要把哪些数据移动到哪些节点</span><br><span class="line">3、需要移动block的机器将数据移动的目的机器上去，同时删除自己机器上的block副本数据。</span><br><span class="line">4、balancer服务，获取到本次数据移动的执行结果，并继续执行这个过程，一直没有数据可以移动或者HDFS集群以及达到了平衡的标准为止。</span><br></pre></td></tr></table></figure>

<p>可能存在的问题：</p>
<p>现在我们设想这样一种情况：</p>
<ol>
<li>数据是3份备份。</li>
<li>HDFS由2个rack组成。</li>
<li>2个rack中的机器磁盘配置不同，第一个rack中每一台机器的磁盘空间为1TB，第二个rack中每一台机器的磁盘空间为10TB。</li>
<li>现在大多数数据的2份备份都存储在第一个rack中。<br>在这样的一种情况下，HDFS级群中的数据肯定是不平衡的。现在我们运行Balancer程序，但是会发现运行结束以后，整个HDFS集群中的数据依旧不平衡：rack1中的磁盘剩余空间远远小于rack2。</li>
</ol>
<p>这是因为Balance程序的开发原则1导致的。<br>简单的说，就是在执行Balancer程序的时候，不会将数据中一个rack移动到另一个rack中，所以就导致了Balancer程序永远无法平衡HDFS集群的情况。</p>
<p>针对于这种情况，可以采取的方案：</p>
<ol>
<li>继续使用现有的Balancer程序，但是修改rack中的机器分布。将磁盘空间小的机器分叉到不同的rack中去。</li>
<li>修改Balancer程序，允许改变每一个rack中所具备的block数量，将磁盘空间告急的rack中存放的block数量减少，或者将其移动到其他磁盘空间富余的rack中去。</li>
</ol>
<p>另外一种方法：<br>–可能存在风险</p>
<p>可以让某个hdfs空间最满的节点先做下线处理，做下decommission，格式化现有的数据盘，然后再重新加入到节点中来，这也是个方法，让hdfs缺失的一份数据平均分配到其他节点上，速度会比较快，</p>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Hadoop</tag>
        <tag>数据平衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Ranger使用遇到问题</title>
    <url>//Ranger%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="Ranger修改密码遇到问题及修复"><a href="#Ranger修改密码遇到问题及修复" class="headerlink" title="Ranger修改密码遇到问题及修复"></a>Ranger修改密码遇到问题及修复</h1><p>版本信息：Ranger-1.2.0集成到Ambari-2.7.3&amp;HDP-3.1.0</p>
<p>问题描述：</p>
<ul>
<li>应要求需要修改大数据平台中 Ranger服务的UI的用户登录密码，以及Ambari平台用户登录密码；</li>
</ul>
<p>操作过程：</p>
<ul>
<li>登录RangerUI，使用需要修改密码的用户登录，点击右上角用户名的<code>profile</code> -&gt; 选择<code>Change Password</code>，然后输入旧密码和新密码，Ok，退出重登；</li>
<li>登录Ambari平台，点击用户名 -&gt; 管理 -&gt; 用户列表 -&gt; 选择指定用户点击修改 -&gt; 点击<code>Chanage Password</code> ，同样用新密码修改后，退出重新登录；</li>
</ul>
<p>发现问题：</p>
<ul>
<li><p>第二天发现平台有报错信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">User:admin credentials on Ambari UI are not in sync with Ranger</span><br></pre></td></tr></table></figure></li>
</ul>
<p>原因及解决：</p>
<ul>
<li><p>ambari的Ranger组件配置文件中<code>Ranger Admin user&#39;s password</code>的密码与新密码不符导致校验出错，</p>
</li>
<li><p>处理方式就是选择Ranger服务-&gt; 配置 -&gt; ADVANCED -&gt; 高级的 ranger-env -&gt; <code>Ranger Admin user&#39;s password</code>，修改其密码为RangerUI中修改的新密码，然后保存配置即可。</p>
<blockquote>
<p>该版本，无需重启服务。</p>
</blockquote>
</li>
<li><p>修改后可以点击检查服务状态，或者等其自动恢复。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Ranger</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Ranger</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive-wiki建议参数测试一下</title>
    <url>//Hive-wiki%E5%BB%BA%E8%AE%AE%E5%8F%82%E6%95%B0%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B.html</url>
    <content><![CDATA[<p><a href="https://cwiki.apache.org/confluence/display/Hive/Hive+on+Spark%3A+Getting+Started">https://cwiki.apache.org/confluence/display/Hive/Hive+on+Spark%3A+Getting+Started</a></p>
<p>Hive wiki Recommended Configuration<br>可以根据现有集群测试一下这些参数效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mapreduce.input.fileinputformat.split.maxsize=750000000</span><br><span class="line">hive.vectorized.execution.enabled=true</span><br><span class="line"></span><br><span class="line">hive.cbo.enable=true</span><br><span class="line">hive.optimize.reducededuplication.min.reducer=4</span><br><span class="line">hive.optimize.reducededuplication=true</span><br><span class="line">hive.orc.splits.include.file.footer=false</span><br><span class="line">hive.merge.mapfiles=true</span><br><span class="line">hive.merge.sparkfiles=false</span><br><span class="line">hive.merge.smallfiles.avgsize=16000000</span><br><span class="line">hive.merge.size.per.task=256000000</span><br><span class="line">hive.merge.orcfile.stripe.level=true</span><br><span class="line">hive.auto.convert.join=true</span><br><span class="line">hive.auto.convert.join.noconditionaltask=true</span><br><span class="line">hive.auto.convert.join.noconditionaltask.size=894435328</span><br><span class="line">hive.optimize.bucketmapjoin.sortedmerge=false</span><br><span class="line">hive.map.aggr.hash.percentmemory=0.5</span><br><span class="line">hive.map.aggr=true</span><br><span class="line">hive.optimize.sort.dynamic.partition=false</span><br><span class="line">hive.stats.autogather=true</span><br><span class="line">hive.stats.fetch.column.stats=true</span><br><span class="line">hive.vectorized.execution.reduce.enabled=false</span><br><span class="line">hive.vectorized.groupby.checkinterval=4096</span><br><span class="line">hive.vectorized.groupby.flush.percent=0.1</span><br><span class="line">hive.compute.query.using.stats=true</span><br><span class="line">hive.limit.pushdown.memory.usage=0.4</span><br><span class="line">hive.optimize.index.filter=true</span><br><span class="line">hive.exec.reducers.bytes.per.reducer=67108864</span><br><span class="line">hive.smbjoin.cache.rows=10000</span><br><span class="line">hive.exec.orc.default.stripe.size=67108864</span><br><span class="line">hive.fetch.task.conversion=more</span><br><span class="line">hive.fetch.task.conversion.threshold=1073741824</span><br><span class="line">hive.fetch.task.aggr=false</span><br><span class="line">mapreduce.input.fileinputformat.list-status.num-threads=5</span><br><span class="line">spark.kryo.referenceTracking=false</span><br><span class="line">spark.kryo.classesToRegister=org.apache.hadoop.hive.ql.io.HiveKey,org.apache.hadoop.io.BytesWritable,org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>现场Hive用过的语法</title>
    <url>//%E7%8E%B0%E5%9C%BAHive%E7%94%A8%E8%BF%87%E7%9A%84%E8%AF%AD%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="部分现场Hive用过的语法"><a href="#部分现场Hive用过的语法" class="headerlink" title="部分现场Hive用过的语法"></a>部分现场Hive用过的语法</h2><p>1.<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into table simba.t_res_phy_attribute_3d partition(action_time=&#x27;202006&#x27;, import_time=&#x27;2020060315&#x27;) select uuid,code_type,code,attribute_type,attribute,code_area,attribute_area,capture_time,longitude,latitude,location_type,location,location_area,action,origin_data,origin_data_uuid,start_time,end_time,count from simba.simba_phy_attribute where action_time=&#x27;202006&#x27; and import_time&gt;=2020060100 and import_time&lt;2020060400 and origin_data not in (&#x27;lt_jizhu&#x27;,&#x27;yd_jizhu&#x27;,&#x27;dx_jizhu&#x27;);</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li><p>生成uuid</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">reflect(&quot;java.util.UUID&quot;,&quot;randomUUID&quot;)</span><br><span class="line"></span><br><span class="line">The <span class="keyword">function</span> GenericUDFReflect(class,<span class="keyword">method</span>[,arg1[,arg2]...])</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间格式正则表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   ^[1-9]\d&#123;3&#125;-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])\s+(20|21|2|23|[0-1]\d):[0-5]\d:[0-5]\d$</span><br><span class="line">regexp_extract(&#x27;2020-06-12 12:37:37&#x27;,&#x27;^[1-9]\d&#123;3&#125;-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])\s+(20|21|2|23|[0-1]\d):[0-5]\d:[0-5]\d$&#x27;,0)</span><br><span class="line"></span><br><span class="line">   regexp_extract(offereffdate,&#x27;^[1-9]\\d&#123;3&#125;-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])\\s+(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d$&#x27;,0),$s)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有结果，返回空字符串 ‘’</li>
<li>注意是空字符串，而不是’ ‘，同样也不是NULL， 判断是需要使用 x!&#x3D;’’ ,或者 x!&#x3D;’’ or x is not null</li>
</ul>
</li>
<li><p>删除指定表指定分区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> simba.simba_phy_attribute_temp <span class="keyword">drop</span> if <span class="keyword">exists</span> <span class="keyword">partition</span> (action_time<span class="operator">=</span><span class="number">2001</span><span class="number">-0</span>) PURGE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>convert a string to timestamp</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">from_utc_timestamp(date_format(<span class="string">&#x27;2020-05-12 19:57:12&#x27;</span>,<span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>),<span class="string">&#x27;UTC&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>hive表重命名</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> rename <span class="keyword">to</span> <span class="operator">&lt;</span>new_table_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<p> 样例：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> titan_mass.t_20200613114054_rxwi rename <span class="keyword">to</span> simba.t_res_jizhudengji;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 Hive 中导出数据到本地</p>
<ol>
<li><p>将需要导出的表，另存为文本格式的表数据<br>可以是 csv 格式，语法如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 另存一张新表 <span class="type">row</span> format serde <span class="string">&#x27;org.apache.hadoop.hive.serde2.OpenCSVSerde&#x27;</span> <span class="keyword">with</span> SERDEPROPERTIES (<span class="string">&#x27;escapeChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;\&quot;&#x27;</span>, <span class="string">&#x27;quoteChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;\&quot;&#x27;</span>,<span class="string">&#x27;separatorChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;,&#x27;</span>) stored <span class="keyword">as</span> textfile <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 需要导出的表 ;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> titan_mass.special_app_result01 <span class="type">row</span> format serde <span class="string">&#x27;org.apache.hadoop.hive.serde2.OpenCSVSerde&#x27;</span> <span class="keyword">with</span> SERDEPROPERTIES (<span class="string">&#x27;escapeChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;\&quot;&#x27;</span>, <span class="string">&#x27;quoteChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;\&quot;&#x27;</span>,<span class="string">&#x27;separatorChar&#x27;</span><span class="operator">=</span><span class="string">&#x27;,&#x27;</span>) stored <span class="keyword">as</span> textfile <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> titan_mass.aaaaa;</span><br></pre></td></tr></table></figure>
<p>也可以是普通 textfile 格式，如下 <code>\t</code> 分割字段，<code>\n</code> 换行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> titan_temp.express_yunda <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> stored <span class="keyword">as</span> textfile <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> simba.express<span class="operator">-</span>yunda<span class="operator">-</span>waybill;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认需要导出数据的csv表在hdfs上的路径<br>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">desc formatted special_app_result01;</span><br><span class="line">hdfs://ambari01/apps/hive/warehouse/titan_mass.db/special_app_result01</span><br></pre></td></tr></table></figure>
</li>
<li><p>在装由hadoop客户端的机器上，执行下面语句，将csv格式的数据导出到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -get hdfs://ambari01/apps/hive/warehouse/titan_mass.db/special_app_result01 /opt/install</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以将文件导出到windows中，用导入工具处理，也可以先在windows下配置导入工具的模型，然后将导入工具和模型放到数据所在机器，然后linux执行</p>
</li>
</ol>
</li>
<li><p>取top1<br>hive中分组取top1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> titan_temp.jizhudengji_etl <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> stored <span class="keyword">as</span> textfile <span class="keyword">as</span> <span class="keyword">select</span> customername,certtypeid,idcard,cardaddr,originphone,address,status,offerexpdate,offereffdate <span class="keyword">from</span> (<span class="keyword">select</span> customername,certtypeid,idcard,cardaddr,originphone,address,status,offerexpdate,offereffdate,<span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> originphone <span class="keyword">order</span> <span class="keyword">by</span> offereffdate <span class="keyword">desc</span>) <span class="keyword">as</span> row_number <span class="keyword">from</span> simba.tj_jizhudengji) t <span class="keyword">where</span> row_number<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="恢复drop和truncate-hive表或分区"><a href="#恢复drop和truncate-hive表或分区" class="headerlink" title="恢复drop和truncate hive表或分区"></a>恢复drop和truncate hive表或分区</h2><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li>切换到 hive 用户<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su - hive</span><br></pre></td></tr></table></figure></li>
<li>查看 hdfs 上 <code>.Trash</code>目录下被误删除的表或者分区<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs dfs -ls /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email</span><br></pre></td></tr></table></figure></li>
<li>通过 hdfs 的 mv 或者 cp 命令将 <code>.Trash </code>目录下的数据恢复到原来表路径下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs dfs -cp /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email/* /apps/hive/warehouse/titan_temp.db/t_email</span><br></pre></td></tr></table></figure></li>
<li>恢复 meta 信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msck repair table titan_temp.t_email;</span><br></pre></td></tr></table></figure></li>
<li>恢复统计信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--这里需要查看hive官方文档的StatsDev章节的existing tables -analyze，对两个分区全部分区内容做analyze</span><br><span class="line">analyze table titan_temp.t_email partition(action_time,import_time) compute statistics;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="truncate-，drop-表数据恢复过程"><a href="#truncate-，drop-表数据恢复过程" class="headerlink" title="truncate ，drop 表数据恢复过程"></a>truncate ，drop 表数据恢复过程</h3><h4 id="1-创建表，插入测试数据"><a href="#1-创建表，插入测试数据" class="headerlink" title="1. 创建表，插入测试数据"></a>1. 创建表，插入测试数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建表，插入测试数据</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_test_recover <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> stored <span class="keyword">as</span> orc tblproperties (<span class="string">&#x27;orc.compress&#x27;</span><span class="operator">=</span><span class="string">&#x27;SNAPPY&#x27;</span>) <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> relate_attribute_stat_temp limit <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> titan_temp.t_email</span><br><span class="line">(</span><br><span class="line">    cor_id                       string           comment <span class="string">&#x27;话单唯一标识&#x27;</span>,</span><br><span class="line">    location_code                <span class="type">decimal</span>(<span class="number">6</span>)       comment <span class="string">&#x27;数据来源地&#x27;</span></span><br><span class="line"></span><br><span class="line">)                                                       </span><br><span class="line">comment <span class="string">&#x27;t_email&#x27;</span></span><br><span class="line">partitioned <span class="keyword">by</span> (                                           </span><br><span class="line">                 action_time  string comment <span class="string">&#x27;cap_time&#x27;</span>,</span><br><span class="line">                 import_time  string comment <span class="string">&#x27;import_time&#x27;</span></span><br><span class="line">               )</span><br><span class="line"><span class="type">row</span> format delimited                                       </span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>                                  </span><br><span class="line">stored <span class="keyword">as</span> orc tblproperties (<span class="string">&#x27;orc.compression&#x27;</span><span class="operator">=</span><span class="string">&#x27;snappy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> titan_temp.t_email <span class="keyword">SET</span> SERDEPROPERTIES (<span class="string">&#x27;escape.delim&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> titan_temp.t_email <span class="keyword">partition</span>(action_time<span class="operator">=</span><span class="string">&#x27;202006&#x27;</span>,import_time<span class="operator">=</span><span class="string">&#x27;20200629&#x27;</span>) <span class="keyword">select</span> cdrid,location_code <span class="keyword">from</span> simba.data_email <span class="keyword">where</span> import_time<span class="operator">=</span><span class="string">&#x27;2020062912&#x27;</span> limit <span class="number">200</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> titan_temp.t_email <span class="keyword">partition</span>(action_time<span class="operator">=</span><span class="string">&#x27;202007&#x27;</span>,import_time<span class="operator">=</span><span class="string">&#x27;20200729&#x27;</span>) <span class="keyword">select</span> cdrid,location_code <span class="keyword">from</span> simba.data_email <span class="keyword">where</span> import_time<span class="operator">=</span><span class="string">&#x27;2020072912&#x27;</span> limit <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看测试表中数据量</span></span><br><span class="line"><span class="number">0</span>: jdbc:hive2:<span class="operator">/</span><span class="operator">/</span><span class="number">192.168</span><span class="number">.10</span><span class="number">.27</span>:<span class="number">2181</span>,<span class="number">192.168</span><span class="number">.10</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> titan_temp.t_email;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--+</span></span><br><span class="line"><span class="operator">|</span> _c0  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">400</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-truncate-的恢复过程"><a href="#2-truncate-的恢复过程" class="headerlink" title="2. truncate 的恢复过程"></a>2. truncate 的恢复过程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--将表数据清空，truncate</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; truncate table titan_temp.t_email;</span><br><span class="line">No rows affected (0.349 seconds)</span><br><span class="line"></span><br><span class="line">--切换到hive用户</span><br><span class="line">-- 查看hdfs目录下的Trash目录下被清空的数据</span><br><span class="line">-bash-4.1$ hdfs dfs -ls /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email</span><br><span class="line">Found 2 items</span><br><span class="line">drwx------   - hive hdfs          0 2020-07-31 11:09 /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email/action_time=202006</span><br><span class="line">drwx------   - hive hdfs          0 2020-07-31 11:09 /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email/action_time=202007</span><br><span class="line"></span><br><span class="line">--恢复hdfs目录下的数据</span><br><span class="line">-bash-4.1$ hdfs dfs -cp /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email/* /apps/hive/warehouse/titan_temp.db/t_email</span><br><span class="line"></span><br><span class="line">-bash-4.1$ hdfs dfs -ls /apps/hive/warehouse/titan_temp.db/t_email</span><br><span class="line">Found 2 items</span><br><span class="line">drwxrwxrwx   - hive hdfs          0 2020-07-31 11:09 /apps/hive/warehouse/titan_temp.db/t_email/action_time=202006</span><br><span class="line">drwxrwxrwx   - hive hdfs          0 2020-07-31 11:09 /apps/hive/warehouse/titan_temp.db/t_email/action_time=202007</span><br><span class="line"></span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; select * from titan_temp.t_email limit 1;</span><br><span class="line">+---------------------------------------+------------------------+----------------------+----------------------+--+</span><br><span class="line">|            t_email.cor_id             | t_email.location_code  | t_email.action_time  | t_email.import_time  |</span><br><span class="line">+---------------------------------------+------------------------+----------------------+----------------------+--+</span><br><span class="line">| e3b30b3d-35fc-400b-ae53-fce3ddfd9d6c  | 120000                 | 202006               | 20200629             |</span><br><span class="line">+---------------------------------------+------------------------+----------------------+----------------------+--+</span><br><span class="line">10 rows selected (0.119 seconds)</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; select count(1) from titan_temp.t_email;</span><br><span class="line">+------+--+</span><br><span class="line">| _c0  |</span><br><span class="line">+------+--+</span><br><span class="line">| 0    |</span><br><span class="line">+------+--+</span><br><span class="line"></span><br><span class="line">--修复meta信息</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; msck repair table titan_temp.t_email;</span><br><span class="line">--统计数据量</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; analyze table titan_temp.t_email compute statistics;</span><br><span class="line">Error: Error while compiling statement: FAILED: SemanticException [Error 10115]: Table is partitioned and partition specification is needed (state=42000,code=10115)</span><br><span class="line"></span><br><span class="line">--这里需要查看hive官方文档的StatsDev章节的existing tables -analyze，对两个分区全部分区内容做analyze</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; analyze table titan_temp.t_email partition(action_time,import_time) compute statistics;</span><br><span class="line">No rows affected (0.485 seconds)</span><br><span class="line"></span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; select count(1) from titan_temp.t_email;</span><br><span class="line">+------+--+</span><br><span class="line">| _c0  |</span><br><span class="line">+------+--+</span><br><span class="line">| 400  |</span><br><span class="line">+------+--+</span><br><span class="line">1 row selected (0.085 seconds)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-drop-的恢复过程"><a href="#3-drop-的恢复过程" class="headerlink" title="3. drop 的恢复过程"></a>3. drop 的恢复过程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--DROP TABLE</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; drop table titan_temp.t_email;</span><br><span class="line">No rows affected (0.315 seconds)</span><br><span class="line"></span><br><span class="line">-bash-4.1$ hdfs dfs -ls /apps/hive/warehouse/titan_temp.db/t_email</span><br><span class="line">ls: `/apps/hive/warehouse/titan_temp.db/t_email&#x27;: No such file or directory</span><br><span class="line">-bash-4.1$</span><br><span class="line"></span><br><span class="line">--重新建表，然后查看新表信息</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; select count(1) from titan_temp.t_email;</span><br><span class="line">+------+--+</span><br><span class="line">| _c0  |</span><br><span class="line">+------+--+</span><br><span class="line">| 0    |</span><br><span class="line">+------+--+</span><br><span class="line">1 row selected (0.45 seconds)</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; show partitions titan_temp.t_email;</span><br><span class="line">+------------+--+</span><br><span class="line">| partition  |</span><br><span class="line">+------------+--+</span><br><span class="line">+------------+--+</span><br><span class="line">No rows selected (0.208 seconds)</span><br><span class="line"></span><br><span class="line">--从Trash中恢复数据</span><br><span class="line">-bash-4.1$ hdfs dfs -cp /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email /apps/hive/warehouse/titan_temp.db/</span><br><span class="line"></span><br><span class="line">-bash-4.1$ hdfs dfs -ls /apps/hive/warehouse/titan_temp.db/t_email</span><br><span class="line">Found 2 items</span><br><span class="line">drwxr-xr-x   - hive hdfs          0 2020-07-31 14:30 /apps/hive/warehouse/titan_temp.db/t_email/action_time=202006</span><br><span class="line">drwxr-xr-x   - hive hdfs          0 2020-07-31 14:30 /apps/hive/warehouse/titan_temp.db/t_email/action_time=202007</span><br><span class="line"></span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; select count(1) from titan_temp.t_email;</span><br><span class="line">Error: Error while compiling statement: FAILED: SemanticException [Error 10001]: Line 1:21 Table not found &#x27;t_email&#x27; (state=42S02,code=10001)</span><br><span class="line"></span><br><span class="line">--查看信息</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; show partitions titan_temp.t_email;</span><br><span class="line">+------------+--+</span><br><span class="line">| partition  |</span><br><span class="line">+------------+--+</span><br><span class="line">+------------+--+</span><br><span class="line">No rows selected (0.208 seconds)</span><br><span class="line"></span><br><span class="line">--修复meta信息，恢复分区信息</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; msck repair table titan_temp.t_email;</span><br><span class="line">No rows affected (0.238 seconds)</span><br><span class="line"></span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; show partitions titan_temp.t_email;</span><br><span class="line">+------------------------------------------+--+</span><br><span class="line">|                partition                 |</span><br><span class="line">+------------------------------------------+--+</span><br><span class="line">| action_time=202006/import_time=20200629  |</span><br><span class="line">| action_time=202007/import_time=20200729  |</span><br><span class="line">+------------------------------------------+--+</span><br><span class="line">2 rows selected (0.164 seconds)</span><br><span class="line"></span><br><span class="line">重新执行count(1) 或者执行统计信息分析</span><br><span class="line">select count(1) 或者 0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; analyze table titan_temp.t_email partition(action_time,import_time) compute statistics;</span><br><span class="line">No rows affected (0.422 seconds)</span><br><span class="line"></span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; select count(1) from titan_temp.t_email;</span><br><span class="line">+------+--+</span><br><span class="line">| _c0  |</span><br><span class="line">+------+--+</span><br><span class="line">| 400  |</span><br><span class="line">+------+--+</span><br><span class="line">1 row selected (0.154 seconds)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-删除分区后的恢复过程"><a href="#4-删除分区后的恢复过程" class="headerlink" title="4. 删除分区后的恢复过程"></a>4. 删除分区后的恢复过程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; alter table titan_temp.t_email drop if exists partition (action_time=202006);</span><br><span class="line">INFO  : Dropped the partition action_time=202006/import_time=20200629</span><br><span class="line">No rows affected (0.272 seconds)</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; select count(1) from titan_temp.t_email;</span><br><span class="line">+------+--+</span><br><span class="line">| _c0  |</span><br><span class="line">+------+--+</span><br><span class="line">| 200  |</span><br><span class="line">+------+--+</span><br><span class="line">1 row selected (0.094 seconds)</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; show partitions titan_temp.t_email;</span><br><span class="line">+------------------------------------------+--+</span><br><span class="line">|                partition                 |</span><br><span class="line">+------------------------------------------+--+</span><br><span class="line">| action_time=202007/import_time=20200729  |</span><br><span class="line">+------------------------------------------+--+</span><br><span class="line">1 row selected (0.167 seconds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-bash-4.1$ hdfs dfs -ls /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email</span><br><span class="line">Found 2 items</span><br><span class="line">drwx------   - hive hdfs          0 2020-07-31 14:44 /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email/action_time=202006</span><br><span class="line">drwxr-xr-x   - hive hdfs          0 2020-07-31 14:44 /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email/action_time=2020061596177856492</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-bash-4.1$ hdfs dfs -mv /user/hive/.Trash/Current/apps/hive/warehouse/titan_temp.db/t_email/action_time=202006 /apps/hive/warehouse/titan_temp.db/t_email</span><br><span class="line">-bash-4.1$ hdfs dfs -ls /apps/hive/warehouse/titan_temp.db/t_email</span><br><span class="line">Found 2 items</span><br><span class="line">drwx------   - hive hdfs          0 2020-07-31 14:44 /apps/hive/warehouse/titan_temp.db/t_email/action_time=202006</span><br><span class="line">drwxr-xr-x   - hive hdfs          0 2020-07-31 14:30 /apps/hive/warehouse/titan_temp.db/t_email/action_time=202007</span><br><span class="line"></span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; msck repair table titan_temp.t_email;</span><br><span class="line">No rows affected (0.229 seconds)</span><br><span class="line">0: jdbc:hive2://192.168.10.27:2181,192.168.10&gt; show partitions titan_temp.t_email;</span><br><span class="line">+------------------------------------------+--+</span><br><span class="line">|                partition                 |</span><br><span class="line">+------------------------------------------+--+</span><br><span class="line">| action_time=202006/import_time=20200629  |</span><br><span class="line">| action_time=202007/import_time=20200729  |</span><br><span class="line">+------------------------------------------+--+</span><br><span class="line">2 rows selected (0.161 seconds)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>BigData</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive小文件合并问题</title>
    <url>//Hive%E5%B0%8F%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="Hive小文件合并问题"><a href="#Hive小文件合并问题" class="headerlink" title="Hive小文件合并问题"></a>Hive小文件合并问题</h1><h2 id="输入合并"><a href="#输入合并" class="headerlink" title="输入合并"></a>输入合并</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--hive-0.8.0及其之后默认就是CombineHiveInputFormat,可以将多个小文件合并成一个split切片，也可以将一个大文件，分成N个split（即N个map的输入）</span></span><br><span class="line">hive.input.format<span class="operator">=</span>org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;</span><br><span class="line"><span class="comment">--切片大小最大值，不设置,则所有输入只启动一个map任务</span></span><br><span class="line">mapreduce.input.fileinputformat.split.maxsize</span><br><span class="line"><span class="comment">--同一节点的数据块形成切片时，切片大小的最小值</span></span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.node</span><br><span class="line"><span class="comment">--同一机架的数据块形成切片时，切片大小的最小值</span></span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.rack</span><br></pre></td></tr></table></figure>
<p>大小关系：</p>
<ul>
<li>maxSplitSize &gt;&#x3D; minSplitSizeRack &gt;&#x3D; minSplitSizeNode</li>
<li>否则会抛出IOException</li>
</ul>
<p>周一测试一下，minSplitSizeNode与minSplitSizeRack大小设置是否会报IOException异常？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CombineFileInputFormat.java 代码中有这样一段，表示minsize.per.node &lt;= minsize.per.rack ，否则抛异常</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (minSizeRack != <span class="number">0L</span> &amp;&amp; minSizeNode &gt; minSizeRack) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Minimum split size per node&quot;</span> + minSizeNode + <span class="string">&quot; cannot be smaller than minimum split size per rack &quot;</span> + minSizeRack);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; hive-1.2.1 上进行验证：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">set</span> mapreduce.input.fileinputformat.split.minsize.per.node<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">set</span> mapreduce.input.fileinputformat.split.minsize.per.rack<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">Job Submission failed <span class="keyword">with</span> exception <span class="string">&#x27;java.io.IOException(Minimum split size per node 2 cannot be larger than minimum split size per rack 1)&#x27;</span></span><br><span class="line">FAILED: Execution Error, <span class="keyword">return</span> code <span class="number">1</span> <span class="keyword">from</span> org.apache.hadoop.hive.ql.exec.mr.MapRedTask. Minimum split size <span class="keyword">per</span> node <span class="number">2</span> cannot be larger than minimum split size <span class="keyword">per</span> rack <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>mapreduce.input.fileinputformat.split.maxsize<br>mapreduce.input.fileinputformat.split.minsize.per.node<br>mapreduce.input.fileinputformat.split.minsize.per.rack<br>上面三个参数如果&#x3D;0，那么在调用CombineFileInputFormat.getSplit()方式时，会分别使用下面三个参数值填充<br>mapred.max.split.size<br>mapred.min.split.size.per.node<br>mapred.min.split.size.per.rack</p>
<ul>
<li>这个需要到hive中确认一下默认参数</li>
</ul>
<p>形成切片的过程：<br>可以参考下面博客内容：<br><a href="https://blog.csdn.net/hellojoy/article/details/104866468">https://blog.csdn.net/hellojoy/article/details/104866468</a></p>
<ol>
<li>不断迭代节点列表，逐个节点（以数据块为单位）形成切片（Local Split）：<ol>
<li>如果maxSplitSize&#x3D;&#x3D;0，则整个节点上的block数据形成一个切片</li>
<li>如果maxSplitSize!&#x3D;0，遍历并累加每个节点上的数据，如果累加数据块大小&gt;&#x3D; maxSplitSize，则将这些数据块形成一个切片。继续该过程，直到剩余数据块累加大小 &lt; maxSplitSize。则进行一下步</li>
<li>如果剩下数据块累加大小 &gt;&#x3D; minSplitSizeNode， 则将这些累加的剩余数据块形成一个切片。继续该过程，直到剩余数据块累加大小 &lt; minSplitSizeNode。则进行一下步，并将这些数据块留下来待后续处理。</li>
</ol>
</li>
<li>不断迭代机架列表，逐个机架（以数据块为单位）形成切片（Rack Split）：<ol>
<li>遍历并累加这个机架上所有节点的数据块（这些数据块即上一步遗留下来的数据块），如果累加数据块大小 &gt;&#x3D; maxSplitSize，则将这些数据块形成一个切片。继续该步骤，直到剩余数据块累加大小 &lt; maxSplitSize，则进行下一步。</li>
<li>如果剩余数据块累加大小 &gt;&#x3D; minSplitSizeRack，则将这些剩余数据块形成一个切片。如果剩余数据块累加大小 &lt; minSplitSizeRack，则这些数据块留待后续处理。</li>
</ol>
</li>
<li>遍历并累加所有Rack上的剩余数据块，如果累加数据块大小 &gt;&#x3D; maxSplitSize，则将这些数据块形成一个切片。继续该过程，直到剩余数据块累加大小 &lt; maxSplitSize，则进行下一步。</li>
<li>将最终剩余的数据块形成一个切片</li>
</ol>
<blockquote>
<p>重点是，当启用自动合并功能时，避免因为文件过小，而参数过大，导致最终小文件只能通过步骤4来进行合并，应该尽可能利用前面的方式来处理</p>
</blockquote>
<p>对hive输入格式设置为CombineHiveInputFormat的进行分析map数是如何计算的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set hive.input.format=org.apache.hadoop.hive.al.io.CombineHiveInputFormat</span><br></pre></td></tr></table></figure>

<p>map数与逻辑split数是一致的，决定map的主要因素有：</p>
<p>1、相关表或分区input的文件个数</p>
<p>2、input文件的大小</p>
<p>3、input文件在node和rack的分布</p>
<p>4、set mapred.max.split.size; 最大split大小</p>
<p>5、set mapred.min.split.size.per.node; 一个节点上最小的split大小</p>
<p>6、set mapred.min.split.size.per.rack;  一个机架上最小的split大小</p>
<h2 id="输出合并"><a href="#输出合并" class="headerlink" title="输出合并"></a>输出合并</h2><p>例如：</p>
<h3 id="1-不能设置为0，否则，还是合并为一个mapper。"><a href="#1-不能设置为0，否则，还是合并为一个mapper。" class="headerlink" title="1. 不能设置为0，否则，还是合并为一个mapper。"></a>1. 不能设置为0，否则，还是合并为一个mapper。</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">set</span> mapreduce.input.fileinputformat.split.minsize.per.rack<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">set</span> mapreduce.input.fileinputformat.split.minsize.per.node<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">Hadoop job information <span class="keyword">for</span> Stage<span class="number">-1</span>: number <span class="keyword">of</span> mappers: <span class="number">1</span>; number <span class="keyword">of</span> reducers: <span class="number">0</span></span><br><span class="line"><span class="number">2019</span><span class="number">-05</span><span class="number">-28</span> <span class="number">15</span>:<span class="number">42</span>:<span class="number">09</span>,<span class="number">538</span> Stage<span class="number">-1</span> map <span class="operator">=</span> <span class="number">0</span><span class="operator">%</span>,  reduce <span class="operator">=</span> <span class="number">0</span><span class="operator">%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> mapreduce.input.fileinputformat.split.minsize.per.node<span class="operator">=</span><span class="number">0</span></span><br><span class="line">	<span class="comment">-- 不能设置为0，否则，还是合并为一个mapper。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-测试开启输出合并小文件的参数后，第二个merge-job的per-node和per-rack数值的变化"><a href="#2-测试开启输出合并小文件的参数后，第二个merge-job的per-node和per-rack数值的变化" class="headerlink" title="2. 测试开启输出合并小文件的参数后，第二个merge job的per.node和per.rack数值的变化"></a>2. 测试开启输出合并小文件的参数后，第二个merge job的per.node和per.rack数值的变化</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> titan_mass.t_20210309145  <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> stored <span class="keyword">as</span> orc tblproperties (<span class="string">&#x27;orc.compress&#x27;</span><span class="operator">=</span><span class="string">&#x27;SNAPPY&#x27;</span>) <span class="keyword">as</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> mapreduce.input.fileinputformat.split.maxsize<span class="operator">=</span><span class="number">4096000000</span>;</span><br><span class="line"><span class="keyword">set</span> hive.merge.mapfiles<span class="operator">=</span><span class="literal">false</span>;</span><br><span class="line"><span class="keyword">set</span> mapreduce.input.fileinputformat.split.minsize.per.node<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">set</span> mapreduce.input.fileinputformat.split.minsize.per.rack<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">set</span> mapreduce.job.queuename<span class="operator">=</span>titan_low;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> titan_mass.tmp_052815_02  <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> stored <span class="keyword">as</span> orc tblproperties (<span class="string">&#x27;orc.compress&#x27;</span><span class="operator">=</span><span class="string">&#x27;SNAPPY&#x27;</span>) <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> simba.dw_evt <span class="keyword">where</span> usernum<span class="operator">=</span><span class="string">&#x27;15295558956&#x27;</span> <span class="keyword">and</span> import_time<span class="operator">&gt;=</span><span class="string">&#x27;2021032800&#x27;</span> <span class="keyword">and</span> import_time<span class="operator">&lt;</span><span class="string">&#x27;2021032900&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>表的文件个数和大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@web04.simba.bd.com ~]# hdfs dfs -count -h -v /apps/hive/warehouse/titan_mass.db/tmp_052815_02</span><br><span class="line">   DIR_COUNT   FILE_COUNT       CONTENT_SIZE PATHNAME</span><br><span class="line">           1          159            336.2 K /apps/hive/warehouse/titan_mass.db/tmp_052815_02</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--测试开启输出合并小文件的参数后，第二个merge job的per.node和per.rack数值的变化</span><br><span class="line">hive&gt; set hive.merge.mapfiles=true;</span><br><span class="line">hive&gt; set hive.merge.mapredfiles=true;</span><br><span class="line">hive&gt; set mapreduce.input.fileinputformat.split.maxsize=4096000000;</span><br><span class="line">hive&gt; set hive.merge.size.per.task=256000000;</span><br><span class="line">hive&gt; set hive.merge.smallfiles.avgsize=16000000;</span><br><span class="line">hive&gt; set mapreduce.input.fileinputformat.split.minsize.per.node=1;</span><br><span class="line">hive&gt; set mapreduce.input.fileinputformat.split.minsize.per.rack=1;</span><br><span class="line">hive&gt; set mapreduce.job.queuename=titan_low;</span><br><span class="line">hive&gt; create table test.tmp_smallf_04021417  row format delimited fields terminated by &#x27;\t&#x27; stored as orc tblproperties (&#x27;orc.compress&#x27;=&#x27;SNAPPY&#x27;) as select * from titan_mass.tmp_052815_02;</span><br><span class="line">Query ID = root_20210402142118_d7bd5e86-1772-4cd3-863b-812db5214b9c</span><br><span class="line">Total jobs = 1</span><br><span class="line">Launching Job 1 out of 1</span><br><span class="line">Number of reduce tasks is set to 0 since there&#x27;&#x27;s no reduce operator</span><br><span class="line">Starting Job = job_1615708732706_61993, Tracking URL = http://ambari01.simba.bd.com:8088/proxy/application_1615708732706_61993/</span><br><span class="line">Kill Command = /usr/hdp/2.6.1.0-129/hadoop/bin/hadoop job  -kill job_1615708732706_61993</span><br><span class="line">Hadoop job information for Stage-1: number of mappers: 29; number of reducers: 0</span><br><span class="line">2021-04-02 14:21:30,821 Stage-1 map = 0%,  reduce = 0%</span><br><span class="line">2021-04-02 14:21:37,394 Stage-1 map = 34%,  reduce = 0%, Cumulative CPU 18.55 sec</span><br><span class="line">2021-04-02 14:21:38,447 Stage-1 map = 76%,  reduce = 0%, Cumulative CPU 94.1 sec</span><br><span class="line">2021-04-02 14:21:39,502 Stage-1 map = 90%,  reduce = 0%, Cumulative CPU 110.59 sec</span><br><span class="line">2021-04-02 14:21:40,552 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 124.24 sec</span><br><span class="line">MapReduce Total cumulative CPU time: 2 minutes 4 seconds 240 msec</span><br><span class="line">Ended Job = job_1615708732706_61993</span><br><span class="line">Stage-4 is filtered out by condition resolver.</span><br><span class="line">Stage-3 is selected by condition resolver.</span><br><span class="line">Stage-5 is filtered out by condition resolver.</span><br><span class="line">Starting Job = job_1615708732706_61996, Tracking URL = http://ambari01.simba.bd.com:8088/proxy/application_1615708732706_61996/</span><br><span class="line">Kill Command = /usr/hdp/2.6.1.0-129/hadoop/bin/hadoop job  -kill job_1615708732706_61996</span><br><span class="line">Hadoop job information for Stage-3: number of mappers: 1; number of reducers: 0</span><br><span class="line">2021-04-02 14:21:49,260 Stage-3 map = 0%,  reduce = 0%</span><br><span class="line">2021-04-02 14:21:55,635 Stage-3 map = 100%,  reduce = 0%, Cumulative CPU 5.09 sec</span><br><span class="line">MapReduce Total cumulative CPU time: 5 seconds 90 msec</span><br><span class="line">Ended Job = job_1615708732706_61996</span><br><span class="line">Moving data to directory hdfs://ambari01/apps/hive/warehouse/test.db/tmp_smallf_04021417</span><br><span class="line">Table test.tmp_smallf_04021417 stats: [numFiles=1, numRows=146, totalSize=90414, rawDataSize=446513]</span><br><span class="line">MapReduce Jobs Launched:</span><br><span class="line">Stage-Stage-1: Map: 29   Cumulative CPU: 124.24 sec   HDFS Read: 742866 HDFS Write: 127642 SUCCESS</span><br><span class="line">Stage-Stage-3: Map: 1   Cumulative CPU: 5.09 sec   HDFS Read: 338055 HDFS Write: 90414 SUCCESS</span><br><span class="line">Total MapReduce CPU Time Spent: 2 minutes 9 seconds 330 msec</span><br><span class="line">OK</span><br><span class="line">Time taken: 39.689 seconds</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">application_1615708732706_61993的Configuration</span><br><span class="line"></span><br><span class="line">mapreduce.input.fileinputformat.split.maxsize	4096000000	job.xml ⬅ programatically</span><br><span class="line">hive.merge.size.per.task	256000000	job.xml ⬅ programatically</span><br><span class="line">hive.merge.smallfiles.avgsize	16000000	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.node	1	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.rack	1	job.xml ⬅ programatically</span><br><span class="line"></span><br><span class="line">开启merge参数后自动启来的job</span><br><span class="line">application_1615708732706_61996的Configuration</span><br><span class="line"></span><br><span class="line">mapreduce.input.fileinputformat.split.maxsize	256000000	job.xml ⬅ programatically</span><br><span class="line">hive.merge.size.per.task	256000000	job.xml ⬅ programatically</span><br><span class="line">hive.merge.smallfiles.avgsize	16000000	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.node	256000000	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.rack	256000000	job.xml ⬅ programatically</span><br></pre></td></tr></table></figure>

<h3 id="3-在session级别per-node和per-rack参数都设置-x3D-1的情况下，下面几个任务都是merge-map-job"><a href="#3-在session级别per-node和per-rack参数都设置-x3D-1的情况下，下面几个任务都是merge-map-job" class="headerlink" title="3. 在session级别per.node和per.rack参数都设置&#x3D;1的情况下，下面几个任务都是merge map job"></a>3. 在session级别per.node和per.rack参数都设置&#x3D;1的情况下，下面几个任务都是merge map job</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://115.15.3.203:19888/jobhistory/conf/job_1558144373688_14700</span><br><span class="line"></span><br><span class="line">hive.merge.size.per.task	256000000	job.xml ⬅ file:/data/bigdata/tbds/etc/hive/conf.server/hive-site.xml</span><br><span class="line">hive.merge.smallfiles.avgsize	16000000	job.xml ⬅ file:/data/bigdata/tbds/etc/hive/conf.server/hive-site.xml</span><br><span class="line">mapreduce.input.fileinputformat.split.maxsize	256000000	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize	4096000000	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.node	256000000	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.rack	256000000	job.xml ⬅ programatically</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://115.15.3.203:19888/jobhistory/conf/job_1558144373688_13167</span><br><span class="line"></span><br><span class="line">hive.merge.size.per.task	2000000	job.xml ⬅ programatically</span><br><span class="line">hive.merge.smallfiles.avgsize	16000000	job.xml ⬅ file:/data/bigdata/tbds/etc/hive/conf.server/hive-site.xml</span><br><span class="line">mapreduce.input.fileinputformat.split.maxsize	16000000	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize	4096000000	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.node	16000000	job.xml ⬅ programatically</span><br><span class="line">mapreduce.input.fileinputformat.split.minsize.per.rack	16000000	job.xml ⬅ programatically</span><br></pre></td></tr></table></figure>

<p>从上面2,3的结果可知道，开启merge参数后自动启来的job中决定生成split的三个参数会受到<code>hive.merge.size.per.task</code>和<code>hive.merge.smallfiles.avgsize</code>两个参数中值较大的参数的影响</p>
<h3 id="处理输出合并时的操作结论"><a href="#处理输出合并时的操作结论" class="headerlink" title="处理输出合并时的操作结论"></a>处理输出合并时的操作结论</h3><p>所以我们的策略是不开启 merge job，而是单独起一个任务来处理，执行insert overwrite来重新插入一次，主要是防止merge job仅起一个map导致加载数据过慢</p>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Hive</tag>
        <tag>小文件合并</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark简单整理</title>
    <url>//Spark%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86.html</url>
    <content><![CDATA[<h1 id="Spark简单整理"><a href="#Spark简单整理" class="headerlink" title="Spark简单整理"></a>Spark简单整理</h1><p>对着下面的问题，问一下自己是否能回答的上来？回答的对吗？</p>
<h3 id="1-入门，初识Spark"><a href="#1-入门，初识Spark" class="headerlink" title="1. 入门，初识Spark"></a>1. 入门，初识Spark</h3><p>主要参考spark官方文档<br><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html">RDD Programming Guide</a></p>
<ul>
<li>如何开始写一个spark程序，maven中引用什么包，代码中import什么classs</li>
<li>如何读取外部数据，创建RDD</li>
<li>如何对RDD进行transformation，和Action操作<ul>
<li>如何传递自定义函数给Spark的Transformation和Action操作函数</li>
<li>执行操作时，注意闭包问题，即变量和函数的生命周期和使用范围</li>
<li>Shuffle操作的注意事项<ul>
<li>什么时候会触发shuffle？</li>
<li>shuffle是什么意思？触发shuffle后代表了什么？</li>
<li>如何优化？</li>
</ul>
</li>
<li>RDD的序列化问题<ul>
<li>如何序列化？</li>
<li>什么时候需要序列化？</li>
<li>序列化的注意事项</li>
<li>几种序列化级别如何选择？分别对应什么使用场景<ul>
<li>这里就选择看美团的这篇<a href="https://tech.meituan.com/2016/04/29/spark-tuning-basic.html">基础优化指南</a>的<strong>如何选择一种最合适的持久化策略</strong>章节的内容就可以</li>
<li>优先选择带有<code>_SER</code>后缀的级别</li>
</ul>
</li>
</ul>
</li>
<li>为处理闭包问题中的变量使用范围，引出的2种<strong>Shared Variables</strong>共享变量<ul>
<li>broadcast变量</li>
<li>accumulator累加器</li>
</ul>
</li>
</ul>
</li>
<li>如何执行写好的spark程序？<ul>
<li>多种执行方式<ul>
<li>通过spark-submit脚本提交，</li>
<li>通过java api提交</li>
</ul>
</li>
<li><code>spark-submit</code> 如何执行程序？<ul>
<li>本地执行</li>
<li>集群执行，参考Spark官方文档<a href="https://spark.apache.org/docs/latest/submitting-applications.html">通过spark-submit启动程序</a><ul>
<li>提交集群执行时的注意事项<ul>
<li>提交与执行的流程是什么样子的？</li>
<li>涉及的组件与概念？</li>
<li>这部分应该可以单独开一个章节</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-了解Spark执行内容及基本概念"><a href="#2-了解Spark执行内容及基本概念" class="headerlink" title="2.了解Spark执行内容及基本概念"></a>2.了解Spark执行内容及基本概念</h3><ul>
<li>程序常用的执行方式<ul>
<li>本地执行</li>
<li>集群执行</li>
</ul>
</li>
<li>集群执行时的执行流程，与集群的交互方式？</li>
<li>了解spark程序运行的过程<ul>
<li>如何查看运行过程？通过spark的web-ui</li>
<li>如何看懂web-ui展示的内容<ul>
<li><a href="https://spark.apache.org/docs/latest/cluster-overview.html#glossary">组件术语的解释</a>,这部分很重要，对看懂web-ui流程有帮助<ul>
<li>Job</li>
<li>Stage</li>
<li>driver<ul>
<li>SparkContext</li>
</ul>
</li>
<li>executor</li>
<li>task</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>sprak executor，driver与yarn之间的关系<ul>
<li>资源如何分配？</li>
</ul>
</li>
</ul>
<h3 id="3-Spark调优"><a href="#3-Spark调优" class="headerlink" title="3. Spark调优"></a>3. Spark调优</h3><ul>
<li>基本方向</li>
<li>哪些方面可以操作？<ul>
<li>代码方面<ul>
<li>复用rdd，重复的数据做cache</li>
</ul>
</li>
<li>集群参数方面，资源分配</li>
<li>shuffle</li>
<li>算子的使用</li>
<li>序列化</li>
<li>GC</li>
<li>数据倾斜</li>
<li></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark_shuffle杂记</title>
    <url>//spark_shuffle%E6%9D%82%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="为什么会发生shuffle？"><a href="#为什么会发生shuffle？" class="headerlink" title="为什么会发生shuffle？"></a>为什么会发生shuffle？</h1><ol>
<li>分布式系统中，并行计算任务涉及到聚合数据需求时，前一个任务向后一个任务传输数据的过程会涉及不同executor或不同节点间将相同key传输到一台机器上，这个过程存在大量数据读取，写入，网络传输，涉及IO，压缩，解压，序列化和反序列化等等。</li>
</ol>
<p>所以如涉及跨节点的聚合需求时，往往就很快。</p>
<p>Spark会根据宽依赖把它一系列的算子划分成不同的 Stage，Stage 的内部会进行 Pipeline，Stage 与 Stage 之间进行 Shuffle，Shuffle 的过程包含三部份。</p>
<p>第一部份是 Shuffle 的 Write；第二部份是网络的传输；第三部份就是 Shuffle 的 Read，这三大部份涉及了<strong>内存操作、磁盘IO、网络IO以及 JVM 的管理</strong>。</p>
<h3 id="整体优化方向："><a href="#整体优化方向：" class="headerlink" title="整体优化方向："></a>整体优化方向：</h3><ul>
<li>减少数据IO，磁盘写，网络传输</li>
<li>提高shuffle需要的内存（这里也有一个点需要注意，java gc）</li>
</ul>
<p>shuffle的演进：</p>
<p>hashshuffle –》 sorted-based shuffle –》 Tungsten shuffle</p>
<p>spark中，将map端划分数据、持久化数据的过程称为shuffle write，而reducer端读取数据，聚合数据的过程称为shuffle read</p>
<ul>
<li>map端也会发生聚合操作，需要看具体实现</li>
</ul>
<p>Mapper端进行aggregate的好处是，减少些磁盘的写次数，减少网络传输的数据量，减少reduce task获取mapper task数据的次数</p>
<p>Reducer端如果内存不够，写磁盘的代价是双倍的，在mapper端无论内存够不够，它都需要先写磁盘。而reducer端在计算的时候，需要又一次的把数据从磁盘上抓回来，所以实际生产环境下需要适当的把shuffle内存调大一点。</p>
<p>问题变为如何高效的实现shuffle write和shuffle read </p>
<h1 id="如何高效的实现shuffle-write和shuffle-read"><a href="#如何高效的实现shuffle-write和shuffle-read" class="headerlink" title="如何高效的实现shuffle write和shuffle read"></a>如何高效的实现shuffle write和shuffle read</h1><p>【ShuffleRead】reduce阶段</p>
<p>shufflerdd计算过程， 需要先把mappartitionsrdd中的数据fetch过来，问题：</p>
<ol>
<li>什么时候fetch？parent stage中的一个shuffleMapTask执行完？还是等全部shuffleMapTask执行完？<ul>
<li>为了迎合stage的概念（Spark job是按照stage线性执行的，只有当parent stage的task都执行完才能执行下一个stage），所以是parent stage的所有shuffleMapTask都执行完，才进行fetch。</li>
</ul>
</li>
<li>边fetch边处理？还是一次性fetch完再处理？<ul>
<li>边fetch边处理。</li>
</ul>
</li>
<li>fetch来的数据存在哪里？<ul>
<li>刚fetch来的FileSegment文件放在softBuffer缓冲区中，经过处理后的文件放在<code>内存+磁盘</code>中，放在<code>内存+磁盘</code>，主要需要考虑的问题是如何在两者中间取得平衡？</li>
</ul>
</li>
<li>怎么获取要fetch的数据的存放位置？<ul>
<li>一个shuffleMapStage形成后，会将该stage中最后一个rdd注册到MapOutputTrackerMaster中，通过MapOutputTrackerMaster.registerShuffle(shuffleid,rdd.partitions.size)方法。这个步骤很重要，因为shuffle过程中需要MapOutputTrackerMaster来执行shuffleMapTask将数据输出到什么位置。每个shuffleMapTask完成时都会将filesegment的存储位置汇报给MapOutputTrackerMaster。因此reducer在shuffle过程中读取数据的时候，要去driver里的MapOutputTrackerMaster询问shuffleMapTask数据输出的位置。</li>
</ul>
</li>
</ol>
<hr>
<p>【hashshuffle】以前的方式，spark-2.1.1 版本之前就不用了，看一下它的优缺点。<br>hashshuffle中，shuffle wirte实现比较简单，没有做排序等额外操作，仅需要重新partition数据然后写到本地，对hashshuffle来说，遇到的问题就是如何减少IO消耗。</p>
<p>&#x2F;&#x2F; TODO（SLi）这里缺少 hashshuffle 的基本结构</p>
<p>hashshuffle中，每条记录，通过partitioner.partition(record.getkey())来决定自己被分配到哪个缓冲区（bucket），及最后写到哪个block文件中（Filesegment）</p>
<p>hashshuffle的这个操作带来的问题：</p>
<p>shuffle write写文件的时候，内存中有两个东西，<br>    - 有一个缓冲区buffer，<br>    - 有一个操作本地磁盘文件的文件句柄。<br>也就是说，但是从shuffle write内存占用的角度，内存已经被两部分占用了。如果M*R数量很多，在shuffle过程中，这么多的内存消耗，很容易产生OOM，对GC来说也是很大的负担。hashshuffle的时候，如果reducer通过drive去mapper端读取数据时，这么多小文件需要打开对应个数的网络通道读取，打开这么多端口也不是一件轻松的事情。<br>这就导致一个非常常见的操作：reducer端fetch数据的时候，说文件找不到。其实不是真的找不到，而是GC导致程序不响应</p>
<ol>
<li>因为是shuffleMapTask都会包含R个缓冲区（R&#x3D;reducer的个数，即下一个阶段task的个数），所以如果有M个shuffleMapTask，R个reducer，那么就会产生M*R个小文件，因为通常任务里M和R都很大，就会导致磁盘上大量文件，同时可能产生低效IO消耗。（spark的stage是所有shuffleMapTask任务都处理完，再执行下一个stage，及shuffle read部分，在此之前所有小文件都会存下来）</li>
<li>缓冲区占用内存太大，同样因为每个maptask都开R个缓冲区，M*R也会产生大量缓冲区占用内存（由于内存中需要保存大量文件操作句柄和临时信息，如果数据处理的规模比较庞大，内存可能OOM）</li>
</ol>
<p>优化：</p>
<ol>
<li>问题1比较好解决，spark consolidated hash-based shuffle里面实现的consolidation方法，<ul>
<li>将原来每个maptask都写R个文件，改为一个core产生R个文件，这样同一个core中连续执行的maptask可以共同输出文件，写到一起，这样磁盘上产生的文件个数可以有原来M<em>R,减少为cores</em>R，会少很多。</li>
</ul>
</li>
<li>问题2不好解决，因为写文件到磁盘一定要开缓冲区，而且缓冲区太小影响IO速度</li>
</ol>
<p>consolidated hashshuffle也有弱点：</p>
<ul>
<li>如果reducer端的并行任务或者数据分片过多的话，则core*redcuer 任务也会过大，产生很多小文件。</li>
</ul>
<p>hashshuffle的处理shuffle write的方式严重制约了spark的集群规模和处理数据量的级别</p>
<hr>
<p>【sorted-based shuffle】</p>
<p>为什么最终舍弃hashshuffle，选择了sorted-based shuffle？</p>
<blockquote>
<p>即使是使用consolidation的方式，依然也会产生很多小文件，最终还是要减少Mapper端文件个数。</p>
</blockquote>
<p>好处：</p>
<ul>
<li>mapper端内存占用减少</li>
<li>reducer端拉取数据的次数减少</li>
<li>网络通道的句柄减少；</li>
<li>整体上提升了spark处理数据量的级别</li>
</ul>
<p>sorted-based是如何减少mapper端文件个数的？</p>
<blockquote>
<p>sorted-based shuffle不会为每个reducer中的task产生一个单独的文件，而是每个shuffleMapTask写两个文件，一个是index和一个data文件。其中data存储的是当前task的shuffle输出的分类数据，而index文件则存储了data文件中的数据通过partitioner的分类信息。下一个阶段的stage中的task就是根据这个index文件获取自己所需要抓取的上一个stage中shuffleMapTask产生的数据。</p>
</blockquote>
<p>假设并行度是100，那么sorted-based shuffle mapper端产生的文件个数为 <code>100*2</code>，相比hashshuflle <code>100*100</code>的个数极大减少。</p>
<p>sorted-based shuffle 主要在mapper阶段，与reducer端没有任何关系。在mapper阶段要进行排序。</p>
<ul>
<li>如何排序的？这里没太写明白。</li>
</ul>
<ol>
<li>根据partitionid进行排序，</li>
<li>根据本身数据的key进行排序。<ul>
<li>溢写前对内存中已有的数据进行排序，排序后会分批将数据写入磁盘，默认1w条一个batch。写的过程是通过java的bufferOutputStream，先生成多个临时文件，然后再merge成一个最终文件，同时在merge的过程中会写一个index文件，标记下个stage每个task需要的数据的start offset和end offset。</li>
</ul>
</li>
</ol>
<p>在mapper极端进行排序的目的：</p>
<ul>
<li>让reducer进行抓取的时候变得更高效。<blockquote>
<p>具体而言，reducer首先找driver去获取parent stage中的每个shuffleMapTask输出的位置信息，根据位置信息获取index文件，解析index文件，从解析的index文件中获取data文件中属于自己的那部分内容。</p>
</blockquote>
</li>
</ul>
<p>sorted-based shuffle的弱点：</p>
<ul>
<li>强制排序<ul>
<li>它要基于记录本身排序，是sorted-based shuffle最致命的性能消耗。</li>
<li>如果数据本身不需要排序的话，会导致多余的消耗</li>
<li>如果需要在partition内进行排序的话，就需要进行mapper端和reducer端两次排序</li>
</ul>
</li>
</ul>
<p>bypass机制<br>当shuffle read task 的数量&lt;&#x3D; bypass参数的阈值，就自动启动<br>与sorted-based shuffle 不同点在于，第一写磁盘机制不同，第二不会进行排序</p>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Spark</tag>
        <tag>Shuffle</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka中部分概念</title>
    <url>//kafka%E4%B8%AD%E9%83%A8%E5%88%86%E6%A6%82%E5%BF%B5.html</url>
    <content><![CDATA[<p>kafka中常用的内容</p>
<ol start="0">
<li><p>什么是rebalance？</p>
<ul>
<li>rabalance本质是一种协议，规定了consumer group中的所有consumer对于如何分配订阅的topic的每个分区这件事，如何达成一致</li>
</ul>
</li>
<li><p>目前使用的是什么版本？</p>
<ul>
<li>0.9之前(0.8.2及其之前)使用的是zookeeper存储Partition 的 Offset 信息 (consumers&#x2F;{group}&#x2F;offsets&#x2F;{topic}&#x2F;{partition})，<ul>
<li>zookeeper 并不适用频繁写操作的场景</li>
</ul>
</li>
<li>0.9及其之后，通过内置 Topic(__consumer_offsets) 的方式来记录对应 Partition 的 Offset</li>
</ul>
</li>
<li><p>查看一下broker的机器上是否有coordinator<br>Group Coordinator 是一个服务，每个 Broker在启动的时候都会启动一个该服务。</p>
<ul>
<li>Group Coordinator 的作用是用来存储 Group 的相关 Meta 信息，并将对应 Partition 的 Offset 信息记录到 Kafka 内置Topic(__consumer_offsets) 中</li>
</ul>
</li>
<li><p>group如何选择coordination？如何查看__consumer_offsets中每个group对应的partition信息？命令？</p>
<ul>
<li>Group 对应在 __consumer_offsets 上的 Partition</li>
<li>offsets.topic.num.partitions 50个分区</li>
</ul>
</li>
<li><p>发生 rebalance 的时机 ？</p>
<ul>
<li>组成员个数发生变化。例如有新的 consumer 实例加入该消费组或者离开组。</li>
<li>订阅的 Topic 个数发生变化。</li>
<li>订阅 Topic 的分区数发生变化。</li>
</ul>
</li>
<li><p>消费者也有leader？</p>
</li>
<li><p>问题：</p>
<ol>
<li>consumer-group成员在接收到coordinate的syncgroup的response后，如何知道自己消费哪个topic的哪个partition？如何在response中找到自己的这个信息？</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>GC调优</title>
    <url>//GC%E8%B0%83%E4%BC%98.html</url>
    <content><![CDATA[<p><code>GC</code> 调优</p>
<p><strong>核心思路：</strong> 尽量在年轻代把对象回收了，减少进入老年代的对象。</p>
<p>TODO，写一下如何查看 GC 。</p>
<p>具体调优还得看场景，需要根据 GC 日志具体分析，常见的需要关注的指标是：</p>
<ul>
<li><code>Young GC</code> 和 <code>Full GC</code> 触发的频率和原因</li>
<li>对象晋升的速率</li>
<li>老年代内存占用量</li>
<li>等等（以后补充）</li>
</ul>
<p>比如，发现频繁产生 <code>Full GC</code> ，分析日志之后发现没有内存泄漏，只是 <code>Young GC</code> 之后会有大量对象进入老年代，然后触发 <code>Full GC</code> 。所以就能得知，是 <code>Survivor</code> 空间设置太小，导致对象过早进入老年代，因此调大 <code>Survivor</code> 或者晋升年龄设置的太小。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>//Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</url>
    <content><![CDATA[<p>Java类加载机制</p>
<ol>
<li>类是怎样被加载的？</li>
<li>类的加载顺序是什么？</li>
</ol>
<h1 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h1><p>TODO</p>
<p>详细的流程，看一下《深入理解 Java虚拟机》虚拟机的类加载章节</p>
<p>类加载流程分为一下5个阶段：</p>
<blockquote>
<p>每个阶段做什么内容？</p>
</blockquote>
<ul>
<li>加载（Loading）</li>
<li>链接（Linking）<ul>
<li>验证（Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
</ul>
</li>
<li>初始化（Initialization）</li>
</ul>
<p>加载是全部加载吗？还是用到哪些加载哪些？</p>
<p>resolution （解析）步骤中的 符号引用是什么？</p>
<p>JDK9之前是一种，JDK9之后，由于引入了平台模块化系统（JPMS），文件结构发生了变化</p>
<p>JVM 是动态加载、链接和初始化类和接口的</p>
<p>加载：通过类和接口的名字找到二进制描述并创建类和接口的过程；</p>
<p>链接：将类和接口合并进jvm运行时状态，使类和接口可以被运行的过程；</p>
<p>初始化：类和接口的初始化包括执行类和接口的初始化方法。</p>
<p>5.1. jvm 如何从 class 文件中获取符号引用的；（运行时常量池的构造）</p>
<blockquote>
<p>对比 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.5">run-time constant pool</a> 的描述，和 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html">Java虚拟机规范第5章</a> 中表述，可知 <code>the binary representation of a class or interface</code> 基本可以用编译后生成的 <code>class file</code> 代替；</p>
</blockquote>
<ul>
<li><p>运行时常量池，每个 .class 文件中都会有一个 <code>constant pool</code>表（constant_pool table），</p>
<p><img src="https://ligongzhao-pics.oss-cn-hangzhou.aliyuncs.com/imgjvm_01constant_pool.png" alt="jvm01constant_pool"></p>
<ul>
<li><p>运行时常量池是.class文件中的<code>constant_pool</code>表的运行时表示；</p>
</li>
<li><p>存储内容：运行时常量池的功能类似于传统编程语言的符号表（symbol table），尽管它包含的数据范围比典型的符号表更广。</p>
</li>
<li><p>分配和构造时间：每个运行时常量池都是从Java虚拟机的<strong>方法区（method area）</strong>分配的(§2.5.4)。类或接口的运行时常量池是在Java虚拟机创建类或接口时构造的(§5.3)。</p>
</li>
<li><p>在创建类或接口时，如果构造类或接口的运行时常量池所需要的内存比jvm方法区提供的更多，jvm抛出<code>OOM</code>错误</p>
</li>
</ul>
</li>
<li><p>方法区，jvm中各线程共享，</p>
<ul>
<li>在jvm启动时创建，逻辑上属于heap的一部分；</li>
<li>方法区类似于常规语言中用于编译代码的存储区，或类似于操作系统进程中的“文本”段（”text” segment）。它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化以及接口初始化中使用的特殊方法(2.9)。</li>
<li>不要求连续的内存空间，具体的实现方式由各jvm厂商决定，</li>
<li>大小可以是固定的，也可以根据计算需要进行扩展。可以不实现垃圾回收和压缩功能。</li>
</ul>
</li>
<li><p>堆，jvm中各线程共享，</p>
<ul>
<li><p>jvm启动时创建；</p>
</li>
<li><p>为所有类实例（对象）和数组（arrays）分配内存的运行时数据区域；</p>
</li>
<li><p>大小与方法区一样，可以是固定的（fixed），也可以根据计算需要进行扩展，同时如果过大也可以收缩，堆的内存同样不需要是连续的。</p>
</li>
</ul>
</li>
<li><p>class 文件中的<code>constant_pool</code>表，用于在创建类和接口时构造运行时常量池；</p>
</li>
<li><p>运行时常量池中的所有引用最初都是符号的，这些符号引用都是从 class 文件结构中获得（问题：什么是符号引用？）</p>
</li>
<li><p><code>L ClassName ;</code> ，例如：Ljava&#x2F;lang&#x2F;String;  -&gt; String</p>
</li>
<li><p><code>[ 字段类型</code>，数组； 例如：[Ljava&#x2F;lang&#x2F;String;  -&gt; String[]</p>
</li>
<li><p>如果元素类型是基本类型，则由相应的字段描述符表示(4.3.2)。</p>
</li>
<li><p>否则，如果元素类型是引用类型，则用ASCII“L”字符后接元素类型的二进制名称(4.2.1)，再接ASCII“;”字符表示。</p>
</li>
<li><p><strong>the binary name</strong> ，文档中提到的表示，正常类的全限定名为：<code>java.lang.String</code>  -&gt; 二进制名称为： <code>java/lang/String</code>， 即将 <code>.</code>分隔符换为<code>/</code>分隔符；</p>
</li>
<li><p>浮点数，不管是 float，double，都遵循 IEEE 754</p>
</li>
<li><p>问题：class 文件中 constant_pool 表示的常量池怎样在运行时使用？都是些字段名，字段类型，方法签名等符号集，无法使用啊？</p>
</li>
</ul>
<p>5.2. 解释了jvm启动时如何进行加载、链接和初始化的过程；</p>
<ul>
<li>Java虚拟机通过使用 <code>bootstrap class loader</code>(5.3.1)创建一个初始类来启动，（该初始类以依赖于实现的方式指定）。然后，Java虚拟机链接初始类，初始化它，并调用公共类方法void main(String[])。该方法的调用驱动所有进一步的执行。组成主方法的Java虚拟机指令的执行可能导致链接(并因此创建)其他类和接口，以及调用其他方法。</li>
<li>在Java Virtual Machine的实现中，可以将初始类作为命令行参数提供。或者，实现可以提供一个初始类，该类设置一个类装入器，然后装入应用程序。初始类的其他选择也是可能的，只要它们与前一段给出的规范一致。</li>
</ul>
<p>5.3. 类和接口的二进制描述如何被加载的，同时类和接口如何被创建的；</p>
<ul>
<li>创建类或接口的方式<ol>
<li>在类或方法D的运行时常量池中引用了C，会触发对类或接口C的创建（creation）；</li>
<li>调用了java se平台库中的方法，例如反射，也可能触发对类或接口的创建</li>
</ol>
</li>
<li>类加载器和类的关系？<ul>
<li>定义加载器（一个加载器L 直接创建了类C）</li>
<li>初始加载器 （直接定义或者委托加载了一个类）</li>
</ul>
</li>
<li>运行时，一个类或接口由二进制名字和其定义类加载器决定，它的运行时包（package）由包名和这个类的定义类加载器决定；</li>
<li>an array class 是被 JVM 直接创建的，并不是通过类加载器加载的。（问题，JVM的哪部分创建的 数组类）</li>
<li>为什么在5.3章节说，只有 bootstrap class loader 和 user-defined class loader 两种类加载器？extension class loader 和 application class loader 去哪里了？</li>
<li>jvm 可以在 verification 和 resolution 阶段load a class</li>
<li>定义了类加载过程中遇到异常，如何抛出不同的异常；</li>
<li>一个行为良好的类加载器应该维护三个属性:<ul>
<li>给定相同的名称，一个好的类类加载器应该始终返回相同的class对象。</li>
<li>第二点没有看懂，像是在说加载的类是泛型类时的处理方式；？</li>
<li>第三点也没有看懂，提到了用户自定义类加载器的处理方式？</li>
</ul>
</li>
</ul>
<p>5.3.1. 使用 Bootstrap 类加载器，加载非数组类</p>
<p>5.3.5. 从 class 文件中获取Class</p>
<ul>
<li>检查二进制内容是满足 ClassFile 结构，否则报错；</li>
<li>检查class文件的jdk版本要求，与机器上安装的jdk不兼容也报错,<code>UnsupportedClassVersionError</code>；</li>
<li></li>
</ul>
<blockquote>
<p>jvm 加载、链接、初始化的过程，是分工处理，并不是加载一个方法处理全部，而是每个方法只做该方法的部分，然后交给下一个，依次循环。同时，每个方法中可以检查并调用前面方法来动态处理。</p>
</blockquote>
<p>5.4. 链接的过程；</p>
<p>主要是 verify 和 preparation 两个阶段，resolution 是可选阶段。</p>
<p>链接过程会涉及新内存的分配，可能发生 OOM；</p>
<p>链接阶段具体的实现比较灵活，只要满足三个前提即可：</p>
<ul>
<li>链接前，类或接口需要被完全加载；</li>
<li>初始化前，类或接口需要被完全验证和准备；</li>
<li>链接过程中检测的错误需要被抛出？</li>
</ul>
<p>验证，确保类或接口的二进制表示在结构上是正确的。？这与load过程中的检查功能不是重复了吗？</p>
<ul>
<li>不重复，load过程是检查 ClassFile结构，41.和4.8章节的内容，verify 阶段验证4.9章节的内容；</li>
</ul>
<p>验证可能导致加载额外的类和接口，但不需要对它们进行验证或准备。</p>
<ul>
<li>问题：谁，在什么阶段对额外触发的load内容进行验证或准备？</li>
</ul>
<p>preparation</p>
<p>对类或接口的<strong>静态字段</strong>进行默认值赋值（2.3,2.4章节）；（真正的初始化还是在初始化阶段）</p>
<p>准备阶段可以在类创建后的任何时候执行，但是要在初始化前完成；</p>
<p>resolution</p>
<p>Java虚拟机指令<code>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokvirtual, ldc, ldc_w, multianewarray, new, putfield，和putstatic</code> 对运行时常量池进行符号引用。<strong>这些指令的执行都需要解析其符号引用</strong>。</p>
<blockquote>
<p>上面文本中提到的指令，除 invokedynamic 之外，其他指令解析一次其符号引用即可；</p>
<p>invokedynamic 指令解析的具体值是绑定到具体的 invokedynamic 调用位置的，其他 invokedynamic 需要重新解析；</p>
</blockquote>
<p>解析是动态地从运行时常量池中的符号引用确定具体值的过程。</p>
<blockquote>
<p>具体值，是内存中可以真实查到的</p>
</blockquote>
<p>5.5. 类和接口如何被初始化的；</p>
<p>以下操作会对类或接口C，进行初始化操作：</p>
<ul>
<li><p>执行任何引用C的Java虚拟机指令<code>new, getstatic, putstatic或invokestatic (new, getstatic, putstatic, invokestatic)</code>。这些指令通过字段引用或方法引用直接或间接引用类或接口C，则会初始化C。</p>
</li>
<li><p>在类库(2.12)中调用某些反射方法，例如，在类class或包java.lang.reflect中调用。</p>
</li>
<li><p>如果C是一个类，它的一个子类的初始化，则类C也会被初始化；</p>
</li>
<li><p>如果C是一个声明非抽象、非静态方法的接口，则直接或间接实现C的类的初始化。</p>
</li>
<li><p>如果C是一个类，它在Java虚拟机启动时被指定为初始类(5.2)。</p>
</li>
</ul>
<p>因为jvm是多线程的，所以初始化类也需要保证同步（因为不同线程可能会初始化相同的类），所以每个类或接口都有唯一的一个初始化锁LC，具体初始化过程如下：</p>
<ul>
<li>略</li>
</ul>
<p>5.6. 绑定本地方法的概念；</p>
<p>5.6. jvm退出；</p>
<p>在jvm层面，每个java 类的构造函数都是实例初始化的方法。该方法名为 init，由编译器提供。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Bootstrap ClassLoader (启动类加载器)</p>
<ul>
<li><p>加载 <jre>&#x2F;lib 目录下符合要求的类，如 rt.jar</p>
<blockquote>
<p><jre> 是指 jre 的安装目录</p>
</blockquote>
</li>
</ul>
<p>Extension ClassLoader (扩展类加载器)</p>
<ul>
<li>加载 <jre>&#x2F;lib&#x2F;ext 目录下的类</li>
</ul>
<p>Application ClassLoader &#x2F; System ClassLoader （应用类加载器&#x2F;系统类加载器）</p>
<ul>
<li>加载用户程序中 classpath 指定的所有 jar 或目录</li>
</ul>
<p>自定义 ClassLoader</p>
<h1 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h1><p>双亲委派过程：如果一个类加载器需要加载类，那么首先它会把这个类加载请求委派给父类加载器去完成，如果父类还有父类则接着委托，每一层都是如此，一直递归到顶层（即启动类加载器），当父类加载器无法完成这个请求（父类加载器中没有加载过这个类）时，子类才会尝试去加载。</p>
<ul>
<li>一般情况加载会从应用类加载器委托给扩展类加载器，然后再委托给启动类加载器，启动类加载器找不到然后扩展类加载器找，扩展类加载器找不到再由应用类记载器找。</li>
</ul>
<h2 id="双亲委派解决了什么问题？"><a href="#双亲委派解决了什么问题？" class="headerlink" title="双亲委派解决了什么问题？"></a>双亲委派解决了什么问题？</h2><p>在实际应用中，双亲委派解决了 Java 基础类统一加载的问题。</p>
<p>以 <code>java.lang.Object</code> 来说，加载它经过一层层委托，最终由 Bootstrap ClassLoader 去找 lib目录下 rt.jar 里面的 <code>java.lang.Object</code> 加载到 JVM 中。</p>
<p>这样如果有不法分子自己造一个 <code>java.lang.Object</code> ，里面嵌了不好的代码，如果我们按照双亲委派模型来实现的话，最终加载到 JVM 中的只会是我们 rt.jar 里面的代码，这样核心的基础代码就得到了保护。JVM 中不会出现两个 Object。</p>
<p>违反双亲委派的例子</p>
<p>问题：SPI 怎么违反双亲委派模型了？</p>
<p>我觉得不能叫打破或者违反，而应该是没有依据双亲委派模型实现的类加载方式。</p>
<blockquote>
<p>BootstrapClassloader无法委派AppClassLoader来加载类，也就是说BootstrapClassloader中加载的类中无法使用由AppClassLoader加载的类。</p>
</blockquote>
<p>这个规则是哪里规定的？</p>
<ul>
<li>很明显java.sql包是由BootstrapClassloader加载器加载的；而接口的实现类com.mysql.jdbc.Driver是由第三方实现的类库，由AppClassLoader加载器进行加载的，我们的问题是DriverManager再获取链接的时候必然要加载到com.mysql.jdbc.Driver类，这就是由BootstrapClassloader加载的类使用了由AppClassLoader加载的类，很明显和双亲委托机制的原理相悖</li>
</ul>
<p>线程上下文类加载器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getCallerClass();</span><br></pre></td></tr></table></figure>





<p>调用类的静态方法会初始化该类？初始化动作做了哪些事情？</p>
<p>当高层提供了统一接口让低层去实现，同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的 ClassLoader 找到并加载该类。</p>
<blockquote>
<p>问题：怎样判断是高层需要加载低层的类？而不是低层本身需要加载该类？</p>
<p>怎样判断一个类应该由哪个类加载器加载？</p>
</blockquote>
<p>Class.forName()?</p>
<p>ClassLoader?</p>
<h1 id="类加载顺序"><a href="#类加载顺序" class="headerlink" title="类加载顺序"></a>类加载顺序</h1><ol>
<li>我们知道，jvm中发现一个类（通过类的package+ClassName来确定唯一）已经被加载了，那么它会直接使用而不会再加载同名的类了</li>
<li>如何查看jvm启动过程中的类加载顺序？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 jvm 启动脚本(用户java程序启动脚本)中，添加 -verbose 参数或者 -XX:+TraceClassLoading，</span><br><span class="line">日志中就会打印类的加载顺序日志</span><br></pre></td></tr></table></figure></li>
<li>那么如果有两个相同的类，如何确认先加载哪个？</li>
</ol>
<p><a href="https://docs.oracle.com/javase/7/docs/technotes/tools/solaris/classpath.html">参考jdk1.7官方文档</a></p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/classpath.html">jdk1.8的相同内容的位置</a></p>
<p>在文档的<code>Understanding class path wildcards</code>章节中写道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The order in which the JAR files in a directory are enumerated in the expanded class path is not specified and may vary from platform to platform and even from moment to moment on the same machine.</span><br><span class="line">If a specific order is required then the JAR files can be enumerated explicitly in the class path.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面两段的大意为：在同一个目录下的jar的加载顺序是不能指定的，可能因平台而异，甚至在同一台机器上不同时刻也有所不同。</p>
</blockquote>
<blockquote>
<p>如果希望指定顺序，那么可以显示的在classpath中枚举jar文件。</p>
</blockquote>
<p>同时官方文档在<code>Specification order</code>段落中，还写道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The order in which you specify multiple class path entries is important. The Java interpreter will look for classes in the directories in the order they appear in the class path variable. In the example above, the Java interpreter will first look for a needed class in the directory /java/MyClasses. Only if it doesn&#x27;t find a class with the proper name in that directory will the interpreter look in the /java/OtherClasses directory.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大意为：当你的classpath中有多个路径时，指定这些路径的顺序很重要，jvm会按照classpath路径中的顺序依次加载其中的类，如果已经找到了需要的类，就不会从后面加载，如果没有才会向后查找。</p>
</blockquote>
<p>综上，同一个classpath目录下的jar的加载顺序是无法指定的，但是可以通过在classpath中显示指定jar文件顺序或者目录的顺序来达到指定加载顺序的目的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存结构及GC原理</title>
    <url>//Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8AGC%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h1 id="Java内存结构及GC原理"><a href="#Java内存结构及GC原理" class="headerlink" title="Java内存结构及GC原理"></a>Java内存结构及GC原理</h1><h1 id="我最想要了解的内容"><a href="#我最想要了解的内容" class="headerlink" title="我最想要了解的内容"></a>我最想要了解的内容</h1><ol>
<li><p>内存结构，jvm由哪些部分组成？它们分别起到什么作用？</p>
</li>
<li><p>GC什么时候发生？GC的日志如何查看？GC调优的依据是什么？如何判断 ？</p>
</li>
</ol>
<h1 id="JVM内存结构-x2F-布局"><a href="#JVM内存结构-x2F-布局" class="headerlink" title="JVM内存结构&#x2F;布局"></a>JVM内存结构&#x2F;布局</h1><p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5">java8虚拟机规范</a>，JVM内存结构，就是 Run-Time Data Areas ，运行时数据区域</p>
<p>jvm定义了6个运行时区域，</p>
<ul>
<li>程序计数器pc (program counter) register</li>
<li>jvm栈 jvm stack </li>
<li>本地方法栈 native method stack</li>
<li>堆 heap<ul>
<li>java8虚拟机规范中这样描述：a heap that is shared among all Java Virtual Machine threads</li>
</ul>
</li>
<li>方法区 method area</li>
<li>运行时常量池 Run-Time Constant Pool</li>
</ul>
<p>从是否可被线程共享，可以分为</p>
<ul>
<li>线程私有： pc register，jvm stack，native method stack</li>
<li>被所有jvm线程共享：heap，method area（包含运行时常量池）。</li>
</ul>
<p>6个数据区域的作用</p>
<ul>
<li><p>程序计数器：</p>
<ul>
<li>每个线程都有自己的pc register，</li>
<li>如果正在执行的方法不是native，那么程序计数器包含当前正在执行的java虚拟机（jvm）指令的地址</li>
<li>如果线程当前正在执行的方法是native，那么jvm的程序计数器的值是undefined（即null）</li>
<li>程序计数器的内存足够保存返回地址和本地指针，不会内存异常</li>
</ul>
</li>
<li><p>jvm栈</p>
<ul>
<li>用于方法调用和返回，</li>
<li>保存方法的局部变量和部分结果</li>
<li></li>
</ul>
</li>
<li><p>native method stack（也称为本地方法栈，我觉得称为“本机方法栈”也合适）</p>
<ul>
<li>因为java8虚拟机规范中有这样一段描述：<code>to support native methods (methods written in a language other than the Java programming language)</code></li>
</ul>
</li>
<li><p>堆</p>
<ul>
<li>存放所有类实例和数组</li>
<li>java8虚拟机规范中这样描述：The heap is the run-time data area from which memory for <code>all class instances</code> and <code>arrays</code> is allocated</li>
<li>允许用户初始化大小，并控制最大最小值</li>
</ul>
</li>
<li><p>方法区</p>
<ul>
<li>类似于C语言中编译代码的存储区域或操作系统进程中的”text”段，</li>
<li>存储每个类的结构，例如，运行时常量池，字段和方法，以及方法和构造函数的代码，还包括用于类和对象初始化及其接口初始化的特殊方法</li>
<li>逻辑上是heap的一部分，同时java规范中仅规定一定要有这个data area，但是没有规定具体的实现，</li>
<li>与heap一样允许用户初始化大小，并控制最大最小值</li>
<li>可能抛出OOM</li>
</ul>
</li>
<li><p>运行时常量池<br>运行时常量池是类文件（第4.4节）中constant_pool表的按类或按接口的运行时表示。<br>它包含多种常量，从编译时已知的数字文字到必须在运行时解析的方法和字段引用。<br>运行时常量池的功能类似于常规编程语言的符号表，尽管它包含的数据范围比典型的符号表还大。</p>
</li>
</ul>
<p>问题：<br>可达性分析 需要分析与GC Roots的关联，那么对象产生是如何与GC Roots的关联的？什么时候失去与GC Roots的关联？</p>
<p>heap中，young generation 与old generation 中的各个区域默认分配多大内存空间呢？</p>
<h1 id="GC原理"><a href="#GC原理" class="headerlink" title="GC原理"></a>GC原理</h1><h2 id="如何判断哪些对象是需要回收的垃圾对象？"><a href="#如何判断哪些对象是需要回收的垃圾对象？" class="headerlink" title="如何判断哪些对象是需要回收的垃圾对象？"></a>如何判断哪些对象是需要回收的垃圾对象？</h2><p>两种常用的方法：</p>
<ol>
<li>引用计数算法<ul>
<li>逻辑：在对象在中添加一个引用计数器，对象被引用，计数器+1，引用失效，计数器-1，统计计数器为0的对象视为需要回收的对象</li>
<li>缺点：难以解决对象之间的循环应用，即A引用B，B引用A</li>
<li>应用范围：微软COM技术，python</li>
</ul>
</li>
<li>可达性分析算法<ul>
<li>逻辑：将GC Roots作为起点，通过起点向下遍历，走过的路径作为引用链，仅判定引用链包含的对象作为可达对象，不可达对象即为需要回收</li>
<li>GC Roots范围： 1. 虚拟机栈中引用的对象；2. 方法区中类静态属性引用的对象；3. 方法区中常量引用的对象；4. 本地方法栈中JNI引用的对象</li>
<li>应用范围：主流jvm虚拟机</li>
</ul>
</li>
</ol>
<p>问题：关于循环引用的问题，如果A引用B，B引用A，这两个对象是否能被GC回收？<br>答：关键不在于A、B之间是否有引用，而是A、B是否可以一直向上追溯到GC Roots。如果与GC Roots没有关联，则会被回收，否则即可继续存活。</p>
<h2 id="内存区域中哪些区域需要GC"><a href="#内存区域中哪些区域需要GC" class="headerlink" title="内存区域中哪些区域需要GC"></a>内存区域中哪些区域需要GC</h2><ol>
<li><p>不需要GC的：jvm线程独享的区域，pc register（程序计数器），jvm stack（jvm栈），native method stack（本地方法栈），其生命周期与线程相同（线程启动时创建，线程结束时销毁），不需要GC。</p>
</li>
<li><p>需要GC的：heap（虚拟机堆），method area（方法区），这两个数据区域，在jvm中是所有线程共享的，同时它们在虚拟机启动时创建，内存分配和回收具有不确定性。</p>
<ul>
<li>因为常量池在method area中，所以也需要GC</li>
</ul>
</li>
</ol>
<h2 id="常见的GC算法"><a href="#常见的GC算法" class="headerlink" title="常见的GC算法"></a>常见的GC算法</h2><h3 id="以Hotspot为例，来分析下GC的主要过程"><a href="#以Hotspot为例，来分析下GC的主要过程" class="headerlink" title="以Hotspot为例，来分析下GC的主要过程"></a>以Hotspot为例，来分析下GC的主要过程</h3><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>【问题1】，标记-整理(&#x2F;压缩)法，会让整理后的对象内存地址发生变化，那么暂定的线程是如何正常运行的？重启启动后重新获取对象的内存地址？</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载过程和双亲委派模型</title>
    <url>//%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<h1 id="类加载过程和双亲委派模型"><a href="#类加载过程和双亲委派模型" class="headerlink" title="类加载过程和双亲委派模型"></a>类加载过程和双亲委派模型</h1><h1 id="简述类加载过程"><a href="#简述类加载过程" class="headerlink" title="简述类加载过程"></a>简述类加载过程</h1><blockquote>
<p>详细流程，看一下 《深入理解 Java 虚拟机》中的虚拟机的类加载章节</p>
</blockquote>
<p>一般来说我们把 Java 的类加载过程分为三个主要步骤（其中链接又细分了三个子步骤）：</p>
<ul>
<li>加载 （Loading）<ul>
<li>将 Java 字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象）。如果输入的数据不满足 ClassFile 结构（Java 虚拟机规范中的4.1和4.8章节内容），则会抛出 <code>ClassFormatError</code>。<blockquote>
<ol>
<li>这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至可以是网络数据源等；</li>
<li>loading 阶段是用户可以参与的阶段，除了 JVM 内置的三种类加载器外，我们可以自定义类加载器，实现自己的类加载过程；</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>链接 （Linking）（有三个子步骤）<blockquote>
<p>这是核心的步骤，简单说就是把原始的类定义信息平滑地转入 JVM 运行过程中。</p>
</blockquote>
<ul>
<li>验证 （Verification）<ul>
<li>验证字节信息是符合 Java 虚拟机规范的（4.9章节内容），否则就抛出 VerifyError，这样可以防止恶意信息或者不合规的信息危害 JVM 的运行。这是 JVM 安全的重要保障。<blockquote>
<p>verification 阶段可能触发更多 class 的加载，但不需要对它们进行验证和准备。</p>
<p>问题：额外触发的类加载，它们的 linking 什么时候来做？排队等当前linking 做完？</p>
</blockquote>
</li>
</ul>
</li>
<li>准备 （Preparation）<ul>
<li>创建类或接口中的<strong>静态变量</strong>，并为它们赋初始值（分配内存空间）。<blockquote>
<p>但是这里的赋初始值，与后面显示初始化阶段(initialization)的内容有区别，侧重点在于分配变量所需要的内存空间，并不会执行更进一步的 JVM 指令。</p>
</blockquote>
</li>
</ul>
</li>
<li>解析 （Resolution）<ul>
<li>将运行时常量池中的符号引用（symbolic reference）替换为直接引用。</li>
<li>Java 虚拟机指令 <code>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokvirtual, ldc, ldc_w, multianewarray, new, putfield，和putstatic</code> 在运行时常量池中是符号引用。这些指令的执行都需要解析其符号引用变为直接引用。<blockquote>
<p>上面提到的指令，除 invokedynamic 之外，其他指令解析一次其符号引用即可。</p>
<p>invokedynamic 指令解析的具体值是绑定到具体的 invokedynamic 调用位置的。</p>
</blockquote>
</li>
<li>解析是动态地从运行时常量池中的符号引用确定具体值的过程。<blockquote>
<p>符号引用可以理解为是标记的标签，设置一个接话，暂时没有人选，设定该人员为 A ，等开始做的时候，确定让小明去做。解析就是把 A（符号引用）替换为小明（直接引用）。符号引用就是一个字面量，没有什么实质性的意义，只是一个代表。直接引用指的是一个真实引用，在内存中可以通过这个引用查到目标。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>初始化 （Initialization）<ul>
<li>这一步骤是真正去执行类初始化的代码逻辑，包括静态字段赋值，执行静态代码块的逻辑，父类型的初始化逻辑优先当前类的逻辑。</li>
<li>下面5个操作会对类或接口 C 进行初始化操作：<ol>
<li>执行任何引用C 的Java 虚拟机指令 <code>new, getstatic, putstatic或invokestatic (new, getstatic, putstatic, invokestatic)</code> 。这些指令通过字段引用或者方法引用直接或间接引用类或接口C，则会初始化C。</li>
<li>在类库中调用某些反射方法，例如，在类class或者<code>java.lang.reflect</code>中调用。</li>
<li>如果C 是一个类，它的一个子类初始化，则类C 也会被初始化。</li>
<li>如果C 是一个声明非抽象、非静态方法的接口，则直接或间接实现C 的类初始化，也会初始化C。</li>
<li>如果C 是一个类，它在Java 虚拟机启动时被指定为初始类，则会初始化C。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="https://ligongzhao-pics.oss-cn-hangzhou.aliyuncs.com/img04classloader_detail.png"></p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><ol>
<li>JVM 是动态加载，链接和初始化类和接口的；</li>
<li>在 JVM 层面，每个 Java 类的构造函数都是实例初始化的方法。编译器将该方法命名为 <code>init</code>。</li>
</ol>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>通过查看 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">Java 虚拟机规范</a> 内容我们可以知道，对于 Java 虚拟机来说，只有两种类加载器：</p>
<ul>
<li>启动类加载器（bootstrap class loader）<ul>
<li>这个类加载器使用 C&#x2F;C++ 语言实现，是虚拟机自身的一部分；（Hotspot 使用 C++，JRockit 和 J9 使用 C，具体可以参考《深入理解Java虚拟机》虚拟机类加载机制，章节）<ul>
<li><strong>虚拟机自身一部分</strong>，这样理解，虚拟机自身是由 C&#x2F;C++ 实现的，启动类加载器是在虚拟机内部实现的；其他的核心类库都是属于虚拟机外部</li>
</ul>
</li>
</ul>
</li>
<li>其他类加载器（虚拟机规范中称为：user-defined class loader）<ul>
<li>这些类加载器都是有 Java 语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。<ul>
<li>包括扩展类加载器和应用类加载器都在 rt.jar 核心库中，由 Java 语言实现，虚拟机启动时加载创建，都属于 <code>user-defind class loader</code>。</li>
<li>JDK提供的内置类加载器的关系查看下面内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p> <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3">Java 虚拟机规范</a> </p>
<blockquote>
<p>We will sometimes represent a class or interface using the notation <code>&lt;N, Ld&gt;</code>, where <code>N</code> denotes the name of the class or interface and <code>Ld</code> denotes the defining loader of the class or interface.</p>
<p>We will also represent a class or interface using the notation <code>NLi</code>, where <code>N</code> denotes the name of the class or interface and <code>Li</code> denotes an initiating loader of the class or interface.</p>
</blockquote>
<p>从上面内容我们可以知道，</p>
<p>对于任何一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的<strong>唯一性</strong>，每个类加载器，都拥有一个独立的类名称空间。</p>
<p>更通俗一些：比较两个类是否<strong>相等</strong>，只有在这两个类是<strong>由同一个类加载器加载的前提下</strong>才有意义。否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<ul>
<li>这里所指的“相等”，包括代表类的 Class 对象的 <code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法的返回结果，也包括了使用 <code>isstanceof</code> 关键字做对象所属关系判定等各种情况。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spoonli.mall.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">myLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getClass().getResourceAsStream(fileName);</span><br><span class="line">          <span class="keyword">if</span> (is == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">          is.read(b);</span><br><span class="line">          <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 用自定义的类加载器加载该类并实例化</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myLoader.loadClass(<span class="string">&quot;com.spoonli.mall.jvm.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line">    System.out.println(obj.getClass());</span><br><span class="line">    <span class="comment">// 判断对象是否为 ClassLoaderTest 类型</span></span><br><span class="line">    System.out.println(obj <span class="keyword">instanceof</span> ClassLoaderTest);</span><br><span class="line">    <span class="comment">// 查看通过自定义类加载器加载并实例化的对象的类加载器与 jvm内加载的ClassLoaderTest的类加载器；</span></span><br><span class="line">    System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">    System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.spoonli.mall.jvm.ClassLoaderTest</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">com.spoonli.mall.jvm.ClassLoaderTest$<span class="number">1</span>@7e32c033</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p>上面代码构造了一个简单的类加载器，从运行结果看，尽管来自同一个 Class 文件，但是自定义类加载器加载的创建的对象，在做所属类型判断时返回了 false 。因为此时 Java 虚拟机中同时存在两个 ClassLoaderTest 类，一个由 jvm 虚拟机的应用程序类加载器加载的，一个是我们自定义的类加载器加载的。在虚拟机中是两个相互独立的类，所以所对象所属类型检查时的结果为 false 。</p>
<blockquote>
<p>这段来自 《深入Java虚拟机》第3版P281。</p>
</blockquote>
<h2 id="Java-8-及其之前，JDK-提供的三种内置类加载器"><a href="#Java-8-及其之前，JDK-提供的三种内置类加载器" class="headerlink" title="Java 8 及其之前，JDK 提供的三种内置类加载器"></a>Java 8 及其之前，JDK 提供的三种内置类加载器</h2><ul>
<li><p>启动类加载器（Bootstrap Class Loader）</p>
<ul>
<li>它属于虚拟机自身的一部分，用 C++ 实现的，主要负责加载 <code>jre/lib</code> 目录中的 jar 文件，如 rt.jar，或被 <code>-Xbootclasspath</code> 参数指定的路径中的并且文件名是被虚拟机识别的文件</li>
</ul>
</li>
<li><p>扩展类加载器（Extension or Ext Class Loader）</p>
<ul>
<li>它是 Java 实现的，独立于虚拟机，负责加载<code>jre/lib/ext</code>目录下的 jar 包，这就是所谓的 extension 机制，该目录也可以通过设置 <code>java.ext.dir</code> 系统参数来覆盖  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.ext.dirs=xxx your_app</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>应用类加载器（Application or App Class Loader）</p>
<ul>
<li>它是 Java 实现的，独立于虚拟机。负责加载用户指定的 <code>classpath</code>的内容。<blockquote>
<p>有个容易混淆的概念，系统(system)类加载器，通常来说，其默认就是 JDK 内建的应用类加载器，但是它同样可以通过系统参数修改，例如</p>
</blockquote>
</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.system.class.loader=com.yourapp.YourClassLoader your_app</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果我们指定了system参数，JDK 内建的应用类加载器就会成为我们自定义加载器的父亲，这种方式通常在类似需要改变双亲委派模型的场景。</p>
</blockquote>
</li>
</ul>
<p>所以，一般情况（没有自定义类加载器时），类加载会从应用类加载器委托给扩展类加载器，再委托给启动类加载器，启动类加载器找不到然后扩展类加载器找，扩展类加载器找不到再由应用类加载器找。</p>
<p><img src="https://ligongzhao-pics.oss-cn-hangzhou.aliyuncs.com/img02parents_delegation_model.png" alt="双亲委派模型"></p>
<h2 id="如何看出三种内置加载器的父子关系？"><a href="#如何看出三种内置加载器的父子关系？" class="headerlink" title="如何看出三种内置加载器的父子关系？"></a>如何看出三种内置加载器的父子关系？</h2><ol>
<li><code>AppClassLoader</code> 与<code>ExtClassLoader</code></li>
</ol>
<p><code>AppClassLoader</code>,<code>ExtClassLoader</code>是由<code>sun.misc.Launcher</code>初始化的，查看<code>Launcher</code> 和 <code>ClassLoader</code> 源码的构造方法可以知道<code>AppClassLoader</code>与<code>ExtClassLoader</code>的父子关系由<code>Launcher</code>保证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面源码摘录自 sun.misc.Launcher.class(jdk1.8.0_291)</span></span><br><span class="line"><span class="comment">// 代码为IDE反编译获得，所以变量名可读性较弱，但不影响理解</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Launcher</span><span class="params">()</span> &#123;</span><br><span class="line">  Launcher.ExtClassLoader var1;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// var1 是 ExtClassLoader 变量，这里获取 ExtClassLoader</span></span><br><span class="line">    var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ExtClassLoader 即 var1 作为入参，传入了 getAppClassLoader(var1)</span></span><br><span class="line">    <span class="built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread.currentThread().setContextClassLoader(<span class="built_in">this</span>.loader);</span><br><span class="line">  <span class="comment">//省略其他代码</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>沿着 <code>getAppClassLoader()</code> 方法，根据对应参数和涉及方法，最后可以追踪到 <code>ClassLoader</code> 的构造方法中，可以看到 <code>getAppClassLoader(var1)</code> 中传入的参入 <code>var1</code> 最终被保存在 <code>ClassLoader</code> 的 <code>parent</code> 成员变量中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> &#123;</span><br><span class="line">    <span class="comment">// 在 ClassLoader 中 parent 就是当前类加载器的父加载器，在 loadClass() 方法中，即父委派模型的具体实现代码中，可以看到 parent 的作用。</span></span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述，<code>AppClassLoader</code> 与 <code>ExtClassLoader</code> 的父子关系由 <code>Launcher</code> 保证。</p>
<ol start="2">
<li><code>BootStrapClassLoader</code> 与 <code>ExtClassLoader</code> 父子关系如何确定的？</li>
</ol>
<p><code>ClassLoader</code> 中 <code>loadClass()</code> 的源码逻辑提供了答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面源码摘录自 java.lang.ClassLoader.java (jdk1.8.0_291)</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过滤</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果父加载器抛出 ClassNotFoundException 异常，</span></span><br><span class="line">                    <span class="comment">// 说明父加载器无法完成加载请求。</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在父加载器无法加载时，再调用本身的 findClass 方法进行加载。</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，在加载类的过程中，找不到 <code>parent</code> 的时候，会首先调用 <code>findBootstrapClassOrNull(name)</code> 去尝试返回由 <code>BootStrapClassLoader</code> 加载的 Java 核心类。<strong>这种机制便保证了 <code>BootStrapClassLoader</code> 是所有<code>ClassLoader</code> 的父加载器。</strong></p>
<blockquote>
<p>bootstrap class loader 作为顶级类加载器，没有 parent ，所以 parent &#x3D;&#x3D; null，就可以表示使用的是 bootstrap class loader。</p>
</blockquote>
<h2 id="Java-9开始，Java-类加载器的变化"><a href="#Java-9开始，Java-类加载器的变化" class="headerlink" title="Java 9开始，Java 类加载器的变化"></a>Java 9开始，Java 类加载器的变化</h2><p>在 JDK 9 中，由于 Jigsaw 项目引入了 Java平台模块化系统（JPMS），Java SE 的源代码被划分为一系列模块。</p>
<p>类加载器，类文件容器等都发生了非常大的变化。</p>
<ul>
<li><p>前面提到的 <code>-Xbootclasspath</code>即修改启动类加载器加载目录的参数不可用了。API 已经被划分到具体的模块中了，所以编程了对相应模块进行修改的方式了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设修改的模块为 java.base，那么先编译好相关模块，并替换 java.base 模块，然后通过下面参数替换。</span></span><br><span class="line">java --patch-module java.base=your_path yourApp</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展类加载器被重命名为<strong>平台类加载器（Platform Class Loader）</strong>，而且 extension 机制被移除。也就意味着，如果我们指定 <code>java.ext.dirs</code>系统变量，或者 <code>lib/ext</code> 目录存在，则 JVM 将直接返回错误！</p>
<blockquote>
<p>建议解决办法就是将其放入 classpath 中。</p>
</blockquote>
</li>
<li><p>部分不需要 AllPermission 的 Java 基础模块，被降级到平台类加载器中，相应的权限也被更精细粒度地限制起来。</p>
</li>
<li><p>rt.jar 和 tools.jar 同样被移除了，JDK 的核心类库以及相关资源，被存储在 Jimage 文件中，并通过新的 JRT 文件系统访问，而不是原有的 JAR 文件系统。<strong>但是对大部分软件兼容性影响不大。</strong></p>
</li>
<li><p>增加了 <code>Layer</code> 的抽象，JVM 启动默认创建 <code>BootLayer</code>，开发者也可以自定义和实例化 <code>Layer</code>，可以更加方便的实现类似容器一般的抽象逻辑。</p>
</li>
<li><p>内建类加载器器都在 <code>BootLayer</code>中，其他 <code>Layer</code>内部有自定义的类加载器，不同版本模块，可以同时工作在不同的 <code>Layer</code>。</p>
</li>
</ul>
<h2 id="通常类加载机制的基本特征"><a href="#通常类加载机制的基本特征" class="headerlink" title="通常类加载机制的基本特征"></a>通常类加载机制的基本特征</h2><ol>
<li><p>双亲委派模型。但不是一种强制性约束，它是一种 JAVA 设计者推荐使用类加载器的方式。所以<strong>不是所有类加载都遵守这个模型</strong>，比如 JDK 内部的 <strong>SPI 机制</strong>。用户可以在标准 API 框架上，提供自己的实现。这种机制不会用双亲委派模型去加载，而是利用所谓的<strong>上下文加载器</strong>。</p>
<blockquote>
<p>关于 SPI 机制，和上下文加载器，参考<a href="TODO">TODO</a></p>
</blockquote>
</li>
<li><p>类可见性，一个类加载器只能看到由他自己家或是其父辈类加载器加载的类，它自己是看不到更低层级类加载器所加载的类的。</p>
<ul>
<li>例如，如果父加载器（ExtClassLoader）需要加载的类<code>$JAVA_HOME/jre/ext/xxx.jar#Class A</code> 引用了存在于更低层级类加载器 <code>AppClassLoader</code>负责范围（<code>$class_path</code>）中才存在的类，那么在加载过程中就报错。</li>
<li>当这种需求出现的时候，可以使用 JDK 提供的另一种类加载器 <code>ContentClassLoader</code> 予以解决。</li>
</ul>
</li>
<li><p>单一性，由于父加载器的类对自家在其是可见的，所以父加载器加载过的类，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一个类仍然可以被加载多次，因为互相并不可见。</p>
</li>
<li><p>全盘负责原则，当一个 classloader 加载一个 Class 的时候，这个 Class 所依赖的和引用的其他 Class <code>通常</code> 也由这个 classloader 负责加载；</p>
</li>
<li><p>cache 机制，如果 cache 中保存了这个 class 就直接返回它，如果没有才从文件中读取和转换成 Class，并存入 cache。（这就是为什么修改了 class 但是必须重启 JVM 才能生效，并且类只加载一次的原因。）</p>
</li>
</ol>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>常见的场景：</p>
<ul>
<li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。这方便的集大成者是 <code>Java EE</code>,<code>OSGI</code>,<code>JPMS</code>等框架<ul>
<li>例如，两个模块依赖某个类库的不同版本，如果分别被不同的容器加载，就可以互补干扰。</li>
</ul>
</li>
<li>应用需要从不同的数据源获取类定义信息。<ul>
<li>例如，网络数据源；</li>
</ul>
</li>
<li>需要自己操纵字节码，动态修改或生成类。</li>
</ul>
<p>简单理解自定义类加载过程：</p>
<ol>
<li>指定类或接口的名称，找到其二进制描述并加载，（这里往往就是自定义类加载器会“定制”的部分），例如在特定数据源根据名字获取字节码，或者修改或生成字节码。</li>
<li>创建 Class 对象，并完成类加载过程。二进制信息到 Class 对象的转换，通常就是依赖 <code>defineClass</code>，我们无需自己实现，它是 <code>final</code> 方法。有了 Class 对象，后序完成加载过程就顺利成章了。</li>
</ol>
<p>具体实现可以参考<a href="https://www.baeldung.com/java-classloaders">用例</a></p>
<p>JDK 目前对 “java.”开头的包增加了权限保护，在自定义类加载器的时候，可以将这些包仍然交给 jdk 加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (name.startWith(<span class="string">&quot;java.&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>  ClassLoader.getSystemClassLoader().loadClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使再重写 <code>loadClass(String name)</code>方法时，也只需要重写我们需要的部分，可以将父类中 <code>loadClass()</code>方法的相关内容抄过来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">	Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.startWith(<span class="string">&quot;java.&quot;</span>)) &#123;</span><br><span class="line">		    <span class="keyword">return</span>  ClassLoader.getSystemClassLoader().loadClass(name);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 执行我们重写的 findClass(name) 方法；</span></span><br><span class="line">        <span class="keyword">return</span> findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h1><p>简单说，就是当类加载器（Class Loader）试图加载某个类的时候，首先将这个类加载请求委派给父加载器去完成，如果父加载器还有父类则接着向上委托，一直递归到顶层。当父加载器找不到相应的类，无法完成这个请求时，子类才会尝试去加载。</p>
<p>使用委派模型的目的，是避免重复加载 Java 类。</p>
<blockquote>
<p>注：这里的“双亲”是翻译的有些问题的，称为 <strong>“父委派模型”</strong> 可能更合适，因为每一层只有一个父加载器，并不能称为双亲（父母两个），不过既然流传已久，知道这里的“双亲委派模型”中的双亲的真实含义即可。可以理解为一种长久的翻译错误。</p>
</blockquote>
<p>委派模型的 Oracle 官方出处： <a href="https://docs.oracle.com/javase/tutorial/ext/basics/load.html">The Java Class Loading Mechanism</a></p>
<blockquote>
<p>The Java platform uses <code>a delegation model</code> for loading classes. The basic idea is that <code>every class loader has a &quot;parent&quot; class loader</code>. When  loading a class, a class loader <code>first &quot;delegates&quot; the search for the  class to its parent class loader</code> before attempting to find the class  itself.</p>
</blockquote>
<p>翻译一下就是：</p>
<blockquote>
<p>Java平台使用<code>委托模型</code>来加载类。基本思想是，每个类加载器都有一个“父”类加载器。当加载类时，类加载器首先将查找类的任务“委托”给它的父类加载器，然后再尝试自己去加载这个类。</p>
</blockquote>
<p>文档中也介绍了具体实现，查看源码 <code>java.lang.ClassLoader</code>的<code>loadClass</code>方法。</p>
<p>但是父类委派模型的基本特性没有找到出处：</p>
<ul>
<li><p>单一性</p>
</li>
<li><p>一般性</p>
</li>
<li><p>可见性</p>
</li>
<li><p>全盘负责</p>
</li>
</ul>
<p>上面这些网上找来的委派模型和类加载器的原则，暂时没有找到官方出处。</p>
<h2 id="如何定义符合父委派模型的类加载器？"><a href="#如何定义符合父委派模型的类加载器？" class="headerlink" title="如何定义符合父委派模型的类加载器？"></a>如何定义符合父委派模型的类加载器？</h2><ol>
<li>首先，自定义一个类加载器继承<code>ClassLoader</code>;</li>
<li>重写 <code>ClassLoader</code> 中的<code>findClass(String name)</code> 方法，<ul>
<li>在方法中自行实现读取 class 文件为 byte 数组；</li>
<li>调用 <code>defineClass</code> 方法将 byte 数组解析加载为类；</li>
</ul>
</li>
</ol>
<p>经过之前分析 <code>loadClass()</code>方法，如果父辈加载失败，会自动调用自己的 <code>findClass()</code>方法来完成加载。</p>
<h2 id="如何自定义一个违背父委派模型的类加载器？"><a href="#如何自定义一个违背父委派模型的类加载器？" class="headerlink" title="如何自定义一个违背父委派模型的类加载器？"></a>如何自定义一个违背父委派模型的类加载器？</h2><ol>
<li>首先，自定义一个类加载器并继承<code>ClassLoader</code>;</li>
<li>重写 <code>ClassLoader</code>中的<code>loadClass(String name)</code>方法；</li>
</ol>
<p>总结：自定义类加载器时，重写 <code>findClass(String name)</code>方法会遵循父委派模型，重写<code>loadClass(String name)</code> 方法会破坏&#x2F;违背父委派模型。</p>
<h1 id="有哪些没有按照双亲委派模型实现的例子？"><a href="#有哪些没有按照双亲委派模型实现的例子？" class="headerlink" title="有哪些没有按照双亲委派模型实现的例子？"></a>有哪些没有按照双亲委派模型实现的例子？</h1><p>即，打破&#x2F;违反了双亲委派模型</p>
<p>上面提到的 [通常类加载机制的三个基本特征](# 通常类加载机制的三个基本特征) 中有写，SPI 机制没有遵守双亲委派模型。例如 Java 中 JNDI，JDBC等都是利用这种机制。</p>
<h2 id="为什么说-JDBC-破坏了-x2F-没有遵守双亲委派模型？"><a href="#为什么说-JDBC-破坏了-x2F-没有遵守双亲委派模型？" class="headerlink" title="为什么说 JDBC 破坏了&#x2F;没有遵守双亲委派模型？"></a>为什么说 JDBC 破坏了&#x2F;没有遵守双亲委派模型？</h2><p>重点在 <code>DriverManager</code>的静态代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the initial JDBC drivers by checking the System property</span></span><br><span class="line"><span class="comment"> * jdbc.properties and then use the &#123;<span class="doctag">@code</span> ServiceLoader&#125; mechanism</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在由 Bootstrap Class Loader 加载的类中，加载了由 App Class Loader 加载的类，破坏了类加载器机制中的可见性，所以没有遵守双亲委派模型？直接使用了上下文加载器就避开破坏可见性的问题了。？是这样吗？</p>
<p><code>DriverManager</code>的 <code>classloader</code> 是bootstrap，而得到的 <code>connection</code> 的<code>classloader</code>是application。如果在A类引用B类时发现B类还没有加载，那么会调用A类的类加载器进行加载，并且由于可见性的原因，bootstrap加载的类是看不到ext或者application加载的类的，对应这里的<code>DriverManager</code>和<code>connection</code>，所以说SPI破坏了双亲委任模型。</p>
<p>可见性？在哪里规定的？</p>
<blockquote>
<p>这是创建 SPI 的原因吗？</p>
</blockquote>
<p>没有SPI时，你可以现在classpath里加一个mysql-connector-java.jar，然后这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="type">Driver</span> <span class="variable">d</span> <span class="operator">=</span> (Driver) clz.newInstance();</span><br></pre></td></tr></table></figure>

<p>这就没问题了，这里用了Application Classloader加载了mysql-connector-java.jar的com.mysql.jdbc.Driver。问题是你这里进行了硬编码（hard code），即一定要加载”com.mysql.jdbc.Driver”，不是很优雅，不能实现“用接口编程，自动实例化真的实现“的这种编码形式。</p>
<p>问题：</p>
<ol>
<li>为什么 Bootstrap Class Loader 加载器只负责加载 jre&#x2F;lib 目录下的文件？是在哪里硬编码（hardcode ）了吗？</li>
<li>从哪里得出三个内置加载器的关系？</li>
<li>Class.forName(<className>) vs  classloader.loadClass(<className>)？</li>
</ol>
<h1 id="Tomcat-如何违背父委派模型，以及为什么违背"><a href="#Tomcat-如何违背父委派模型，以及为什么违背" class="headerlink" title="Tomcat 如何违背父委派模型，以及为什么违背"></a>Tomcat 如何违背父委派模型，以及为什么违背</h1><p>首先，tomcat 官方文档中描述了其自定义的类加载器层级关系：</p>
<blockquote>
<p>When Tomcat is started, it creates a set of class loaders that are organized into the following parent-child relationships, where the parent class loader is above the child class loader:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    Bootstrap ($JAVA_HOME/jre/lib/ ; $JAVA_HOME/jre/lib/ext)</span><br><span class="line">        |</span><br><span class="line">     System  ($CATALINA_HOME/bin/bootstrap.jar ; $CATALINA_BASE/bin/tomcat-juli.jar / $CATALINA_HOME/bin/tomcat-juli.jar ; $CATALINA_HOME/bin/commons-daemon.jar)</span><br><span class="line">        |</span><br><span class="line">     Common ($CATALINA_BASE/lib ; $CATALINA_HOME/lib)</span><br><span class="line">     /     \</span><br><span class="line">Webapp1   Webapp2 ... (/WEB-INF/classes ; /WEB-INF/lib )</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="如何违背父委派模型"><a href="#如何违背父委派模型" class="headerlink" title="如何违背父委派模型"></a>如何违背父委派模型</h2><p>每一个 webapp classloader 在加载类时，会优先在 <code>WEB-INF/classes</code> 和 <code>WEB-INF/lib</code> 中搜索并尝试加载，而不是优先委托给父加载器尝试加载。</p>
<p>这样做的好处是它允许不同的 web 项目去重载 Tomcat 提供的 lib 包（如 <code>$CATALINA_HOME/lib/</code>中的 jar 包）。</p>
<p>这极大程度上保证了不同 web 项目的独立性和自由度。</p>
<h2 id="为什么违背"><a href="#为什么违背" class="headerlink" title="为什么违背"></a>为什么违背</h2><p>Tomcat 作为一个服务器容器，需要有同时运行多个 war 包的能力，而每个 war 包中都拥有自己的依赖 lib 库（<code>WEB-INF/lib</code>）以及各自的项目代码（<code>WEB-INF/classes</code>），为了保证每个 web 项目可以共同运行，互不干扰，Tomcat 为每个项目都创建一个单独的 webapp classloader，它会负责加载对应的 web 项目下 <code>WEB-INF/classes</code> 的 class 文件和资源以及 <code>WEB-INF/lib</code>下的 jar 包中所包含的 class 文件和资源文件，使得这些被加载的内容仅对该 web 项目可见，对其他 web 项目不可见。</p>
<blockquote>
<p>类加载器的可见性，自带隔离特性。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>类加载</tag>
        <tag>双亲委派</tag>
      </tags>
  </entry>
  <entry>
    <title>== and equals() and hashCode()</title>
    <url>//==%20and%20equals()%20and%20hashCode().html</url>
    <content><![CDATA[<h1 id="x3D-x3D-and-equals-and-hashCode"><a href="#x3D-x3D-and-equals-and-hashCode" class="headerlink" title="&#x3D;&#x3D; and equals() and hashCode()"></a>&#x3D;&#x3D; and equals() and hashCode()</h1><h2 id="涉及两个主要内容"><a href="#涉及两个主要内容" class="headerlink" title="涉及两个主要内容"></a>涉及两个主要内容</h2><ul>
<li><code>==</code> 与 <code>equals()</code>方法的区别</li>
<li><code>equals()</code>方法与<code>hashCode()</code>方法介绍</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.baeldung.com/java-equals-hashcode-contracts">Java equals() and hashCode() Contracts</a> 这篇整体不错，从名字可知是equals()&amp;hashCode()的。</li>
<li><a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a> 这是一篇博客园的博客，涉及&#x3D;&#x3D;，equals() 和hashCode()，整体内容写得还不错，除了中间有一些小点表述有些小错误，看的时候可以自动忽略错误的部分。</li>
<li><a href="https://www.geeksforgeeks.org/difference-equals-method-java/">Difference between &#x3D;&#x3D; and .equals() method in Java</a> 这篇也可以看一下</li>
<li><a href="https://www.geeksforgeeks.org/override-equalsobject-hashcode-method/">Why to Override equals(Object) and hashCode() method ?</a> 这篇是对Stack Overflow上回答的整理，也不错</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/">java-api中的hashCode()与equals()介绍</a> 这是jdk1.8的官方文档对两个方法的描述。</li>
</ul>
<h1 id="x3D-x3D-与equals-的异同"><a href="#x3D-x3D-与equals-的异同" class="headerlink" title="&#x3D;&#x3D; 与equals()的异同"></a>&#x3D;&#x3D; 与equals()的异同</h1><p>相同点：都可以用来比较两个变量是否相等。</p>
<p><strong>不同点</strong>：</p>
<ol>
<li><p>equals()是方法method，&#x3D;&#x3D;是操作符operator；</p>
</li>
<li><p>equals()只能用于判断两个对象是否相等（即，只能用于判断引用数据类型的变量），不能用于判断基本数据类型的变量。</p>
</li>
<li><p>&#x3D;&#x3D; 既可以判断基本数据类型的变量，也可以用于引用数据类型</p>
<ol>
<li>对于<strong>基本数据类型</strong>来说，&#x3D;&#x3D;比较的是<strong>值</strong>；</li>
<li>对于<strong>引用数据类型</strong>来说，&#x3D;&#x3D;比较的是<strong>对象的内存地址</strong>。</li>
</ol>
<blockquote>
<p>因为Java只有值传递（call by value，按值调用），所以对于&#x3D;&#x3D;来说，不管是比较基本数据类型，还是引用数据类型，其本质都是比较值，只是引用数据类型的变量其值存的是对象的地址。</p>
</blockquote>
</li>
</ol>
<h1 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h1><p><strong>作用</strong>：用于判断其他对象是否与该对象相等。（判断两个对象是否相等。）</p>
<p>实现equals()方法时，需要满足JavaSE定义的如下约定：</p>
<blockquote>
<p>以下约定针对所有的non-null reference value（非null的引用值）</p>
</blockquote>
<ul>
<li><strong>反身性 reflexive</strong> ，不为null的x，满足 <code>x.equals(x)</code> 为<code>true</code>。</li>
<li><strong>对称性 symmetric</strong>，不为null的x，y，如果x.equals(y) 为true，那么y.equals(x)也应该为true。</li>
<li><strong>传递性 transitive</strong>，不为null的x，y，z，当x.equals(y)为true，y.equals(z)为true，那么x.equals(z)也应该为true。</li>
<li><strong>一致性 consistent</strong> ，对于不为null的x，y，只要它们对象的equals()方法没有修改，那么无论调用多少次x.equals(y)，都应该始终返回true或者始终返回false。</li>
<li>对于任何不会null的引用值x，x.equals(null) 应该返回false。</li>
</ul>
<h4 id="注意：使用equals-方法进行比较两个对象是否相等时，有两种使用情况："><a href="#注意：使用equals-方法进行比较两个对象是否相等时，有两种使用情况：" class="headerlink" title="注意：使用equals()方法进行比较两个对象是否相等时，有两种使用情况："></a>注意：使用equals()方法进行比较两个对象是否相等时，有两种使用情况：</h4><ol>
<li><p><strong>类没有覆盖Object.java中的equals()方法</strong>，此时equals()方法等价于**&#x3D;&#x3D;**，是比较对象的地址是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.java 中定义的equals()方法。当使用默认方法时，等价于 ==,比较对象的地址。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类覆盖了Object.java中的equals()方法</strong>，此时我们一般使用equals()方法来判断两个对象的内容是否相等，这也是一般我们使用equals()的场景。</p>
</li>
</ol>
<h2 id="equals-amp-hashCode-的联系"><a href="#equals-amp-hashCode-的联系" class="headerlink" title="equals() &amp; hashCode()的联系"></a>equals() &amp; hashCode()的联系</h2><ul>
<li><p>当不用在基于哈希表的集合数据类型中时，equals() 与 hashcode()，可以没有什么关联，此时hashCode不起作用。</p>
</li>
<li><p>当用在基于哈希表的集合类型中时，equals()重写，则hashcode()一定要一起重写（原因下面写）。</p>
</li>
</ul>
<h3 id="什么后需要复写equals-和-hashcode"><a href="#什么后需要复写equals-和-hashcode" class="headerlink" title="什么后需要复写equals() 和 hashcode()?"></a>什么后需要复写equals() 和 hashcode()?</h3><p><strong>请注意</strong>，每当重写此方法（equals）时，通常都需要重写 <code>hashCode</code> 方法，以维护 <code>hashCode</code> 方法的一般约定，即<code>相等的对象必须具有相等的哈希码</code>。</p>
<blockquote>
<p>Note that it is generally necessary to override the <code>hashCode</code> method whenever this method is overridden, so as to maintain the general contract for the <code>hashCode</code> method, which states that equal objects must have equal hash codes.</p>
</blockquote>
<p>JavaSE文档上 <a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p>
<h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h1><p><strong>作用</strong>：返回对象的哈希码值。支持此方法是为了使用哈希表，例如 HashMap 提供的哈希表。</p>
<blockquote>
<p>Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html"><code>HashMap</code></a>.</p>
</blockquote>
<h3 id="hashCode的一般约定："><a href="#hashCode的一般约定：" class="headerlink" title="hashCode的一般约定："></a><strong>hashCode的一般约定</strong>：</h3><ul>
<li><p>在 Java 应用程序执行期间（即在同一个JVM中），只要对象的 equals()方法中涉及的信息没有被修改，那么在同一个对象上无论调用hashCode方法多少次，hashCode 方法必须始终返回相同的整数。</p>
<p>在不同的Java程序运行期间（即不同的JVM中），则不需要保持一致。</p>
</li>
<li><p>如果根据 equals(Object) 方法两个对象相等，则对两个对象中的每一个调用 hashCode 方法必须产生相同的整数结果。</p>
<blockquote>
<p>简单的说就是，两个对象如果通过equals()相等，那么它们的hasCode值必须相等。</p>
<p>相等的对象要有相等的hashCode。</p>
</blockquote>
</li>
<li><p>当根据equals(Object)方法判断两个对象不相等，那么不要求它们的hashCode必须唯一，但是从提升hashtable性能的角度考虑，不同的对象应该生成不同的hashCode。</p>
<blockquote>
<p>不同的对象，hashCode要尽量唯一。</p>
<p>注：（如果对象不同但是hashCode相同，这就是hash冲突，会影响哈希表的性能）</p>
</blockquote>
</li>
</ul>
<p><strong>hashCode使用场景</strong>：</p>
<p>Hashcode值，主要用于基于散列的集合，如 HashMap、HashSet、HashTable…等</p>
<blockquote>
<p>Hashcode value is mostly used in hash-based collections like HashMap, HashSet, HashTable….etc</p>
</blockquote>
<p>HashMap和HashSet，当插入时，使用对象的hashCode值来决定对象插入时的存储在集合中的位置，当查找时，使用hashCode来帮助定位对象在集合中的位置。</p>
<p>Hash检索，涉及：</p>
<ol>
<li>firstly，使用hashCode()方法找出正确的bucket；</li>
<li>secondly, 使用equals()在bucket中搜索正确的元素。</li>
</ol>
<p>补充：哈希值&#x2F;散列码（hash code）的作用</p>
<blockquote>
<p>我们都知道，散列表（&#x2F;哈希表）存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！<br>散列表的本质是通过数组实现的。当我们要获取散列表中的某个“值”时，实际上是要获取数组中的某个位置的元素。而数组的位置，就是通过“键”来获取的；更进一步说，数组的位置，是通过“键”对应的散列码计算得到的。</p>
</blockquote>
<h3 id="可以举例说明在hase-based-collection中如果equals-与hashCode-不一起重写会带来哪些错误的影响"><a href="#可以举例说明在hase-based-collection中如果equals-与hashCode-不一起重写会带来哪些错误的影响" class="headerlink" title="可以举例说明在hase-based collection中如果equals()与hashCode()不一起重写会带来哪些错误的影响"></a>可以举例说明在hase-based collection中如果equals()与hashCode()不一起重写会带来哪些错误的影响</h3><p>可以查看参考文章中的举例</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO</title>
    <url>//Java%20IO.html</url>
    <content><![CDATA[<ol>
<li>Java提供了哪些IO方式？</li>
<li>NIO如何实现多路复用？</li>
<li>Java有几种文件拷贝方式？哪种最高效？</li>
</ol>
<h1 id="如何正确使用getResourceAsStream-这个函数获取一些配置文件？"><a href="#如何正确使用getResourceAsStream-这个函数获取一些配置文件？" class="headerlink" title="如何正确使用getResourceAsStream()这个函数获取一些配置文件？"></a>如何正确使用getResourceAsStream()这个函数获取一些配置文件？</h1><p>getResourceAsStream(String path)这个函数的参数是一个路径，但是这个路径应该怎么填？使用该函数的难点也就在此。</p>
<p>记住一个关键点：</p>
<blockquote>
<p>getResourceAsStream这个函数寻找文件的起点是JAVA项目编译之后的根目录。</p>
</blockquote>
<p>比如一般maven项目编译之后根目录都是<code>target/classes</code>这个目录，即classpath 为 <code>target/classes</code><br>该目录下的文件结构，就是打包之后jar包中的文件结构</p>
<p>先总结：</p>
<ol>
<li>使用 Class对象调用时, 区分 <code>相对路径</code> &amp; <code>绝对路径</code><br><code>Class.getResourceAsStream(String path)</code> ： path 不以’&#x2F;‘开头时（即为相对路径）默认是以当前类所在位置, 以相对路径的形式寻找资源文件，以’&#x2F;‘开头（即为绝对路径）则是从ClassPath根下获取。其只是通过path构造一个绝对路径，最终还是由ClassLoader获取资源。</li>
<li><code>Class.getClassLoader.getResourceAsStream(String path)</code> ：默认则是从ClassPath根下获取，path不能以’&#x2F;‘开头，最终是由ClassLoader获取资源。</li>
<li>Class 类调用, 实际逻辑和 classLoader 一样, 只不过在开始前, 加了一个函数: resolveName, 处理了绝对路径和相对路径 最终底层和 classLoader 调用的函数一致: getBootstrapResource</li>
</ol>
<p>举例说明：</p>
<p>比如下面这个目录树就是一个maven项目编译之后的文件分布情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── com</span><br><span class="line">│   ├── spoon</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       └── TestConstants.class</span><br><span class="line">├── config</span><br><span class="line">│   └── config2.properties</span><br><span class="line">└── config.properties</span><br></pre></td></tr></table></figure>

<p>问题：在TestGetResourceAsStream.class这个类中应该怎么获取config.properties和config2.properties这两个文件呢？</p>
<p>方法1.<br>使用Class.getResourceAsStream()<br>config这个文件的路径是&#x2F;config.properties(&#x2F;表示根目录)，config2.properties这个文件的路径是&#x2F;config&#x2F;config2.properties，所以我们可以使用下面的代码获取这两个文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绝对路径的方式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResourceClassAndFileInSamePackage</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取config2.properties</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">config2</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/config/config2.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取config.properties</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">config</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/config.properties&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对路径的方式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResourceClassAndFileInSamePackage</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取config2.properties</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">config2</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;../../../config/config2.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取config.properties</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">config</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;../../../config.properties&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2.<br>使用<code>Class.getClassLoader().getResourceAsStream(String path)</code><br>因为该方法默认使用的是classpath的根目录，所以路径前不能添加<code>/</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResourceClassAndFileInSamePackage</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取config2.properties</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">config2</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;config/config2.properties&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取config.properties</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">config</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内部类</title>
    <url>//Java%20%E5%86%85%E9%83%A8%E7%B1%BB.html</url>
    <content><![CDATA[<h1 id="嵌套类-Nested-Classes"><a href="#嵌套类-Nested-Classes" class="headerlink" title="嵌套类(Nested Classes)"></a>嵌套类(Nested Classes)</h1><blockquote>
<p>Nested classes are divided into two categories: non-static and static. Non-static nested classes are called <em>inner classes</em>. Nested classes that are declared <code>static</code> are called <em>static nested classes</em>. </p>
<p>–来自 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">Oracle 官方Java指南</a></p>
</blockquote>
<p>嵌套类分为两种，静态和非静态。非静态的称为 <code>内部类</code>，静态的称为<code>静态嵌套类</code>（也是我们说的 <code>静态内部类</code>）</p>
<p>简单理解就是：如果把类比喻成鸡蛋，内部类为蛋黄,外部类是蛋壳。那么静态类相当于熟鸡蛋，就算蛋壳破碎（外部类没有实例化），蛋黄依然完好（内部类可以实例化）；而非静态类相当于生鸡蛋，蛋壳破碎（无实例化），蛋黄也会跟着xx（不能实例化）。</p>
<blockquote>
<ul>
<li><p>Non-static nested classes (inner classes) have access to other members  of the enclosing class, even if they are declared private. </p>
</li>
<li><p>Static nested classes do not have access to other members of the enclosing class. 问题：不能使用 static 修饰的变量&#x2F;方法？看完试一下。</p>
</li>
</ul>
</blockquote>
<h3 id="为什么使用嵌套类？"><a href="#为什么使用嵌套类？" class="headerlink" title="为什么使用嵌套类？"></a>为什么使用嵌套类？</h3><p> 内部类：</p>
<ol>
<li>是一种逻辑分组：当一个类仅在另一个类中使用时，嵌套在一起，成为 “助手类”；</li>
<li>可以更好的封装：B嵌套在A中，B可以访问A的所有成员变量和方法（包括定义为 private 的），同时 B 自身可以对外界隐藏起来，只给 A 用；</li>
<li>增加代码可读性和可维护性；</li>
</ol>
<p>静态嵌套类，就是一个独立的类。更多的知识表明类结构和命名空间，表明静态嵌套类和外部类是强关联的，专用于外部类。</p>
<ul>
<li>比如有A，B两个类，B有点特殊，虽然可以独立存在，但只被A使用。<br>这时候怎么办？如果把B并入A里，复杂度提高，搞得A违反单一职责。如果B独立，又可能被其他类（比如同一个包下的C）依赖，不符合设计的本意。所以不如将其变成A.B，等于添加个注释，告诉其他类别使用B了，它只跟A玩。– <a href="https://www.zhihu.com/question/28197253/answer/39880399">参考知乎铁心男回答</a></li>
<li>例如：<code>ThreadLocal</code> 与 <code>ThreadLocalMap</code></li>
</ul>
<p>静态嵌套类和非静态内部类最大的区别是：非静态内部类编译后隐式保存着外部类的引用（就算外部类对象没用了也GC不掉），但是静态内部类没有。</p>
<h2 id="内部类-Inner-Classes"><a href="#内部类-Inner-Classes" class="headerlink" title="内部类(Inner Classes)"></a>内部类(Inner Classes)</h2><p>特性：</p>
<ol>
<li>与其外部类的实例相关联，就像是实例方法和实例参数一样；</li>
<li>可以直接（direct）访问外部类的方法和字段；</li>
<li>因为与实例相关联，不能在内部类中定义任何 static 成员；<ul>
<li>an inner class is associated with an instance, it cannot define any static members itself.</li>
</ul>
</li>
<li>隐式保存着外部类的引用；</li>
</ol>
<p>使用：</p>
<ul>
<li>需要先实例化外部类，在实例化内部类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OuterClass</span> <span class="variable">outerObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">innerObject</span> <span class="operator">=</span> outerObject.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure>



<p>注意：<code>本地类</code>（在方法中定义的类）和 <code>匿名类</code> 都属于内部类</p>
<h2 id="静态嵌套类-Static-Nested-Classes"><a href="#静态嵌套类-Static-Nested-Classes" class="headerlink" title="静态嵌套类(Static Nested Classes)"></a>静态嵌套类(Static Nested Classes)</h2><p>特性：</p>
<ol>
<li>与外部类相关联，与类方法和类变量（被 static 修饰的 method 和 field）；</li>
<li>使用静态嵌套类与使用其他顶级类(top-level class)一样（定义静态，非静态成员），与外部类的实例交互就像任何其他顶级类一样；<ul>
<li>只是为了方便打包，嵌套在一个顶级类中的顶级类；（仅表明结构上是归属外部类的；）</li>
</ul>
</li>
<li>不能直接访问外部类中非静态成员（因为这些属于类对象的）；<ul>
<li>但是可以通过实例化外部类的方式访问；（参考下面的样例）</li>
</ul>
</li>
</ol>
<p>使用：</p>
<ul>
<li>实例化静态嵌套类的方法与顶级类一样。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StaticNestedClass</span> <span class="variable">staticNestedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticNestedClass</span>();</span><br></pre></td></tr></table></figure>



<p>内部类和静态嵌套类的结合样例：</p>
<ul>
<li>请注意，静态嵌套类与外部类的实例成员进行交互，就像任何其他顶级类一样。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">outerField</span> <span class="operator">=</span> <span class="string">&quot;Outer field&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticOuterField</span> <span class="operator">=</span> <span class="string">&quot;Static outer field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">accessMembers</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(outerField);</span><br><span class="line">            System.out.println(staticOuterField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNestedClass</span> &#123;</span><br><span class="line">        <span class="comment">// 这里告诉我们，静态嵌套类中可以像其他顶级类一样使用外部类对象，并访问其成员</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">accessMembers</span><span class="params">(OuterClass outer)</span> &#123;</span><br><span class="line">            <span class="comment">// Compiler error: Cannot make a static reference to the non-static</span></span><br><span class="line">            <span class="comment">//     field outerField</span></span><br><span class="line">            <span class="comment">// System.out.println(outerField);</span></span><br><span class="line">            <span class="comment">// 这样就可以访问</span></span><br><span class="line">            System.out.println(outer.outerField);</span><br><span class="line">            System.out.println(staticOuterField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inner class:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">innerObject</span> <span class="operator">=</span> outerObject.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerObject.accessMembers();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\nStatic nested class:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        <span class="type">StaticNestedClass</span> <span class="variable">staticNestedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticNestedClass</span>();        </span><br><span class="line">        staticNestedObject.accessMembers(outerObject);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\nTop-level class:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        <span class="type">TopLevelClass</span> <span class="variable">topLevelObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopLevelClass</span>();        </span><br><span class="line">        topLevelObject.accessMembers(outerObject);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopLevelClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accessMembers</span><span class="params">(OuterClass outer)</span> &#123;     </span><br><span class="line">        <span class="comment">// Compiler error: Cannot make a static reference to the non-static</span></span><br><span class="line">        <span class="comment">//     field OuterClass.outerField</span></span><br><span class="line">        <span class="comment">// System.out.println(OuterClass.outerField);</span></span><br><span class="line">        System.out.println(outer.outerField);</span><br><span class="line">        System.out.println(OuterClass.staticOuterField);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>什么是 package private</p>
<h1 id="类成员-Class-Members"><a href="#类成员-Class-Members" class="headerlink" title="类成员(Class Members)"></a>类成员(Class Members)</h1><ul>
<li>Class variables</li>
<li>Class methods</li>
</ul>
<p>被 <code>static</code> 修饰的 field 称为 <code>static field </code> or <code>class variables</code>，它们属于类，而不是类生成的 object，</p>
<p>位置：</p>
<ul>
<li><p>类的实例（对象）共享 <code>static field</code>，这个变量的位置在内存中是固定的（fixed）。</p>
</li>
<li><p>普通的 field，属于 object，所以每个对象的field都存在不同的内存中。</p>
</li>
</ul>
<p>使用：</p>
<ul>
<li>通常使用 <code>Class.static_field</code> 的形式，</li>
<li>（可以但是最好不要用的形式：）<code>&lt;Object&gt;.static_field</code>，因为这样无法体现 static_field 是类变量。</li>
</ul>
<p>静态变量&#x2F;方法与非静态变量&#x2F;方法的使用组合：</p>
<ul>
<li>non-static 可以使用 static，反过来不行；</li>
<li>non-static 可以使用 non-static 和 static；</li>
<li>static 仅可以使用 static；</li>
<li>static 修饰的方法中，不能使用 <code>this</code>关键字（因为没有可供 this 引用的实例）</li>
</ul>
<blockquote>
<p>主要因为生成的时间不一样，static修饰的在类加载完就存在了，non-static 的则是需要创建对象后才存在，所以 static 修饰的不能使用 non-static，因为使用内存中没有的对象。</p>
</blockquote>
<h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>在实例方法或构造函数中，<code>this</code>是对当前对象的引用 （当前对象：正在调用其方法或构造函数的对象。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="number">1.</span> 与 field 一起使用：</span><br><span class="line">    通常是发生了遮蔽（特定作用域中（例如在构造函数中）出现了与外部作用域中相同名称的变量名（如下例子），导致在这个特定作用域中定义的同名变量隐藏了外部的同名变量，这时如果要使用外部变量就不能直接使用变量名，需要用 <span class="built_in">this</span> 关键字）</span><br><span class="line"><span class="comment">// 原因是 构造函数的参数与field重名，导致被遮蔽（shadow）,所以通过 this，表明是要赋值给 Point 类中的field。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShadowTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FirstLevel</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">methodInFirstLevel</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">            System.out.println(<span class="string">&quot;this.x = &quot;</span> + <span class="built_in">this</span>.x);</span><br><span class="line">            <span class="comment">// 通过所属的类名引用包含较大作用域的成员变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;ShadowTest.this.x = &quot;</span> + ShadowTest.<span class="built_in">this</span>.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">ShadowTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShadowTest</span>();</span><br><span class="line">        ShadowTest.<span class="type">FirstLevel</span> <span class="variable">fl</span> <span class="operator">=</span> st.<span class="keyword">new</span> <span class="title class_">FirstLevel</span>();</span><br><span class="line">        fl.methodInFirstLevel(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">x = <span class="number">23</span></span><br><span class="line"><span class="built_in">this</span>.x = <span class="number">1</span></span><br><span class="line">ShadowTest.<span class="built_in">this</span>.x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 与 构造函数一起使用：</span><br><span class="line"><span class="comment">// 这里希望提供有默认值的构造函数，使用时根据参数个数选择合适的构造函数；</span></span><br><span class="line"><span class="comment">// 注意，使用时 this(xxx) 需要写在构造函数的第一行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width, height;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> ThreadLocal 中的例子：</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里的 this 是调用get() 方法的对象的引用</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3中的具体使用，this 就是 threadLocalName 对象的引用</span></span><br><span class="line">	ThreadLocal&lt;String&gt; threadLocalName = ThreadLocal.withInitial(() -&gt; Thread.currentThread().getName());</span><br><span class="line">    threadLocalName.get()</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html">Oracle官方指南内容</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java动态代理</title>
    <url>//Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html</url>
    <content><![CDATA[<h1 id="什么是动态代理？"><a href="#什么是动态代理？" class="headerlink" title="什么是动态代理？"></a>什么是动态代理？</h1><p>动态代理是一种代理机制，动态是相对于静态来说的。</p>
<p>代理可以看做是调用目标的一个包装，通常用来在调用真实目标之前进行一些逻辑处理。</p>
<ul>
<li>静态代理：是我们预先写好的一个代理类，在编译后，生成一个 class 文件。<ul>
<li>静态代理需要我们为每个目标类写对应的代理类。</li>
</ul>
</li>
<li>动态代理：在运行时生成代理类，并加载到 JVM 中。<ul>
<li>相比于静态代理更加灵活，可以通过指定目标来动态生成代理类。</li>
</ul>
</li>
</ul>
<p>代理也是一种解耦，调用者与目标类之间的解耦。在某种情况下，调用者不能或不想直接引用另一个对象，这时代理对象可以在调用者和目标之间起到中介的作用。</p>
<h1 id="常见的动态代理"><a href="#常见的动态代理" class="headerlink" title="常见的动态代理"></a>常见的动态代理</h1><ul>
<li><p>JDK 动态代理</p>
</li>
<li><p>CGLIB</p>
</li>
</ul>
<h1 id="JDK-动态代理实现步骤"><a href="#JDK-动态代理实现步骤" class="headerlink" title="JDK 动态代理实现步骤"></a>JDK 动态代理实现步骤</h1><ol>
<li><p>定义一个目标类(被代理对象类)和一个目标类实现的接口；</p>
</li>
<li><p>实现一个 <code>InvocationHandler</code>（调用处理器，实现 <code>InvocationHandler</code> 接口）得到一个切面类（自定义实现的调用处理器），实际是将代理类中处理的业务放到 <code>InvocationHandler</code>的方法中完成；</p>
</li>
<li><p>然后利用 <code>Proxy</code> 根据目标类的类加载器、接口和切面类（自定义实现的调用处理器）得到一个代理类；</p>
<blockquote>
<p>代理类的逻辑就是把所有接口方法的调用，转发到切面类的 <code>invoke()</code> 方法上，在 <code>invoke()</code> 方法中做一些增强的处理，然后利用反射调用目标类的方法。</p>
</blockquote>
</li>
</ol>
<h1 id="JDK-动态代理主要涉及到的类"><a href="#JDK-动态代理主要涉及到的类" class="headerlink" title="JDK 动态代理主要涉及到的类"></a>JDK 动态代理主要涉及到的类</h1><ol>
<li><code>java.lang.reflect.InvocationHandler</code>： 生成代理类前需要实现<code>InvocationHandle</code> 接口的 <code>invoke()</code> 方法，将代理类要实现的业务逻辑写在里面，以供后面运行时生成的代理类调用；</li>
<li><code>java.lang.reflect.Proxy</code>： 生成代理类的主类。通过 Proxy 类生成的代理类都继承了 Proxy 类。Proxy的主要调用方法为 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>  –&gt; 一个静态方法<ul>
<li>第一个参数为类加载器，通常为目标类（被代理类）的类加载器，即通过类加载器加载代理类到 JVM 的方法区；</li>
<li>第二个参数为被代理类所有实现的接口，一个数据，通常可能为一个接口；</li>
<li>第三个参数为自定义实现的调用处理器 <code>InvocationHandler</code>；</li>
</ul>
</li>
</ol>
<h2 id="为什么-JDK-动态代理要求目标类一定要定义接口？"><a href="#为什么-JDK-动态代理要求目标类一定要定义接口？" class="headerlink" title="为什么 JDK 动态代理要求目标类一定要定义接口？"></a>为什么 JDK 动态代理要求目标类一定要定义接口？</h2><p><strong>答：</strong> 因为 Java <strong>单继承</strong>的特性，生成的动态代理类一定要继承 Proxy 类，所以动态代理只能针对接口代理。</p>
<blockquote>
<p>这点可以通过反编译运行时动态生成的代理类得到。</p>
</blockquote>
<p><a href="%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6">如何获得运行时动态生成的类？</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行时动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从上面类的定义可知，代理类必须继承 Proxy 类，只能对接口代理。</span></span><br></pre></td></tr></table></figure>



<h1 id="CGLIB-的实现步骤"><a href="#CGLIB-的实现步骤" class="headerlink" title="CGLIB 的实现步骤"></a>CGLIB 的实现步骤</h1><p>GCLIB 是通过字节码生成技术来实现调用的逻辑。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h1 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h1><p>动态代理，装饰者模式，和类的继承 之间的区别？</p>
<p>最终目的：对原有&#x2F;指定方法进行功能上的扩展<br>在不修改原业务的基础上，基于原业务方法，进行重新的扩展，实现新的业务。</p>
<h1 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h1><p>java反射可以通过<br>getConstructor,getField和getMethod<br>以及相应的<br>getDeclaredConstructor,getDeclaredField和getDeclaredMethod分别获取构造方法，域和方法</p>
<p>区别在于getDeclaredXXX方法只会获取该类自身声明的内容，而不会获取继承来的内容</p>
<p>由于数组的特殊性，Array类提供一组特殊方法供反射使用</p>
<pre><code>Object array = Array.newInstance(String.class, 10); //等价于 new String[10]
Array.set(array, 0, &quot;Hello&quot;);  //等价于array[0] = &quot;Hello&quot;
Array.set(array, 1, &quot;World&quot;);  //等价于array[1] = &quot;World&quot;
System.out.println(Array.get(array, 0));  //等价于array[0]
</code></pre>
<p>反射对于泛型的处理，如List<String><br>正常情况下，运行时，JVM看到的是原始类型，List，看不到List<String></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>动态代理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态代理</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识点汇总</title>
    <url>//Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<h1 id="基础知识点汇总"><a href="#基础知识点汇总" class="headerlink" title="基础知识点汇总"></a>基础知识点汇总</h1><ol>
<li><pre><code class="java">/**
 * The &lt;code&gt;Stack&lt;/code&gt; class represents a last-in-first-out
 * (LIFO) stack of objects. 
 * ... 
 * &lt;p&gt;A more complete and consistent set of LIFO stack operations is
 * provided by the &#123;@link Deque&#125; interface and its implementations, which
 * should be used in preference to this class.  For example:
 * &lt;pre&gt;   &#123;@code
 *   Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();&#125;&lt;/pre&gt;
 *
 * @author  Jonathan Payne
 * @since   JDK1.0
 */
public
class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123;...
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &gt; 上面是jdk Stack源码中的注释，其中，建议当我们需要使用Stack这个数据类型时，优先使用Deque及其实现类，它实现了一组更完整和一致的LIFO的栈操作。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">2. 面向对象的三大特征</span><br><span class="line"></span><br><span class="line">   - 封装</span><br><span class="line"></span><br><span class="line">   - 继承</span><br><span class="line"></span><br><span class="line">   - 多态</span><br><span class="line"></span><br><span class="line">     &gt; 顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</span><br><span class="line">     &gt;</span><br><span class="line">     &gt; 常说的“面向接口编程”即使多态。</span><br><span class="line"></span><br><span class="line">     - 执行方法调用时，具体执行哪个类中的方法，必须在程序运行期间才能确定。</span><br><span class="line"></span><br><span class="line">3. String为什么是不可变的？String StringBuffer和StringBuilder的区别？</span><br><span class="line"></span><br><span class="line">   String类中使用final关键字修饰字符数组来保存字符串，`private final char[] value`,所以String对象是不可变的。</span><br><span class="line"></span><br><span class="line">   &gt; Java 9之后，String，StringBuffer和StringBuilder的实现改为byte数组存储字符串`private final byte[] vlaue`</span><br><span class="line"></span><br><span class="line">   - 关于线程安全</span><br><span class="line"></span><br><span class="line">   String对象是不可变得，可以理解为常量，线程安全。</span><br><span class="line"></span><br><span class="line">   StringBuffer对方法加了`同步锁`，所以是线程安全的。</span><br><span class="line"></span><br><span class="line">   StringBuilder没有添加同步锁，所以是非线程安全的。</span><br><span class="line"></span><br><span class="line">   - 关于性能</span><br><span class="line"></span><br><span class="line">     - 在不考虑线程安全的情况下，StringBuilder &gt; StringBuffer &gt; String</span><br><span class="line"></span><br><span class="line">     - String类型每次进行改变时，都会生成一个新的String对象，然后将指针指向新的String对象。</span><br><span class="line">     - StringBuffer每次都会对StringBuffer对象本身操作，而不是生成新的对象并改变对象引用。所以性能比String好。</span><br><span class="line">     - StringBuilder的操作方式与StringBuffer一样，不过由于没有同步锁，所以性能好一些。</span><br><span class="line"></span><br><span class="line">   - 总结：</span><br><span class="line"></span><br><span class="line">     - 操作少量（几个）字符串时，使用`String`;</span><br><span class="line">     - 单线程操作较多字符串时，使用`StringBuilder`；</span><br><span class="line">     - 多线程操作较多字符串时，使用`StringBuffer`；</span><br><span class="line"></span><br><span class="line">4. Object类的常见方法总结</span><br><span class="line"></span><br><span class="line">   Object类是所有类的父类，它提供的方法需要知道</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">5. 什么是反射？反射机制的优缺点？反射的应用场景？</span><br><span class="line"></span><br><span class="line">6. 什么是动态代理？使用场景？动态代理基于什么原因？</span><br><span class="line"></span><br><span class="line">7. 异常</span><br><span class="line"></span><br><span class="line">8. IO[ Java IO]</span><br><span class="line"></span><br><span class="line">9. 谈谈final、finally、finalize有什么不同？</span><br><span class="line"></span><br><span class="line">10. 强引用、软引用、弱引用、幻象引用有什么区别？</span><br><span class="line"></span><br><span class="line">11. int和Integer有什么区别？</span><br><span class="line"></span><br><span class="line"># 12. 深拷贝和浅拷贝</span><br><span class="line"></span><br><span class="line">- 深拷贝：完全拷贝一个对象，包括基本类型和引用类型，堆内的引用对象也会复制一份；</span><br><span class="line">  - 安全的，拷贝前后两个对象完全互不影响。</span><br><span class="line">- 浅拷贝：仅拷贝基本类型和引用，堆内的引用对象和被拷贝的对象共享；</span><br><span class="line">  - 不安全的，拷贝前后共享堆内对象，一方修改内容，另一方会受到影响。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用场景：</span><br><span class="line"></span><br><span class="line">1. 如果对象的属性全是基本类型，深拷贝，浅拷贝都可以；</span><br><span class="line">2. 如果对象的属性不会被改变，深浅都可以；</span><br><span class="line">3. 如果对象的属性经常改变，而拷贝后的对象不希望受到之前对象的影响，深拷贝。</span><br><span class="line"></span><br><span class="line"># 13. 重载和重写的区别？</span><br><span class="line"></span><br><span class="line">- 重载：在同一个类中，方法名相同，参数类型、顺序或者个数不同。即方法签名不同。</span><br><span class="line"></span><br><span class="line">  &gt; 注意：方法签名，是方法名和参数列表，不包括返回值。</span><br><span class="line"></span><br><span class="line">- 重写（Override）：指子类重写父类的方法，方法签名一致。但是重写的子类方法的逻辑抛出的异常要么和父类一样要么是父类异常的子类，同时方法的访问权限不得低于父类。</span><br><span class="line"></span><br><span class="line"># 14. 什么是内部类，有什么用？</span><br><span class="line"></span><br><span class="line">内部类，是定义在一个类的内部的类</span><br><span class="line"></span><br><span class="line">- 成员内部类：在成员变量的位置定义，则是成员内部类；</span><br><span class="line">- 静态内部类：使用 static 修饰的则为静态内部类；</span><br><span class="line">- 匿名内部类：没有具体类名的为匿名内部类；</span><br><span class="line">- 局部内部类，定义在方法中（一般不太用）；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">成员内部类，可以使用外部类的所有成员变量以及方法，包括 private 的；</span><br><span class="line"></span><br><span class="line">静态内部类，只能使用外部类的静态成员变量以及方法；</span><br><span class="line"></span><br><span class="line">内名内部类，常用来作为回调，使用的时候再实现具体逻辑来执行回调。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实际上，内部类是一个编译层面的概念，像语法糖一样，经过编译之后，内部类会提升为外部顶级类，和外部类没有任何区别，所以在 JVM 中是没有内部类的概念的。</span><br><span class="line"></span><br><span class="line">一般情况下，非静态内部类用在内部类和其他类无任务关联，专属于这个外部类使用，并且也便于调用外部类的成员变量和方法，比较方便。</span><br><span class="line"></span><br><span class="line">静态外部类其实就等于一个顶级类，可以独立于外部类使用，所以更多的只是表明类结构和命名空间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Java 位运算</span><br><span class="line"></span><br><span class="line">位运算符：</span><br><span class="line"></span><br><span class="line">- &amp; ，与， 一假则假，即对应的两个位都为1 时，结果才为 1；</span><br><span class="line"></span><br><span class="line">  用途：</span><br><span class="line"></span><br><span class="line">  1. 清零，如果希望指定位为0，只需要与一个对应位为0 的数与操作即可。</span><br><span class="line"></span><br><span class="line">  2. 取一个数的指定位，例如，取一个int数的高3位，或取低4位，取高3位时只需与高3位为 1，低29位都为0的数相与即可；取低4位，只需与一个高位为0，低4位为1 的数相与即可；</span><br><span class="line"></span><br><span class="line">     ```java</span><br><span class="line">     // ThreadPoolExecutor.java 中 高3位表示 runState，即运行状态，低29位表示workerCount,线程数</span><br><span class="line">     // 这是利用一个数表示两种状态的方式。</span><br><span class="line">     	private static final int COUNT_BITS = Integer.SIZE - 3;  // 29</span><br><span class="line">         private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;  // 低 29 位能表达的最大值，此时低29位全为 1；</span><br><span class="line">         private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;  // 取一个int数的最高3个位，CAPACITY 表示 最高的3个位为0，其余29位为1，取反后最高的3个位为1，其余29位为0，和 c 进行 &amp; 操作，得到的就是 c 中最高的3个位。</span><br></pre></td></tr></table></figure>

  
</code></pre>
</li>
<li><p>判断奇偶，</p>
<p>只需要根据最末位是 0 还是 1 来判断即可，为 0 则是偶数，为 1 则是奇数，因此可以使用 <code>if ((a &amp; 1) == 0)</code> 代替 <code>if (a % 2 == 0)</code> 来判断 a 是否为偶数；</p>
</li>
<li><p>判断第N位是否为1，（与2,3条类似）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x &amp; (<span class="number">1</span>&lt;&lt;n)  <span class="comment">// 判断 x 的第 n 位是否为1 （第3条也是这个意思， 1&lt;&lt;1 == 1，所以可以省略）</span></span><br><span class="line"><span class="comment">// 得到的结果为1，则说明原值该位为1，得到为0，说明该位原值为0；</span></span><br><span class="line"></span><br><span class="line">x &amp; ~(<span class="number">1</span>&lt;&lt;n)  <span class="comment">// 这里还可以设置 x 的第 n 位为 0；</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>| ，或， 一真则真，即对应的两个位有一个为 1 时，结果就为 1；都为 0 时，结果才为 0；</p>
<p>用途：</p>
<ol>
<li><p>与 0 进行 或运算，得到原值；</p>
</li>
<li><p>可以对一个数的某些位设置为 1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x | (<span class="number">1</span>&lt;&lt;n)  <span class="comment">// 设置 x 的第 n 位为 1；</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>~ ，取反，0 -&gt; 1, 1 -&gt; 0 ；</p>
</li>
<li><p>^ ， 异或，对应的两个位相同为 0 ，相异（不同）为 1 ；</p>
<p>几个特性：</p>
<ul>
<li>交换律</li>
<li>结合律：(a^b)^c &#x3D;&#x3D; a^(b^c)</li>
<li>对于任何数x，都有 x^x&#x3D;0，x^0&#x3D;x</li>
<li>自反性: a^b^b&#x3D;a^0&#x3D;a;</li>
</ul>
<p>用途：</p>
<ol>
<li><p>翻转指定位</p>
</li>
<li><p>交换两个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        a ^= b;</span><br><span class="line">        b ^= a;</span><br><span class="line">        a ^= b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>&lt;&lt; ， 左移，各个二进制位全部左移若干位，高位丢弃，低位补 0 ；每左移1位，相当于乘以 2；左移 N 位，相当于乘以 2 的N 次方；</p>
</li>
<li><p><code>&gt;&gt;</code> ，右移，各个二进制位全部右移若干位，对无符号位，高位补 0 ，有符号位，高位补1；每右移1位，相当于除以 2；右移 N 位，相当于除以 2 的N次方；</p>
</li>
<li><p><code>&gt;&gt;&gt;</code> ，Java中的无符号右移，不用担心会溢出。具体原因后面再找。</p>
</li>
</ul>
<p>什么是位图（BitMap）</p>
<p>将一组bit位数据（即0或1）放到一个数组中即为位图（BitMap）</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Jdk1.8之后Windows下环境变量问题</title>
    <url>//Jdk1.8%E4%B9%8B%E5%90%8EWindows%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>结论：JDK8+ 版本，在 Windows 环境下安装完成后，会自动配置环境变量，无需单独配置环境变量。</p>
<p>以 <code>jdk-8u201-windows-x64.exe</code> 版本为例，环境变量 Path 中会自动增加 <code>C:\Program Files\Common Files\Oracle\Java\javapath</code>，这个环境变量，进入该目录下回发现里面有4个 java 的可执行包。</p>
<ul>
<li><p>好处：不需要手动配置 java 的环境变量了；</p>
</li>
<li><p>坏处：当机器上安装了多个版本之后，若要使用自定义的环境变量配置，需要注意 <code>C:\Program Files\Common Files\Oracle\Java\javapath</code> 和 <code>C:\Program Files (x86)\Common Files\Oracle\Java\javapath</code> 两个环境变量的顺序；</p>
</li>
</ul>
<p>例如：</p>
<p>机器上先安装了 JDK8 ，手动配置了 <code>JAVA_HOME</code> 等环境变量，命令行中默认的 java -version 是 <code>java version &quot;1.8.0_291&quot;</code>，但是又安装了 JDK11 后，发现默认 java -version 变成了 <code>java version &quot;11.0.11&quot; 2021-04-20 LTS</code> ，就是因为此时环境变量 <code>C:\Program Files\Common Files\Oracle\Java\javapath</code> 中的内容已经变了。</p>
<p>处理多版本的方法</p>
<p>方法1：在 Path 中修改变量的顺序，将<code>C:\Program Files\Common Files\Oracle\Java\javapath</code> 和 x86 目录两个环境变量的顺序调整到自定义的 <code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</code> 等变量的后面。</p>
<p>方法2：删除 Path 中<code>C:\Program Files\Common Files\Oracle\Java\javapath</code> 这个环境变量。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title>This 关键字</title>
    <url>//This%20%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content><![CDATA[<h1 id="This-关键字"><a href="#This-关键字" class="headerlink" title="This 关键字"></a>This 关键字</h1><p>在实例方法或构造函数中，<code>this</code>是对当前对象的引用 （当前对象：正在调用其方法或构造函数的对象。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="number">1.</span> 与 field 一起使用：</span><br><span class="line">    通常是发生了遮蔽（特定作用域中（例如在构造函数中）出现了与外部作用域中相同名称的变量名（如下例子），导致在这个特定作用域中定义的同名变量隐藏了外部的同名变量，这时如果要使用外部变量就不能直接使用变量名，需要用 <span class="built_in">this</span> 关键字）</span><br><span class="line"><span class="comment">// 原因是 构造函数的参数与field重名，导致被遮蔽（shadow）,所以通过 this，表明是要赋值给 Point 类中的field。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShadowTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FirstLevel</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">methodInFirstLevel</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">            System.out.println(<span class="string">&quot;this.x = &quot;</span> + <span class="built_in">this</span>.x);</span><br><span class="line">            <span class="comment">// 通过所属的类名引用包含较大作用域的成员变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;ShadowTest.this.x = &quot;</span> + ShadowTest.<span class="built_in">this</span>.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">ShadowTest</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShadowTest</span>();</span><br><span class="line">        ShadowTest.<span class="type">FirstLevel</span> <span class="variable">fl</span> <span class="operator">=</span> st.<span class="keyword">new</span> <span class="title class_">FirstLevel</span>();</span><br><span class="line">        fl.methodInFirstLevel(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">x = <span class="number">23</span></span><br><span class="line"><span class="built_in">this</span>.x = <span class="number">1</span></span><br><span class="line">ShadowTest.<span class="built_in">this</span>.x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 与 构造函数一起使用：</span><br><span class="line"><span class="comment">// 这里希望提供有默认值的构造函数，使用时根据参数个数选择合适的构造函数；</span></span><br><span class="line"><span class="comment">// 注意，使用时 this(xxx) 需要写在构造函数的第一行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width, height;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> ThreadLocal 中的例子：</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里的 this 是调用get() 方法的对象的引用</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3中的具体使用，this 就是 threadLocalName 对象的引用</span></span><br><span class="line">	ThreadLocal&lt;String&gt; threadLocalName = ThreadLocal.withInitial(() -&gt; Thread.currentThread().getName());</span><br><span class="line">    threadLocalName.get()</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html">Oracle官方指南内容</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么Java中只有值传递</title>
    <url>//%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92.html</url>
    <content><![CDATA[<h1 id="为什么Java中只有值传递？"><a href="#为什么Java中只有值传递？" class="headerlink" title="为什么Java中只有值传递？"></a>为什么Java中只有值传递？</h1>]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>值传递</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么外部类可以通过内部类对象访问内部类的私有变量</title>
    <url>//%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%96%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F.html</url>
    <content><![CDATA[<p>我们知道 Java 中类的 private 成员正常情况下只能在定义类的内部访问，那么下图为什么可以？又是如何实现的呢？</p>
<p>如下图所示：</p>
<p><img src="https://ligongzhao-pics.oss-cn-hangzhou.aliyuncs.com/imgouter_access_inner_private_variable.jpg"></p>
<p>上图是 JDK 1.8 中 <code>ThreadLocal#get()</code> 方法的源码，从标红的部分可以看到，<code>getEntry()</code> 是 静态内部类 <code>ThreadLocalMap</code> 的 private 方法，为什么在外部类中可以通过对象的方式访问？</p>
<p>回答：</p>
<p>一下回答参考 <a href="https://www.zhihu.com/question/54730071/answer/140867608">R大在知乎上的回答</a></p>
<p>总结就是，</p>
<ul>
<li><p>Java语言规范里允许 <code>enclosing class</code> 访问 <code>inner class</code> 的<code>private/protected</code>成员，也允许<code>inner class</code>访问 <code>enclosing class</code> 的 <code>private/protected</code> 成员。</p>
</li>
<li><p>javac 的做法是，在 <code>enclosing / inner class</code> 之间要访问对方的 private &#x2F;protected 成员时，javac 会生成合适的 <strong>access method</strong>（即 <code>access$xxx</code> 形式的方法）来提供合适的可访问性，这样就绕开了原本的成员的可访问性不足的问题。</p>
</li>
</ul>
<h2 id="如何实现上面规定的？"><a href="#如何实现上面规定的？" class="headerlink" title="如何实现上面规定的？"></a>如何实现上面规定的？</h2><p>虽然 Java 语言规范是允许相互访问 private&#x2F;protected 成员，但是没有规定如何实现这种访问</p>
<p>JVM 规范则在大多数时候都把<strong>每个Class都看作等价于top-level的</strong>，也就是说不关心enclosing &#x2F; inner class之间的嵌套关系。对JVM来说，<code>enclosing class</code>和<code>inner class</code>在大部分情况下都是“不相关的两个类”，所以它们之间相互是不能访问对方的private&#x2F;protected成员的。</p>
<p>在实现中，衔接 Java 语言规范与 JVM 规范的就是 Java 源码级编译器（例如 javac，ECJ等）。既然规范没有规定死要如何实现，各个编译器可以自己发明自己的办法。</p>
<p>javac的做法：</p>
<ul>
<li>在 <code>enclosing / inner class</code> 之间要访问对方的 private &#x2F;protected 成员时，javac 会生成合适的 <strong>access method</strong>（即 <code>access$xxx</code> 形式的方法）来提供合适的可访问性，这样就绕开了原本的成员的可访问性不足的问题。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">outProp</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">inProp</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessInnerProp</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Inner</span>().inProp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    p.accessInnerProp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javac 会把上面的代码解糖为类似下面的形式：（下面的代码是）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> outProp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.outProp = <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessInnerProp</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(Outer$Inner.access$<span class="number">000</span>(<span class="keyword">new</span> <span class="title class_">Outer$Inner</span>(<span class="built_in">this</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    p.accessInnerProp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// javac 编译后内部类是单独的文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer$Inner</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> inProp;</span><br><span class="line">  <span class="keyword">final</span> <span class="comment">/* synthetic */</span> Outer <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Outer$Inner(Outer outer) &#123;</span><br><span class="line">    <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span> = outer;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.inProp = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="type">int</span> access$<span class="number">000</span>(Outer$Inner self) &#123;</span><br><span class="line">    <span class="keyword">return</span> self.inProp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出来 javac 编译后，自动生成了合适的 <code>access$xxx</code> 形式的方法</p>
<ul>
<li>问题，如何得到解糖后的代码？</li>
<li>答：1. javac编译后，javap 看字节码人肉反编译；2. 调试 javac 直接把变换后的 AST 输出成文本。</li>
</ul>
<p>我们可以javap 查看字节码确认：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>: invokestatic  #<span class="number">6</span>                  <span class="comment">// Method com/spoonli/mall/OuterAccessInnerTest$Inner.access$100:(Lc</span></span><br><span class="line">om/spoonli/mall/OuterAccessInnerTest$Inner;)I</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> access$<span class="number">100</span>(com.spoonli.mall.OuterAccessInnerTest$Inner);</span><br><span class="line"></span><br><span class="line">上面内容分别从调用 <span class="keyword">private</span> 成员的外部类和生成access$xxx方法的内部类中反编译得到</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据类型</title>
    <url>//%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content><![CDATA[<h2 id="Java中有几种基本数据类型？对应的包装类分别是什么？各占多少字节？"><a href="#Java中有几种基本数据类型？对应的包装类分别是什么？各占多少字节？" class="headerlink" title="Java中有几种基本数据类型？对应的包装类分别是什么？各占多少字节？"></a>Java中有几种基本数据类型？对应的包装类分别是什么？各占多少字节？</h2><h3 id="Java中有几种基本数据类型？"><a href="#Java中有几种基本数据类型？" class="headerlink" title="Java中有几种基本数据类型？"></a>Java中有几种基本数据类型？</h3><p>8种基本数据类型</p>
<ul>
<li>6中数字类型：<code>byte</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>float</code>,<code>double</code></li>
<li>1种字符类型：<code>char</code></li>
<li>1种布尔类型：<code>boolean</code></li>
</ul>
<h3 id="基本数据类型对应的包装类分别是什么？"><a href="#基本数据类型对应的包装类分别是什么？" class="headerlink" title="基本数据类型对应的包装类分别是什么？"></a>基本数据类型对应的包装类分别是什么？</h3><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
<th>位数bit</th>
<th>字节byte</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
<td>8</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>16</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>32</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>64</td>
<td>8</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>32</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>64</td>
<td>8</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>1</td>
<td></td>
<td>false</td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li><code>boolean</code>,官方文档没有明确定义，它依赖与JVM厂商的具体实现，逻辑上是占用1bit。</li>
<li>java 里使用<code>long</code>类型的数据一定要在数值后面添加<code>L</code>，否则将会作为整形int解析。</li>
<li><code>char</code> 的值为单引号，<code>char a=&#39;h&#39;</code>,String的值为双引号(<code>&quot;</code>)，<code>String b=&quot;hello&quot;</code>。</li>
<li>包装类型就与普通的引用类型一样了，没有赋值就是<code>null</code>，基本数据类型都有默认值，不会为null.</li>
</ol>
</blockquote>
<p>基本数据类型存放在<code>Java虚拟机栈中的局部变量表</code>中，而包装类属于引用类型，存放与<code>Java虚拟机的堆中</code>，相较于对象类型，基本数据类型占用空间非常小。</p>
<blockquote>
<p>局部变量表，主要存放了编译期可知的</p>
<ol>
<li>基本数据类型<br>（byte,short,int,long,float,double,char,boolean）；</li>
<li>对象引用<br>（它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）；</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>//%E5%BC%82%E5%B8%B8.html</url>
    <content><![CDATA[<ol>
<li>Exception和Error有什么区别？</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>如何获取Java运行时动态生成的class文件</title>
    <url>//%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84class%E6%96%87%E4%BB%B6.html</url>
    <content><![CDATA[<p>分析JDK动态代理时我们知道代理类是在运行时动态生成的，那么如何查看这些动态生成的代理类的内容？</p>
<p>使用 <code>Hotspot JVM</code> 时，我们可以使用其提供的 <code>HSDB(Hotspot Debugger)</code> 这个可视化工具来查看。</p>
<p>操作步骤：</p>
<ol>
<li><p>打断点，在想要查看的代理类对象上打个断点（主要是方便获取代理类的类名），然后运行程序；</p>
<p><img src="/pics/01debug_get_proxy.png" alt="打断点"></p>
</li>
<li><p><code>jps</code> 找到自己应用的 <code>PID</code>;</p>
<p><img src="/pics/02pid.png" alt="pid"></p>
</li>
<li><p>在命令行中启动对应版本的 <code>HSDB</code>，<code>java -classpath &quot;%JAVA_HOME%\lib\sa-jdi.jar&quot; sun.jvm.hotspot.HSDB</code> ，此时会启动一个可视化的界面；</p>
</li>
<li><p><code>File -&gt; Attach to Hotspot process...</code> Attach 上自己应用的 <code>PID</code>;</p>
<p><img src="/pics/03attach_to_hotspot_process.png" alt="attach自己的pid"></p>
<p><img src="/pics/04input_pid.png" alt="输入pid"></p>
</li>
<li><p><code>Tools -&gt; Class Browser</code>;</p>
<p><img src="/pics/05class_browser.png" alt="class_browser"></p>
</li>
<li><p>将调试时获取的代理类名称作为关键字搜索；</p>
</li>
<li><p>在搜索到的类结果面板中点 <code>Create .class File</code> ，此时会在启动 <code>HSDB</code> 命令的路径下生产对应的 <code>.class</code> 文件；</p>
<p><img src="/pics/06create_class_file.png" alt="输入要搜索的代理类并保存"></p>
</li>
<li><p>利用 <code>jd-gui.exe</code> 或者 <code>idea</code> 来反编译 <code>.class</code> 文件。</p>
</li>
</ol>
<p>参考资料</p>
<p><a href="https://juejin.cn/post/6844903711177703432">使用HSDB查看javassist生成的动态class</a></p>
<p><a href="https://www.iteye.com/blog/rednaxelafx-727938">如何dump出一个Java进程里的类对应的Class文件？</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Collection问题汇总</title>
    <url>//Java%20Collection%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<ol>
<li>对比Vector、ArrayList、LinkedList有何区别？</li>
<li>对比HashTable、HashMap、TreeMap有何不同？</li>
<li>如何保证集合是线程安全的？ConcurrentHashMap如何实现高效地线程安全？</li>
</ol>
<h2 id="怎样理解有界队列和无界队列？"><a href="#怎样理解有界队列和无界队列？" class="headerlink" title="怎样理解有界队列和无界队列？"></a>怎样理解有界队列和无界队列？</h2><p><strong>有界队列：</strong> 有固定大小的队列。比如，设置了固定大小的 <code>LinkedBlockingQueue</code>，又或者大小为0，只是在生产者和消费者间做中转用的 <code>SynchronousQueue</code>；</p>
<p><strong>无界队列：</strong> 没有固定大小的队列。这些队列的特点是可以直接入列，直到溢出。没有设置范围即取默认最大值（ <code>Integer.MAX_VALUE</code>），当然现实几乎不会有这么大的容量（超过 <code>Integer.MAX_VALUE</code>），所以从使用者的体验上看，就相当于“无界”。比如没有设置固定大小的 <code>LinkedBlockQueue</code>。</p>
<p><strong>总结：</strong>除了 <code>SynchronousQueue</code>队列是有界的，其他队列，是否有界，取决于创建队列时有没有指定容量，设置固定大小的队列为有界队列，没有设置规定大小的队列为无界队列（实现上体验为队列大小为 <code>Integer.MAX_VALUE</code>）。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java容器</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title>时间格式化</title>
    <url>//%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96.html</url>
    <content><![CDATA[<ol>
<li><p>jdk8中两个包都可以实现转换指定string格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用DateTimeFormatter和LocalDateTime时，下面两种转换为指定格式string的format都可以，</span><br><span class="line">但是通过传参可以看出为什么stdFormat.format(localDateTime1);也可以，因为LocalDateTime实现了Temporal接口，而Temporal接口继承了TemporalAccessor接口</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLocalDateTiem</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">stdFormat</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span></span><br><span class="line">        LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stdFormat.format(localDateTime1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> localDateTime1.format(stdFormat);</span><br><span class="line">    Assertions.assertThat(result).isEqualTo(format);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前时间&#x2F;指定时间 的 前一天</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">yesterday</span> <span class="operator">=</span> now.plusDays(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>LocalDateTime 与 字符串类型 时间格式转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String specailTiem=<span class="string">&quot;2021-07-26 15:26:26&quot;</span>;</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateHourFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMddHH&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.parse(specailTiem, dateTimeFormatter);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateTimeHour</span> <span class="operator">=</span> dateTime.format(dateHourFormatter);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java时间格式化</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java时间格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>FastThreadLocal</title>
    <url>//FastThreadLocal.html</url>
    <content><![CDATA[<p>记录一下 FastThreadLocal 的相关内容，<br>FastThreadLocal vs ThreadLocal</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java并发</tag>
        <tag>FastThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的原子类</title>
    <url>//Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB.html</url>
    <content><![CDATA[<p>Java 的原子类</p>
<p>原子类，是 JUC(java.util.concurrent)包下封装的通过无锁的方式实现的一系列现场安全的原子操作类。</p>
<p>原子类的核心原理就是基于 CAS（Compare And Swap）。</p>
<p>CAS 的简单理解：给一个共享变量的内存地址，内存中应该的值（预期值，理解为更新前的值）和新值，然后通过 **<code>一条 CPU 指令</code>**来比较此内存地址中的值是否等于预期值，等于则替换内存地址中的值为新值，不等于则不予替换且换回。</p>
<p>也就是说<strong>硬件层面支持</strong>一条指令来实现这么几个操作，一条指令是不会被打断的，所以保证了原子性。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>通过下面的基本类型原子类，可以线程安全的更新这几个基本类型的值。</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>AtomicReference</li>
<li>AtomicStampedReference</li>
<li>AtomicMarkableReference</li>
</ul>
<p>是对象引用的原子化更新</p>
<p>差别在于 <code>AtomicStampedReference</code> 和 <code>AtomicMarkableReference</code> 可以避免 CAS 的 ABA 问题</p>
<ul>
<li>AtomicStampedReference 通过版本号 stamp 来避免</li>
<li>AtomicMarkableReference 通过一个布尔值 mark 来避免</li>
</ul>
<h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>因为 CAS 是将期望值与内存地址上当时的值进行比较，假设期望值为1，地址上的值现在为1，但是中间被其他人改为了2，然后又改为了1，所以此时你 CAS 操作去对比是可以替换的，你无法得知值是否中间被修改过，这种情况就叫 ABA 问题。</p>
<p>解决 ABA 问题的做法就是使用版本号，每次修改时版本号 +1，这样即使是一样的值，版本号不同，就能得知之前被修改过。</p>
<h2 id="属性更新类型"><a href="#属性更新类型" class="headerlink" title="属性更新类型"></a>属性更新类型</h2><h2 id="累加器类型"><a href="#累加器类型" class="headerlink" title="累加器类型"></a>累加器类型</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发未解决问题汇总</title>
    <url>//Java%E5%B9%B6%E5%8F%91%E6%9C%AA%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<h1 id="Java并发未解决问题汇总"><a href="#Java并发未解决问题汇总" class="headerlink" title="Java并发未解决问题汇总"></a>Java并发未解决问题汇总</h1><ol>
<li>什么是再入锁？</li>
<li>并发实践讲了啥？<ul>
<li>基础，并发性，线程安全性，基础类库提供的并发能力构建线程安全类</li>
<li>利用线程提高并发程序的性能</li>
<li>测试</li>
<li>底层原理</li>
</ul>
</li>
</ol>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ol>
<li>Executors 提供的四个线程池的缺点：（尽管它们内部都是通过创建 ThreadPoolExecutor 来实现的，但是本身不利于资源的合理利用）<ol>
<li>Executors.newFixedThreadPool() 和 Executors.newSingleThreadExecutor() <ul>
<li>主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li>
<li>因为创建的线程池使用的是 <code>new LinkedBlockingQueue&lt;Runnable&gt;()</code> 无界队列。</li>
</ul>
</li>
<li>Executors.newCachedThreadPool() 和 Executors.newScheduledThreadPool() <ul>
<li>主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li>
<li>同时 newCachedThreadPool() 线程池的 corePoolSize 为 0，表示进来的任务进到队列后就必须等待到队列满，然后通过&lt;maximumPoolSize 来不停的创建新线程。</li>
</ul>
</li>
</ol>
</li>
<li>阿里巴巴编码规约中提到，线程池<strong>不允许使用</strong> <code>Executors</code>创建，<strong>应该通过</strong> <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，避免资源耗尽的风险。</li>
</ol>
<h3 id="TheadPoolExecutor-创建线程池"><a href="#TheadPoolExecutor-创建线程池" class="headerlink" title="TheadPoolExecutor 创建线程池"></a>TheadPoolExecutor 创建线程池</h3><p>是线程池的核心实现。</p>
<p>参数解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,  </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,  </span></span><br><span class="line"><span class="params">                          TimeUnit unit,  </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,  </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  </span><br><span class="line">         Executors.defaultThreadFactory(), handler);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p><strong>corePoolSize &amp; maximumPoolSize</strong> </p>
<ul>
<li><p>corePoolSize 核心线程数，</p>
</li>
<li><p>maximumPoolSize 最大线程数</p>
</li>
</ul>
<p>关系如下：</p>
<ol>
<li>当新任务被提交到线程池中，如果当前运行的线程数 &lt; corePoolSize 核心线程数，即使当前有空闲线程，也会新建一个线程来处理新提交的任务；</li>
<li>如果当前运行的线程数 &gt; corePoolSize 核心线程数，但是 &lt; maximumPoolSize 最大线程数，只有当等待队列已满的情况下才会创建新线程。</li>
</ol>
<p><strong>keepAliveTime &amp; unit</strong></p>
<ul>
<li>keepAliveTime 为超过 corePoolSize 线程数的线程的最大空闲时间。超过这个时间如果线程依然空闲，且数量超过 corePoolSize 的数量，空闲线程就会被销毁。</li>
<li>unit 为时间单位。提供了一个枚举类型。</li>
</ul>
<p><strong>等待队列</strong></p>
<p>参数类型为 <code>BlockingQueue</code> 接口，任何阻塞队列(BlockingQueue) 都可以用来缓存提交的队列。</p>
<p>线程池的大小和阻塞队列，共同约束线程池的能力：任务提交给线程池后，各种处理策略如下。</p>
<ol>
<li>如果运行的线程数 <strong>&lt;</strong> corePoolSize 核心线程数，提交新的任务后就会新建一个线程来运行；</li>
<li>如果运行的线程数 <strong>&gt;</strong> corePoolSize 核心线程数，新提交的任务就会进入队列，等待被执行；</li>
<li>如果队列已满，且运行线程数 <strong>&lt;</strong> maximumPoolSize 最大线程数，则新建一个线程来运行该任务；</li>
<li>如果队列已满，且运行线程数 <strong>&gt;</strong> maximumPoolSize 最大线程数，新提交的任务将会根据 <em>拒绝策略</em> 来处理。</li>
</ol>
<blockquote>
<p>线程池中的线程不是一开始就全都创建启动的，而是根据任务量开始慢慢增加 的，这就算是一种<strong>懒加载</strong>，到用的时候再创建线程，节省资源</p>
</blockquote>
<p>三种通用的队列处理方式</p>
<ul>
<li>SynchronousQueue  –这个不太熟悉，查一下</li>
<li>LinkedBlockingQueue，属于无界队列<ul>
<li>特点，当所有核心线程都在运行时，新增任务会进入队列等待，因为是无界队列，所以不会有大于 corePoolSize 的线程被创建，此时 maximumPoolSize 参数失去了作用。</li>
<li>缺点，如果新增任务速度 &gt; 可处理速度，可能导致等待队列无线增长，耗费很多内存，甚至OOM。</li>
<li>适合场景，可以使得瞬间爆发的高频请求变得平滑。</li>
</ul>
</li>
<li>ArrayBlockingQueue，属于有界队列<ul>
<li>队列有最大值，可以防止资源被耗尽；</li>
<li>难点，需要平衡队列的大小与线程数 –这点需要再查资料</li>
</ul>
</li>
</ul>
<blockquote>
<p>无界队列与有界队列有多种实现方式，上面列举的仅是举例</p>
</blockquote>
<p><strong>拒绝策略</strong></p>
<p>当线程池已经关闭，或者达到饱和（达到最大线程数，且队列已满）状态时，新提交的任务会被拒绝。</p>
<p>TheadPoolExecutor 定义了4中拒绝策略：</p>
<ul>
<li>AbortPolicy , 默认策略，拒绝（丢弃）并抛出 <code>RejectedExecutionException</code></li>
<li>CallerRunsPolicy , 直接在 execute 方法的调用线程中运行被拒绝的任务，如果线程池已经关闭，则任务被丢弃；</li>
<li>DiscardPolicy ， 直接丢弃任务，不报错；</li>
<li>DiscardOldestPolicy  ， 丢弃队列中等待时间最长的任务，并执行当前提交的任务。如果线程池已经关闭，则丢弃任务。</li>
</ul>
<blockquote>
<p>还可以自定义拒绝策略，实现 <code>RejectedExecutionHandler</code> 接口即可。</p>
</blockquote>
<p>代码测试：</p>
<h1 id="实现特点及部分提问："><a href="#实现特点及部分提问：" class="headerlink" title="实现特点及部分提问："></a>实现特点及部分提问：</h1><ol>
<li><p>为什么线程池中，队列使用 Runnable 而不是 Thread ？</p>
</li>
<li><p>Thread 中的 start() 与 run() 有什么区别？</p>
</li>
<li><p>此时线程数小于核心线程数，并且线程都处于空闲状态，现在提交一个任务，是新起一个线程还是给之前创建的线程运行？</p>
<ul>
<li>答：execute方法的注释中写道，<code>If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task.</code> 从注释可以知道，此时线程池会新起一个线程来运行新任务，不管老线程是否空闲。</li>
<li>扩展，从注释我们可以知道，虽然默认线程池是懒加载，但它实际是想快速拥有核心线程数的线程数量。</li>
<li>核心线程数代表着线程池中承载日常工作的中坚力量，也就是线程池希望可以尽快创建出这些线程来处理任务，所以是在懒中又急着创建核心线程数。</li>
<li>而最大线程数 maximumPoolSize , 其实是为了应对突发状况，突发问题解决后，就把多出来的线程回收掉，只维持核心线程数量的线程。</li>
</ul>
</li>
<li><p>线程池中，核心线程和最大线程是否有特殊标记？</p>
<ul>
<li>答：没有，无论是核心线程还是非核心线程，在线程池中都一样，当淘汰的时候，不关心是哪些线程，只需要留下核心线程数量个线程即可。</li>
</ul>
</li>
<li><p>你是怎样理解 KeepAliveTime 的？</p>
<ul>
<li>答：线程池只想要核心线程数个线程，maximumPoolSize 中对出来的是为了预留一些来应对突发状态的，当突发状态过去后，线程池只希望维持核心线程数的线程，所以有了 KeepAliveTime，当线程数大于核心线程数之后，如果线程空闲时间超过 KeepAliveTime，就回收线程，直到数量与核心线程数持平。</li>
</ul>
</li>
<li><p>workQueue 有什么作用？</p>
<ul>
<li>答：缓存任务作用，需要注意限制工作队列大小，太长任务等待就会变长，同时缓存过多 可能导致资源耗尽系统崩溃。具体队列长度，需要结合线程数，任务执行时长，能承受的等待时间等决定。</li>
</ul>
</li>
<li><p>拒绝策略的作用？</p>
<ul>
<li>答：来应对过载任务的。线程池会遇到都满且队列也满的情况，这时就需要一种策略来处理 后序提交的任务。这里默认有四种策略，还可以自定义，具体看上面拒绝策略内容。</li>
</ul>
</li>
<li><p>ThreadPoolExecutor 源码中的 ctl 是干嘛的？</p>
<ul>
<li>ctl 是一个涵盖了两个概念的原子整数类，它将工作线程数（ workerCount ）和线程池状态（ runState），结合在一起维护，这样通过一个字段来维护多个值，形成一个原子操作，更容易维护多个值之间的一致性，也算是一种极简主义。（并发包中有很多这种实现）<ul>
<li>低 29 位存放 workerCount ，所以有效的线程数为 (2 ^ 29) - 1 （大约 5亿个）</li>
<li>高 3 位存放 runState</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池有几种状态？</p>
<ul>
<li>看一下源码注解即可，在 ctl字段的注释中。</li>
<li>RUNNING ： 能接受新任务，并处理阻塞队列中的任务；</li>
<li>SHUTDOWN ：不接受新任务，但是可以处理阻塞队列中的任务；</li>
<li>STOP ：不接受新任务，也不处理阻塞队列中的任务，并且还打断正在运行任务的线程，抛异常，就是不干了；</li>
<li>TIDYING ：所有任务都终止，且工作线程也为 0，处于关闭之间的状态；</li>
<li>TERMINATED ：已关闭。</li>
</ul>
</li>
<li><p>线程池的状态是如何变迁的？</p>
<ul>
<li><p>ThreadPoolExecutor 源码的 ctl字段的注释中写的很清楚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* RUNNING -&gt; SHUTDOWN</span><br><span class="line">*    On invocation of <span class="title function_">shutdown</span><span class="params">()</span>, perhaps implicitly in <span class="title function_">finalize</span><span class="params">()</span></span><br><span class="line">* (RUNNING or SHUTDOWN) -&gt; STOP</span><br><span class="line">*    On invocation of <span class="title function_">shutdownNow</span><span class="params">()</span></span><br><span class="line">* SHUTDOWN -&gt; TIDYING</span><br><span class="line">*    When both queue and pool are empty</span><br><span class="line">* STOP -&gt; TIDYING</span><br><span class="line">*    When pool is empty</span><br><span class="line">* TIDYING -&gt; TERMINATED</span><br><span class="line">*    When the <span class="title function_">terminated</span><span class="params">()</span> hook method has completed</span><br></pre></td></tr></table></figure>

<p>问题，如何判断状态从 shutdown -&gt; tidying ? 通过判断 workCount 是否为0 。</p>
</li>
<li><p>可以画个图</p>
</li>
</ul>
</li>
<li><p>原生线程池的核心线程一定伴随着任务慢慢创建的吗？</p>
<ul>
<li>并不是，虽然线程池的默认策略是执行新任务时才启动一个核心线程，但是它也提供了两个预启动的方法来覆盖默认策略。创建线程池后可以调用这两个方法。</li>
<li>prestartCoreThread  当前线程数小于核心线程数时创建一个</li>
<li>prestartAllCoreThreads  创建所有核心线程</li>
</ul>
</li>
<li><p>为什么要把任务先放在任务队列里面，而不是把线程先拉满到最大线程数？</p>
<ul>
<li>答：<ol>
<li>首先我个人觉得没有为什么，就是这样设计的，而且设计的也很合理。</li>
<li>其次，从<code>ctl</code> 上面的注释可知，原线程池的设计本意是希望让核心线程工作，最大线程数是一个应急方案，新建线程帮助消化过多的任务。所以你可以把线程池的 corePoolSize 设置为你想要线程池工作的线程数，任务队列 workQueue 起到一个缓冲的作用。</li>
<li>如果一定要扯一扯 CPU 密集型和 I&#x2F;O 密集型，原版线程池的实现可以认为是偏向 CPU 密集型的，我们知道处理 CPU 密集型任务时，线程太多反而会由于线程频繁切换的开销得不偿失，所以优先堆积任务而不是创建新线程。原版实现也是如此，当任务过多时，先通过任务队列缓存任务，让核心线程去消化。只有当核心线程和队列都满了，才利用最大线程来辅助消化。</li>
<li>对于像 Tomcat 这样的业务场景，大部分情况下是需要大量 I&#x2F;O 处理的情况就做了一些定制，修改了 jdk 中原生线程池的实现，使得在队列没满的时候，可以创建线程至最大线程数。</li>
</ol>
</li>
</ul>
</li>
<li><p>如何修改原生线程池，可以先拉满最大线程数再入任务队列排队？</p>
<p>答：关键点在队列的 <code>offer</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br></pre></td></tr></table></figure>

<p>从上面的 execute 方法（给线程池提交任务的方法）我们可以知道，在这个方法中只要在 <code>offer</code> 方法内部判断此时线程数小于最大线程数的时候返回 false，即可走下面 <code>else if </code> 中的 <code>addWorker()</code> （新增线程）的逻辑，如果数量已经达到最大线程数，直接入队即可。具体可以看一下 Tomcat 中的定制线程。</p>
</li>
</ol>
<h2 id="不懂的地方："><a href="#不懂的地方：" class="headerlink" title="不懂的地方："></a>不懂的地方：</h2><h4 id="1-runWorker-方法中是获取-Runnable-task-执行其-run-方法"><a href="#1-runWorker-方法中是获取-Runnable-task-执行其-run-方法" class="headerlink" title="1. runWorker() 方法中是获取 Runnable task 执行其 run() 方法"></a>1. runWorker() 方法中是获取 Runnable task 执行其 run() 方法</h4><p>答： 根据 Thread 的 start() 和 run() 的关系可知，一个线程调用 start() 即启动后，只要 run() 方法不执行结束，线程就不会终止（遇到异常或调用  stop() 方法主动停止除外）。那么复用线程的过程就是在其 run() 方法中执行循环的过程。所以这也是为什么 <code>runWorker()</code> 方法中是一个 while 循环获取并执行 Runnable task.run() 的过程，这里显示调用 run() 方法其实就是在线程中进行普通的方法调用。</p>
<h4 id="2-为什么-Integer-的低-29-位存放-workerCount-，有效的线程数为-2-29-1-？"><a href="#2-为什么-Integer-的低-29-位存放-workerCount-，有效的线程数为-2-29-1-？" class="headerlink" title="2. 为什么 Integer 的低 29 位存放 workerCount ，有效的线程数为 (2 ^ 29) - 1 ？"></a>2. 为什么 Integer 的低 29 位存放 workerCount ，有效的线程数为 (2 ^ 29) - 1 ？</h4><p>答：首先 Java 中的 Integer 是4个字节，32bit。低29位能表示的最大值就是29个1，同时我们知道最低位上 1 &#x3D; 2^0，那么 2^29其实表示二进制中第30位为1，其他低位为0的情况，再减去1就表示低29位全为1的情况了，即(2^29) -1 。</p>
<h1 id="涉及知识点："><a href="#涉及知识点：" class="headerlink" title="涉及知识点："></a>涉及知识点：</h1><h3 id="1-为什么线程-Thread-要先调用-start-再调用-run-，而不是直接调用-run"><a href="#1-为什么线程-Thread-要先调用-start-再调用-run-，而不是直接调用-run" class="headerlink" title="1. 为什么线程 Thread 要先调用 start() 再调用 run() ，而不是直接调用 run() ?"></a>1. 为什么线程 Thread 要先调用 start() 再调用 run() ，而不是直接调用 run() ?</h3><p>也是问 Thead 中 start() 方法与 run() 方法的关系。</p>
<p>答：</p>
<p>结论：因为 JVM 内存机制规定 </p>
<ol>
<li>run() 就是 Thread 中的一个普通的方法，直接调用 run() 是在当前线程中执行而不是新增线程，程序执行路径还是只有一条，需要等 run() 执行完才能执行后面的内容，无法达到多线程执行的目的；</li>
<li>start() 是启动 Thread 的方法，执行后，JVM 会新建一个线程，然后由这个新线程调用 run() ，这样 run() 就不在主线程中执行了。此时程序主线程无需等待 run() 方法执行完毕，而直接执行后面的代码。run() 在 Thread 中称为线程体，它包含了线程要执行的内容，通过调用 Thread 的 start() 启动线程后，线程处于就绪状态（可运行），并没有执行，在排队等待获取 CPU 时间片，就执行 run() 。run() 执行结束后，此线程即终止。（或者调用 stop() ，线程也会终止。）（在 main 方法中执行时主线程为 main）。</li>
</ol>
<p>Java 线程的说明：</p>
<ul>
<li>Java  的线程是通过 <code>java.lang.Thread</code> 类来实现的。VM 启动时会有一个由<code>主方法</code>所定义的线程。可以通过创建Thread的实例来创建新的线程。每个线程都是通过某个特定Thread对象所对应的方法run() 来完成其操作的，方法run()称为线程体。通过调用Thread类的 start() 方法来启动一个线程。</li>
</ul>
<p>实现并启动线程的方法，2个：</p>
<ul>
<li>方法1，写一个类继承自 Thread 类，重写 run() 方法。创建该类实例后，调用 start() 方法启动线程；</li>
<li>方法2，写一个类实现Runnable接口，实现 run() 方法。用 new Thread(Runnable target).start() 方法来启动；</li>
</ul>
<p>Java 中 Thread 的 start() 中的基本流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread#start() --&gt; <span class="keyword">native</span> <span class="title function_">start0</span><span class="params">()</span> --&gt; JVM_StartThread --&gt; thread_entry --&gt; Thread#run()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">说明：</span><br><span class="line">start方法中调用了本地方法start0，<span class="keyword">native</span>即是本地方法（也是底层方法）。怎么看start0方法，可以去访问openjdk源码。</span><br><span class="line">start0映射的方法就是JVM_StartThread,再看一下jvm.cpp文件中JVM_StartThread方法，里面有段代码</span><br><span class="line">native_thread = <span class="keyword">new</span> <span class="title class_">JavaThread</span>(&amp;thread_entry,sz);</span><br><span class="line"></span><br><span class="line">再看 thread_entry 方法</span><br><span class="line">JavaCalls::call_virtual(&amp;result,obj,KlassHandle(THREAD, SystemDictionary::Thread_klass()),vmSymbols::run_method_name(),vmSymbols::void_mehtod_signature(),THREAD);</span><br><span class="line"><span class="comment">// 这里 vmSymbols::run_method_name() 就是调用Thread 的 run() 方法。</span></span><br></pre></td></tr></table></figure>









<h1 id="遇到问题："><a href="#遇到问题：" class="headerlink" title="遇到问题："></a>遇到问题：</h1><p>看一下 TheadPoolExecutor 是如何处理阻塞队列中的任务的？如何复用线程的？</p>
<ul>
<li>run() 方法中循环调用提交的 <code>run()</code>方法，只要线程自身的 <code>run()</code> 方法不执行完，该线程就不会终止</li>
</ul>
<h2 id="20210827"><a href="#20210827" class="headerlink" title="20210827"></a>20210827</h2><p>下面使用 <code>IntStream.forEach()</code> 代码写的有问题，列出来纠正一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">8</span>).forEach(</span><br><span class="line">        (i) -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            poolExecutor.execute(() -&gt; &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;我是线程： &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 模拟线程执行时间，10s</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// TODO(SLi): 不能在for循环中添加这种 线程池的shutdown 方法。</span></span><br><span class="line">          <span class="comment">// finally &#123;</span></span><br><span class="line">          <span class="comment">//   poolExecutor.shutdown();</span></span><br><span class="line">          <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">原因：因为上面的代码写的有问题，<span class="keyword">try</span>...<span class="keyword">finally</span>... 代码块在forEach() 方法体中，即在<span class="keyword">for</span>循环中，每次循环都将走完方法体，应该把<span class="keyword">finally</span>部分挪到forEach的外面才对。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程</title>
    <url>//Java%E7%BA%BF%E7%A8%8B.html</url>
    <content><![CDATA[<h2 id="线程生命周期的不同状态"><a href="#线程生命周期的不同状态" class="headerlink" title="线程生命周期的不同状态"></a>线程生命周期的不同状态</h2><ul>
<li>新建（NEW ）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java并发</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized VS ReentrantLock</title>
    <url>//Synchronized%20VS%20ReentrantLock.html</url>
    <content><![CDATA[<h1 id="Synchronized-VS-ReentrantLock-区别"><a href="#Synchronized-VS-ReentrantLock-区别" class="headerlink" title="Synchronized VS ReentrantLock 区别"></a>Synchronized VS ReentrantLock 区别</h1><p>相同点：</p>
<ul>
<li>都是可重入锁；</li>
</ul>
<p>不同点：</p>
<ol>
<li>ReentrantLock 需要手动解锁，Synchronized 不需要；</li>
<li>ReentrantLock 支持设置超时时间（可以避免死锁，比较灵活），支持公平锁和非公平锁，可中断，支持条件判断；Synchronized 不支持超时时间，仅支持非公平锁，不可中断，不支持条件；</li>
</ol>
<p>总结：</p>
<p>一般情况下用 <code>Synchronized</code> 足矣，比较简单，复杂情况用 <code>ReentrantLock</code> ，比较灵活，支持的功能比较多。</p>
<blockquote>
<p>性能问题：随着 JDK 版本的改进，Synchronized 的性能越来越好，Synchronized 性能不如 ReentrantLock 已经是N年前的事情了。</p>
</blockquote>
<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>开始前的两个问题</p>
<ol>
<li>轻量级锁是否会进行自旋操作？<br>  答：<br>  在 jdk1.8 的源码中，轻量级锁通过 CAS 获取锁失败后，是直接膨胀成重量级锁。重量级锁会进行自旋。</li>
</ol>
<blockquote>
<p>轻量级锁没有自旋操作。<br>2. 何时进行自旋操作？<br>在升级为 <strong>重量级锁</strong>之后，线程如果没有抢到锁，会进行一段自旋操作，等待锁的释放。自旋失败就入队，并且阻塞线程。</p>
</blockquote>
<p>spin 旋转</p>
<p>源码中，TrySpin_VaryDuration 表示自适应自旋</p>
<p>mutex 互斥</p>
<p>pthread mutex 互斥锁（linux 下常见的实现）<br>mutex lock 互斥锁<br>mutex semaphores 互斥信号量</p>
<p>invariant  不变量<br>variant 变量</p>
<p>recursion 递归<br>recurse 递归</p>
<p>idea 有一个 jclasslib 插件，查看生产的字节码功能较全。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java并发</tag>
        <tag>Synchronized</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>//ThreadLocal.html</url>
    <content><![CDATA[<p><code>ThreadLocal</code> 实例在类中通常是 private static 字段，这些类希望将状态与 Thread 相关联。</p>
<p>使用位置：</p>
<ul>
<li>多线程情况下，一般在线程的 <code>run()</code> 方法中使用</li>
</ul>
<blockquote>
<p>使用位置决定了，在设计的时候，要通过传递 <code>ThreadLocal</code> 实例自身作为 key，从而获取当前线程存储的 value，同时存储&lt;key，value&gt; 的 map 需要在 Thread 中。</p>
</blockquote>
<h2 id="创建-ThreadLocal实例的方法"><a href="#创建-ThreadLocal实例的方法" class="headerlink" title="创建 ThreadLocal实例的方法"></a>创建 <code>ThreadLocal</code>实例的方法</h2><p>方法一：使用 <code>ThreadLocal.withInitial(Supplier&lt;? extends S&gt; supplier)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">ThreadLocal&lt;String&gt; threadLocalName = ThreadLocal</span><br><span class="line">      .withInitial(() -&gt; Thread.currentThread().getName());</span><br></pre></td></tr></table></figure>

<p>方法二：创建新的 ThreadLocal 或其子类，并重写 <code>initialValue()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">ThreadLocal&lt;String&gt; threadLocalName = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">其实 ThreadLocal.withINitial() 方法内部是通过创建 ThreadLocal 子类并重写initialValue() 方法来实现的，看源码部分：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>



<h3 id="为什么要重写-initialValue-方法？"><a href="#为什么要重写-initialValue-方法？" class="headerlink" title="为什么要重写 initialValue()方法？"></a>为什么要重写 <code>initialValue()</code>方法？</h3><p>具体分析：</p>
<p>因为创建了一个 <code>ThreadLocal</code>实例后，在线程内调用<code>ThreadLocal#get()</code> 方法的时候，首次调用时是需要创建 <code>ThreadLocalMap</code> 的，根据源码 <code>get() -&gt; setInitialValue() -&gt; T value = initialValue();</code>  我们知道 value 的内容取决于 <code>initialValue()</code> 方法，而默认该方法返回值为 null，所以需要重写该方法。</p>
<h3 id="问题：ThreadLocal-get-是如何找到当前-Thread-中存储的Map的？"><a href="#问题：ThreadLocal-get-是如何找到当前-Thread-中存储的Map的？" class="headerlink" title="问题：ThreadLocal#get() 是如何找到当前 Thread 中存储的Map的？"></a>问题：<code>ThreadLocal#get()</code> 是如何找到当前 <code>Thread</code> 中存储的Map的？</h3><p>答：通过 <code>Thread t = Thread.currentThread();</code>方法获取对应 Thread，然后 Thread 中有 Map 的变量<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code>，这样将 <code>ThreadLocal</code>本身作为key，传入Thread 内部独立的 Map，对于每个 Thread 来说，就可以实现相同的 key，获取 Thread 自身独自的 value 的功能。</p>
<h2 id="如何设计-ThreadLocal"><a href="#如何设计-ThreadLocal" class="headerlink" title="如何设计 ThreadLocal?"></a>如何设计 <code>ThreadLocal</code>?</h2><p>在线程对象内部搞个 map，把 <code>ThreadLocal</code>对象自身作为 key，把它的值作为 map 的值。</p>
<p><code>ThreadLocal</code> 作为一个容器来使用（对于线程来说是，资源本地化容器），重要的实现就是 <code>get()</code> ，<code>set()</code>方法和其内部的 <code>ThreadLocalMap</code>。</p>
<h2 id="ThreadLocal如何设计ThreadLocalMap中的Entry的？"><a href="#ThreadLocal如何设计ThreadLocalMap中的Entry的？" class="headerlink" title="ThreadLocal如何设计ThreadLocalMap中的Entry的？"></a><code>ThreadLocal</code>如何设计<code>ThreadLocalMap</code>中的<code>Entry</code>的？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);  <span class="comment">// k 被 WeakReference 引用，所以 k 是弱引用</span></span><br><span class="line">        value = v; <span class="comment">// v 还是强引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可知，<code>Entry</code> 继承了 <code>WeakReference</code>类，在它的构造函数中 k 被 <code>WeakReference</code> 所引用即<code>super(k)</code>，所以这个 <strong>key 才是弱引用</strong>，Entry 自己并不是弱引用。</p>
<h1 id="ThreadLocal-为什么要用弱引用？"><a href="#ThreadLocal-为什么要用弱引用？" class="headerlink" title="ThreadLocal 为什么要用弱引用？"></a>ThreadLocal 为什么要用弱引用？</h1><ol>
<li><p>Entry 对 key 是弱引用，那么为什么要使用弱引用呢？</p>
<ul>
<li>如果一个对象没有强引用，<strong>只有弱引用的情况下</strong>， 这个对象是活不过一次 GC 的（遇到GC就会被清除），所以这样的设计就是为了让当外部对 <code>ThreadLocal对象</code>没有强引用的时候，可以将 <code>ThreadLocal对象</code> 给清理掉。</li>
</ul>
</li>
<li><p>那么为什么 Entry 中的 value 不弱引用？</p>
<ul>
<li>Entry 中的 value 如果弱引用，那么只要一次 GC，value 就会被清理掉，这时如果通过 <code>ThreadLocal 对象</code> 查对应的值，就是 null 了。<ul>
<li>（value 只有与 Entry 这一条引用链，而 key(ThreadLocal) 除了与 Entry 这条引用链，栈上还有 <code>ThreadLocal 引用</code>指向堆中的 <code>ThreadLocal 对象</code>，这个引用是强引用，只要这条强引用存在，那说明此时的 ThreadLocal 是有用的。）</li>
</ul>
</li>
</ul>
</li>
<li><p>那么为什么不能是 <code>ThreadLocalMap</code> 与 <code>Entry</code> 是弱引用？</p>
<ul>
<li>原因同上，Entry 也只有ThreadLocalMap 这一条引用链，如果弱引用，那么 Entry 一次 GC 后就会被清理掉，无法正常使用了，所以只能强引用。</li>
</ul>
</li>
</ol>
<p>综上如果想及时清除无用的 ThreadLocal 对象，通过弱化引用的形式，只能操作 Entry 和 key 之间的引用，所以它们之间用弱引用来实现。</p>
<p>下图是 ThreadLocal 在堆栈用的完整引用链：</p>
<p><img src="https://ligongzhao-pics.oss-cn-hangzhou.aliyuncs.com/imgthreadlocal_%E5%A0%86%E6%A0%88%E5%BC%95%E7%94%A8%E9%93%BE.jpg" alt="threadlocal_堆栈引用链"></p>
<p>从上图可知，当随着方法的执行完毕，相应的栈帧也出栈了，此时 <code>threadlocal引用</code> 与 <code>threadlocal对象</code> 这条强引用链也就没了，如果没有别的栈有对 <code>threadlocal对象</code>的引用，那么说明 <code>threadlocal对象</code>无法再被访问到（<strong>定义成静态变量的另说</strong>）。</p>
<p>那么此时 <code>ThreadLocal</code> 只存在于 Entry 之间的弱引用，那此时发生 GC，它就可以被清除了，因为它无法被外部使用了，就等于没用了，应该被处理来省空间。</p>
<p>因为平日线程的使用方式，基本都是线程池，所以线程的生命周期会很长，可能从你部署上线后一直存在，而 <code>ThreadLocal</code>对象的生命周期可能没有这么长。所以为了能让已经没用的 <code>ThreadLocal对象</code>得以回收，Entry 和 key 要设计成弱引用，不然 Entry 和 key 是强引用的话， ThreadLocal 对象会一直在内存中存在。</p>
<h2 id="为什么这样的设计会有内存泄漏？"><a href="#为什么这样的设计会有内存泄漏？" class="headerlink" title="为什么这样的设计会有内存泄漏？"></a>为什么这样的设计会有内存泄漏？</h2><p>什么是<strong>内存泄漏</strong>？</p>
<p>指：程序中已经无用的内存无法被释放，造成系统内存的浪费。</p>
<p>当 Entry 中的 key 即 <code>ThreadLocal</code> 对象被回收之后，会发生 <strong>Entry 中 key 为 null 的情况</strong>，其实这个 Entry 就已经没用了，但是又无法被回收，因为有 <code>Thread -&gt; ThreadLocalMap -&gt; Entry</code> 这条强引用在，这样没用的内存无法被回收，就是内存泄漏</p>
<h3 id="ThreadLocal-是如何设计处理内存泄漏的？"><a href="#ThreadLocal-是如何设计处理内存泄漏的？" class="headerlink" title="ThreadLocal 是如何设计处理内存泄漏的？"></a>ThreadLocal 是如何设计处理内存泄漏的？</h3><p>设计者在多个地方都做了清理无用 Entry ，即 key 已经被回收的 Entry 的操作。</p>
<p>代码中表现为 <code>expungeStaleEntry()</code> 方法。</p>
<p>在 <code>get()</code> , <code>set()</code> 和 <code>rehash()</code> 方法中都 <code>expungeStaleEntry()</code> 调用。</p>
<h1 id="ThreadLocal-最佳实践"><a href="#ThreadLocal-最佳实践" class="headerlink" title="ThreadLocal 最佳实践"></a>ThreadLocal 最佳实践</h1><p>等着无用 Entry 被动回收不是最好方法，如果不调用 set 或 get方法，或者调用 get 都直接命中，或者不发生扩种，那无用的 Entry 岂不是一直存在了吗？<code>expungeStaleEntry()</code>只能防止一部分的内存泄漏。</p>
<p>所以最佳实践是用完之后，调用一下 <code>remove()</code>方法，手动把 Entry 清理掉，这样就不会发生内存泄漏了！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    threadlocal.set(xxx);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadlocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即不需要的时候，显示的 remove 掉。</p>
<p>当然，如果不是线程池使用方法的话，其实不用关心内存泄漏，反正线程执行完就都回收了，<strong>但一般我们都是只用线程池的</strong>，比如你用了 tomcat，其实请求的执行用的就是 tomcat 的线程池，这就是隐式使用的线程池。</p>
<h1 id="扩展知识：Java-的引用"><a href="#扩展知识：Java-的引用" class="headerlink" title="扩展知识：Java 的引用"></a>扩展知识：Java 的引用</h1><p>扩展知识：Java 的引用</p>
<ul>
<li><p>强引用</p>
<ul>
<li>正常的引用，只要有强引用在，JVM 即使发生 OOM 也不会回收被引用的对象的。</li>
</ul>
</li>
<li><p>软引用</p>
<ul>
<li><p>与弱引用及其相似，除了回收时机不同（存活时间比弱引用可能长一些）；</p>
</li>
<li><p>只要内存足够，在 GC 时就不会清除软可达对象，这些对象就会一直保存在内存中。回收时机由 JVM 根据算法来决定。</p>
</li>
<li><p>在触发OOM之前，垃圾收集器一定会清理掉所有所的软可达对象；</p>
</li>
<li><p>适合用来做一些小的 cache，然后让 JVM 去决定什么时候把对象从缓存中清除；</p>
<blockquote>
<p>但是对于严重依赖缓存来提升性能的应用而言，软引用做缓存并不合适，此时应该使用更全面的缓存框架或者应用来处理。</p>
</blockquote>
</li>
<li><p>疑惑点：关于何时被回收？是不是可以理解为，在young GC 时并不会清除软引用，只有在 Full GC 时才会清除？只要堆内有足够内存，即使发生 GC ，也不会清除掉 软引用 ？毕竟 GC 是分带收集的？</p>
</li>
</ul>
</li>
<li><p>弱引用（WeakReference）</p>
<ul>
<li><p>一个<strong>只</strong>被<code>WeakReference</code>引用的对象，它被称为 <code>weakly reachable object</code>（弱可达性对象）。而这样的对象不能阻止垃圾收集器对它的回收</p>
</li>
<li><p>注意：如果一个对象被用<code>WeakReference</code>引用，但是在其他方法中作为方法参数传入时（例如 WeakHashMap#get 方法），那么在该方法（get方法）中，key 并不会被垃圾回收。因为给定的key已经被方法参数所引用。当该方法执行完出栈后，该引用就会消失后才可被垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">WeakReference</span> <span class="variable">weakWidget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(widget);</span><br><span class="line"><span class="comment">// 当有强引用指向 Widget 对象时，调用 weakWidget.get() 方法时，会获得真正的 Widget 对象；否则得到的就是 null</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>虚引用</p>
<ul>
<li><p>get() 方法返回 <code>null</code>，即，无法获取引用对象引用的真正的对象；</p>
</li>
<li><p>唯一作用就是它可以监测到对象的死亡。即，当你的对象真正从内存中移除时，指向这个对象的 <code>PhantomReference</code>对象就会被加入到<code>ReferenceQueue</code>队列中。</p>
<blockquote>
<p>因为 <code>PhantomReference</code>类的构造器必须制定一个 <code>ReferenceQueue</code> 对象。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>ReferenceQueue 的作用</p>
<ul>
<li>在构造 Soft Reference ,Weak Reference, Phantom Reference 时，如果关联一个 <code>ReferenceQueue</code>对象，那么当一个 <code>Reference</code>引用的对象被清除的时候，该<code>Reference</code>对象会被放入给定的队列当中。可以通过从该队列中获取<code>Reference</code>对象，然后做相关的工作。</li>
<li>WeakHashMap 中清除 key 为null 的Entry时使用<code>ReferenceQueue</code>，具体参考 <code>WeakHashMap.expungeStaleEntries()</code>方法</li>
</ul>
</li>
</ul>
<blockquote>
<p>一个对象可以被不同引用类型引用，例如，ThreadLocal 对象可以同时被外部变量强引用，和被ThreadLocalMap 的Entry 作为 key 弱引用。</p>
</blockquote>
<p>关于 <code>finalize()</code>方法的作用？</p>
<p>答：<strong>最佳实践就是不要使用 <code>finalize()</code>方法</strong>，因为它不能保证运行。JVM完全可以决定何时运行垃圾收集器以及收集什么，即使对象符合垃圾收集的条件。</p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/xlinsist/article/details/57089288">深入理解 java 中的 Soft references &amp; Weak references &amp; Phantom reference</a></p>
<p>软引用与弱引用的不同？</p>
<blockquote>
<p>软引用与弱引用唯一的不同就是，垃圾回收器（garbage collector）会通过<strong>算法决定</strong>是否回收软可达对象（softly reachable object），但是会<strong>直接回收</strong>弱可达对象（weakly reachable object）。</p>
</blockquote>
<p>类有三种变量：</p>
<ul>
<li>在类中的成员变量 - fields（字段）</li>
<li>在方法或者代码块中的变量 - local variables（本地变量）</li>
<li>在方法定义中的变量 - parameters （参数）</li>
</ul>
<p>首先要明白各种引用在遇到 GC 之后，引用与被引用对象之间的变化。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java并发</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>Logback使用</title>
    <url>//Logback%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p>Logback使用</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>使用流程</p>
<ol>
<li><p>maven项目中引用logback依赖<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用时具体版本，可以到网上查看</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>java代码中使用<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">// 当写下面这句给类 MonitorTaskInfo.class 创建logger的java代码时，会自动引入上面两个相关的包，</span></span><br><span class="line"><span class="comment">// 但是写的时候LoggerFactory无法自动提示getLogger的方法，这个我很疑惑，不知道具体原因</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MonitorTaskInfo.class);</span><br></pre></td></tr></table></figure></li>
<li><p>在项目的classpath中的目录下添加一个logback.xml的配置文件，配置日志的具体打印方式，日志文件路径等内容</p>
</li>
<li><p>maven中如何引用相关类？</p>
</li>
</ol>
<p>Logback-classic module requires the presence of slf4j-api.jar and logback-core.jar in addition to logback-classic.jar on the classpath.<br>    - 官方文档说，如果向使用Logback-classic模块，classpath中，除了需要logback-classic.jar外，还需要引入 slf4j-api.jar和 logback-core.jar<br>    - 其中logback-*.jar 文件是logback发行版的一部分，而slf4j-api.jar是SLF4J项目中的<br>(不过，在实际使用中发现，maven项目中仅引入logback-class.jar的时候，会自动将logback-core.jar和slf4j-api.jar两个包也引入到项目中，猜测可能是自动引入依赖的原因)</p>
<p>将修改后的logback.xml文件导出来放到gitee上，作为之后使用的一个模板文件使用<br>    - 写上使用的要求和配置的方法</p>
<p><a href="http://logback.qos.ch/manual/introduction.html">http://logback.qos.ch/manual/introduction.html</a><br>更多logback项目的使用说明，请参考上面的官方网站，（甚至可以学习一下该项目的源码，有很多值得学习的地方）</p>
<ol start="2">
<li>logback.xml 文件配置模板，参考目录下的同名文件即可，更详细内容，请参考官网</li>
</ol>
<h1 id="这是为什么topic-process的压缩代码日志一直会打印logback内部信息的原因，"><a href="#这是为什么topic-process的压缩代码日志一直会打印logback内部信息的原因，" class="headerlink" title="这是为什么topic-process的压缩代码日志一直会打印logback内部信息的原因，"></a>这是为什么topic-process的压缩代码日志一直会打印logback内部信息的原因，</h1><blockquote>
<p>我的logback.xml文件有问题</p>
</blockquote>
<p>If any of these two conditions is not fulfilled, Joran cannot interpret the debug attribute since the configuration file cannot be read. If the configuration file is found but is malformed, then logback will detect the error condition and automatically print its internal status on the console. </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Logback</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>日志</tag>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下设置DNS</title>
    <url>//CentOS7%E4%B8%8B%E8%AE%BE%E7%BD%AEDNS.html</url>
    <content><![CDATA[<p>在 CentOS 7 下，手工设置 <code>/etc/resolv.conf</code> 里的 DNS，过了一会，发现被系统重新覆盖或者清除了。和 CentOS 6 下<br>的设置 DNS 方法不同，有几种方式： </p>
<h2 id="1-使用-NetworkManager-的命令行工具-nmcli-来设置："><a href="#1-使用-NetworkManager-的命令行工具-nmcli-来设置：" class="headerlink" title="1. 使用 NetworkManager 的命令行工具 nmcli 来设置："></a>1. 使用 NetworkManager 的命令行工具 nmcli 来设置：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前网络连接</span></span><br><span class="line">[root@zabbix ~]# nmcli c show</span><br><span class="line">NAME         UUID                                  TYPE      DEVICE</span><br><span class="line">System eth0  5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0</span><br><span class="line">System eth1  9c92fad9-6ecb-3e6c-eb4d-8a47c6f50c04  ethernet  --</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改当前网络连接对应的 DNS 服务器，这里的网络连接可以用 NAME 或 UUID</span></span><br><span class="line">[root@zabbix ~]# nmcli con mod &quot;System eth0&quot; +ipv4.dns 8.8.4.4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将配置生效</span></span><br><span class="line">[root@zabbix ~]# nmcli c up &quot;System eth0&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看该命令的帮助文档：</p>
<p>nmcli –help</p>
</blockquote>
<h2 id="2-使用传统方法，修改网卡的-DNS-配置"><a href="#2-使用传统方法，修改网卡的-DNS-配置" class="headerlink" title="2. 使用传统方法，修改网卡的 DNS 配置"></a>2. 使用传统方法，修改网卡的 DNS 配置</h2><p>在 <strong>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-&lt;网卡名&gt;</strong> 文件中修改，只需要在最后一行添加新的DNS地址就可以了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DNS1=8.8.8.8</span><br><span class="line">DNS2=114.114.114.114</span><br></pre></td></tr></table></figure>

<p>重启网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<p>验证查看 <code>/etc/resolv.conf</code> 配置文件存在 DNS 配置了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/l1028386804/article/details/79850698">CentOS 7 下，如何设置DNS服务器</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS7</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash文件名中包含空格的处理方法</title>
    <url>//Bash%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E5%8C%85%E5%90%AB%E7%A9%BA%E6%A0%BC%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>文件或目录名带有空格，例如 “解决VM Workstation安装VMware Tools显示灰色的办法.md”。利用下面命令处理文件时，报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">解决VM Workstation安装VMware Tools显示灰色的办法.md</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">for</span> i <span class="keyword">in</span> `find . -<span class="built_in">type</span> f`;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span></span><br><span class="line">./解决VM</span><br><span class="line">Workstation安装VMware</span><br><span class="line">Tools显示灰色的办法.md</span><br></pre></td></tr></table></figure>

<p>如上所示，shell 中把 <code>解决VM Workstation安装VMware Tools显示灰色的办法.md</code> 文件解析成了三个文件。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>因为在 Bash 中，环境变量 <code>IFS</code> 的默认值将<code>\n\t</code> 即 <code>空格、回车、Tab</code>，作为值与值之间的分隔符，而不是作为文件名的一部分。</p>
<p>IFS 的 man page 描述如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p> IFS    The <em>Internal Field Separator</em> that is used for word splitting after expansion and to  split  lines  into words with the read builtin command.  The default value is “<space><tab><newline>‘’.</p>
</blockquote>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>通过修改 <code>IFS</code> 的值<strong>修改默认的分隔符</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存 IFS 的默认值</span></span><br><span class="line">DEFAULT_IFS=$IFS</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 \n 作为默认分隔符</span></span><br><span class="line">IFS=$(echo -en &quot;\b&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处理需要的内容</span></span><br><span class="line">do something</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还原 IFS 分隔符</span></span><br><span class="line">IFS=$DEFAULT_IFS</span><br></pre></td></tr></table></figure>

<blockquote>
<p>echo 的  -e ，启动反斜杠转移（默认是disable的）</p>
<p>-n ，不输出结尾换行符</p>
<p>\b ，回车符</p>
</blockquote>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p><a href="https://blog.csdn.net/keypeople/article/details/78147288">Linux shell 技巧：对文件名中包含空格的处理方法</a><br><a href="https://www.jb51.net/article/49797.htm">Shell中处理包含空格的文件名实例</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Bash</tag>
        <tag>IFS</tag>
      </tags>
  </entry>
  <entry>
    <title>常用代码段</title>
    <url>//%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%AE%B5.html</url>
    <content><![CDATA[<p>常用代码段</p>
<ol>
<li><p>用于找到执行脚本的绝对路径，避免软链接问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-*- sh -*-</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extend the <span class="built_in">ulimit</span> size, ensure <span class="built_in">local</span> spark tmp file process</span></span><br><span class="line">ulimit -n 65536</span><br><span class="line">PRG=&quot;$0&quot;</span><br><span class="line">while [ -h &quot;$PRG&quot; ]; do</span><br><span class="line">  ls=`ls -ld &quot;$PRG&quot;`</span><br><span class="line">  link=`expr &quot;$ls&quot; : &#x27;.*-&gt; \(.*\)$&#x27;`</span><br><span class="line">  if expr &quot;$link&quot; : &#x27;.*/.*&#x27; &gt; /dev/null; then</span><br><span class="line">    PRG=&quot;$link&quot;</span><br><span class="line">  else</span><br><span class="line">    PRG=`dirname &quot;$PRG&quot;`/&quot;$link&quot;</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line">PRGDIR=`dirname &quot;$PRG&quot;`</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注释的两句可要可不要，是获取脚本名称的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PRG_NAME=`<span class="built_in">basename</span> <span class="string">&quot;<span class="variable">$PRG</span>&quot;</span>`</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PRG_NAME_MAIN=<span class="string">&quot;<span class="variable">$&#123;PRG_NAME%.*&#125;</span>&quot;</span></span></span><br><span class="line">cd $PRGDIR/..</span><br><span class="line">ROOT_DIR=`pwd -P`</span><br><span class="line"></span><br><span class="line">cd - &gt;/dev/null</span><br></pre></td></tr></table></figure>

</li>
<li><p>计算时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ts=$(date -d $&#123;d&#125; +%s)</span><br><span class="line">next_day_ts=$(($ts + 86400))  # 后一天的时间戳</span><br><span class="line">action_time=$(date -d $&#123;d&#125; +&quot;%Y%m&quot;)</span><br><span class="line">cur_import_time=&quot;$&#123;d&#125;00&quot;</span><br><span class="line">next_import_time=$(date -d @$&#123;next_day_ts&#125; +&quot;%Y%m%d00&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>包管理工具</title>
    <url>//%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.html</url>
    <content><![CDATA[<h1 id="使用yum列出软件包支持的所有版本"><a href="#使用yum列出软件包支持的所有版本" class="headerlink" title="使用yum列出软件包支持的所有版本"></a>使用yum列出软件包支持的所有版本</h1><p>一般情况下yum list只会列出最新版本，以下使用Docker为例，列出其支持的所有可安装版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sort -r 对结果进行倒序排序</p>
</blockquote>
<p><a href="https://blog.51cto.com/watchmen/1934660">查看已安装软件包信息及未安装rpm包信息</a></p>
<p><strong>查看软件包的详细信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qpi rpm包</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>//%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<h1 id="找出当前正在使用的-shell-类别"><a href="#找出当前正在使用的-shell-类别" class="headerlink" title="找出当前正在使用的 shell 类别"></a>找出当前正在使用的 shell 类别</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -p $$</span><br></pre></td></tr></table></figure>



<p>样例结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个例子当前的shell是 bash</span></span><br><span class="line">[root@zabbix ~]# ps -p $$</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">15719 pts/0    00:00:00 bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个例子当前的shell是 zsh</span></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ ps -p $$</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line"> 159553 pts/1    00:00:04 zsh</span><br></pre></td></tr></table></figure>



<h1 id="查看当前shell版本"><a href="#查看当前shell版本" class="headerlink" title="查看当前shell版本"></a>查看当前shell版本</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">使用对应shell名 --version</span><br></pre></td></tr></table></figure>

<p>样例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh的版本</span></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ zsh --version</span><br><span class="line">zsh 5.9 (x86_64-debian-linux-gnu)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash的版本</span></span><br><span class="line">[root@zabbix ~]# bash --version</span><br><span class="line">GNU bash, version 4.2.46(2)-release (x86_64-redhat-linux-gnu)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="查看当前系统支持的-shell-类型"><a href="#查看当前系统支持的-shell-类型" class="headerlink" title="查看当前系统支持的 shell 类型"></a>查看当前系统支持的 shell 类型</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>



<h1 id="shebang的写法"><a href="#shebang的写法" class="headerlink" title="shebang的写法"></a>shebang的写法</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虽然shell的shebang有多种写法，但是通过参考权威文档，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以后我的shell，统一使用下面的这中写法</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>



<h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><h2 id="时间戳与指定时间格式互转"><a href="#时间戳与指定时间格式互转" class="headerlink" title="时间戳与指定时间格式互转"></a>时间戳与指定时间格式互转</h2><ul>
<li><p>date +%s   可以得到UNIX的时间戳;</p>
</li>
<li><p>将日期时间与时间戳互转：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date -d &quot;2015-08-04 00:00:00&quot; +%s     # 输出：1438617600</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间戳转换为指定时间格式：（具体时间格式写法，查看data的帮助）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date -d @1438617600  &quot;+%Y-%m-%d&quot;    # 输出：2015-08-04</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果需要得到指定日期的前后几天：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seconds=`date -d &quot;2015-08-04 00:00:00&quot; +%s`       # 得到时间戳</span><br><span class="line">seconds_new=`expr $seconds + 86400`                   # 加上一天的秒数86400</span><br><span class="line">date_new=`date -d @$seconds_new &quot;+%Y-%m-%d&quot;`   # 获得指定日前加上一天的日前</span><br></pre></td></tr></table></figure>
</li>
<li><p>get today,yesterday</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">today=$(date +%Y%m%d)  # 指定yyyyMMdd格式的日期</span><br><span class="line"></span><br><span class="line">yesterday=$(date -d &quot;1 day ago&quot; +%Y%m%d)   # 生成昨天yyyyMMdd的日期</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="计算耗时"><a href="#计算耗时" class="headerlink" title="计算耗时"></a>计算耗时</h2><p>start_time&#x3D;<code>date +%s</code><br>end_time&#x3D;<code>date +%s</code><br>cost_time&#x3D;$(( ${end_time} - ${start_time} ))</p>
<h1 id="计算-–这里有问题，let不好"><a href="#计算-–这里有问题，let不好" class="headerlink" title="计算 –这里有问题，let不好"></a>计算 –这里有问题，let不好</h1><p>let a &#x3D; “1 + 2”</p>
<h1 id="Sed"><a href="#Sed" class="headerlink" title="Sed"></a>Sed</h1><ol>
<li><p>使用sed匹配某一行并替换这一行的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &quot;/&lt;要替换的内容&gt;/c&lt;新内容&gt;&quot; &lt;文件&gt;</span><br><span class="line"></span><br><span class="line">(注意/c&lt;新内容&gt;,这里有一个字母c)</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">sed -i &quot;/BUILD_NUMBER=/cBUILD_NUMBER=$1&quot; file</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件头插入字符串 ABCDE</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件头即文件的第一行插入数据</span></span><br><span class="line">sed -i &#x27;1i\ABCDE&#x27; file.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明： -i ，表示直接修改文件，（不使用则会将修改后的内容输出到屏幕）。</p>
</blockquote>
</li>
<li><p>查看文件中间一段，你可以使用sed命令，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">取文件100~200行[100,200]的数据</span><br><span class="line">sed -n &#x27;100,200p&#x27; filename &gt; xxx </span><br><span class="line"></span><br><span class="line">sed -n &#x27;3p&#x27; filename  # 输出文件的第3行</span><br><span class="line"></span><br><span class="line">sed -n &#x27;2,5p&#x27; filename  # 输出文件的第2到5行</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>删除文件中N行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/xxx/d&#x27; filename  # 删除包含xxx的行</span><br><span class="line"></span><br><span class="line">sed &#x27;2d&#x27; filename  # 删除第2行</span><br><span class="line"></span><br><span class="line">sed &#x27;$d&#x27; filename  # 删除最后一行</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Mv"><a href="#Mv" class="headerlink" title="Mv"></a>Mv</h1><p>批量mv文件到指定目录下</p>
<p>-t &lt;执行目录&gt;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">例如：将查询出的sql文件批量mv到test_target目录下</span><br><span class="line">mv -t test_target `find . -name &quot;gen_sql_file_20200101_1595*.log&quot; -type f`</span><br></pre></td></tr></table></figure>



<h1 id="Awk"><a href="#Awk" class="headerlink" title="Awk"></a>Awk</h1><p>获取最后一列</p>
<p>样例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat xxx | awk -F &#x27;-&#x27; &#x27;&#123;print $NF&#125;&#x27;</span><br><span class="line"></span><br><span class="line">上面样例是对传过来的数据，按照 &#x27;-&#x27; 分割，打印最后一列。</span><br></pre></td></tr></table></figure>





<h1 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h1><p>使用find命令查找指定路径下的文件时：<br>注意：<br>  find &lt;非软连接路径&gt; …  –没有问题，非软连接路径可以直接使用路径名，或者最后带有”&#x2F;“路径符号，都可以匹配到<br>  find &lt;软连接路径&gt;&#x2F;  …  –软连接路径需要添加“&#x2F;” 路径符号，否则无法匹配到内容</p>
<h1 id="修改linux日期时间"><a href="#修改linux日期时间" class="headerlink" title="修改linux日期时间"></a>修改linux日期时间</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date -s &quot;20091112 18:30:50&quot; &amp;&amp;hwclock --systohc</span><br><span class="line"></span><br><span class="line">date -s                        //设置当前时间，只有root权限才能设置，其他只能查看</span><br><span class="line">date -s 20120523               //设置成20120523，这样会把具体时间设置成空00:00:00</span><br><span class="line">date -s 01:01:01               //设置具体时间，不会对日期做更改</span><br><span class="line">date -s &quot;01:01:01 2012-05-23&quot;  //这样可以设置全部时间</span><br><span class="line">date -s &quot;01:01:01 20120523&quot;    //这样可以设置全部时间</span><br><span class="line">date -s &quot;2012-05-23 01:01:01&quot;  //这样可以设置全部时间</span><br><span class="line">date -s &quot;20120523 01:01:01&quot;    //这样可以设置全部时间</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查硬件时间，这是BIOS时间</span></span><br><span class="line">hwclock --show </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果它与我们的系统时间不同，让它设置它，使其匹配。 使用下面提供的命令，BIOS将从上面设置的系统时间获取时间，并记住它。</span></span><br><span class="line">hwclock --systohc </span><br></pre></td></tr></table></figure>

<h1 id="文件的三个时间"><a href="#文件的三个时间" class="headerlink" title="文件的三个时间"></a>文件的三个时间</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">stat</span> 1234</span></span><br><span class="line">  File: 1234</span><br><span class="line">  Size: 7630            Blocks: 8          IO Block: 65536  regular file</span><br><span class="line">Device: b8239a14h/3089340948d   Inode: 2533274791067408  Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (197609/ spoonli)   Gid: (197121/ UNKNOWN)</span><br><span class="line">Access: 2020-12-03 23:11:06.615512900 +0800</span><br><span class="line">Modify: 2020-12-03 23:11:06.615512900 +0800</span><br><span class="line">Change: 2020-12-03 23:11:06.615064400 +0800</span><br></pre></td></tr></table></figure>
<ul>
<li>三个时间代表的含义：<ul>
<li>access time：表示我们最后一次访问（仅仅是访问，没有改动）文件的时间</li>
<li>modify time：表示我们最后一次修改文件的时间</li>
<li>change time：表示我们最后一次对文件属性改变的时间，包括权限，大小，属性等等。</li>
</ul>
</li>
</ul>
<p>有以下三种情况：</p>
<ol>
<li>当我们仅仅只是读取文件时，access time 改变，而modify，change time 不会改变</li>
<li>当修改文件时，access，modify，change time 都会跟着改变</li>
<li>当修改文件属性时，change time 改变，而access，modify time 不变</li>
</ol>
<p>通过ls命令查看文件的时间属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -lc filename 列出文件的 ctime （最后更改时间）</span><br><span class="line">ls -lu filename 列出文件的 atime（最后存取时间）</span><br><span class="line">ls -l filename 列出文件的 mtime （最后修改时间）</span><br></pre></td></tr></table></figure>

<h1 id="文件md5"><a href="#文件md5" class="headerlink" title="文件md5"></a>文件md5</h1><p>MD5只与文件内容有关，只要文件内容不一样，得出来的MD5值完全不一样。就是文件内容差一个字符不一样，得出的MD5值也完全不一样。</p>
<p>修改文件名是不会改变文件的md5值的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> metabase.db.trace.db 1234</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">md5sum</span> 1234</span></span><br><span class="line">ff92155dcaddac06332929dd1948c241 *1234</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">md5sum</span> metabase.db.trace.db</span></span><br><span class="line">ff92155dcaddac06332929dd1948c241 *metabase.db.trace.db</span><br></pre></td></tr></table></figure>


<h1 id="SCP"><a href="#SCP" class="headerlink" title="SCP"></a>SCP</h1><p>无需单独输入密码，远程传输文件<br>-i <identity_file></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用当前主机root用户的id_rsa密钥， 将192.168.10.25主机下的文件传输到当前目录下</span><br><span class="line"></span><br><span class="line">scp -i /root/.ssh/id_rsa root@192.168.10.25:/opt/lobster-import-2.7.3_ti528-dev.zip ./</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>指定端口号，使用 <code>-P</code> 大写的 P ，</p>
<p>语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -P port file_name [user@]ip:dir_path</span><br></pre></td></tr></table></figure>

<ul>
<li>-P port ，port 为指定的端口号</li>
<li>user，远程主机的用户名</li>
<li>ip，远程主机 IP</li>
<li>dir_path，远程的一个 user 可以写入文件的目录</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -P 2233 test.log root@172.17.216.53:/home/test/</span><br></pre></td></tr></table></figure>





<h1 id="rsync替换cp命令显示速度和进度"><a href="#rsync替换cp命令显示速度和进度" class="headerlink" title="rsync替换cp命令显示速度和进度"></a>rsync替换cp命令显示速度和进度</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rsync &quot;远程同步&quot;（remote sync）的意思</span><br><span class="line"></span><br><span class="line">  - 本地两个目录之间同步文件</span><br><span class="line">  - 本地与远程机器同步文件</span><br><span class="line">  - x，不支持远程与远程的同步</span><br><span class="line"></span><br><span class="line">如果是本地目录间同步，可以代替`cp`与`mv`</span><br><span class="line"></span><br><span class="line">rsync 的最大特点是增量传输，即会检查发送方和接收方已有的文件，仅传输有变动的部分（默认规则是文件大小或修改时间有变动）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">一般最常用的选项组合：-avzPr 来进行传输,</span><br><span class="line"></span><br><span class="line">一般，-a参数可以替代-r，</span><br><span class="line">  - 不过不需要同步文件元信息，则只使用-r，否则即可使用-a</span><br><span class="line"></span><br><span class="line">-P :--progress 显示同步的过程及传输时的进度等信息</span><br><span class="line">  - 这个参数可以实现传输文件时打印传输进度的功能</span><br></pre></td></tr></table></figure>




<h1 id="创建FTP用户"><a href="#创建FTP用户" class="headerlink" title="创建FTP用户"></a>创建FTP用户</h1><p>创建ftp用户和目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd lzy_datarefine --home-dir /data/DJ/datarefine/120000</span><br><span class="line">usermod --home /data/DJ/datarefine/120000 -m lzy_datarefine</span><br><span class="line">echo 123456 | passwd lzy_datarefine --stdin</span><br><span class="line">su - lzy_datarefine</span><br><span class="line">mkdir datarefine</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@datarefine01 ~]# useradd lzy_datarefine --home-dir /data/DJ/datarefine/120000</span><br><span class="line">useradd: cannot create directory /data/DJ/datarefine/120000</span><br><span class="line">    - 原因： 因为主目录所在的父目录不存在，或者主目录已经存在</span><br><span class="line">    - 我的情况是主目录所在父目录不存在，先创建父目录，然后再执行就可以了</span><br></pre></td></tr></table></figure>
<h1 id="lftp命令，linux登录ftp"><a href="#lftp命令，linux登录ftp" class="headerlink" title="lftp命令，linux登录ftp"></a>lftp命令，linux登录ftp</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lftp 用户名:密码@ftp地址:传送端口 (默认21)</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">lftp simba_dw:123456f@192.168.10.129</span><br></pre></td></tr></table></figure>

<h1 id="Linux内置命令"><a href="#Linux内置命令" class="headerlink" title="Linux内置命令"></a>Linux内置命令</h1><h2 id="EXEC"><a href="#EXEC" class="headerlink" title="EXEC"></a>EXEC</h2><h1 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h1><ol>
<li>添加&amp;让命令异步执行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command &amp;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">sleep 10 &amp;</span><br></pre></td></tr></table></figure>
执行这条命令后，并不会阻塞10秒，而是立即返回。</li>
</ol>
<p>当一个程序正在执行并且占用当前终端时我们同时按下 Ctrl + z ,这样就会把正在执行的前台程序放到后台挂起。</p>
<ol start="2">
<li><p>如果command2需要等到并行的command1执行之后再执行，就需要<code>wait</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command1 &amp;    # command1命令会被放到后台执行</span><br><span class="line">wait          # wait后面的命令command2会等待command1命令执行之后再执行</span><br><span class="line">command2</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了避免并发进程数过多，导致机器卡死，需要限制并发的数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">  joblist=($(jobs -p))</span><br><span class="line">  while (( $&#123;#joblist[*]&#125; &gt;= 20 ))</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">      sleep 1</span><br><span class="line">      joblist=($(jobs -p))</span><br><span class="line">  &#125;</span><br><span class="line">  done</span><br><span class="line">  sleep 10 &amp;</span><br><span class="line">&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ol>
<p>第二种执行并发程序的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 并发运行的最佳实践</span><br><span class="line"></span><br><span class="line"># 总进程数</span><br><span class="line">Sp=15</span><br><span class="line"># 并发数,并发数过大可能造成系统崩溃</span><br><span class="line">Qp=5</span><br><span class="line"># 存放进程的队列</span><br><span class="line">Qarr=();</span><br><span class="line"># 运行进程数</span><br><span class="line">run=0</span><br><span class="line"># 将进程的添加到队列里的函数</span><br><span class="line">function push() &#123;</span><br><span class="line">    Qarr=($&#123;Qarr[@]&#125; $1)</span><br><span class="line">    run=$&#123;#Qarr[@]&#125;</span><br><span class="line">&#125;</span><br><span class="line"># 检测队列里的进程是否运行完毕</span><br><span class="line">function check() &#123;</span><br><span class="line">    oldQ=($&#123;Qarr[@]&#125;)</span><br><span class="line">    Qarr=()</span><br><span class="line">    for p in &quot;$&#123;oldQ[@]&#125;&quot;;do</span><br><span class="line">        if [[ -d &quot;/proc/$p&quot; ]];then</span><br><span class="line">            Qarr=($&#123;Qarr[@]&#125; $p)</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">    run=$&#123;#Qarr[@]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># main</span><br><span class="line">for((i=0; i&lt;$Sp; i++));do</span><br><span class="line">    echo &quot;running $i &quot; </span><br><span class="line">    sleep 3 &amp;</span><br><span class="line">    push $!</span><br><span class="line">    while [[ $run -gt $Qp ]];do</span><br><span class="line">        check</span><br><span class="line">        sleep 0.1</span><br><span class="line">    done</span><br><span class="line">done</span><br><span class="line">echo -e &quot;time-consuming: $SECONDS   seconds&quot;    #显示脚本执行耗时</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h1><ol>
<li><p>需要注意的是 <code>[</code> 与 <code>]</code> 与操作数之间一定要有一个空格，否则会报错。</p>
</li>
<li><p>在进行字符串比较时，最好使用双中括号 <code>[[ ]]</code>. 因为单中括号可能会导致一些错误，因此最好避开它们。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在string字符串比较时，更推荐使用 [[ $str1 == $str2 ]]，</span><br><span class="line">     尽管&quot;==&quot;与  [[ $str1 = $str2 ]] 效果一样，但是，&quot;=&quot;可能会与赋值语句混淆</span><br><span class="line"></span><br><span class="line">[[ -z $str1 ]]   如果 str1 是空字符串，则返回真</span><br><span class="line"></span><br><span class="line">[[ -n $str1 ]]   如果 str1 是非空字符串，则返回真</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>  &#x3D; 号 前后有一个空格，有空格是关系比较，没有空格就变成了赋值效果</p>
</li>
</ol>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Do this:</span></span><br><span class="line">if [[ &quot;$&#123;my_var&#125;&quot; == &quot;some_string&quot; ]]; then</span><br><span class="line">  do_something</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-z (string length is zero) and -n (string length is not zero) are</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">preferred over testing <span class="keyword">for</span> an empty string</span></span><br><span class="line">if [[ -z &quot;$&#123;my_var&#125;&quot; ]]; then</span><br><span class="line">  do_something</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is OK (ensure quotes on the empty side), but not preferred:</span></span><br><span class="line">if [[ &quot;$&#123;my_var&#125;&quot; == &quot;&quot; ]]; then</span><br><span class="line">  do_something</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：当做string空值判断时，用上面的例子，不要用下面的例子<br>不好的例子：(不建议)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Not this: 这种使用填充字符的方式不好</span></span><br><span class="line">if [[ &quot;$&#123;my_var&#125;X&quot; == &quot;some_stringX&quot; ]]; then</span><br><span class="line">  do_something</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>可以通过 -a (and) 或 -o (or) 结合多个条件进行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ $var1 -ne 0 -a $var2 -gt 2 ]  # 使用逻辑与 -a</span><br><span class="line">[ $var1 -ne 0 -o $var2 -gt 2 ]  # 使用逻辑或 -o</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用逻辑运算符 &amp;&amp; 和 || 可以轻松地将多个条件组合起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]];</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h1><p>结论：</p>
<ol>
<li>不要将<code>&gt;</code>和<code>&lt;</code>等比较符号，与<code>[[ ... ]]</code>搭配来做数值比较，因为可能变成字典比较</li>
<li>建议使用<code>(( ... ))</code>搭配<code>&gt;</code>和<code>&lt;</code>等比价符号 </li>
<li>或者 将<code>-lt</code>,<code>-gt</code>与<code>[[ ... ]]</code>搭配来做数值比较</li>
</ol>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if (( $my_var &gt; 3 )); then</span><br><span class="line">  do_something</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ &quot;$&#123;my_var&#125;&quot; -gt 3 ]]; then</span><br><span class="line">  do_something</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>错误例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Probably unintended lexicographical comparison.</span></span><br><span class="line">if [[ &quot;$&#123;my_var&#125;&quot; &gt; 3 ]]; then</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">True <span class="keyword">for</span> 4, <span class="literal">false</span> <span class="keyword">for</span> 22.</span></span><br><span class="line">  do_something</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h1 id="shell算术操作"><a href="#shell算术操作" class="headerlink" title="shell算术操作"></a>shell算术操作</h1><p><strong>注意：</strong> 埋坑点，let aa&#x3D;”0<em>3600”;echo $? &#x3D;1, ((aa&#x3D;0</em>3600));echo $?&#x3D;1, aa$((0*3600));echo $?&#x3D;0</p>
<blockquote>
<p>TODO(SLi): <strong>上面的shell算术部分写的有问题，需要修改一下</strong></p>
</blockquote>
<hr>
<h1 id="使用Trap捕获signals-信号量"><a href="#使用Trap捕获signals-信号量" class="headerlink" title="使用Trap捕获signals(信号量)"></a>使用Trap捕获signals(信号量)</h1><h4 id="1-主要参考："><a href="#1-主要参考：" class="headerlink" title="1. 主要参考："></a>1. 主要参考：</h4><p><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html">Catching signals</a>，<br>还有<a href="https://stackoverflow.com/questions/22009364/is-there-a-try-catch-command-in-bash">Mark K Cowan’s answer</a></p>
<h4 id="2-主要目的："><a href="#2-主要目的：" class="headerlink" title="2.主要目的："></a>2.主要目的：</h4><p>在脚本退出前做一些操作，可以是异常处理，可以是清理工作等</p>
<h4 id="3-语法及用法："><a href="#3-语法及用法：" class="headerlink" title="3. 语法及用法："></a>3. 语法及用法：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trap [COMMANDS] [SIGNALS]</span><br><span class="line"></span><br><span class="line">your_code_do_some_thing</span><br></pre></td></tr></table></figure>
<p>关于<code>SIGNALS</code>的知识点，参考<a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_01.html">Signals</a>章节。</p>
<ul>
<li>注意：SIGKILL and SIGSTOP can not be caught, blocked or ignored.<ul>
<li>可以理解为，就是当你执行kill -9 PID的时候，程序会直接被杀掉，不会其他机会了。</li>
</ul>
</li>
</ul>
<h4 id="4-样例："><a href="#4-样例：" class="headerlink" title="4. 样例："></a>4. 样例：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Here is a very simple example, catching Ctrl+C from the user, upon <span class="built_in">which</span> a message is printed. When you try to <span class="built_in">kill</span> this program without specifying the KILL signal, nothing will happen:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主要测试，捕获用户输入的Ctrl+C的快捷键，并打印信息。如果你使用<span class="built_in">kill</span>命令来直接杀死这个脚本，那么什么都不会输出</span></span><br><span class="line"></span><br><span class="line">trap &quot;echo Booh!&quot; SIGINT SIGTERM</span><br><span class="line">echo &quot;pid is $$&quot;</span><br><span class="line"></span><br><span class="line">while :			# This is the same as &quot;while true&quot;.</span><br><span class="line">do</span><br><span class="line">        sleep 60	# This script is not really doing anything.</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<h1 id="新手可能常犯的错误"><a href="#新手可能常犯的错误" class="headerlink" title="新手可能常犯的错误"></a>新手可能常犯的错误</h1><h2 id="1-引用变量时，关于引号的使用"><a href="#1-引用变量时，关于引号的使用" class="headerlink" title="1. 引用变量时，关于引号的使用"></a>1. 引用变量时，关于引号的使用</h2><p>引用变量时需要在变量名前添加”$”前缀，但是是否使用引号，以及如何使用，可能会带来不同的结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量如下：</span></span><br><span class="line"></span><br><span class="line">example=&quot;Hello world&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">主要注意，不使用引号，使用双引号的区别</span><br><span class="line"></span><br><span class="line">使用方式        结果            单词数</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">example        Hello world    2</span></span><br><span class="line">&quot;$example&quot;      Hello world    1</span><br></pre></td></tr></table></figure>
<p>在下面两个地方使用内容中有空格的变量时尤其需要注意：</p>
<ul>
<li>在脚本中引用外部配置文件的时候尤其需要注意上面的内容，</li>
<li>在for循环中使用时需要注意<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for animal in &quot;$example&quot;; do</span><br><span class="line">    ... # 这里就只会循环一次</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for animal in $example; do</span><br><span class="line">    ... # 这里就会循环两次</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
上面的内容引用<a href="https://wiki.bash-hackers.org/scripting/newbie_traps#expanding_using_variables">Expanding (using) variables</a> 和 <a href="https://wiki.bash-hackers.org/syntax/quoting#string_lists_in_for-loops">String lists in for-loops</a> 两个章节</li>
</ul>
<h3 id="总的规则就是"><a href="#总的规则就是" class="headerlink" title="总的规则就是"></a>总的规则就是</h3><ol>
<li>引用变量时，总是用双引号(“”)将应用的变量包起来，而不是裸用<code>$</code>符号<ul>
<li>数组除外，只有在使用<em>数组</em> 时，不需要用双引号包起来</li>
<li>如果是<code>$数字</code>的形式，那么当超过9的时候，需要使用例如，<code>$&#123;11&#125;</code>的形式，否则<code>$11</code>则是$1和数字1的组合，并不是第11个参数<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"></span><br><span class="line">PRG=&quot;$0&quot;</span><br><span class="line"></span><br><span class="line">PRGDIR=`dirname &quot;$PRG&quot;`</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h1><h2 id="screen-命令"><a href="#screen-命令" class="headerlink" title="screen 命令"></a>screen 命令</h2><ol>
<li>开启一个新的session</li>
<li>查看开启的session</li>
<li>临时离开当前session</li>
<li>进入指定session</li>
<li>关闭（销毁）session</li>
<li>新session自定义名称</li>
</ol>
<ul>
<li>screen -S &lt;新session名称&gt;</li>
</ul>
<h2 id="amp-和-nohup"><a href="#amp-和-nohup" class="headerlink" title="&amp; 和 nohup"></a>&amp; 和 nohup</h2><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>总结常用数组的内容</p>
<p>更多内容可以参考 <a href="https://www.runoob.com/linux/linux-shell-array.html">Shell 数组</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="定义方式1"><a href="#定义方式1" class="headerlink" title="定义方式1"></a>定义方式1</h3><p>Shell 数组用<code>括号()</code>来定义，元素用 <code>空格</code> 符号分割，语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=(value1,value2,...)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tags=(&quot;A&quot; &quot;B&quot; C D)</span><br></pre></td></tr></table></figure>

<h3 id="定义方式2"><a href="#定义方式2" class="headerlink" title="定义方式2"></a>定义方式2</h3><p>直接使用数组下标定义数组：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><h3 id="获取单个元素"><a href="#获取单个元素" class="headerlink" title="获取单个元素"></a>获取单个元素</h3><p>读取数组元素值的一般格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">my_arr=(a b c d)</span><br><span class="line"></span><br><span class="line">echo &quot;first element: $&#123;my_arr[0]&#125;&quot;</span><br><span class="line">echo &quot;second element: $&#123;my_arr[1]&#125;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="获取数组中的所有元素"><a href="#获取数组中的所有元素" class="headerlink" title="获取数组中的所有元素"></a>获取数组中的所有元素</h3><p>格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 @，或者 *</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;array_name[@]&#125;</span></span><br><span class="line">或</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;array_name[*]&#125;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">my_arr=(a b c d)</span><br><span class="line"></span><br><span class="line">echo &quot;all elements: $&#123;my_arr[*]&#125;&quot;</span><br><span class="line">echo &quot;all elements: $&#123;my_arr[@]&#125;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="获取数组索引"><a href="#获取数组索引" class="headerlink" title="获取数组索引"></a>获取数组索引</h3><p>在数组变量名前添加 <code>!</code>感叹号，可以获取素组的所有索引，格式如下： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;!array_name[*]&#125;</span></span><br><span class="line">或</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;!array_name[@]&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h3><p>获取数组长度的方法与获取字符串长度的方法相同，在数组变量名前添加 <code>#</code>符号， 格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#array_name[*]&#125;</span></span></span><br><span class="line">或</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#array_name[@]&#125;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="1-for-循环遍历数组"><a href="#1-for-循环遍历数组" class="headerlink" title="1. for 循环遍历数组"></a>1. for 循环遍历数组</h3><p>注意点：</p>
<ol>
<li>数组要单独定义，不能定义在 for 的 列表位置；</li>
</ol>
<p>举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=(1 2 3)</span><br><span class="line"></span><br><span class="line">1. for .. in 的形式</span><br><span class="line">for i in $&#123;a[@]&#125;;do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">2. 可以带数组下标的 for...in</span><br><span class="line">for i in &quot;$&#123;!a[@]&#125;&quot;;do   </span><br><span class="line">    printf &quot;%s\t%s\n&quot; &quot;$i&quot; &quot;$&#123;a[$i]&#125;&quot;  </span><br><span class="line">done </span><br><span class="line"></span><br><span class="line">3. 标准 for 循环</span><br><span class="line">for(( i=0;i&lt;$&#123;#a[@]&#125;;i++ ));do</span><br><span class="line">  echo $&#123;a[i]&#125;</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-for-…-序列"><a href="#2-for-…-序列" class="headerlink" title="2. for … 序列"></a>2. for … 序列</h3><p>序列的形式可以直接写在 &lt;列表&gt; 的位置；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in &#123;22..30&#125;;do</span><br><span class="line">	echo $i;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>







<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>-e 和 -E 作用的解释，不过-E还不懂，得测试一下才行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e      Exit immediately if a pipeline (which may consist of a single simple command),  a subshell command enclosed  in  parentheses,  or  one  of the commands executed as part of a command list enclosed by braces (see SHELL GRAMMAR above) exits with a non-zero status.  The shell does not exit if the command that fails is part of the command list immediately following a while or until keyword, part of the test following the if or elif reserved words, part of any command executed in a &amp;&amp; or ││ list except the command following the final &amp;&amp; or ││, any command in a pipeline but the last, or  if  the command’s  return  value  is  being  inverted with !.  A trap on ERR, if set, is executed before the shell exits.  This option applies to the shell environment and each subshell environment separately  (see  COMMAND  EXECUTION  ENVIRONMENT above), and may cause subshells to exit before executing all the commands in the subshell.</span><br><span class="line"></span><br><span class="line">-E      If set, any trap on ERR is inherited by shell functions, command substitutions, and commands  executed  in  a  subshell environment.  The ERR trap is normally not inherited in such cases.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="修改系统的sysctl-vm-swappiness-x3D-0值"><a href="#修改系统的sysctl-vm-swappiness-x3D-0值" class="headerlink" title="修改系统的sysctl vm.swappiness&#x3D;0值"></a>修改系统的sysctl vm.swappiness&#x3D;0值</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/vm/swappiness</span><br><span class="line">sysctl vm.swappiness=0</span><br><span class="line">each &quot;vm.swappiness=0&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>



<h1 id="理解Linux系统-x2F-etc-x2F-init-d目录和-x2F-etc-x2F-rc-local脚本"><a href="#理解Linux系统-x2F-etc-x2F-init-d目录和-x2F-etc-x2F-rc-local脚本" class="headerlink" title="理解Linux系统&#x2F;etc&#x2F;init.d目录和&#x2F;etc&#x2F;rc.local脚本"></a>理解Linux系统&#x2F;etc&#x2F;init.d目录和&#x2F;etc&#x2F;rc.local脚本</h1><ol>
<li><p>&#x2F;etc&#x2F;init.d 该目录下包含许多系统的各种服务的启动和停止脚本；</p>
<ul>
<li><p>用service命令可执行init.d目录中相应服务的脚本。</p>
</li>
<li><p>例如：&#x2F;etc&#x2F;init.d&#x2F;network restart 重启网络， service network restart</p>
</li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;rc#.d(其实是软链接文件，&#x2F;etc&#x2F;rc.d&#x2F;rc#.d，这里#代表一个指定的初始化级别，范围是0~6)，该文件下包含许多对进程进行控制的脚本。这些脚本放置的地方，将决定这些脚本什么时候开始运行。</p>
</li>
<li><p>&#x2F;etc&#x2F;rc.local(其实是软连接文件：&#x2F;etc&#x2F;rc.d&#x2F;rc.local)，该脚本是在系统初始化级别脚本运行之后执行的；</p>
<blockquote>
<p><strong>该脚本是在系统初始化级别的脚本运行之后再执行的</strong>，因此可以安全地在里面添加你想在系统启动之后执行的脚本。</p>
</blockquote>
</li>
</ol>
<h1 id="查看内存型号"><a href="#查看内存型号" class="headerlink" title="查看内存型号"></a>查看内存型号</h1><p>打开命令窗口Ctrl + Alt + T输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dmidecode --type memory</span><br></pre></td></tr></table></figure>

<p>即可显示<strong>内存</strong>条的信息。</p>
<h1 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h1><p>centos7</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl list-unit-files  (查看开机启动项)</span><br><span class="line"></span><br><span class="line">systemctl list-unit-files  |  grep 程序名称   （查看某些服务开机启动状态）</span><br><span class="line"></span><br><span class="line">systemctl  list-unit-files |  grep enable （查看哪些为开机启动服务）</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>centos6</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ckconfig --list</span><br></pre></td></tr></table></figure>



<h1 id="Shell-判断字符串包含关系"><a href="#Shell-判断字符串包含关系" class="headerlink" title="Shell 判断字符串包含关系"></a>Shell 判断字符串包含关系</h1><h2 id="方法一，利用-grep-查询"><a href="#方法一，利用-grep-查询" class="headerlink" title="方法一，利用 grep 查询"></a>方法一，利用 grep 查询</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirp=&quot;学习笔记/运维/ELK&quot;</span><br><span class="line">result=$(echo $dirp| grep &quot;学习笔记&quot;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断结果是否为空字符串，不为空即包含，为空则不包含；</span></span><br><span class="line">if [[ -n $result ]];then</span><br><span class="line">    echo &quot;包含&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;不包含&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="方法二，利用字符串运算符"><a href="#方法二，利用字符串运算符" class="headerlink" title="方法二，利用字符串运算符"></a>方法二，利用字符串运算符</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirp=&quot;学习笔记/运维/ELK&quot;</span><br><span class="line">if [[ $dirp =~ &quot;学习笔记&quot; ]];then</span><br><span class="line">    echo &quot;包含&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;不包含&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>利用 <code>=~</code> 直接判断字符串的包含，结果为 true 则包含，为 false 则不包含。</p>
<h1 id="bash-如何数组和字符串相互转换"><a href="#bash-如何数组和字符串相互转换" class="headerlink" title="bash 如何数组和字符串相互转换"></a>bash 如何数组和字符串相互转换</h1><p>如何把下面的数组和字符串进行相互转换？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(&quot;学习笔记&quot; &quot;运维&quot; &quot;ELK&quot;) &lt;=&gt; &quot;学习笔记/运维/ELK&quot;</span><br><span class="line"></span><br><span class="line">tag_arr=(&quot;学习笔记&quot; &quot;运维&quot; &quot;ELK&quot;)</span><br><span class="line">tag_str=&quot;学习笔记/运维/ELK&quot;</span><br></pre></td></tr></table></figure>

<h2 id="数组-gt-字符串"><a href="#数组-gt-字符串" class="headerlink" title="数组-&gt;字符串"></a>数组-&gt;字符串</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEFAULT_IFS=$IFS</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将数组 -&gt; 字符串</span></span><br><span class="line">tag_str=[$(IFS=,;echo &quot;$&#123;tag_arr[*]&#125;&quot;)]</span><br><span class="line">IFS=$DEFAULT_IFS</span><br></pre></td></tr></table></figure>

<p>通过赋值IFS，指定分隔符&#x2F;连接符。</p>
<blockquote>
<p>注意，处理完后，需要恢复 IFS 的默认值，防止后续处理出现问题。</p>
</blockquote>
<p>如果连接符不需要特定（默认为 空格，回车，Tab）,那么数组-&gt;字符串只需要将 IFS部分去掉即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tag_str=[$(echo &quot;$&#123;tag_arr[*]&#125;&quot;)]</span><br></pre></td></tr></table></figure>

<h2 id="字符串-gt-数组"><a href="#字符串-gt-数组" class="headerlink" title="字符串-&gt; 数组"></a>字符串-&gt; 数组</h2><p>方法一：如果字符串是空格分隔，直接使用下面命令即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tag_str=&quot;学习笔记 运维 ELK&quot;</span><br><span class="line">tag_arr=($&#123;tag_str&#125;)</span><br></pre></td></tr></table></figure>

<p>方法二：如果字符串分隔符是其他字符，那么把分隔符变成空格即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tag_str=&quot;学习笔记/运维/ELK&quot;</span><br><span class="line">tag_arr=($(echo $tag_str | tr &quot;/&quot; &quot; &quot;))</span><br></pre></td></tr></table></figure>

<p>方法三：使用 awk 命令分割字符串，然后拼接为数组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tag_arr=($(echo $tag_str | awk &#x27;&#123;len=split($0,a,&quot;/&quot;);for(i=2;i&lt;=len;i++) print a[i]&#125;&#x27;))</span><br></pre></td></tr></table></figure>



<p>参考链接：<a href="https://www.jianshu.com/p/d663df2cba3e">bash如何把数组和字符串互相转换</a></p>
<h1 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h1><p>lsmod 显示&#x2F;列出 Linux 内核中当前加载的 modules 的状态。该命令将 &#x2F;proc&#x2F;modules 文件的内容进行格式化输出。</p>
<p><strong>字段含义</strong></p>
<ul>
<li><strong>Module</strong>：模块的名称。这通常是模块文件的名称，减去扩展名（.o或.ko），但它可能有一个自定义名称，可以在使用insmod命令插入模块时将其指定为选项。</li>
<li><strong>Size</strong>：驻留模块使用的内存量，以字节为单位。</li>
<li><strong>Used by</strong>：此列包含一个数字，表示正在使用的模块实例数。 如果该数字为零，则当前未使用该模块。 数字后面的文本表示有关使用模块的内容的任何可用信息：这通常是设备名称，文件系统标识符或另一个模块的名称。</li>
</ul>
<p>参考链接：<a href="https://blog.csdn.net/weixin_33712987/article/details/94235806">lsmod命令</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu-OpenSSH升级过程</title>
    <url>//Ubuntu-OpenSSH%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>升级前准备</li>
<li>手动升级流程</li>
<li>遇到问题及解决</li>
</ul>
<h1 id="升级前准备"><a href="#升级前准备" class="headerlink" title="升级前准备"></a>升级前准备</h1><p>查看待升级机器的系统版本及OpenSSH 和其依赖的 OpenSSL，ZLib的版本</p>
<ul>
<li>ubuntu-16.04<ul>
<li>OpenSSH_7.2p2 Ubuntu-4ubuntu2.8, OpenSSL 1.0.2g  1 Mar 2016</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@openstack-backupagent-zw-sjzt2:~# apt-get install -s zlib1g</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">zlib1g is already the newest version (1:1.2.8.dfsg-2ubuntu4.3).</span><br></pre></td></tr></table></figure>





<h1 id="手动升级流程"><a href="#手动升级流程" class="headerlink" title="手动升级流程"></a>手动升级流程</h1><p>对于可以连接互联网的Ubuntu机器，比较方便。对于不能连接互联网的机器，需要考虑到下载依赖包。</p>
<p>重点说一下离线安装过程（不能连接互联网）</p>
<h2 id="1-离线安装编译openssh源码需要编译环境"><a href="#1-离线安装编译openssh源码需要编译环境" class="headerlink" title="1. 离线安装编译openssh源码需要编译环境"></a>1. 离线安装编译openssh源码需要编译环境</h2><p>一，下面步骤在一台有网的相同版本的服务器上进行操作</p>
<ol>
<li><p>查询有哪些软件包；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-cache search xxx(要搜索的包名)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后对xxx执行安装或仅下载不安装操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install xxx     # 下载并安装 xxx 包</span><br><span class="line">apt-get -d install xxx  # 仅下载xxx到缓存位置，不安装</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存的文件在 /var/cache/apt/archives 目录下</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成依赖关系，</p>
<ul>
<li>到上一步骤缓存的目录下将安装 xxx 所涉及的包 copy 到指定目录下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /root/offline_gcc_packages</span><br><span class="line">cp -r /var/cache/apt/archives /root/offline_gcc_packages</span><br><span class="line">chmod 777 -R /root/offline_gcc_packages</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建立 deb 包的依赖关系</span></span><br><span class="line">apt-get install dpkg-dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个步骤非常重要，后面再说</span></span><br><span class="line">dpkg-scanpackages archives /dev/null &gt; root/offline_gcc_packages/Packages</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将生成的Packages复制到和deb同目录下</span></span><br><span class="line">cp /root/offline_gcc_packages/Packages root/offline_gcc_packages/archives/Packages</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打成压缩包，以备后用</span></span><br><span class="line">cd /root/</span><br><span class="line">tar zcvf offline_gcc_packages_ubuntu_right.tar.gz /root/offline_gcc_packages</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<p>二，在离线的服务器上进行安装</p>
<ol>
<li><p>将 <code>offline_gcc_packages_ubuntu_right.tar.gz </code> 解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf offline_gcc_packages_ubuntu_right.tar.gz</span><br></pre></td></tr></table></figure>


</li>
<li><p>将安装包解压后的目录和源路径，添加到系统源 <code>sources.list</code> 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改前，先备份原有文件</span></span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清空原有内容，或者注释掉</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">/etc/apt/sources.list</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入下面一行内容</span></span><br><span class="line">deb file:///root/offline_gcc_packages xenial/</span><br></pre></td></tr></table></figure>


</li>
<li><p>更新系统源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里可能遇到一些报错，</p>
<p>apt-get update —allow-insecure-repositories</p>
<p>注意，本地的源是没有签名的，直接更新ubuntu1604下的apt会提示找不到release文件，是一种不安全的源，默认是被禁用的。如果还要安装的话需要加上这个 –allow-unauthenticated选项。</p>
<p>apt-get update –allow-unauthenticated</p>
</blockquote>
</li>
<li><p>离线安装 gcc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install gcc</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：在执行是可能会出现这样的错误</strong> You will have to enable the component called ‘main’</p>
<p>解决方法：sudo add-apt-repository main</p>
</blockquote>
</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>上面步骤中，需要格外注意的是创建 deb 包的依赖关系与修改系统源的步骤。这两步骤是紧密关联的。</p>
<p>Packages 记录了archives目录下的 deb 包的依赖关系和每个deb文件其他信息，系统源根据会查询指定目录下 Packages 文件中的 <code>Filename</code> 找到需要的 deb 文件。Packages 文件中的<code>Filename</code>，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Filename: archives/binutils_2.26.1-1ubuntu1~16.04.8_amd64.deb</span><br></pre></td></tr></table></figure>

<p>系统源配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里重点两部分内容：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   &lt;这部分是文件的父级目录，找文件时会拼接这个路径&gt;  &lt;这部分是操作系统版本号名称&gt;</span></span><br><span class="line"> deb file:///root/offline_gcc_packages        xenial/</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">N: Can&#x27;t drop privileges for downloading as file &#x27;/root/offline_gcc_packages/xenial/InRelease&#x27; couldn&#x27;t be accessed by user &#x27;_apt&#x27;. - pkgAcquire::Run (13: Permission denied)</span><br><span class="line">W: The repository &#x27;file:/root/offline_gcc_packages xenial/ Release&#x27; does not have a Release file.</span><br><span class="line">N: Data from such a repository can&#x27;t be authenticated and is therefore potentially dangerous to use.</span><br><span class="line">N: See apt-secure(8) manpage for repository creation and user configuration details.</span><br><span class="line">E: Failed to fetch file:/root/offline_gcc_packages/xenial/Packages  File not found - /root/offline_gcc_packages/xenial/Packages (2: No such file or directory)</span><br><span class="line">E: Some index files failed to download. They have been ignored, or old ones used instead.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N: Can&#x27;t drop privileges for downloading as file &#x27;/root/offline_gcc_packages/archives/libmpc3_1.0.3-1_amd64.deb&#x27; couldn&#x27;t be accessed by user &#x27;_apt&#x27;. - pkgAcquire::Run (13: Permission denied)</span><br></pre></td></tr></table></figure>



<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>依然需要一台同配置可联网的 Ubuntu16.04LTS版本系统</p>
<ol>
<li><p>将后面编译OpenSSH源码需要的包下载到本地</p>
<blockquote>
<p>下载前，先进入 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F; 目录下，清空原有的缓存包</p>
</blockquote>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -d gcc zlib1g-dev libssl-dev libpam0g-dev libsystemd-dev make</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Ubuntu官网上搜索下面两个版本的deb包</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">libssl1.0.0=1.0.2g-1ubuntu4.20</span><br><span class="line">- libssl1.0.0_1.0.2g-1ubuntu4.20_amd64.deb</span><br><span class="line">libc6=2.23-0ubuntu11.3</span><br><span class="line">- libc6_2.23-0ubuntu11.3_amd64.deb</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入本地缓存目录，将步骤1中下载的包 copy 到与步骤2下载的包相同目录下，然后打包并放到离线的机器上</p>
</li>
<li><p>在离线机器上解压缓存包，并安装所有包</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -i *</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-离线升级OpenSSH"><a href="#2-离线升级OpenSSH" class="headerlink" title="2. 离线升级OpenSSH"></a>2. 离线升级OpenSSH</h2><ol>
<li><p>下载 openssh-8.8p1 源码，解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf openssh-8.8p1.tar.gz</span><br><span class="line">cd openssh-8.8p1/</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置安装路径，并生成makefile文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr --sysconfdir=/etc/ssh --with-md5-passwords --with-pam --with-zlib --with-privsep-path=/var/lib/sshd</span><br></pre></td></tr></table></figure>

<p>没有报错，且看到类似如下内容，表示执行成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">Preprocessor flags:  -D_XOPEN_SOURCE=600 -D_BSD_SOURCE -D_DEFAULT_SOURCE</span><br><span class="line">      Linker flags:  -Wl,-z,relro -Wl,-z,now -Wl,-z,noexecstack -fstack-protector-strong -pie</span><br><span class="line">         Libraries: -lcrypto -ldl -lutil -lz  -lcrypt -lresolv</span><br><span class="line">         +for sshd:  -lpam</span><br><span class="line"></span><br><span class="line">PAM is enabled. You may need to install a PAM control file</span><br><span class="line">for sshd, otherwise password authentication may fail.</span><br><span class="line">Example PAM control files can be found in the contrib/</span><br><span class="line">subdirectory</span><br></pre></td></tr></table></figure>


</li>
<li><p>修改源码</p>
<p>在源码目录下，找到 <code>sshd.c</code> 文件，找到<strong>调用</strong> <code>server_accept_loop</code> 函数的行，（这个函数的定义也在这个文件中，找到调用位置！）。添加向<code>systemd</code>发送通知的行，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Signal systemd that we are ready to accept connections */</span></span><br><span class="line">sd_notify(<span class="number">0</span>, <span class="string">&quot;READY=1&quot;</span>);</span><br><span class="line"><span class="comment">/* Accept a connection and return in a forked child */</span></span><br><span class="line">server_accept_loop(&amp;sock_in, &amp;sock_out,&amp;newsock, config_s);</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>在 第 2072 行添加 15个空格+ <code>sd_notify(0,&quot;READY=1&quot;);</code></p>
</li>
<li><p>在第 44 行 添加</p>
</li>
</ol>
</blockquote>
<p>同时在源文件开头添加引用头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;systemd/sd-daemon.h&gt;</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><p>修改 Makefile 文件</p>
<p>编译前，需要在源码目录中，找到步骤2生成的 <code>Makefile</code>文件，修改变量<code>LIBS</code>，添加对 <code>systemd</code>的依赖，内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LIBS=-lcrypto -ldl -lutil -lz -lcrypt -lresolv -lsystemd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在文件的第 50 行，追加 <code>-lsystemd</code></p>
</blockquote>
</li>
<li><p>编译，安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<p>安装完成后，会自动执行 <code>sshd -t /etc/ssh/sshd_config</code>，将提示中出现的几个弃用或不支持的参数注释掉，报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/ssh/sshd_config line 16: Deprecated option UsePrivilegeSeparation</span><br><span class="line">/etc/ssh/sshd_config line 19: Deprecated option KeyRegenerationInterval</span><br><span class="line">/etc/ssh/sshd_config line 20: Deprecated option ServerKeyBits</span><br><span class="line">/etc/ssh/sshd_config line 31: Deprecated option RSAAuthentication</span><br><span class="line">/etc/ssh/sshd_config line 38: Deprecated option RhostsRSAAuthentication</span><br><span class="line">/etc/ssh/sshd_config line 61: Unsupported option GSSAPIAuthentication</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>sed -i -e &quot;16s/^/#/&quot; -e &quot;19s/^/#/&quot; -e &quot;20s/^/#/&quot; -e &quot;31s/^/#/&quot; -e &quot;38s/^/#/&quot; -e &quot;61s/^/#/&quot; /etc/ssh/sshd_config</code></p>
</blockquote>
</li>
<li><p>重启服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="遇到问题及解决"><a href="#遇到问题及解决" class="headerlink" title="遇到问题及解决"></a>遇到问题及解决</h1><h2 id="离线安装依赖包的问题"><a href="#离线安装依赖包的问题" class="headerlink" title="离线安装依赖包的问题"></a>离线安装依赖包的问题</h2><h2 id="2-升级后-sshd-服务处于activating-start-状态"><a href="#2-升级后-sshd-服务处于activating-start-状态" class="headerlink" title="2. 升级后 sshd 服务处于activating(start)  状态"></a>2. 升级后 sshd 服务处于<code>activating(start)</code>  状态</h2><p>在 [离线升级OpenSSH](# 2. 离线升级OpenSSH) 章节中，添加了步骤3和4，即修改源码并修改Makefile文件的内容。</p>
<p>这是因为如果只执行步骤1,2,5,6的情况下，在<code>Ubuntu16.04 LTS</code>版本中，安装重试时，会报如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu-test-update-openssh:/etc/ssh# systemctl restart sshd</span><br><span class="line">Job for ssh.service failed because a timeout was exceeded. See &quot;systemctl status ssh.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure>

<p>执行 <code>systemctl status ssh.service</code> 查看服务状态，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">● ssh.service - OpenBSD Secure Shell server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: activating (start) since Sun 2022-02-06 12:54:51 UTC; 1min 18s ago</span><br><span class="line">  Process: 23608 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 23611 (sshd)</span><br><span class="line">    Tasks: 1</span><br><span class="line">   Memory: 508.0K</span><br><span class="line">      CPU: 21ms</span><br><span class="line">   CGroup: /system.slice/ssh.service</span><br><span class="line">           └─23611 sshd: /usr/sbin/sshd [listener] 0 of 10-100 startup</span><br><span class="line"></span><br><span class="line">Feb 06 12:54:51 ubuntu-test-update-openssh systemd[1]: Starting OpenBSD Secure Shell server...</span><br><span class="line">Feb 06 12:54:51 ubuntu-test-update-openssh sshd[23611]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">Feb 06 12:54:51 ubuntu-test-update-openssh sshd[23611]: Server listening on :: port 22.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上所示，服务的状态为 <code>Active: activating (start)</code>，尽管端口已经监听，且能正常连接，但是这种状态并不正常。即使执行 <code>journalctl -xe</code> 也看不到有用的信息。</p>
<p>查看系统日志 <code>tail -f /var/log/syslog</code>，会发现 <code>ssh.server</code> 服务在不停的重启。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>首先查看 <code>sshd</code> 服务启动文件 <code>/lib/systemd/system/ssh.service</code> ，部分内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/etc/default/ssh</span><br><span class="line">ExecStart=/usr/sbin/sshd -D $SSHD_OPTS</span><br><span class="line">ExecStart=/usr/sbin/sshd $SSHD_OPTS</span><br><span class="line">ExecReload=/usr/sbin/sshd -t</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartPreventExitStatus=255</span><br><span class="line">Type=notify</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里重点看<code>Type=notify</code> 配置，这意味着当前服务启动完毕，会通知 <code>systemd</code>，再继续往下执行。</p>
<p>所以出现命令挂起的原因是 <code>sshd</code> 服务启动后，没有给 <code>systemd</code> 服务发消息，导致 <code>systemd</code> 一直等待，直到超时。这也是为什么执行 restart 命令后会报 timeout 的原因。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="方法1（推荐）"><a href="#方法1（推荐）" class="headerlink" title="方法1（推荐）"></a>方法1（推荐）</h4><blockquote>
<p>这种方法更可靠，减少之后使用过程中遇到其他未知问题的可能。</p>
</blockquote>
<p>添加步骤3和4，即修改源码，添加通知 <code>systemd</code> 的内容和依赖。</p>
<p>同时在前面安装编译源码的依赖时，安装了<code>libsystemd-dev</code> 依赖包，这是因为默认的依赖中，不包含 <code>sd_notify</code> 这个函数，所以需要执行编译前安装依赖包。单独安装使用如下命名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install libsystemd-dev</span><br></pre></td></tr></table></figure>



<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>通过前面内容，我们知道服务挂起的原因是因为服务启动配置中设置了<code>Type=notify</code>，但是启动后并没有通知<code>systemd</code>导致，所以这里直接注释掉该选项，即不通知<code>systemd</code>，这种情况下，系统会使用默认的<code>Type=simle</code>配置（ExecStart 字段启动的进程为主进程）。</p>
<p>然后重新加载配置文件，并重启服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OpenSSH</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu软件包操作</title>
    <url>//Ubuntu%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<h1 id="如何在本地下载具有依赖项的deb软件包？"><a href="#如何在本地下载具有依赖项的deb软件包？" class="headerlink" title="如何在本地下载具有依赖项的deb软件包？"></a>如何在本地下载具有依赖项的deb软件包？</h1><p>下载具有所有依赖项的软件包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install --download-only gcc</span><br><span class="line">sudo apt-get install -d gcc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d , --download-only  表示仅下载不安装，会将指定软件的所有依赖的包都下载下来。</span></span><br></pre></td></tr></table></figure>

<p>所有下载的文件都保存在 <code>/var/cache/apt/archives/</code> 目录中。</p>
<p>我们可以将下载的相关的deb包，复制到其他目录，然后转到该目录下，使用 <code>dpkg</code> 命令安装这些包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i *</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意， <code>/var/cache/apt/archives/</code>  目录会缓存本机所有安装或下载的包，如果仅需要指定软件包所需要的依赖包，可以先把该目录下的其他deb删除。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会清除缓存目录下所有的deb软件包</span></span><br><span class="line">sudo apt-get clean</span><br></pre></td></tr></table></figure>





<h1 id="安装指定版本软件"><a href="#安装指定版本软件" class="headerlink" title="安装指定版本软件"></a>安装指定版本软件</h1><p><strong>列出</strong>一个软件的版本的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-cache madison &lt;soft_name&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu-test-update-openssh:~# apt-cache madison openssh-client</span><br><span class="line">openssh-client | 1:7.2p2-4ubuntu2.10 | http://mirrors.ustc.edu.cn/ubuntu xenial-updates/main amd64 Packages</span><br><span class="line">openssh-client | 1:7.2p2-4ubuntu2.8 | http://security.ubuntu.com/ubuntu xenial-security/main amd64 Packages</span><br><span class="line">openssh-client |  1:7.2p2-4 | http://mirrors.ustc.edu.cn/ubuntu xenial/main amd64 Packages</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>安装指定版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  openssh-client=1:6.6p1-2ubuntu1</span><br></pre></td></tr></table></figure>





<h1 id="Ubuntu-查看指定软件是否已安装"><a href="#Ubuntu-查看指定软件是否已安装" class="headerlink" title="Ubuntu 查看指定软件是否已安装"></a>Ubuntu 查看指定软件是否已安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">方法1，</span><br><span class="line">dpkg -l &lt;deb_package&gt;</span><br><span class="line"></span><br><span class="line">方法2，</span><br><span class="line">dpkg -l | grep &lt;deb_package&gt;</span><br></pre></td></tr></table></figure>

<p>如果是通过源码自己安装，只能看可执行文件是否存在了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -L &lt;deb_package&gt;</span><br></pre></td></tr></table></figure>





<p>补充，rpm包查看方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa &lt;rpm_package&gt;</span><br><span class="line">rpm -qa | grep &lt;rpm_package&gt;</span><br><span class="line">yum list installed | grep &lt;rpm_package&gt;</span><br></pre></td></tr></table></figure>





<h1 id="Ubuntu-dpkg-常用方法"><a href="#Ubuntu-dpkg-常用方法" class="headerlink" title="Ubuntu dpkg 常用方法"></a>Ubuntu dpkg 常用方法</h1><ol>
<li>安装指定 deb 软件包，<code>dpkg -i &lt;deb_package&gt;</code></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>apt</tag>
        <tag>dpkg</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu问题处理</title>
    <url>//Ubuntu%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<h2 id="Ubuntu20-04-修改网卡配置"><a href="#Ubuntu20-04-修改网卡配置" class="headerlink" title="Ubuntu20.04 修改网卡配置"></a>Ubuntu20.04 修改网卡配置</h2><p><strong>ubuntu 从 17.10 开始，已放弃在 <code>/etc/network/interfaces</code> 里固定 IP 的配置，即使配置也不会生效，而是改成 netplan 方式 ，配置写在 <code>/etc/netplan/01-netcfg.yaml</code> 或者类似名称的 yaml 文件里”</strong></p>
<ul>
<li>Ubuntu20.04 服务器版的网络服务是 <code>systemd-networkd</code>；</li>
<li>桌面版（图形界面），使用 <code>NetworkManager</code> 服务；</li>
</ul>
<p><code>man netplan</code> 可以查看详细的功能说明。</p>
<p>下面是在树莓派4B 上的 Ubuntu20.04 Server版本上配置无线网卡的过程：</p>
<ol>
<li><p>配置之前通过 <code>ip a</code> 查看 <code>wlan0</code> 网卡信息，没有 ip 地址；</p>
</li>
<li><p>修改 <code>/etc/netplan/50-cloud-init.yaml</code> 文件配置；</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">    <span class="attr">ethernets:</span></span><br><span class="line">        <span class="attr">eth0:</span></span><br><span class="line">            <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">wifis:</span></span><br><span class="line">        <span class="comment"># 网卡名</span></span><br><span class="line">        <span class="attr">wlan0:</span></span><br><span class="line">            <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">access-points:</span></span><br><span class="line">                <span class="comment"># 这里填写需要连接的 wifi 的 sid名称</span></span><br><span class="line">                <span class="attr">&quot;FAST_250E&quot;:</span></span><br><span class="line">                    <span class="comment"># 这里填写 wifi 密码</span></span><br><span class="line">                    <span class="attr">password:</span> <span class="string">&quot;15xxxxx7&quot;</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置好文件后，执行 <code>netplan try --debug</code> 命令没有错误的情况下会提示更新配置，按回车键接受新的配置；</p>
</li>
<li><p>查看当前网卡信息 <code>ip a</code> 确认 ip 信息；</p>
</li>
</ol>
<blockquote>
<p>可以通过查看 netplan 文件认识一下 netplan</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ which netplan</span><br><span class="line">/usr/sbin/netplan</span><br><span class="line">ubuntu@ubuntu:~$ ll /usr/sbin/netplan</span><br><span class="line">lrwxrwxrwx 1 root root 31 Dec  3 10:12 /usr/sbin/netplan -&gt; ../share/netplan/netplan.script*</span><br><span class="line">ubuntu@ubuntu:~$ file /usr/share/netplan/netplan.script</span><br><span class="line">/usr/share/netplan/netplan.script: Python script, ASCII text executable</span><br><span class="line">ubuntu@ubuntu:~$ netplan -h</span><br><span class="line">usage: /usr/sbin/netplan  [-h] [--debug]  ...</span><br><span class="line"></span><br><span class="line">Network configuration in YAML</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message and exit</span><br><span class="line">  --debug     Enable debug messages</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line"></span><br><span class="line">    help      Show this help message</span><br><span class="line">    apply     Apply current netplan config to running system</span><br><span class="line">    generate  Generate backend specific configuration files from /etc/netplan/*.yaml</span><br><span class="line">    get       Get a setting by specifying a nested key like &quot;ethernets.eth0.addresses&quot;, or &quot;all&quot;</span><br><span class="line">    info      Show available features</span><br><span class="line">    ip        Retrieve IP information from the system</span><br><span class="line">    set       Add new setting by specifying a dotted key=value pair like ethernets.eth0.dhcp4=true</span><br><span class="line">    try       Try to apply a new netplan config to running system, with automatic rollback</span><br><span class="line">ubuntu@ubuntu:~$</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面信息可知，netplan 是一个 python 程序，使用 yaml 文件格式配置。</p>
<h2 id="ubuntu-设置-root-用户密码"><a href="#ubuntu-设置-root-用户密码" class="headerlink" title="ubuntu 设置 root 用户密码"></a>ubuntu 设置 root 用户密码</h2><h1 id="ubuntu-查看防火墙"><a href="#ubuntu-查看防火墙" class="headerlink" title="ubuntu 查看防火墙"></a>ubuntu 查看防火墙</h1><p>ufw &#x3D;&gt; uncomplicated firewall 简单防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@www:~# systemctl status ufw</span><br><span class="line">● ufw.service - Uncomplicated firewall</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/ufw.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (exited) since Tue 2022-04-19 18:12:32 CST; 2 weeks 0 days ago</span><br><span class="line">       Docs: man:ufw(8)</span><br><span class="line">   Main PID: 554 (code=exited, status=0/SUCCESS)</span><br><span class="line">        CPU: 6ms</span><br><span class="line"></span><br><span class="line">Apr 19 18:12:31 ubuntu systemd[1]: Starting Uncomplicated firewall...</span><br><span class="line">Apr 19 18:12:32 ubuntu systemd[1]: Finished Uncomplicated firewall.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认是启动的。</p>
<h1 id="解决apt-get-x2F-var-x2F-lib-x2F-dpkg-x2F-lock-frontend-问题"><a href="#解决apt-get-x2F-var-x2F-lib-x2F-dpkg-x2F-lock-frontend-问题" class="headerlink" title="解决apt-get &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend 问题"></a>解决apt-get &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend 问题</h1><p>运行 apt-get 时报如下错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)</span><br><span class="line">E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</span><br></pre></td></tr></table></figure>

<p>解决方案:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /var/lib/dpkg/lock-frontend</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br><span class="line">sudo rm /var/cache/apt/archives/lock</span><br></pre></td></tr></table></figure>

<p>可以依次删除，或者删除一条后，执行apt-get，一般会继续报错并提到上面的其他文件的，然后依据报错提示文件删除即可。</p>
<p>或者使用下面的思路来处理。</p>
<blockquote>
<p>用 lsof 命令看看这几个文件是被哪个进程锁住的啊，然后先杀掉那几个进程。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof /var/lib/dpkg/lock-frontend</span><br></pre></td></tr></table></figure>

<p>因为可能是 apt 其他进程在运行，所以会锁住dpkg file，要么等待完成，要么提前删除文件或者结束该进程。</p>
<p>也可以</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep apt</span><br><span class="line"></span><br><span class="line">kill -9 &lt;进程ID&gt;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>现场遇到的部分问题总结</title>
    <url>//%E7%8E%B0%E5%9C%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<ol>
<li><p>表示selinux开了，关掉</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Tue Feb 02 19:56:28 2021] [notice] SELinux policy enabled; httpd running as context unconfined_u:system_r:httpd_t:s0</span><br><span class="line"></span><br><span class="line">[root@offlinedata02 map_server]# vim /etc/selinux/config</span><br><span class="line">disable</span><br><span class="line">[root@offlinedata02 map_server]# setenforce 0</span><br><span class="line">[root@offlinedata02 map_server]# getenforce</span><br><span class="line">Permissive</span><br></pre></td></tr></table></figure>

</li>
<li><p>时区报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nagios报错如下：</span><br><span class="line">=================================== FAILURES ===================================</span><br><span class="line">__________________________ test_java_timezone[local] ___________________________</span><br><span class="line">host = &lt;testinfra.host.Host object at 0x7ff137b80650&gt;</span><br><span class="line">def test_java_timezone(host):</span><br><span class="line">tz = host.check_output(&quot;&quot;&quot;jrunscript -e &#x27;var TZ = Java.type(&quot;java.util.TimeZone&quot;); print( TZ.getDefault().getID() )&#x27;&quot;&quot;&quot;) # nopep8</span><br><span class="line">&gt; assert tz == &quot;Asia/Shanghai&quot;</span><br><span class="line">E AssertionError: assert &#x27;PRC&#x27; == &#x27;Asia/Shanghai&#x27;</span><br><span class="line">E - PRC</span><br><span class="line">E + Asia/Shanghai</span><br><span class="line">check-env/test_timezone.py:12: AssertionError</span><br><span class="line">1 failed, 15 passed, 1 skipped in 1.59 seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">处理方式：</span><br><span class="line">rm -f /etc/localtime;ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">原因参考：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>nfs挂载遇到问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@web15.simba.bd.com logs]# showmount -e 192.168.10.164</span><br><span class="line">clnt_create: RPC: Port mapper failure - Unable to receive: errno 113 (No route to host)</span><br></pre></td></tr></table></figure>
<p>解决方法：<br> nfs服务端 防火墙开了导致，关闭即可，或者配置端口放行</p>
</li>
</ol>
<h2 id="解决-Linux-下图形界面卡死不能操作的问题"><a href="#解决-Linux-下图形界面卡死不能操作的问题" class="headerlink" title="解决 Linux 下图形界面卡死不能操作的问题"></a>解决 Linux 下图形界面卡死不能操作的问题</h2><ol>
<li><p><code> Ctrl + Alt + F2</code></p>
<p>进入新的 shell 界面</p>
</li>
<li><p>根据提示登录</p>
</li>
<li><p>输入 <code>init 3</code></p>
<blockquote>
<p> 初始化，有当前级别改到第三个级别，没有图形的网络模式</p>
</blockquote>
</li>
<li><p>根据提示，再次登陆 root 用户，然后输入 <code>init 5</code></p>
<blockquote>
<p>即可进入图形界面</p>
</blockquote>
</li>
</ol>
<p>注意：Linux 下共有 6 个虚拟控制台，F2~F6，分别对应这不同的权限。</p>
<p>  PS：图形桌面与命令行模式相关切换快捷键 </p>
<p>  1、图形桌面—&gt;命令行模式：Ctrl+Alt+F1&#x2F;F2&#x2F;F3&#x2F;F4&#x2F;F5&#x2F;F6 </p>
<p>  2、命令行模式—&gt;图形桌面：Ctrl+Alt+F7 </p>
<p>  3、解除命令行模式锁定光标快捷键：Ctrl+Alt </p>
<h1 id="gzip-stdin-not-in-gzip-format"><a href="#gzip-stdin-not-in-gzip-format" class="headerlink" title="gzip: stdin: not in gzip format"></a>gzip: stdin: not in gzip format</h1><p>执行解压命令，在解压.gz或者.bz2格式的文件的文件的时候可能会出现这样的错误提示 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf zabbix.tar.gz</span><br></pre></td></tr></table></figure>

<p>报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip: stdin: not in gzip format </span><br><span class="line">tar: Child returned status 1 </span><br><span class="line">tar: Error is not recoverable: exiting now</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong></p>
<p>文件后缀，与文件压缩格式不匹配。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li><p>首先使用 <code>file</code> 查看该文件的真是属性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@zabbix ansible]# file zabbix.tar.gz</span><br><span class="line">zabbix.tar.gz: POSIX tar archive (GNU)</span><br></pre></td></tr></table></figure>

<p>从结果来看，这是个 <code>tar</code> 文件，并不是 <code>tar.gz</code> 文件</p>
</li>
<li><p>根据真实属性，执行解压命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@zabbix ansible]# tar xvf zabbix.tar.gz</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>错误总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>错误总结</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>//README.html</url>
    <content><![CDATA[<h1 id="Rust-xmind"><a href="#Rust-xmind" class="headerlink" title="Rust-xmind-"></a>Rust-xmind-</h1>]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust-xmind-master</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-xmind-master</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim</title>
    <url>//Vim.html</url>
    <content><![CDATA[<h1 id="什么是Vim"><a href="#什么是Vim" class="headerlink" title="什么是Vim"></a>什么是Vim</h1><p>Vim是从Vi发展而来的一款编辑器，功能较为强大，在程序员中，尤其是底层开发程序员中使用较多。<br>一般来说，Ubuntu等linux操作系统在安装时自带Vi编辑器，但是使用Vim则需要进行安装，安装方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure>

<h1 id="Vim三种模式介绍"><a href="#Vim三种模式介绍" class="headerlink" title="Vim三种模式介绍"></a>Vim三种模式介绍</h1><p>Vim有三种模式，分别是命令模式（Command mode）、插入模式（Insert mode）、底线命令模式（Last line mode）。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>刚打开Vim时，Vim所处的模式就是命令模式，此时敲击键盘的字母会被视为命令而非输入字符。<br>命令模式下常用命令如下：</p>
<ul>
<li>i，切换到插入模式；</li>
<li>:，切换到底线命令模式；</li>
<li>x，删除当前光标所处的字符；</li>
<li>r，替换当前光标所处的字符；</li>
</ul>
<h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><p>在命令模式下，按i就进入到输入模式。在输入模式下，可以就行代码的编辑。<br>在插入模式下，要切换到命令模式，在需要按<br>ESC键。</p>
<h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>在命令模式下，按下:（英文冒号）则切换到底线命令模式。<br>在底线命令模式下，最常用的命令就是保存和退出命令：</p>
<ul>
<li>:q，退出程序；</li>
<li>:w，保存文件。</li>
</ul>
<h1 id="更详细的用法"><a href="#更详细的用法" class="headerlink" title="更详细的用法"></a>更详细的用法</h1><h2 id="命令模式下命令"><a href="#命令模式下命令" class="headerlink" title="命令模式下命令"></a>命令模式下命令</h2><ul>
<li>移动光标的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h 或 向左箭头键(←)	光标向左移动一个字符</span><br><span class="line"></span><br><span class="line">j 或 向下箭头键(↓)	光标向下移动一个字符</span><br><span class="line"></span><br><span class="line">k 或 向上箭头键(↑)	光标向上移动一个字符</span><br><span class="line"></span><br><span class="line">l 或 向右箭头键(→)	光标向右移动一个字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps：如果想要进行多次移动的话，例如向下移动 3 行，可以使用 “3j” 或 “3↓” 的组合按键， 亦即加上想要进行的次数即可。</span><br><span class="line"></span><br><span class="line">[Ctrl] + [f]	屏幕『向下』移动一页，相当于 [Page Down]按键</span><br><span class="line"></span><br><span class="line">[Ctrl] + [b]	屏幕『向上』移动一页，相当于 [Page Up] 按键</span><br><span class="line"></span><br><span class="line">[Ctrl] + [d]	屏幕『向下』移动半页</span><br><span class="line"></span><br><span class="line">[Ctrl] + [u]	屏幕『向上』移动半页</span><br><span class="line"></span><br><span class="line">+	光标移动到非空格符的下一行</span><br><span class="line"></span><br><span class="line">–	光标移动到非空格符的上一行</span><br><span class="line"></span><br><span class="line">n&lt;space&gt;	按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20&lt;space&gt; 则光标会向后面移动 20 个字符距离。</span><br><span class="line"></span><br><span class="line">0 或功能键[Home]	这是数字『 0 』：移动到这一行的最前面字符处</span><br><span class="line"></span><br><span class="line">$ 或功能键[End]	移动到这一行的最后面字符处</span><br><span class="line"></span><br><span class="line">H	光标移动到这个屏幕的最上方那一行的第一个字符</span><br><span class="line"></span><br><span class="line">M	光标移动到这个屏幕的中央那一行的第一个字符</span><br><span class="line"></span><br><span class="line">L	光标移动到这个屏幕的最下方那一行的第一个字符</span><br><span class="line"></span><br><span class="line">G	移动到这个文件的最后一行</span><br><span class="line"></span><br><span class="line">nG	n 为数字。移动到这个文件的第 n 行，可配合set nu</span><br><span class="line"></span><br><span class="line">gg	移动到这个文件的第一行，相当于 1G</span><br><span class="line"></span><br><span class="line">n&lt;Enter&gt;	n 为数字。光标向下移动 n 行</span><br></pre></td></tr></table></figure>

<ul>
<li>搜索替换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/word	向光标之下寻找一个名称为 word 的字符串</span><br><span class="line"></span><br><span class="line">?word	向光标之上寻找一个字符串名称为 word 的字符串</span><br><span class="line"></span><br><span class="line">n	这个 n 是英文按键。代表重复前一个搜寻的动作。</span><br><span class="line"></span><br><span class="line">N	这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 使用 /word 配合 n 及 N 是非常有帮助的,可以让你重复的找到一些你搜寻的关键词。</span><br><span class="line"></span><br><span class="line">:n1,n2s/word1/word2/g	n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2， 举例：</span><br><span class="line">『:100,200s/vbird/VBIRD/g』。</span><br><span class="line"></span><br><span class="line">:1,$s/word1/word2/g	从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 。</span><br><span class="line"></span><br><span class="line">:1,$s/word1/word2/gc	从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2并且在取代前显示提示字符给用户确认 (confirm) 是否需要取代。</span><br></pre></td></tr></table></figure>

<ul>
<li>删除、复制与贴上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x, X	在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) </span><br><span class="line"></span><br><span class="line">nx	n 为数字，连续向后删除 n 个字符。举例来说，要连续删除 10 个字符， 『10x』</span><br><span class="line"></span><br><span class="line">dd	删除游标所在的那一整行</span><br><span class="line"></span><br><span class="line">ndd	n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行</span><br><span class="line"></span><br><span class="line">d1G	删除光标所在到第一行的所有数据</span><br><span class="line"></span><br><span class="line">dG	删除光标所在到最后一行的所有数据</span><br><span class="line"></span><br><span class="line">d$	删除游标所在处，到该行的最后一个字符</span><br><span class="line"></span><br><span class="line">d0	那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</span><br><span class="line"></span><br><span class="line">yy	复制游标所在的那一行</span><br><span class="line"></span><br><span class="line">nyy	n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行</span><br><span class="line"></span><br><span class="line">y1G	复制游标所在行到第一行的所有数据</span><br><span class="line"></span><br><span class="line">yG	复制游标所在行到最后一行的所有数据</span><br><span class="line"></span><br><span class="line">y0	复制光标所在的那个字符到该行行首的所有数据</span><br><span class="line"></span><br><span class="line">y$	复制光标所在的那个字符到该行行尾的所有数据</span><br><span class="line"></span><br><span class="line">p, P	p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行.</span><br><span class="line">例如，目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 </span><br><span class="line"></span><br><span class="line">J	将光标所在行与下一行的数据结合成同一行</span><br><span class="line"></span><br><span class="line">c	重复删除多个数据，例如向下删除 10 行，[ 10cj ]</span><br><span class="line"></span><br><span class="line">u	复原前一个动作</span><br><span class="line"></span><br><span class="line">[Ctrl]+r	重做上一个动作,这个 u 与 [Ctrl]+r 是很常用的指令,一个是复原，另一个则是重做一次</span><br></pre></td></tr></table></figure>

<h2 id="命令模式切换到插入模式常用命令"><a href="#命令模式切换到插入模式常用命令" class="headerlink" title="命令模式切换到插入模式常用命令"></a>命令模式切换到插入模式常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i, I	进入插入模式(Insert mode),i 为『从目前光标所在处插入』， I 为『在目前所在行的第一个非空格符处开始插入』</span><br><span class="line"></span><br><span class="line">a, A	进入插入模式(Insert mode),</span><br><span class="line">a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在行的最后一个字符处开始插入』</span><br><span class="line"></span><br><span class="line">o, O	进入插入模式(Insert mode), o 为『在目前光标所在的下一行处插入新的一行』； O 为在目前光标所在处的上一行插入新的一行</span><br><span class="line"></span><br><span class="line">r, R	进入取代模式(Replace mode),</span><br><span class="line">r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；</span><br><span class="line"></span><br><span class="line">[Esc]	退出编辑模式，回到一般模式中</span><br></pre></td></tr></table></figure>

<h2 id="底线命令模式下常用命令"><a href="#底线命令模式下常用命令" class="headerlink" title="底线命令模式下常用命令"></a>底线命令模式下常用命令</h2><ul>
<li>指令行的保存、离开等指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:w	将编辑的数据写入文件中</span><br><span class="line"></span><br><span class="line">:w!	若文件属性为『只读』时，强制写入该文件。</span><br><span class="line"></span><br><span class="line">:q	离开 vi </span><br><span class="line"></span><br><span class="line">:q!	若曾修改过文件，又不想抱存，使用 ! 为强制离开不保存文件</span><br><span class="line"></span><br><span class="line">:wq	保存后离开，若为 :wq! 则为强制保存后离开 </span><br><span class="line"></span><br><span class="line">ZZ	若文件没有改动，则不保存离开，若文件已经被改动过，则保存后离开</span><br><span class="line"></span><br><span class="line">:w [filename]	将编辑的数据保存成另一个文件</span><br><span class="line"></span><br><span class="line">:r [filename]	在编辑的数据中，读入另一个文件的数据。亦即将 『filename』 这个文件内容加到游标所在行后面</span><br><span class="line"></span><br><span class="line">:n1,n2 w [filename]	将 n1 到 n2 的内容保存成 filename 这个文件</span><br><span class="line"></span><br><span class="line">:! command	暂时离开 vi 到指令行模式下执行 command 的显示结果，例如</span><br><span class="line">『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息</span><br></pre></td></tr></table></figure>

<ul>
<li>vim 环境的变更</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set nu	显示行号，设定之后，会在每一行的前缀显示该行的行号</span><br><span class="line">:set nonu	与 set nu 相反，取消行号</span><br></pre></td></tr></table></figure>

<h1 id="编写程序中常用方式讲解"><a href="#编写程序中常用方式讲解" class="headerlink" title="编写程序中常用方式讲解"></a>编写程序中常用方式讲解</h1><p>写一个简短的程序，说明一下命令用法。</p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ul>
<li>列操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令模式下，ctrl+v 选中要操作的列，然后进行操作即可</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust-xmind-master</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-xmind-master</tag>
      </tags>
  </entry>
  <entry>
    <title>database_interface</title>
    <url>//database_interface.html</url>
    <content><![CDATA[<h1 id="sqlx"><a href="#sqlx" class="headerlink" title="sqlx"></a>sqlx</h1><p>使用前，选择依赖时，<strong>必须</strong>选择一种 runtime 特性，即 <code>runtime + tls</code> 的一种选项；</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Cargo.toml</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment"># tokio + rustls</span></span><br><span class="line"><span class="attr">sqlx</span> = &#123; version = <span class="string">&quot;0.5&quot;</span>, features = [ <span class="string">&quot;runtime-tokio-rustls&quot;</span> ] &#125;</span><br><span class="line"><span class="comment"># async-std + native-tls</span></span><br><span class="line"><span class="attr">sqlx</span> = &#123; version = <span class="string">&quot;0.5&quot;</span>, features = [ <span class="string">&quot;runtime-async-std-native-tls&quot;</span> ] </span><br></pre></td></tr></table></figure>

<blockquote>
<p>runtime + TLS backend 是针对 cargo 问题的一种解决方案。</p>
</blockquote>
<p>问题：</p>
<ol>
<li><p>什么是 runtime？</p>
</li>
<li><p>什么是 tls（transport layer security 传输层安全）？</p>
</li>
<li><p>native-tls 与 rustls 的区别？</p>
</li>
<li><p>actix actor 响应式编程？那么什么是响应式变成？之前scala时有见到过，但是没有认真看，好像越来越多的地方用到了？</p>
</li>
<li><p>通过下面的错误提示，大概理解了 compile-time checked 的含义了</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在编写代码时就会有下面的错误提示</span></span><br><span class="line">error communicating with database: 由于目标计算机积极拒绝，无法连接。 (os error <span class="number">10061</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust常用库</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust常用库</tag>
      </tags>
  </entry>
  <entry>
    <title>第二遍学习记录</title>
    <url>//%E7%AC%AC%E4%BA%8C%E9%81%8D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h1><p>cargo</p>
<ul>
<li><p>如何创建新的项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo new xxx</span><br></pre></td></tr></table></figure>


</li>
<li><p>如何编译？检查？运行测试？打包？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo build</span><br><span class="line"></span><br><span class="line">cargo check</span><br><span class="line"></span><br><span class="line">cargo test [需要测试的方法名或者前后缀]</span><br><span class="line"></span><br><span class="line">cargo install</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>单元测试</strong></p>
<p>功能：测试模块的功能是否正确；</p>
<p>位置：rust中单元测试写在模块文件中，与功能代码一起；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>集成测试</strong></p>
<p>功能：是crate外部的测试，仅测试crate的公共接口，类似其他使用该crate的程序一样。</p>
<ul>
<li>主要功能是，检测你的crate的各部分是否能够正确地协同工作；</li>
</ul>
<p>位置：与 src 同级目录下的 <strong>tests</strong> 目录下。</p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>二遍浏览记录</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>二遍浏览记录</tag>
      </tags>
  </entry>
  <entry>
    <title>手动搭建mall过程记录</title>
    <url>//%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAmall%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="学习mall项目过程记录"><a href="#学习mall项目过程记录" class="headerlink" title="学习mall项目过程记录"></a>学习mall项目过程记录</h1><p>目标：</p>
<ol>
<li>利用mall项目学习过程，熟练 Spring Boot 的操作；</li>
<li>同时过程中解决遇到的一些 Java 基本知识点，例如并发编程上的一些知识点；</li>
<li>学习对其他常用组件的操作。</li>
<li>这个过程中遇到什么不会的就学习什么。</li>
<li>期间遇到的第三方软件就使用docker来处理。<ul>
<li>遇到使用时，可以查看《极客时间中相关使用的地方》</li>
</ul>
</li>
</ol>
<h1 id="20210822"><a href="#20210822" class="headerlink" title="20210822"></a>20210822</h1><ol>
<li><p>先把整理博客过一遍，看看是不是循序渐进的讲解，是否跟着操作就可以？</p>
<ul>
<li>可以先把框架搭起来，然后部署运行，后面再扩充。</li>
<li>通过学习项目，学习技术知识点，同时项目中解决某个问题的思路和使用的技术。</li>
</ul>
</li>
<li><p>tiny01，问题，，MyBatis 使用样例去看一下，可以过一下《极客时间中关于Mybatis的视频和demo》，熟悉一下后再来操作</p>
</li>
<li><p>基本spring boot 后台接口 整合 Swagger-UI</p>
</li>
<li><p>利用 Redis 进行验证码校验</p>
</li>
<li><p>利用 Spring Security + JWT 进行用户登录和认证校验，同时进行权限校验；</p>
</li>
<li><p>将商品信息添加到es中，供分析查询。</p>
</li>
<li><p>将用户浏览商品记录存放在mongodb，但是为什么？</p>
</li>
<li><p>整合 rabbitMQ，实现延迟消息？处理下单没有付款</p>
<ul>
<li>那么，如果下单后付款了呢？从ttl队列在消息超时前，将消息取走？</li>
</ul>
</li>
</ol>
<h1 id="20210823"><a href="#20210823" class="headerlink" title="20210823"></a>20210823</h1><ol>
<li>先搭框架，遇到不会的就先看一下该技术，然后再继续。</li>
<li>mybatis，pagehelper，MyBatis genertator 三个mybatis 相关的工具怎么使用？<ul>
<li>简单了解一下，剩下的边使用边学习。<ul>
<li><del>MyBatis Generator</del>，基本达到可用的目标了</li>
<li>MyBatis 看一下手册</li>
<li>PageHelper 边用边看</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="20210901"><a href="#20210901" class="headerlink" title="20210901"></a>20210901</h1><ol>
<li><del>之前学习了 MyBatis Generator 模块</del></li>
<li>今天开始把基础内容搭建一下</li>
<li>Controller 中的常用注解及他们的搭配</li>
<li>在线 API 文档常用插件<ul>
<li>Swagger-UI –ok</li>
<li>Docsify API</li>
</ul>
</li>
</ol>
<h1 id="20210902"><a href="#20210902" class="headerlink" title="20210902"></a>20210902</h1><ol>
<li><p>安装 elasticsearch ，中文分词，kibana客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个网络，方便后面kibana与 es连接</span><br><span class="line">docker network create mall-network</span><br><span class="line"></span><br><span class="line"># docker 启动单节点集群</span><br><span class="line">docker run --name mall-elasticsearch --net elastic -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -d elasticsearch:7.12.0</span><br><span class="line"></span><br><span class="line">docker run --name mall-kibana --link=mall-elasticsearch:es  -p 5601:5601 -d kibana:7.12.0</span><br><span class="line">docker run --name kib01-test --net elastic -p 5601:5601 -e &quot;ELASTICSEARCH_HOSTS=http://es01-test:9200&quot; docker.elastic.co/kibana/kibana:7.14.1</span><br><span class="line"></span><br><span class="line">docker run --name mall-kibana --net elastic  -p 5601:5601 -e &quot;ELASTICSEARCH_HOSTS=http://mall-elasticsearch:9200&quot; -d kibana:7.12.0</span><br><span class="line"></span><br><span class="line">修改配置，解决跨域访问问题</span><br><span class="line">首先进入到容器中，然后进入到指定目录修改elasticsearch.yml文件。</span><br><span class="line">docker exec -it mall-elasticsearch /bin/bash</span><br><span class="line">cd /usr/share/elasticsearch/config/</span><br><span class="line">vi elasticsearch.yml</span><br><span class="line">在elasticsearch.yml的文件末尾加上:</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line"></span><br><span class="line">修改配置后重启容器即可。</span><br><span class="line">docker restart mall-elasticsearch</span><br><span class="line"></span><br><span class="line">安装ik分词器</span><br><span class="line">注意：elasticsearch的版本和ik分词器的版本需要保持一致，不然在重启的时候会失败。可以在这查看所有版本，选择合适自己版本的右键复制链接地址即可。</span><br><span class="line">docker exec -it mall-elasticsearch /bin/bash</span><br><span class="line">cd /usr/share/elasticsearch/plugins/</span><br><span class="line">elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.0/elasticsearch-analysis-ik-7.12.0.zip</span><br><span class="line">--这个分词器可以离线安装吗？</span><br><span class="line">exit</span><br><span class="line">docker restart mall-elasticsearch</span><br><span class="line"></span><br><span class="line">启动以后可以打开浏览器输入http://localhost:5601就可以打开kibana的界面了。</span><br><span class="line">然后可以在kibana界面的dev tools中验证是否安装成功；</span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;美国留给伊拉克的是一个烂摊子吗？&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="shell">docker run --link的作用

docker run --link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。

--link的格式：

--link &lt;name or id&gt;:alias

其中，name和id是源容器的name和id，alias是源容器在link下的别名。

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. docker 已经创建的 container 如何修改配置？比如添加一个 --net 的网络配置？</span><br><span class="line"></span><br><span class="line">4. 先实现 es 与 spring boot 的集成，然后再把 spring-data 看一下，之后再进行 spring-mongoDB 的集成，可以算作对 spring-data 的熟练度操作</span><br><span class="line"></span><br><span class="line">5. 后续还是需要对 elasticsearch ，redis 这些工具熟悉操作</span><br><span class="line"></span><br><span class="line">6. 当使用的框架需要升级时，需要注意程序中调用的外部系统是否需要跟着升级，例如，将 Spring Boot-2.13 升级到 2.3.0，此时，2.3.0中依赖的 elasticsearch 所需要的包 中有对 elasticsearch 系统版本号的依赖，这时就需要对es进行升级并对升级后新jar的改动做业务程序上的改动。</span><br><span class="line"></span><br><span class="line">7. 查一下 spring data es 如何配置连接 es，尤其是客户端版本jar 比安装的es版本老可以吗？</span><br><span class="line"></span><br><span class="line">8. ```</span><br><span class="line">   X-Compile-Elasticsearch-Version: 6.4.3  这个什么意思？</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>Spring Boot 连接 es集群遇到问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-09-02 17:17:57.272 ERROR 24068 --- [           main] .d.e.r.s.AbstractElasticsearchRepository : failed to load elasticsearch nodes : org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [&#123;#transport#-1&#125;&#123;58oIvCIHQq2lIg6Ut6hJww&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9200&#125;]</span><br><span class="line"></span><br><span class="line">原因，版本不对应，具体是 Elasticsearch 的版本与 spring-data-elasticsearch 的版本不对应，导致客户端不兼容服务，连不上。参考官方提供的兼容版本，要么替换 spring boot 的版本，要么更换 elasticsearch 的版本，或者不使用 spring-data-elasticsearch , 改用 Transport Client</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 MySQL 导入数据到 elasticsearch 报错 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error attempting to get column &#x27;productCategoryName&#x27; from result set.  Cause: java.sql.SQLDataException: Cannot determine value type from string &#x27;T恤&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="20210903"><a href="#20210903" class="headerlink" title="20210903"></a>20210903</h1><ol>
<li>熟悉一下 Spring data</li>
<li>mybatis</li>
<li>redis</li>
<li>es</li>
<li>数据结构</li>
<li>单元测试</li>
</ol>
<p>问题：</p>
<p>Spring Data 的 Repository 中 自定义的 查询接口谁来实现？</p>
<ol>
<li><p>Spring Boot 连接 es集群遇到问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-09-02 17:17:57.272 ERROR 24068 --- [           main] .d.e.r.s.AbstractElasticsearchRepository : failed to load elasticsearch nodes : org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [&#123;#transport#-1&#125;&#123;58oIvCIHQq2lIg6Ut6hJww&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9200&#125;]</span><br><span class="line"></span><br><span class="line">原因，版本不对应，具体是 Elasticsearch 的版本与 spring-data-elasticsearch 的版本不对应，导致客户端不兼容服务，连不上。参考官方提供的兼容版本，要么替换 spring boot 的版本，要么更换 elasticsearch 的版本。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参考官方提供的 spring-data-elasticsearch 样例</span><br><span class="line">https://github.com/spring-projects/spring-data-examples/tree/main/elasticsearch/example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring-data-elasticsearch、Elasticsearch 客户端驱动程序和 Spring Boot 版本之间的兼容性可以在参考官方文档。</span><br><span class="line">https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#preface.versions</span><br><span class="line"></span><br><span class="line">升级之后 spring-data-elasticsearch 配置文件怎么配置？</span><br><span class="line">查看 Spring Boot 参考文档中 Feature 章节</span><br><span class="line">https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.nosql.elasticsearch</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结，依赖外部系统时，多关注版本的兼容性。</p>
</blockquote>
</li>
<li><p>关于ES7.X移除Transport Client 性能疑惑</p>
<p>问：Transport Client是基于Netty实现的tcp客户端.非阻塞IO 多路复用 在高并发下表现很好。但是Rest Client是基于HTTP实现的.HTTP1.1不支持多路复用.在高并发下性能应该会下降的很明显。性能上有下降的情况下，为什么要移除 TC 呢？</p>
<p>答：性能是会有一些影响，不过现实情况，这些差异你根本不用担心的，使用 HTTP 代替 TCP  更多的是避免版本耦合的问题，Transport Client 耦合太高了，以前服务器和客户端版本不一致，会出现两边对象无法反序列化的问题，如果用  TCP，升级服务端，客户端也得都升级，什么滚动升级基本上也别想了。 此为 HTTP  性能已经足够强悍了，并发吞吐同样可以达到很高，更多的时候是其它资源先不够，此外 Rest 协议底层一样也是基于 Netty 的（去看看RestXXXAction里面的prepareRequest()实现方法就明白了）。Rest Client可以多指定几个ES服务器呢，轮巡处理。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>项目练习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>项目练习</tag>
      </tags>
  </entry>
  <entry>
    <title>openEuler使用记录</title>
    <url>//openEuler%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<p>如何更换repo源为其他站点，</p>
<ul>
<li>不报403错误</li>
</ul>
<p><a href="http://repo.openeuler.org/openEuler-20.03-LTS-SP3">http://repo.openeuler.org/openEuler-20.03-LTS-SP3</a></p>
<p>&#x2F;usr&#x2F;src&#x2F;kernels</p>
<p>报错如下：</p>
<p>解决如下：</p>
<p><a href="https://codeantenna.com/a/dGtpC18EL9">https://codeantenna.com/a/dGtpC18EL9</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./stratovirt \</span><br><span class="line">    -machine microvm \</span><br><span class="line">    -kernel /tmp/vmlinux.bin \</span><br><span class="line">    -append &quot;console=ttyS0 reboot=k panic=1 root=/dev/ram rdinit=/bin/sh&quot; \</span><br><span class="line">    -initrd /tmp/StratoVirt-initrd \</span><br><span class="line">    -qmp unix:/proc/19999/socket,server,nowait \</span><br><span class="line">    -serial stdio</span><br></pre></td></tr></table></figure>



<p>为什么目前在虚拟机上安装的openEuler都不支持kvm功能？即没有 &#x2F;dev&#x2F;kvm 文件？</p>
<h1 id="树莓派安装-openEuler-过程记录"><a href="#树莓派安装-openEuler-过程记录" class="headerlink" title="树莓派安装 openEuler 过程记录"></a>树莓派安装 openEuler 过程记录</h1>]]></content>
      <categories>
        <category>容器&amp;虚拟化</category>
        <category>openEuler</category>
      </categories>
      <tags>
        <tag>容器&amp;虚拟化</tag>
        <tag>openEuler</tag>
        <tag>StratoVirt</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用问题汇总</title>
    <url>//hexo%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<h1 id="本地搭建-hexo-框架"><a href="#本地搭建-hexo-框架" class="headerlink" title="本地搭建 hexo 框架"></a>本地搭建 hexo 框架</h1><p>参考链接：</p>
<p><a href="https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%80)%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">从零开始免费搭建自己的博客(一)——本地搭建hexo框架</a></p>
<p>我选择的主题与参考链接中作者使用的主题一样 <code>ayer</code>，以下涉及的部分需求会与主题关联。</p>
<h1 id="使用过程中遇到的问题及解决过程"><a href="#使用过程中遇到的问题及解决过程" class="headerlink" title="使用过程中遇到的问题及解决过程"></a>使用过程中遇到的问题及解决过程</h1><h2 id="1-执行-hexo-deploy-后报错Error-Deployer-not-found-git"><a href="#1-执行-hexo-deploy-后报错Error-Deployer-not-found-git" class="headerlink" title="1. 执行 hexo deploy 后报错Error Deployer not found: git"></a>1. 执行 hexo deploy 后报错<code>Error Deployer not found: git</code></h2><p>配置<code>_config.yml</code> 文件中的<code>deploy</code>字段后报错<code>Error Deployer not found: git</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:ligongzhao/ligongzhao.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决方法，安装 <code>hexo-deployer-git</code> 插件，在站点目录下安装插件即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-分类、标签和关于我菜单点击报错"><a href="#2-分类、标签和关于我菜单点击报错" class="headerlink" title="2. 分类、标签和关于我菜单点击报错"></a>2. 分类、标签和关于我菜单点击报错</h2><p>本地启动 hexo 后，发现侧边菜单栏中的 <code>分类</code> ， <code>标签</code> 和<code>关于我</code>，点击报错。</p>
<p><strong>解决方法：</strong></p>
<p>参考主题作者博文：</p>
<p><a href="https://shen-yu.gitee.io/2019/ayer/#%E5%88%86%E7%B1%BB">主题配置分类</a></p>
<p>具体操作如下：</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 <code>source/categories/index.md</code> 文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>配置参考分类，把值改为 <code>tags</code> 即可。</p>
<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><p>关于我的配置为 <code>about</code>，即一个post文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new about</span><br></pre></td></tr></table></figure>

<p>会在 <code>_post</code> 目录下创建一个 <code>about.md</code> 文件，然后把需要的内容写在里面即可。</p>
<blockquote>
<p>如果需要贴图片，想放在本地，可以参考官方资源目录的操作方式，即在项目的 <code>_config.yml</code> 配置文件中修改 <code>post_asset_folder</code> 值为 true，</p>
<p>即， <code>post_asset_folder: true</code>，这样再执行上面新建 post 文件时，会创建一个与文件同名的目录，将图片放入目录，文件中使用相对路径引用即可。</p>
</blockquote>
<p>官方资源目录相关内容，<a href="https://hexo.io/zh-cn/docs/asset-folders">资源目录</a></p>
<h2 id="3-文章如何分目录存放"><a href="#3-文章如何分目录存放" class="headerlink" title="3. 文章如何分目录存放"></a>3. 文章如何分目录存放</h2><p>使用 <code>hexo new</code> 命令创建的 post 文件时，默认是直接生产在 <code>_post</code> 目录下。如果文件过多时所有文件放在一个目录下容易显得凌乱。如何对文件进行分类且 <code>hexo</code> 能识别呢？</p>
<p><strong>解决方法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &lt;文章标题&gt; -p &lt;文章相对路径&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;认识虚拟化&quot; -p &quot;学习笔记\容器&amp;虚拟化\认识虚拟化.md&quot;</span><br></pre></td></tr></table></figure>



<h3 id="如何批量导入？"><a href="#如何批量导入？" class="headerlink" title="如何批量导入？"></a>如何批量导入？</h3><p>将文件按照指定目录复制到 <code>_post</code> 目录下，文件中添加文件前缀 <code>Yaml Front Matter</code> ，可以参考 <code>scaffolds\post.md</code>  文件中的内容。</p>
<p>例如：</p>
<p>先创建目录 <code>学习笔记\容器&amp;虚拟化\</code>，然后在 <code>认识虚拟化.md</code> 文件头中添加下面内容。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">认识虚拟化</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">认识虚拟化.html</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-04-03 12:21:28</span></span><br><span class="line"><span class="attr">updated:</span> <span class="number">2022-10-04 23:16:19</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">容器&amp;虚拟化</span></span><br><span class="line"></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> [<span class="string">容器&amp;虚拟化</span>]</span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>可以通过写脚本批量处理。</p>
<h2 id="4-如何在主页上仅展示标题，不展示摘要"><a href="#4-如何在主页上仅展示标题，不展示摘要" class="headerlink" title="4. 如何在主页上仅展示标题，不展示摘要"></a>4. 如何在主页上仅展示标题，不展示摘要</h2><p>默认主页中的文章是展示标题和正文的。</p>
<p>如果需要展示正文摘要，然后添加 <code>更多</code> 按钮，可以通过在文章中添加 <code>&lt;!-- more --&gt;</code> 来截取并生成更多的按钮；</p>
<p>如果要满足仅展示标题，不展示摘要需求，则需要修改 <code>ayer</code> 主题配置文件 <code>_config.yml</code> 的参数。将 <code>excerpt_all</code> 的参数修改为 <code>false</code>，即 <code>excerpt_all: false</code>  。</p>
<h1 id="hexo-分支问题"><a href="#hexo-分支问题" class="headerlink" title="hexo 分支问题"></a>hexo 分支问题</h1><p>hexo双分支管理有时会出现一些问题，诸如本地与远端分支不同，pull失败，分支文件混淆等问题，按照以下方式操作避免并解决已存在的问题</p>
<ul>
<li><p>查看本地分支，输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></li>
</ul>
<p>　　 绿色的为当前选中分支</p>
<ul>
<li><p>查看远端分支，输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当本地分支与远端分支不同时，采取下列对应情况处理</p>
<ol>
<li><p>远端已有main和hexo分支，本地只有main分支，则执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout --track origin/hexo</span><br></pre></td></tr></table></figure></li>
</ol>
<p>本地会新建一个分支<code>hexo</code>并自动跟踪远端</p>
<p>本地已有main和hexo分支，远端只有main分支，则执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>

<ol>
<li>将本地分支推送到远端，并在远端建立hexo分支</li>
</ol>
<p>若无法关联，需要先输入命令关联</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin &#x27;远端仓库地址&#x27; </span><br></pre></td></tr></table></figure>

<p>远端仓库地址若设置SSH后，使用<a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;</a>:’用户名‘&#x2F;’仓库名‘.git</p>
<p>参考链接：</p>
<p><a href="https://qhp.us/index.php/archives/16/">hexo配置和常见问题解决</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装MySQL</title>
    <url>//CentOS7%E5%AE%89%E8%A3%85MySQL.html</url>
    <content><![CDATA[<h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><p>1 安装套件库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -Uvh</span><br></pre></td></tr></table></figure>

<p>2 安装MySQL</p>
<p>3 启动MySQL，并设置开机自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">systemctl enable mysqld</span><br></pre></td></tr></table></figure>

<p>4 查看root密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/log/mysqld.log | grep &quot;temporary password&quot;</span><br></pre></td></tr></table></figure>

<p>5 使用 root 登录MySQL，并修改root密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new-password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>6 更新权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装卸载MariaDB</title>
    <url>//CentOS7%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BDMariaDB.html</url>
    <content><![CDATA[<h1 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install mariadb mariadb-server</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动mariadb</span></span><br><span class="line">systemctl start mariadb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置开机自启动</span></span><br><span class="line">systemctl enable mariadb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置root密码等相关</span></span><br><span class="line">mysql_secure_installation</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试登录</span></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>



<h1 id="卸载-MariaDB"><a href="#卸载-MariaDB" class="headerlink" title="卸载 MariaDB"></a>卸载 MariaDB</h1><p>1 查看已安装的 MariaDB</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mariadb*</span><br></pre></td></tr></table></figure>

<p>2 停止数据库服务，并删除服务开机自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop mariadb.service</span><br><span class="line">systemctl disable mariadb.service</span><br></pre></td></tr></table></figure>

<p>3 移除 MariaDB</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum erase mariadb*</span><br></pre></td></tr></table></figure>

<p>4 删除遗留的相关文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -f /etc/my.cnf</span><br><span class="line">rm -rf /var/lib/mysql</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MariaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL使用记录</title>
    <url>//MySQL%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="1-连接远程数据库"><a href="#1-连接远程数据库" class="headerlink" title="1. 连接远程数据库"></a>1. 连接远程数据库</h1><p>方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h &lt;主机IP&gt; -P &lt;mysql端口&gt; -u &lt;mysql登录账号&gt; -p[密码]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&lt;&gt; 表示必填，</p>
<p>[] 表示选填，</p>
</blockquote>
<p>样例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MySQL 连接远程数据库（192.168.5.116），端口“3306”，用户名为“root”，密码“123456” </span><br><span class="line"></span><br><span class="line">方法一，显示密码</span><br><span class="line">mysql -h 192.168.5.116 -P 3306 -u root -p123456 </span><br><span class="line"></span><br><span class="line">方法二，不显示密码</span><br><span class="line">mysql -h 192.168.5.116 -P 3306 -u root -p</span><br><span class="line">会在登录时提示输入密码</span><br></pre></td></tr></table></figure>

<h1 id="2-创建用户并授权"><a href="#2-创建用户并授权" class="headerlink" title="2. 创建用户并授权"></a>2. 创建用户并授权</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户 tt，设置密码为 xxx</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;tt&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将本地所有库表的所有权限授予 tt 用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> tt@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新权限</span></span><br><span class="line">FLUSH privileges;</span><br></pre></td></tr></table></figure>

<p>授权部分操作权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予远程登录 tt 用户时对所有库表执行部分权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">create</span>,<span class="keyword">insert</span>,<span class="keyword">select</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> tt@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">FLUSH privileges;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>tt@&#39;localhost&#39;</code> , 表示本地登录的权限设置；</p>
<p><code>tt@&#39;%&#39;</code> , 表示远程登录时的权限设置；</p>
<p><code>ON *.*</code> ,表示所有库表，当需要指定库表是，<code>ON &lt;库&gt;.&lt;表&gt;</code>, 进行对应替换即可。</p>
</blockquote>
<h1 id="3-时间转换"><a href="#3-时间转换" class="headerlink" title="3. 时间转换"></a>3. 时间转换</h1><h2 id="timestamp-转为指定时间格式"><a href="#timestamp-转为指定时间格式" class="headerlink" title="timestamp 转为指定时间格式"></a>timestamp 转为指定时间格式</h2><p>将 timestamp 格式转换为指定 date 格式</p>
<ul>
<li><code>FROM_UNIXTIME(unix_timestamp,format)</code><ul>
<li>unix_timestamp 是 10 位时间戳，如果是 13 位的时间戳，则需要<code>/1000</code>；</li>
</ul>
</li>
</ul>
<p>将 date 格式转换为指定 date 格式</p>
<ul>
<li><code>DATE_FORMAT(date,format)</code></li>
</ul>
<p>常用格式占位符</p>
<ul>
<li>%Y年、%m月、%d日、%H时、%i分、%s秒</li>
</ul>
<p>样例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> DATE_FORMAT(UPDATE_TIME,<span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="keyword">as</span> <span class="type">date</span> <span class="keyword">from</span> info_apply;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- update_time 2022-10-10 12:45:43</span></span><br><span class="line"><span class="comment">-- 结果为 2022-10-10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> FROM_UNIXTIME(UPDATE_TS,<span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="keyword">as</span> <span class="type">date</span> <span class="keyword">from</span> info_apply;</span><br><span class="line"><span class="comment">-- UPDATE_TS  1665832560</span></span><br><span class="line"><span class="comment">-- 结果为 2022-10-15</span></span><br></pre></td></tr></table></figure>



<h1 id="MySQL查看数据表最后更新时间"><a href="#MySQL查看数据表最后更新时间" class="headerlink" title="MySQL查看数据表最后更新时间"></a>MySQL查看数据表最后更新时间</h1><p><strong>需求场景：</strong>查看数据库中的某一个数据表是否有更新, 以判断数据更新的最后时间, 以判断出有价值的信息。</p>
<p>查看指定数据库的指定表的更新时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> `TABLE_NAME`, `UPDATE_TIME` <span class="keyword">FROM</span> `information_schema`.`TABLES` <span class="keyword">where</span> `TABLE_SCHEMA` <span class="operator">=</span> <span class="string">&#x27;DB_NAME&#x27;</span> <span class="keyword">and</span> `TABLE_NAME` <span class="operator">=</span> <span class="string">&#x27;TABLE_NAME&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>需要查看数据库的更新时间则去掉 <code> and TABLE_NAME = &#39;TABLE_NAME&#39;</code> 部分；</p>
<p>样例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name,update_time <span class="keyword">from</span> information_schema.`TABLES` it <span class="keyword">where</span> it.TABLE_SCHEMA<span class="operator">=</span><span class="string">&#x27;qa_test&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 qa_test 库中更新时间并根据 update_time 字段倒序排序；</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker中修改MySQL密码</title>
    <url>//Docker%E4%B8%AD%E4%BF%AE%E6%94%B9MySQL%E5%AF%86%E7%A0%81.html</url>
    <content><![CDATA[<p><strong>问题背景</strong></p>
<p>zabbix 使用的 MySQL 是在 Docker 中启动的，发现存在 root 弱密码问题，需要进行修改。</p>
<p><strong>处理过程</strong></p>
<h4 id="1-通过-docker-exec-命令进入容器"><a href="#1-通过-docker-exec-命令进入容器" class="headerlink" title="1. 通过 docker exec 命令进入容器"></a>1. 通过 docker exec 命令进入容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-server /bin/bash</span><br></pre></td></tr></table></figure>



<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h4><p>因为机器为离线状态无法安装新软件，采用以下方法向文件中<strong>追加多行</strong>内容</p>
<ul>
<li>如果仅追加一行，直接使用 <code>&gt;&gt;</code> 追加符号即可；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; /etc/mysql/conf.d/docker.cnf &lt;&lt;EOF</span><br><span class="line">skip-grant-tables</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<ul>
<li>需要添加的文件在两个 EOF 中间；</li>
<li>也可以修改 <code>/etc/mysql/my.cnf</code> 文件，这个文件所有MySQL 通用， <code>docker.cnf</code>  只有 docker 中存在；</li>
</ul>
<p>如果添加内容错了，可以使用下面的命令来删除多余内容；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从第2行（包括第2行）到文件末尾的所有行，会直接修改原文件</span></span><br><span class="line">sed -i &#x27;2,$d&#x27; /etc/mysql/conf.d/docker.cnf</span><br></pre></td></tr></table></figure>



<h4 id="3-退出-docker-重启-MySQL-容器"><a href="#3-退出-docker-重启-MySQL-容器" class="headerlink" title="3. 退出 docker 重启 MySQL 容器"></a>3. 退出 docker 重启 MySQL 容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart mysql-server</span><br></pre></td></tr></table></figure>



<h4 id="4-再次进入容器，直接登录-MySQL"><a href="#4-再次进入容器，直接登录-MySQL" class="headerlink" title="4. 再次进入容器，直接登录 MySQL"></a>4. 再次进入容器，直接登录 MySQL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-server /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在容器中使用 mysql 可以直接登录了</span></span><br><span class="line">mysql</span><br></pre></td></tr></table></figure>



<h4 id="5-修改-root-账号密码"><a href="#5-修改-root-账号密码" class="headerlink" title="5. 修改 root 账号密码"></a>5. 修改 root 账号密码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># MySQL <span class="number">5.7</span><span class="number">.6</span><span class="operator">+</span>版本以上</span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> authentication_string <span class="operator">=</span> PASSWORD(<span class="string">&#x27;g123455.&#x27;</span>) <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># MySQL <span class="number">5.7</span><span class="number">.6</span>版本以下</span><br><span class="line">use mysql;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> password<span class="operator">=</span> PASSWORD(<span class="string">&#x27;g123455.&#x27;</span>) <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="6-还原配置"><a href="#6-还原配置" class="headerlink" title="6. 还原配置"></a>6. 还原配置</h4><p>按照第2步，删除添加的 <code>skip-grant-tables</code> 配置，还原配置，退出容器，重启 MySQL 就可以了。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql遇到的问题</title>
    <url>//mysql%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>20210829</p>
<ol>
<li>在 IDEA 中 Spring Boot 配置 MySQL 信息链接docker中的 MySQL，报错如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.8.0_291]</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:1.8.0_291]</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.8.0_291]</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[na:1.8.0_291]</span><br><span class="line">	at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:105) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:151) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.exceptions.ExceptionFactory.createCommunicationsException(ExceptionFactory.java:167) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeProtocol.negotiateSSLConnection(NativeProtocol.java:361) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeAuthenticationProvider.negotiateSSLConnection(NativeAuthenticationProvider.java:777) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeAuthenticationProvider.proceedHandshakeWithPluggableAuthentication(NativeAuthenticationProvider.java:486) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeAuthenticationProvider.connect(NativeAuthenticationProvider.java:202) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeProtocol.connect(NativeProtocol.java:1449) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.NativeSession.connect(NativeSession.java:165) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:955) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:825) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	... 38 common frames omitted</span><br><span class="line">Caused by: javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher suites are inappropriate)</span><br><span class="line">	at sun.security.ssl.HandshakeContext.&lt;init&gt;(HandshakeContext.java:171) ~[na:1.8.0_291]</span><br><span class="line">	at sun.security.ssl.ClientHandshakeContext.&lt;init&gt;(ClientHandshakeContext.java:101) ~[na:1.8.0_291]</span><br><span class="line">	at sun.security.ssl.TransportContext.kickstart(TransportContext.java:238) ~[na:1.8.0_291]</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:394) ~[na:1.8.0_291]</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:373) ~[na:1.8.0_291]</span><br><span class="line">	at com.mysql.cj.protocol.ExportControlled.performTlsHandshake(ExportControlled.java:315) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.protocol.StandardSocketFactory.performTlsHandshake(StandardSocketFactory.java:188) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeSocketConnection.performTlsHandshake(NativeSocketConnection.java:99) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeProtocol.negotiateSSLConnection(NativeProtocol.java:352) ~[mysql-connector-java-8.0.15.jar:8.0.15]</span><br><span class="line">	... 45 common frames omitted</span><br></pre></td></tr></table></figure>
解决：</li>
</ol>
<p>在 url 中添加 <code>&amp;useSSL=false</code> 解决。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:33060/mall?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false</span><br><span class="line">--这里 33060 是本机映射 docker 中的 3306 端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Java-中使用MySql-8-0-注意事项"><a href="#Java-中使用MySql-8-0-注意事项" class="headerlink" title="Java 中使用MySql 8.0 注意事项"></a>Java 中使用MySql 8.0 注意事项</h1><ol>
<li>maven 依赖中，com.mysql.jdbc.Driver 更换为 <code>com.mysql.cj.jdbc.Driver</code>;</li>
<li>MySQL 8.0 以上版本不需要建立 SSL 连接的，需要显示关闭；<ul>
<li>使用参数 <code>useSSL=false</code>;</li>
</ul>
</li>
<li><code>allowPublicKeyRetrieval=true</code> 允许客户端从服务器获取公钥；</li>
<li>需要设置 CST，即时区</li>
</ol>
<p>样例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test_demo?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="关于-left-join-后结果集顺序问题"><a href="#关于-left-join-后结果集顺序问题" class="headerlink" title="关于 left join 后结果集顺序问题"></a>关于 left join 后结果集顺序问题</h1><p>左连接后，mysql 对结果集重新进行了排序，并不是按照左表的顺序展示，与预想的不一样，如何 left join 后，使结果集的顺序按照左表的顺序展示？</p>
<p><strong>解决方法：</strong></p>
<p>给左表添加自增 ID，然后 left join 后排序。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Orace导入导出</title>
    <url>//Orace%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html</url>
    <content><![CDATA[<h2 id="windows本地使用exp导出远程库"><a href="#windows本地使用exp导出远程库" class="headerlink" title="windows本地使用exp导出远程库"></a>windows本地使用exp导出远程库</h2><p>打开cmd命令行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp username/passwd@ip:port/服务名 file=xxx.dmp full=y log=xxx.log</span><br></pre></td></tr></table></figure>

<h3 id="如果windows本地没有安装oracle客户端，怎么下载？"><a href="#如果windows本地没有安装oracle客户端，怎么下载？" class="headerlink" title="如果windows本地没有安装oracle客户端，怎么下载？"></a>如果windows本地没有安装oracle客户端，怎么下载？</h3><ol>
<li>可以到<a href="https://www.oracle.com/cn/database/technologies/instant-client/winx64-64-downloads.html">oracle官网</a>下载<code>Basic Package</code>和<code>Tools Package</code>两个包，这里建议下载<code>Version&gt; Version 12.2.0.1.0</code>的，因为之前里面不带exp.exe客户端。</li>
<li>然后将两个包里的内容解压到同一个目录下（可以先解压<a href="https://www.oracle.com/cn/database/technologies/instant-client/winx64-64-downloads.html#license-lightbox">instantclient-basic-windows.x64-12.2.0.1.0.zip</a>到当前文件夹，然后解压<a href="https://www.oracle.com/cn/database/technologies/instant-client/winx64-64-downloads.html#license-lightbox">instantclient-tools-windows.x64-12.2.0.1.0.zip</a>到当前文件夹，文件夹内容文件会自动合并到一起）。</li>
<li>打开cmd，执行上面exp语句，可以实现将远程oracle库备份下来的目的。</li>
</ol>
<h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><h4 id="1-EXP-00091"><a href="#1-EXP-00091" class="headerlink" title="1. EXP-00091"></a>1. EXP-00091</h4><p>问题现象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">EXP-00091: Exporting questionable statistics.</span><br><span class="line">. . exporting table                        SNP_TXT       6345 rows exported</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>产生原因：</p>
<blockquote>
<p>数据库的服务器端和客户端字符集不同导致。</p>
</blockquote>
<p>解决方法：</p>
<ol>
<li><p>用 sys 用户登录oracle客户端。</p>
</li>
<li><p>执行</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$NLS_PARAMETERS <span class="keyword">WHERE</span> <span class="keyword">PARAMETER</span><span class="operator">=</span><span class="string">&#x27;NLS_CHARACTERSET&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>NLS_CHARACTERSET</code> 必须为大写。</p>
</blockquote>
</li>
<li><p>根据查询出来的服务端字符集，设置客户端的字符集。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">NLS_CHARACTERSET查询结果为：</span><br><span class="line">ZHS16GBK</span><br><span class="line"></span><br><span class="line">那么Linux下可以修改为：</span><br><span class="line">export NLS_LANG=AMERICAN_AMERICA.ZHS16GBK</span><br><span class="line"></span><br><span class="line">Windows下可以修改为：</span><br><span class="line">set NLS_LANG=AMERICAN_AMERICA.ZHS16GBK</span><br><span class="line"></span><br><span class="line">（Windows也可以修改注册表，依次进入 HKEY\_LOCAL\_MACHINE→SOFTWARE→ORACLE→HOME0 目录，修改NLS_LANG 的值）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考链接：</p>
<ol>
<li><a href="https://blog.csdn.net/wangjialiang/article/details/6051817">解決EXP-00091</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle使用过程遇到问题记录</title>
    <url>//Oracle%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="Oracle-使用过程遇到问题"><a href="#Oracle-使用过程遇到问题" class="headerlink" title="Oracle 使用过程遇到问题"></a>Oracle 使用过程遇到问题</h1><ol>
<li>ORA-01031: insufficient privileges</li>
</ol>
<p><em>Question</em>:  I just created a new database and when I try to create a directoty I get the error: “ORA-01031: insufficient privileges”.  How do I stop the ORA-01031 error?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL&gt; create directory EXT_DIR as &#x27;c:\TEMP&#x27;;</span><br><span class="line">create directory EXT_DIR as &#x27;c:\TEMP&#x27;</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01031: insufficient privileges</span><br></pre></td></tr></table></figure>

<p><em>Answer</em>:  The ORA-01031: “insufficient privileges” error occurs when you attempt to execute a program or function for which you have not been granted the appropriate privileges.<br>You must have the “CREATE ANY DIRECTORY” system privilege to create directories with Oracle.  Or, log into Oracle with a user who possess the SYSDBA role.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">connect</span> <span class="keyword">system</span><span class="operator">/</span>manager <span class="keyword">as</span> SYSDBA;</span><br><span class="line"></span><br><span class="line">Connected.</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">any</span> directory <span class="keyword">to</span> fred;</span><br><span class="line"></span><br><span class="line">Granted.</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">connect</span> fred<span class="operator">/</span>flintstone;</span><br><span class="line"></span><br><span class="line">Connected.</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">create</span> directory EXT_DIR <span class="keyword">as</span> <span class="string">&#x27;c:\TEMP&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Directory created.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>oracle创建directory目录<ul>
<li>新建directory<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] DIRECTORY <span class="operator">&lt;</span>目录变量名<span class="operator">&gt;</span> <span class="keyword">AS</span> <span class="string">&#x27;&lt;目录路径&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace directory dump_dir <span class="keyword">as</span> <span class="string">&#x27;D:\dump\dir&#x27;</span></span><br><span class="line">这样把目录d:\dump\dir设置成dump_dir代表的directory</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>赋权，将目录权限赋给指定用户<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant &lt;权限，多个用逗号分隔&gt; on directory &lt;目录变量&gt; to &lt;用户&gt;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">grant read,write on directory dump_dir to user01</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>directory相关其他操作<ul>
<li>查询有哪些directory<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_directories</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>删除指定directory<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> directory <span class="operator">&lt;</span>目录<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">drop</span> directory dump_dir</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="加载外表操作"><a href="#加载外表操作" class="headerlink" title="加载外表操作"></a>加载外表操作</h2><p>1. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Table created.</span><br><span class="line"></span><br><span class="line">INSERT INTO DW_CDR SELECT BEGINTIME,USERNUM,HOMEAREA,RELATENUM,RELATEHOMEAC,IMSI,IMEI,CURAREA,NEID,LAI,CI,LONGITUDE,LATITUDE,BILLTYPE,CALLTYPE,DTMF,CALLDURATION,CAUSE,RLGTIME,ALERTTIME,CONNECTTIME,DISCONNECTTIME,SID,IDFLAG,RAWRELATENUM,REDIRFLAG,ORIGCALLEDNO,DISCONNECTTYPE,NEWLAI,NEWCI,NEWLONGITUDE,NEWLATITUDE,TMSI,SPCODE FROM TB_CDR</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-29913: error in executing ODCIEXTTABLEOPEN callout</span><br><span class="line">ORA-31619: invalid dump file</span><br><span class="line">&quot;/opt/dw_data_temp/20200101/172/CDR/TB_CDR_10424.log&quot;      --为什么会有这个文件？是dmp包里的？还是我的脚本生成的？d</span><br><span class="line">                                                            -- 导入外表时，默认会在dmp文件同级目录下生成log日志文件，需要使用参数控制</span><br><span class="line">ORA-27072: File I/O error</span><br><span class="line">Linux-x86_64 Error: 25: Inappropriate ioctl for device</span><br><span class="line">Additional information: 4</span><br><span class="line">Additional information: 1</span><br><span class="line">Additional information: 41</span><br></pre></td></tr></table></figure>

<p>2. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">报错如下：</span><br><span class="line">select count(1) from tb_cdr</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-29913: error in executing ODCIEXTTABLEFETCH callout</span><br><span class="line">ORA-30653: reject limit reached</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line">在最后添加下面语句</span><br><span class="line">reject limit unlimited;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">create table &lt;table_name&gt;</span><br><span class="line">(...) organization external(...) reject limit unlimited;</span><br></pre></td></tr></table></figure>

<p>3. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO DW_CDR SELECT BEGINTIM,USERNUM,HOMEAREA,RELATENUM,RELATEHOMEAC,IMSI,IMEI,CURAREA,NEID,LAI,CI,LONGITUDE,LATITUDE,BILLTYPE,CALLTYPE,DTMF,CALLDURATION,CAUSE,RLGTIME,ALERTTIME,CONNECTTIME,DISCONNECTTIME,SID,IDFLAG,RAWRELATENUM,REDIRFLAG,ORIGCALLEDNO,DISCONNECTTYPE,NEWLAI,NEWCI,NEWLONGITUDE,NEWLATITUDE,TMSI,SPCODE FROM TB_CDR</span><br><span class="line">*</span><br><span class="line">ERROR at line 1:</span><br><span class="line">ORA-01950: no privileges on tablespace &#x27;DW_DATA&#x27;</span><br><span class="line">表空间权限有限：</span><br><span class="line"></span><br><span class="line">下面语句解决：</span><br><span class="line">alter user c##dw_data quota unlimited on DW_DATA;</span><br><span class="line"></span><br><span class="line">grant unlimited tablespace to c##dw_data;</span><br></pre></td></tr></table></figure>

<h1 id="oracle导入导出"><a href="#oracle导入导出" class="headerlink" title="oracle导入导出"></a>oracle导入导出</h1><ol>
<li>使用sqluldr2工具高效导出oracle数据<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sqludlr2的帮助参数</span><br><span class="line"></span><br><span class="line">sqluldr2_linux64_10204.bin help=yes</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：如果需要导出的数据不带表头，需要设置参数head&#x3D;no，同时text使用默认设置。<br>如果使用text&#x3D;CSV,则head参数无效，生成的数据中默认带表头</p>
<h1 id="oracle修改表名"><a href="#oracle修改表名" class="headerlink" title="oracle修改表名"></a>oracle修改表名</h1><p>ALTER TABLE old_table_name RENAME TO new_table_name;</p>
<h1 id="oracle-删除数据"><a href="#oracle-删除数据" class="headerlink" title="oracle 删除数据"></a>oracle 删除数据</h1><p> 用于删除表中的某行或整个数据表中的数据</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span><span class="keyword">table</span><span class="operator">/</span><span class="keyword">view</span><span class="operator">&gt;</span> [<span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>

<p>注意事项：<br>如果有外键关联，则删除数据之前,需先删除外键关联数据</p>
<h1 id="oracle的日期格式"><a href="#oracle的日期格式" class="headerlink" title="oracle的日期格式"></a>oracle的日期格式</h1><ol>
<li>oracle在进行日期格式转换时，指定的日期格式与Java中的不一致，需要注意，否则匹配的出时间不正确<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> keywords <span class="keyword">where</span> to_char(create_time,<span class="string">&#x27;yyyy-mm-dd HH24:MI:SS&#x27;</span>) <span class="operator">&gt;</span><span class="string">&#x27;2019-02-02 00:00:00&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time; </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Oracle导数时报错：ORA-12899-value-too-large-for-column"><a href="#Oracle导数时报错：ORA-12899-value-too-large-for-column" class="headerlink" title="Oracle导数时报错：ORA-12899: value too large for column"></a>Oracle导数时报错：ORA-12899: value too large for column</h1><p>参考下面链接</p>
<p><a href="https://www.linkedin.com/pulse/why-do-i-get-ora-12899-value-too-large-column-when-sinan-petrus-toma?trk=read_related_article-card_title">https://www.linkedin.com/pulse/why-do-i-get-ora-12899-value-too-large-column-when-sinan-petrus-toma?trk=read_related_article-card_title</a></p>
<p>我现场操作是，选择修改有问题的表的字段，将字段的长度，由byte该为char。</p>
<p>最开始我打算使用省事的方式，就是直接修改数据库的<code>nls_length_semantics</code>参数，将默认的<code>BYTE</code>改为<code>CHAR</code>，但是发现好像不起作用，重新导入的表，字段的data_type还是<code>BYTE</code>。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL的问题</title>
    <url>//SQL%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="撤销-UNIQUE-约束"><a href="#撤销-UNIQUE-约束" class="headerlink" title="撤销 UNIQUE 约束"></a>撤销 UNIQUE 约束</h2><p>Oracle：</p>
<pre><code>ALTER TABLE Persons
DROP CONSTRAINT uc_PersonID
</code></pre>
<p>1、撤销掉一列(没有命名)的unique怎么操作？</p>
<p>2、为unique命名的好处？为什么为unique命名？</p>
<pre><code>CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)
)
</code></pre>
<p>不是说，一张表中只能有一个主键吗？，为什么可以对多列创建主键约束？</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL笔记</title>
    <url>//SQL%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="SQL（结构化查询语言）"><a href="#SQL（结构化查询语言）" class="headerlink" title="SQL（结构化查询语言）"></a>SQL（结构化查询语言）</h1><hr>
<p>SQL(结构化查询语言) 是用于访问和处理数据库的计算机语言</p>
<blockquote>
<p>结构化的查询语句<br>方便我们访问数据库</p>
</blockquote>
<p>SQL</p>
<ul>
<li>面向数据库执行查询</li>
<li>从数据库中取回数据</li>
<li>在数据库中插入记录</li>
<li>更新数据库中数据</li>
<li>从数据库中删除记录</li>
<li>创建新数据库</li>
<li>在数据库中创建新表</li>
<li>在数据库中创建存储过程</li>
<li>在数据库中创建视图</li>
<li>设置表、存储过程和视图的权限</li>
</ul>
<p>SQL是一种ANSI定制的标准<br>大部分SQL数据库程序会以相似的支持关键字，同时也有自己的扩展</p>
<blockquote>
<p>SQL对大小写不敏感</p>
</blockquote>
<h2 id="SQL语句后的分号"><a href="#SQL语句后的分号" class="headerlink" title="SQL语句后的分号"></a>SQL语句后的分号</h2><p>分号的作用是在数据库系统中分隔每条SQL语句的标准方法，</p>
<h2 id="SQL-DML-和-DDL"><a href="#SQL-DML-和-DDL" class="headerlink" title="SQL DML 和 DDL"></a>SQL DML 和 DDL</h2><p>SQL分两部分：</p>
<blockquote>
<p>DML（数据操作语言）<br>DDL（数据定义语言）</p>
</blockquote>
<ul>
<li><p>DML 操作表中数据</p>
<ul>
<li>select 从数据库表中获取数据</li>
<li>update 更新数据库表中数据</li>
<li>delete 从数据库表中删除数据</li>
<li>insert into 向数据库表中插入数据</li>
</ul>
</li>
<li><p>DDL操作数据库相关的数据库，表，索引等非数据部分</p>
<ul>
<li>create database -创建新数据库</li>
<li>alter database -修改数据库</li>
<li>create table -创建新表</li>
<li>alter table -修改表</li>
<li>drop table -删除表</li>
<li>create index -创建索引</li>
<li>drop index -删除索引</li>
</ul>
</li>
</ul>
<p>SQL where字句注意事项：</p>
<blockquote>
<p>条件值周围使用的是’单引号’</p>
</blockquote>
<blockquote>
<p>如果是数值，不需要使用引号</p>
</blockquote>
<blockquote>
<p>在where中，如果需要更复杂的表达式，需要用”()”来括起来</p>
</blockquote>
<pre><code>SELECT * FROM Persons WHERE (FirstName=&#39;Thomas&#39; OR FirstName=&#39;William&#39;)
AND LastName=&#39;Carter&#39;
</code></pre>
<blockquote>
<p>ORDER BY 语句用于根据指定的列对结果集进行<code>排序</code>。</p>
</blockquote>
<blockquote>
<p>ORDER BY 语句<code>默认按照升序</code>对记录进行排序。</p>
</blockquote>
<blockquote>
<p>如果希望按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。(升序ASC，降序DESC)</p>
</blockquote>
<pre><code>1.以升序显示Company列内容：
SELECT Company, OrderNumber FROM Orders ORDER BY Company 

2.以升序显示Company列内容，以升序显示OrderNumber列内容:
SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber
注：当有多个列需要排序时，会先按照前面列的要求排序，当前面列有相同值时，再对相同值按照后面列顺序进行排序，（遇到null也是这样）

3.按照降序显示Company内容，按照升序显示OrderNumber内容：
SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC
</code></pre>
<p>INSERT INTO语句<br>用于向表中插入新值，</p>
<p>语法：</p>
<pre><code>向表中插入值：（必须按照表中已有列顺序插入，）
INSERT INTO 表名称 VALUES (值1, 值2,....)	
    例:INSERT INTO Persons VALUES (&#39;Gates&#39;, &#39;Bill&#39;, &#39;Xuanwumen 10&#39;, &#39;Beijing&#39;)

向表中指定列插入值：
INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)
    例：INSERT INTO Persons (LastName, Address) VALUES (&#39;Wilson&#39;, &#39;Champs-Elysees&#39;)
</code></pre>
<p>UPDATE语句</p>
<p>用于修改表中行内容</p>
<p>语法：</p>
<pre><code>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值

UPDATE Person SET Address = &#39;Zhongshan 23&#39;, City = &#39;Nanjing&#39; WHERE LastName = &#39;Wilson&#39;
</code></pre>
<p>DELETE语句</p>
<p>用于删除表中的行</p>
<p>语法：</p>
<pre><code>DELETE FROM 表名称 WHERE 列名称 = 值


删除LastName为‘Wilson’的行
DELETE FROM Person WHERE LastName = &#39;Wilson&#39;

不删除表的情况下，删除表中所有内容
DELETE FROM table_name 
或者
DELETE * FROM table_name 
</code></pre>
<p>返回前N条数据</p>
<pre><code>MySQL语法：
SELECT column_name(s) FROM table_name LIMIT number

Oracle：
SELECT column_name(s) FROM table_name WHERE ROWNUM &lt;= number
</code></pre>
<p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</p>
<p>“Persons” 表中选取居住在以 “N” 开始的城市里的人：</p>
<pre><code>SELECT * FROM Persons WHERE City LIKE &#39;N%&#39;
</code></pre>
<p>通过使用 NOT 关键字，从 “Persons” 表中选取居住在不包含 “lon” 的城市里的人：</p>
<pre><code>SELECT * FROM Persons WHERE City NOT LIKE &#39;%lon%&#39;
注：&quot;%&quot; 可用于定义通配符（模式中缺少的字母）。
</code></pre>
<p>SQL通配符</p>
<p>SQL 通配符必须与 LIKE 运算符一起使用</p>
<p>IN 操作符</p>
<p>IN 操作符允许我们在 WHERE 子句中规定多个值</p>
<pre><code>选取姓氏为 Adams 和 Carter 的人：
SELECT * FROM Persons WHERE LastName IN (&#39;Adams&#39;,&#39;Carter&#39;)
</code></pre>
<p>BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于两个值之间的数据范围。</p>
<p>BETWEEN … AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。</p>
<p>NOT BETWEEN … AND</p>
<h2 id="Alias（别名）"><a href="#Alias（别名）" class="headerlink" title="Alias（别名）"></a>Alias（别名）</h2><p><code>AS</code>为关键字</p>
<pre><code>表名的别名：
SELECT column_name(s) FROM table_name AS alias_name
列名的别名：
SELECT column_name AS alias_name FROM table_name
</code></pre>
<p>例子：<br>假设我们有两个表分别是：”Persons” 和 “Product_Orders”。我们分别为它们指定别名 “p” 和 “po”。<br>现在，我们希望列出 “John Adams” 的所有定单。【将多个表中的数据组成一个新的结果表】</p>
<pre><code>SELECT po.OrderID, p.LastName, p.FirstName
FROM Persons AS p, Product_Orders AS po
WHERE p.LastName=&#39;Adams&#39; AND p.FirstName=&#39;John&#39;
</code></pre>
<p>不使用别名的 SELECT 语句：</p>
<pre><code>SELECT Product_Orders.OrderID, Persons.LastName, Persons.FirstName
FROM Persons, Product_Orders
WHERE Persons.LastName=&#39;Adams&#39; AND Persons.FirstName=&#39;John&#39;
</code></pre>
<p>所以，使用别名可以是SQL语句更易于阅读和书写</p>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>主键（Primary Key）是一个列，在这个列中的每一行的值都是<code>唯一</code>的。在表中，每个主键的值都是唯一的。这样做的目的是在<code>不重复</code>每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。</p>
<pre><code>从两个表Persons，和Orders表中，获取主键一样的几列数据：（结果组成一个结果集）
SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo FROM Persons,Orders WHERE Persons.Id_P = Orders.Id_P 
</code></pre>
<p>也可以使用Join来</p>
<pre><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons 
INNER JOIN Orders 
ON Persons.Id_P = Orders.Id_P
</code></pre>
<p>下面列出了您可以使用的 JOIN 类型，以及它们之间的差异。</p>
<pre><code>JOIN: 如果表中有至少一个匹配，则返回行  （INNER JOIN 与 JOIN 是相同的）
LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行
RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行
FULL JOIN: 只要其中一个表中存在匹配，就返回行
</code></pre>
<p>例：</p>
<pre><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
INNER JOIN Orders
ON Persons.Id_P=Orders.Id_P
ORDER BY Persons.LastName
</code></pre>
<h2 id="SQL-UNION-操作符"><a href="#SQL-UNION-操作符" class="headerlink" title="SQL UNION 操作符"></a>SQL UNION 操作符</h2><p>UNION 操作符用于<code>合并</code>两个或多个 SELECT 语句的结果集</p>
<p>语法：</p>
<pre><code>SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2
</code></pre>
<p><strong>注：UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条SELECT语句中的列的顺序必须相同。</strong></p>
<p><strong>注释：默认地，UNION 操作符选取所有不同的值。如果允许重复的值，请使用 UNION ALL。</strong></p>
<h2 id="SELECT…INTO…"><a href="#SELECT…INTO…" class="headerlink" title="SELECT…INTO…"></a>SELECT…INTO…</h2><p>SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。</p>
<blockquote>
<p>常用于创建表的备份复件或者用于对记录进行存档。</p>
</blockquote>
<p>语法：<br>    将指定列插入新表（也可以是 * 所有的列）</p>
<pre><code>SELECT column_name(s)
INTO new_table_name [IN externaldatabase] 
FROM old_tablename
</code></pre>
<p>例：</p>
<pre><code>SELECT LastName,FirstName
INTO Persons_backup
FROM Persons
</code></pre>
<p>例：从多个表中选取数据（例子中用的是inner join）</p>
<pre><code>SELECT Persons.LastName,Orders.OrderNo
INTO Persons_Order_Backup
FROM Persons
INNER JOIN Orders
ON Persons.Id_P=Orders.Id_P
</code></pre>
<h2 id="CREATE-DATABASE-语句"><a href="#CREATE-DATABASE-语句" class="headerlink" title="CREATE DATABASE 语句"></a>CREATE DATABASE 语句</h2><p>语法：</p>
<pre><code>CREATE DATABASE database_name
</code></pre>
<h2 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h2><p>语法：</p>
<pre><code>CREATE TABLE 表名称
(
列名称1 数据类型,
列名称2 数据类型,
列名称3 数据类型,
....
)
</code></pre>
<p>例：</p>
<pre><code>CREATE TABLE Persons
(
Id_P int,
LastName varchar(255),
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
</code></pre>
<p>可使用 INSERT INTO 语句向空表写入数据。</p>
<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>约束用于限制加入表的数据的类型</p>
<p><strong>可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）</strong></p>
<p>主要有下面几种约束：</p>
<pre><code>- NOT NULL  # NOT NULL约束强制列不接受NULL值,这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。
- UNIQUE    # UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
- PRIMARY KEY 每张表只有一个主键约束，且主键不能为null值
**注**：每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束
- FOREIGN KEY
- CHECK
- DEFAULT
</code></pre>
<p>NOT NULL例子 :</p>
<pre><code>CREATE TABLE Persons
(
Id_P int NOT NULL,  # Id_P 列值不能为空
LastName varchar(255) NOT NULL,  # LastName列值不能为空
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
</code></pre>
<p>UNIQUE约束 on create table</p>
<pre><code>Oracle语法:
CREATE TABLE Persons
(
Id_P int NOT NULL UNIQUE,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
</code></pre>
<p><em>为unique命名的好处？为什么为unique命名？</em></p>
<p>如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的SQL语法：</p>
<pre><code>CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)
)
</code></pre>
<p>对Id_P,和LastName做unique约束，并将unique约束命名为uc_PersonID，</p>
<h2 id="在Alter-table时的unique"><a href="#在Alter-table时的unique" class="headerlink" title="在Alter table时的unique"></a>在Alter table时的unique</h2><p>当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束：</p>
<pre><code>ALTER TABLE Persons ADD UNIQUE (Id_P)
</code></pre>
<p>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束：</p>
<pre><code>ALTER TABLE Persons ADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)
</code></pre>
<h2 id="撤销-UNIQUE-约束"><a href="#撤销-UNIQUE-约束" class="headerlink" title="撤销 UNIQUE 约束"></a>撤销 UNIQUE 约束</h2><p>Oracle：</p>
<pre><code>ALTER TABLE Persons
DROP CONSTRAINT uc_PersonID
</code></pre>
<p>撤销掉一列(没有命名)的unique怎么操作？</p>
<h2 id="Primary-Key"><a href="#Primary-Key" class="headerlink" title="Primary Key"></a>Primary Key</h2><pre><code>CREATE TABLE Persons
(
Id_P int NOT NULL PRIMARY KEY,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
</code></pre>
<h2 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h2><p>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。</p>
<p>FOREIGN KEY 约束用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<h2 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a>CHECK约束</h2><p>创建多个check约束时：</p>
<pre><code>CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=&#39;Sandnes&#39;)
)
</code></pre>
<h2 id="DEFAULT约束"><a href="#DEFAULT约束" class="headerlink" title="DEFAULT约束"></a>DEFAULT约束</h2><p>DEFAULT 约束用于向列中插入默认值</p>
<p>如果没有规定其他的值，那么会将默认值添加到所有的新记录</p>
<p>Oracle：</p>
<pre><code>CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255) DEFAULT &#39;Sandnes&#39;
)
</code></pre>
<p>删除DEFAULT约束：</p>
<pre><code>ALTER TABLE Persons
ALTER COLUMN City DROP DEFAULT
</code></pre>
<h2 id="CREATE-INDEX"><a href="#CREATE-INDEX" class="headerlink" title="CREATE INDEX"></a>CREATE INDEX</h2><p>在表中创建索引，以便更加快速高效地查询数据（用户无法看到索引）</p>
<p><strong>注释</strong>：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</p>
<p>CREATE INDEX 语法</p>
<pre><code>在表上创建一个简单的索引。允许使用重复的值:
CREATE INDEX index_name
ON table_name (column_name)  # &quot;column_name&quot; 为需要索引的列
</code></pre>
<p>CREATE UNIQUE INDEX 语法</p>
<pre><code>在表上创建一个唯一的索引。唯一的索引意味着该列不能拥有相同的索引值
CREATE UNIQUE INDEX index_name
ON table_name (column_name)
</code></pre>
<p>1.创建一个简单的索引，名为 “PersonIndex”，在 Person 表的 LastName 列</p>
<pre><code>create index PersonIndex on Person (LastName)
</code></pre>
<p>2.创建以降序索引某列的值，（使用DESC）</p>
<pre><code>create index PearsonIndex on Person (LastName DESC)
</code></pre>
<p>3.若创建索引不止一列，在括号中列出所需列的名称，用逗号隔开：</p>
<pre><code>create index PersonIndex on Person (LastName, FirstName)
</code></pre>
<h2 id="DROP-删除索引，表及数据库"><a href="#DROP-删除索引，表及数据库" class="headerlink" title="DROP (删除索引，表及数据库)"></a>DROP (删除索引，表及数据库)</h2><p>Oracle:</p>
<pre><code># 删除索引：	
drop index index_name
# 删除表	
drop table table_name (会删除表的结构，属性以及索引)
# 删除数据库
drop database database_name
</code></pre>
<p>仅清空表中数据，不删除表：</p>
<pre><code>truncate table table_name # 和hbase使用方法一样
</code></pre>
<h2 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h2><p>ALTER TABLE 语句用于在已有的表中添加、修改或删除列</p>
<pre><code>alter table table_name add column_name data_type
</code></pre>
<p>删除表中的列：</p>
<pre><code>alter table table_name drop column column_name
# 并不是所有的数据库系统都支持在数据库中删除列的方式
</code></pre>
<p>改变表中列的数据类型：</p>
<pre><code>alter table table_name alter column column_name data_type
</code></pre>
<h2 id="auto-increment字段"><a href="#auto-increment字段" class="headerlink" title="auto increment字段"></a>auto increment字段</h2><p>auto-increment 会在新记录插入表中时生成一个唯一数字</p>
<p>Oracle：</p>
<pre><code># oracle通过sequence创建auto-increment字段（该对象生成数字序列）
create sequence seq_person
minvalue 1
start with 1
increment by 1
cache 10
</code></pre>
<p>上面内容，创建名为seq_person的序列对象，以1起始并以1递增，通过缓存10个值以提高性能</p>
<p>在Persons表中插入新记录，必须使用nextval函数（该函数从定义的seq_person序列中获取下一个值）：</p>
<pre><code>insert into Persons (P_Id,FirstName,LastName) Values (seq_person.nextval, &#39;Lars&#39;, &#39;Monsen&#39;)
</code></pre>
<p>上面的SQL语句，会在“Persons”表中插入一条新记录。‘P_Id’的值来自seq_person序列的下一个数字</p>
<h2 id="VIEW-视图"><a href="#VIEW-视图" class="headerlink" title="VIEW(视图)"></a>VIEW(视图)</h2><p>视图是一个结果集，视图的字段时一个或多个表的字段组成的</p>
<p>SQL CREATE VIEW语法：</p>
<pre><code>create view view_name as
select column_name(s) from table_name where [condition]
</code></pre>
<p><strong>注</strong>：视图总显示最近的数据</p>
<pre><code>create view [Current Product List] as select ProductID,ProductName from Products where Discontinued=No
</code></pre>
<p>更新视图：</p>
<pre><code>create / replace view view_name as 
select column_name(s) from table_name
where condition
</code></pre>
<p>例：</p>
<p>我们向“Current Product List”视图中添加“Category”列，语句：</p>
<pre><code>create view [Current Product List] as select
ProductID,ProductName,Category from Products
where Disconinued=No
</code></pre>
<p>删除视图：</p>
<pre><code>drop view view_name
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Oracle时一些配置参数</title>
    <url>//%E5%AE%89%E8%A3%85Oracle%E6%97%B6%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.html</url>
    <content><![CDATA[<h1 id="自己安装Oracle时，遇到的一些配置参数"><a href="#自己安装Oracle时，遇到的一些配置参数" class="headerlink" title="自己安装Oracle时，遇到的一些配置参数"></a>自己安装Oracle时，遇到的一些配置参数</h1><p>chown -R oracle. database&#x2F;  # 这里的”oracle.”的作用是什么？</p>
<p>yum -y groupinstall “Graphical Administration Tools”<br>yum -y groupinstall “General Purpose Desktop”<br>yum -y groupinstall “Graphics Creation Tools”</p>
<p>yum install -y binutils <br>compat-libcap1 <br>compat-libstdc++-33 <br>compat-libstdc++-33.i686 <br>gcc <br>gcc-c++ <br>glibc.i686 <br>glibc <br>glibc-devel <br>glibc-devel.i686 <br>pdksh <br>libgcc.i686 <br>libgcc <br>libstdc++.i686 <br>libstdc++ <br>libstdc++-devel.i686 <br>libstdc++-devel <br>libaio.i686 <br>libaio <br>libaio-devel.i686 <br>libaio-devel <br>make <br>sysstat <br>unixODBC <br>unixODBC.i686 <br>unixODBC-devel <br>unixODBC-devel.i686 <br>libXext.i686 <br>libXext <br>elfutils-libelf-devel <br>unzip</p>
<ol start="3">
<li>内核参数调整（不低于以下值）<br> vi &#x2F;etc&#x2F;sysctl.conf<br>最后一行添加</li>
</ol>
<p>kernel.shmmni &#x3D; 4096<br>kernel.sem &#x3D; 250 32000 100 128<br>net.ipv4.ip_local_port_range &#x3D; 9000 65500<br>net.core.rmem_default &#x3D; 262144<br>net.core.rmem_max &#x3D; 4194304<br>net.core.wmem_default &#x3D; 262144<br>net.core.wmem_max &#x3D; 1048576<br>加载参数<br>sysctl -p</p>
<p>kernel.shmmax &#x3D; 68719476736<br>kernel.shmall &#x3D; 4294967296<br>net.core.rmem_default &#x3D; 262144<br>net.core.rmem_max &#x3D; 4194304<br>net.core.wmem_default &#x3D; 262144<br>net.core.wmem_max &#x3D; 1048576<br>fs.aio-max-nr &#x3D; 1048576<br>net.ipv4.ip_local_port_range &#x3D; 9000 65500<br>fs.file-max &#x3D; 6815744<br>kernel.sem &#x3D; 250 32000 100 128<br>kernel.shmmni &#x3D; 4096</p>
<p>WARNING:It is recommended to not use the Oracle Base &#x2F;home&#x2F;oracle as the user home directory </p>
<p>sh: &#x2F;bin&#x2F;ksh: No such file or directory  –. 这个内容果然还是应该修改为&#x2F;bin&#x2F;sh</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Postgres操作</title>
    <url>//Postgres%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<h1 id="docker-启动-postgres"><a href="#docker-启动-postgres" class="headerlink" title="docker 启动 postgres"></a>docker 启动 postgres</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">--name</span> postgres<span class="literal">-test</span> <span class="literal">-e</span> POSTGRES_PASSWORD=<span class="number">123456</span> <span class="literal">-p</span> <span class="number">5432</span>:<span class="number">5432</span> <span class="literal">-d</span> postgres</span><br></pre></td></tr></table></figure>



<p>登录到启动的 postgres 容器中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it &lt;container&gt; /bin/bash</span><br></pre></td></tr></table></figure>



<h1 id="登录-Postgres-数据库"><a href="#登录-Postgres-数据库" class="headerlink" title="登录 Postgres 数据库"></a>登录 Postgres 数据库</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到 postgres 用户</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">su - postgres</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 postgres 的客户端</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">psql</span></span><br></pre></td></tr></table></figure>



<h1 id="查看表名"><a href="#查看表名" class="headerlink" title="查看表名"></a>查看表名</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># \d [tablename]</span><br></pre></td></tr></table></figure>





<h1 id="命令行执行-SQL"><a href="#命令行执行-SQL" class="headerlink" title="命令行执行 SQL"></a>命令行执行 SQL</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">psql [dbname] -U &lt;username&gt; -c &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">psql [dbname] -U &lt;username&gt; -f sql文件</span><br></pre></td></tr></table></figure>



<p>例如：查询uts库下所有表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">psql -U uts -c &quot;select tablename from pg_tables where schema=&#x27;public&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p>例如：在命令行执行SQL文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">psql -U uts -f /root/devops/uts-pg/uts_sql.sql</span><br></pre></td></tr></table></figure>



<h1 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h1><h2 id="通过-copy-方式指定表导出"><a href="#通过-copy-方式指定表导出" class="headerlink" title="通过 copy 方式指定表导出"></a>通过 copy 方式指定表导出</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> storage_threat_ips_24 ) <span class="keyword">to</span> <span class="string">&#x27;/opt/nsfocus/data/hadoop/vdb/utsgpback/storage_threat_ips_24.csv&#x27;</span> <span class="keyword">with</span> csv header;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，该方式仅会导出数据，没有表结构。</p>
</blockquote>
<h1 id="导出表结构"><a href="#导出表结构" class="headerlink" title="导出表结构"></a>导出表结构</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pg_dump [-h host -p port] -U &lt;username&gt; -s -t &lt;tablename&gt; &gt; 导出文件.sql</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-s</code> : 只导出表结构，不会导出数据；</p>
<p><code>-t</code> : 指定要导出的数据库表；</p>
</blockquote>
<p>本地导出不用添加主机和端口。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Postgres</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>3.数组中重复的数字</title>
    <url>//3.%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html</url>
    <content><![CDATA[<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><p>找出数组中重复的数字</p>
<p>**题目： **<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<p>2 &lt;&#x3D; n &lt;&#x3D; 100000</p>
<p><strong>思路：</strong></p>
<ol>
<li><p>直接循环，将每一个出现的元素，放到一个容器中，判断容器新添加时是否已经存在，存在则为重复<br>时间复杂度 O(n), 空间复杂度O(n)</p>
</li>
<li><p>如果要求不引入新的内存空间，空间复杂度为O(1),那么就需要修改输入数组，进行排序</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指Offer习题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指Offer习题</tag>
      </tags>
  </entry>
  <entry>
    <title>5.替换空格</title>
    <url>//5.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html</url>
    <content><![CDATA[<h1 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h1><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</p>
<h1 id="解法思路："><a href="#解法思路：" class="headerlink" title="解法思路："></a>解法思路：</h1><p><strong>补充：</strong> 本题也可以直击使用字符串的replaceAll()方法来处理</p>
<h2 id="1-如果函数的输入要求是String"><a href="#1-如果函数的输入要求是String" class="headerlink" title="1. 如果函数的输入要求是String"></a>1. 如果函数的输入要求是String</h2><ol>
<li>在 Python 和 Java 语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。<br>所以空间复杂度为O(n)</li>
</ol>
<p>java,创建一个StringBuilder对象，命名为res，然后遍历字符串中的每个字符 c，java中使用charAt(index) 获取指定索引位置的字符<br>    - 当 c 为空格时：向 res 后添加字符串 “%20” ；<br>    - 当 c 不为空格时：向 res 后添加字符 c ；</p>
<p>最后将res.toString();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) res.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul>
<li>时间复杂度 O(N) ： 遍历使用 O(N) ，每轮添加（修改）字符操作使用 O(1) ；</li>
<li>空间复杂度 O(N) ： Java 新建的 StringBuilder 都使用了线性大小的额外空间。</li>
</ul>
<h2 id="2-如果函数的输入要求是StringBuidler"><a href="#2-如果函数的输入要求是StringBuidler" class="headerlink" title="2. 如果函数的输入要求是StringBuidler"></a>2. 如果函数的输入要求是StringBuidler</h2><p>因为java中StringBuilder是可变的，那么就可以使用类似《剑指offer》中提供的<code>扩充原字符串 + 双指针</code>思路来处理。</p>
<p>先遍历原字符串，遇到空格，则在原字符串末尾 append 任意两个字符，如两个空格。</p>
<p>用指针 <code>i</code> 指向原字符串末尾，<code>j</code> 指向现字符串末尾，<code>i</code>, <code>j</code> 从后往前遍历，当 <code>i</code> 遇到空格，<code>j</code> 位置依次要赋值为 ‘0’,’2’,’%’，若不是空格，直接赋值为 <code>i</code> 指向的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串中的所有空格替换为%20</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 替换后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpaces</span><span class="params">(StringBuffer str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                str.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>, j = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                str.setCharAt(j--, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                str.setCharAt(j--, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                str.setCharAt(j--, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str.setCharAt(j--, ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul>
<li>时间复杂度 O(N) ： 遍历使用 O(N) ，每轮添加（修改）字符操作使用 O(1) ；</li>
<li>空间复杂度 O(N) ： O(1)</li>
</ul>
<p><strong>注意：</strong> 为什么要从后向前遍历？</p>
<ul>
<li>因为，如果从前向后遍历，空格替换为’%20’,是将一个字符替换为三个字符，后面需要处理覆盖移动的操作，最后一个空格后面的字符需要多次移动，</li>
<li>而从后向前，在扩展了原有字符长度的基础上，从后向前，每个字符只需要移动一次，减少了移动次数，提高了效率。</li>
</ul>
<hr>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>注意：</strong>， java中char字符是单引号’’,String字符串才是双引号””</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(<span class="number">1</span>)==<span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路扩展："><a href="#思路扩展：" class="headerlink" title="思路扩展："></a>思路扩展：</h3><p>在合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）需要重复移动数字（或字符）多次，那么我们可以考虑从后往前复制，这样就能减少移动的次数，从而提高效率。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指Offer习题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>剑指Offer习题</tag>
      </tags>
  </entry>
  <entry>
    <title>家庭网络设置</title>
    <url>//%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE.html</url>
    <content><![CDATA[<h1 id="目前家庭网络设置"><a href="#目前家庭网络设置" class="headerlink" title="目前家庭网络设置"></a>目前家庭网络设置</h1><p>入口：移动光猫</p>
<ul>
<li>路由模式</li>
</ul>
<p>一级：TP-LINK 路由器</p>
<ul>
<li>正常模式，同时开启 IPV6</li>
</ul>
<p>二级：移动送的水星路由器</p>
<ul>
<li>桥接模式，连接上一级 TP-LINK 路由器</li>
<li>使用网线与上一级路由器连接，</li>
<li>开启桥接模式后，会自动关闭 DHCP 功能，</li>
<li>需要将路由器 WiFi 的 SSID，密码设置与 TP-LINK 的一样。</li>
</ul>
<h1 id="家庭路由器使用注意事项"><a href="#家庭路由器使用注意事项" class="headerlink" title="家庭路由器使用注意事项"></a>家庭路由器使用注意事项</h1><p>使用 TP-Link 或者 水星路由器</p>
<p>TP-LINK 的默认管理IP为：192.168.1.1</p>
<p>默认的地址为： tplogin.cn</p>
<p>水星的默认管理IP为：192.168.10.1</p>
<p>默认的地址为：melogin.cn</p>
<p>当家里的光猫是开启了路由模式时，再连接路由器时，当光猫的默认管理地址为 192.168.1.1 的时候，那么此时 TP-LINK 的管理地址就会冲突自动切换，如果不知道地址是多少，可以打开命令行，通过 <code>nslookup</code>  命令来查看地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\spoon&gt;nslookup tplogin.cn</span><br><span class="line">服务器:  192.168.1.1</span><br><span class="line">Address:  192.168.1.1</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    tplogin.cn</span><br><span class="line">Address:  192.168.0.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意，如果 TP-LINK 开启了 IPV6 地址之后，那么此时再使用 <code>nslookup</code> 命令解析会失效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\spoon&gt;nslookup melogin.cn</span><br><span class="line">DNS request timed out.</span><br><span class="line">    timeout was 2 seconds.</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  fe80::1</span><br><span class="line"></span><br><span class="line">DNS request timed out.</span><br><span class="line">    timeout was 2 seconds.</span><br><span class="line">DNS request timed out.</span><br></pre></td></tr></table></figure>

<p>机器上如果没有其他 DNS 解析命令时，可以先去关闭 IPV6 功能后再解析。</p>
]]></content>
      <categories>
        <category>网络</category>
        <category>家庭网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>家庭网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Logstash发送MySQL数据到Elasticsearch</title>
    <url>//Logstash%E5%8F%91%E9%80%81MySQL%E6%95%B0%E6%8D%AE%E5%88%B0Elasticsearch.html</url>
    <content><![CDATA[<h1 id="使用-JDBC-input-plugin"><a href="#使用-JDBC-input-plugin" class="headerlink" title="使用 JDBC input plugin"></a>使用 JDBC input plugin</h1><p>Logstash 发送 MySQL 数据到 Elasticsearch 可以通过其内置的 <code>Jdbc input plugin</code> 。</p>
<p>需要两个配置步骤</p>
<ol>
<li>准备 MySQL java 客户端包；</li>
<li>配置 Logstash 的 jdbc pipline 配置文件；</li>
</ol>
<h2 id="1-准备-MySQL-java-客户端包"><a href="#1-准备-MySQL-java-客户端包" class="headerlink" title="1. 准备 MySQL java 客户端包"></a>1. 准备 MySQL java 客户端包</h2><p>将 jar 包放置 logstash&#x2F;lib&#x2F;mysql&#x2F; 目录下。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@elk1-2 logstash-8.4.1]# ll lib/mysql/</span><br><span class="line">total 2268</span><br><span class="line">-rw-r--r-- 1 es es 2321813 Oct  3 20:17 mysql-connector-java-8.0.17.jar</span><br></pre></td></tr></table></figure>



<h2 id="2-配置-Logstash-的-jdbc-pipline-配置文件"><a href="#2-配置-Logstash-的-jdbc-pipline-配置文件" class="headerlink" title="2. 配置 Logstash 的 jdbc pipline 配置文件"></a>2. 配置 Logstash 的 jdbc pipline 配置文件</h2><p>将配置好的 jdbc pipline 配置文件，放到 config&#x2F;logstash.yml 配置文件中 <code>path.config</code> 参数对应的目录下。</p>
<blockquote>
<p>path.config 参数的作用： Where to fetch the pipeline configuration for the main pipeline</p>
</blockquote>
<p>自定义的 pipline 配置文件，需要分别配置 <code>input</code> 和 <code>output</code> 部分。</p>
<p>样例配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">        jdbc_connection_string =&gt; &quot;jdbc:mysql://10.12.0.57:3306/cestc_sandboxie?characterEncoding=UTF-8&amp;useSSL=false&quot;</span><br><span class="line">        jdbc_driver_library =&gt; &quot;/opt/logstash-8.4.1/lib/mysql/mysql-connector-java-8.0.17.jar&quot;</span><br><span class="line">        jdbc_driver_class =&gt; &quot;com.mysql.cj.jdbc.Driver&quot;</span><br><span class="line">        jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">        jdbc_password =&gt; &quot;xxx&quot;</span><br><span class="line">        jdbc_validate_connection =&gt; &quot;true&quot;</span><br><span class="line">        # statement =&gt; &quot;SELECT * FROM cestc_sandboxie.SS_YHXW_LOG WHERE  CJSJ &gt;= :sql_last_value AND CJSJ &lt;= :sql_last_value&quot;</span><br><span class="line">        statement =&gt; &quot;SELECT * FROM cestc_sandboxie.SS_YHXW_LOG limit 20&quot;</span><br><span class="line"></span><br><span class="line">        lowercase_column_names =&gt; false</span><br><span class="line">        # 是否记录上次执行结果，true 表示会将上次执行结果的 tracking_column 字段的值保存到 last_run_metadata_path 指定的文件中</span><br><span class="line">        # record_last_run =&gt; true</span><br><span class="line">        record_last_run =&gt; false</span><br><span class="line">        # 需要记录查询结果某字段的值时，此字段为 true，否则默认 tracking_column 为 timestamp 的值</span><br><span class="line">        # use_column_value =&gt; true</span><br><span class="line">        use_column_value =&gt; false</span><br><span class="line">        # 需要记录的字段，用于增量同步，数据表字段</span><br><span class="line">        tracking_column =&gt; &quot;CJSJ&quot;</span><br><span class="line">        # 增量同步的字段类型：</span><br><span class="line">        tracking_column_type =&gt; timestamp</span><br><span class="line">        # record_last_run 上次数据存放位置</span><br><span class="line">        last_run_metadata_path =&gt; &quot;/opt/logstash-8.4.1/data/mysql/last_id&quot;</span><br><span class="line">        # 是否清除 last_run_metadata_path 的记录，需要增量同步时此字段必须为 false</span><br><span class="line">        clean_run =&gt; false</span><br><span class="line">        # 同步频率，默认每分钟同步一次</span><br><span class="line">        #schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [&quot;http://10.12.1.84:9200&quot;]</span><br><span class="line">    index =&gt; &quot;10.12.0.57-sandbox-yhxw-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    # 数据的唯一索引，这里填写查询的表的主键或一个值唯一的字段</span><br><span class="line">    document_id =&gt; &quot;%&#123;ID&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-重启-Logstash"><a href="#3-重启-Logstash" class="headerlink" title="3. 重启 Logstash"></a>3. 重启 Logstash</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/logstash-8.4.1/bin/logstash &amp;</span><br></pre></td></tr></table></figure>

<p>服务会读取 <code>path.config</code> 参数目录下所有的 conf 文件。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/caidewei121/article/details/115487444">ELK-Logstash 将 MySQL 数据同步至 ElasticSearch</a></li>
<li><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html">Logstash-Jdbc-input-plugin</a></li>
<li><a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html">Logstash-Elasticsearch-output-plugin</a></li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>使用systemctl启动filebeat</title>
    <url>//%E4%BD%BF%E7%94%A8systemctl%E5%90%AF%E5%8A%A8filebeat.html</url>
    <content><![CDATA[<p>我安装 Filebeat 时用的是压缩包解压后直接配置的方式。启动时需要执行后台运行命令。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/filebeat-8.4.1-linux-x86_64</span><br><span class="line">nohup ./filebeat -e -c /opt/filebeat-8.4.1-linux-x86_64/filebeat.yml &gt; logs/filebeat-2022100102.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>重启时需要使用 <code>kill -9 &lt;filebeat PID&gt;</code> 的方式。</p>
<p>为了方便，改成自定义Service方式启动 ，即使用 systemctl 来启动 filebeat 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/filebeat.service</span><br><span class="line">chmod +x /usr/lib/systemd/system/filebeat.service</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start filebeat</span><br><span class="line">systemctl enable filebeat</span><br></pre></td></tr></table></figure>



<p><code>filebeat.service</code> 文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=filebeat server daemon</span><br><span class="line">Documentation=/opt/filebeat-8.4.1-linux-x86_64/filebeat --help</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Environment=&quot;CONFIG_OPTS=-c /opt/filebeat-8.4.1-linux-x86_64/filebeat.yml&quot;</span><br><span class="line">ExecStart=/opt/filebeat-8.4.1-linux-x86_64/filebeat $CONFIG_OPTS</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<blockquote>
<p>service 文件配置详情，查看 man systemd.unit；</p>
</blockquote>
]]></content>
      <categories>
        <category>运维</category>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>filebeat</tag>
        <tag>systemctl</tag>
      </tags>
  </entry>
  <entry>
    <title>在CentOS7上安装ELK单节点</title>
    <url>//%E5%9C%A8CentOS7%E4%B8%8A%E5%AE%89%E8%A3%85ELK%E5%8D%95%E8%8A%82%E7%82%B9.html</url>
    <content><![CDATA[<h1 id="1-ELK-简介"><a href="#1-ELK-简介" class="headerlink" title="1. ELK 简介"></a>1. ELK 简介</h1><p>ELK 是  Elasticsearch、Logstash 和 Kibana 三种软件产品的首字母缩写。这三者都是开源软件，通常配合使用，而且又先后归于 Elastic.co 公司名下，所以被简称为 ELK Stack。已经成为目前最流行的集中式日志解决方案。</p>
<ul>
<li>Elasticsearch：分布式搜索和分析引擎，具有高可伸缩、高可靠和易管理等特点。基于 Apache Lucene 构建，能对大容量的数据进行接近实时的存储、搜索和分析操作。通常被用作某些应用的基础搜索引擎，使其具有复杂的搜索功能；</li>
<li>Logstash：数据收集引擎。它支持动态的从各种数据源搜集数据，并对数据进行过滤、分析、丰富、统一格式等操作，然后存储到用户指定的位置；</li>
<li>Kibana：数据分析和可视化平台。通常与 Elasticsearch 配合使用，对其中数据进行搜索、分析和以统计图表的方式展示；</li>
<li>Filebeat：ELK 协议栈的新成员，一个轻量级开源日志文件数据搜集器，基于 Logstash-Forwarder  源代码开发，是对它的替代。在需要采集日志数据的 server 上安装 Filebeat，并指定日志目录或日志文件后，Filebeat  就能读取数据，迅速发送到 Logstash 进行解析，亦或直接发送到 Elasticsearch 进行集中式存储和分析。</li>
</ul>
<p><strong>常用架构</strong></p>
<p>在需要收集数据的服务器上部署 Logstash，然后 Logstash 将解析好的数据发送到 Elasticsearch 中存储，最后在 Kibana 中查询、分析。</p>
<p><code>数据源 -&gt; Logstash -&gt; Elasticsearch -&gt; Kibana</code></p>
<ul>
<li>缺点：Logstash 比较消耗 CPU 和内存资源，在计算资源不丰富的机器上会导致服务器性能下降，影响原本的服务。</li>
</ul>
<p><code>Beats -&gt; Logstash -&gt; Elasticsearch -&gt; Kibana</code></p>
<p>引入 Beats 作为日志收集器。Beats 将数据发送到 Logstash，经 Logstash 解析、过滤后发送到 Elasticsearch 存储，并最后在 Kibana 中分析、查询。</p>
<p>这种架构方式解决了 Logstash 在各个服务器节点上占用系统资源高的问题。相比 Logstash，Beats 所占系统的 CPU 和内存几乎可以忽略不计。另外，Beats 和 Logstash 之间支持 SSL&#x2F;TLS 加密传输，客户端和服务器双向认证，保证了通信安全。</p>
<p>这种架构适合各服务器性能比较敏感的场景，或对数据安全性要求较高的场景。</p>
<p>目前 Beats 包括4种：</p>
<ul>
<li>Packetbeat （搜集网络流量数据）；</li>
<li>Topbeat （搜集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）；</li>
<li>Filebeat （搜集文件数据）；</li>
<li>Winlogbeat （搜集 Windows 实践日志数据）；</li>
</ul>
<p>更多架构使用场景，参考官方文档。</p>
<h1 id="2-基于-Filebeat-架构的安装配置"><a href="#2-基于-Filebeat-架构的安装配置" class="headerlink" title="2. 基于 Filebeat 架构的安装配置"></a>2. 基于 Filebeat 架构的安装配置</h1><p>测试环境，使用 <code>Filebeat -&gt; Logstash -&gt; Elasticsearch -&gt; Kibana</code> 的架构方式来安装，采用单机部署，所有软件部署在一台机器上。</p>
<p>安装环境及版本：</p>
<ul>
<li>服务器信息：<ul>
<li>CentOS 7.6</li>
<li>4C-8G</li>
</ul>
</li>
<li>安装包版本：<ul>
<li>elasticsearch-8.4.1-linux-x86_64.tar.gz</li>
<li>kibana-8.4.1-linux-x86_64.tar.gz</li>
<li>logstash-8.4.1-linux-x86_64.tar.gz</li>
<li>filebeat-8.4.1-linux-x86_64.tar.gz</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：安装 ELK （Elastic Stack）时，涉及的所有<strong>版本需要相同</strong>，如上所示，4个软件版本都是 8.4.1 。</p>
<p>​           安装顺序按照上面软件包列出的顺序，从上到下依次安装；</p>
<p>具体参考 <a href="https://www.elastic.co/guide/en/elastic-stack/current/installing-elastic-stack.html">官方安装 Elastic Stack 章节</a>。</p>
</blockquote>
<p>本次安装采用官网压缩包的方式。</p>
<h2 id="2-1-安装-JDK（已经安装过，可以跳过）"><a href="#2-1-安装-JDK（已经安装过，可以跳过）" class="headerlink" title="2.1. 安装 JDK（已经安装过，可以跳过）"></a>2.1. 安装 JDK（已经安装过，可以跳过）</h2><p>安装 openJDK 即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk.x86_64</span><br></pre></td></tr></table></figure>

<p>查看 java 安装情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[es@elk1-2 opt]$ java -version</span><br><span class="line">openjdk version &quot;1.8.0_181&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure>



<h2 id="2-2-安装配置-Elasticsearch"><a href="#2-2-安装配置-Elasticsearch" class="headerlink" title="2.2. 安装配置 Elasticsearch"></a>2.2. 安装配置 Elasticsearch</h2><p>Elasticsearch 中包含了内置的 OpenJDK，可以不用单独安装 JDK。</p>
<h3 id="下载-tar-gz-安装包，并解压安装"><a href="#下载-tar-gz-安装包，并解压安装" class="headerlink" title="下载 .tar.gz 安装包，并解压安装"></a>下载 <code>.tar.gz</code> 安装包，并解压安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf elasticsearch-8.4.1-linux-x86_64.tar.gz -C /opt</span><br></pre></td></tr></table></figure>



<h3 id="设置-data-的目录"><a href="#设置-data-的目录" class="headerlink" title="设置 data 的目录"></a>设置 data 的目录</h3><p>创建额外的 Elasticsearch 数据存储目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/data/esdata</span><br></pre></td></tr></table></figure>



<h3 id="创建有目录的用户，并修改目录权限"><a href="#创建有目录的用户，并修改目录权限" class="headerlink" title="创建有目录的用户，并修改目录权限"></a>创建有目录的用户，并修改目录权限</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd es -U -m</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-U 创建一个与用户名相同的用户组，</p>
<p>-m 创建用户的家目录，</p>
</blockquote>
<p>修改 Elasticsearch 安装目录和数据存储目录权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R es:es /opt/elasticsearch-8.4.1</span><br><span class="line">chown -R es:es /opt/data/esdata</span><br></pre></td></tr></table></figure>



<h3 id="修改-Elasticsearch-配置文件"><a href="#修改-Elasticsearch-配置文件" class="headerlink" title="修改 Elasticsearch 配置文件"></a>修改 Elasticsearch 配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /opt/elasticsearch-8.4.1/config/elasticsearch.yml</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">test-es</span>             <span class="comment">#配置一个名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">es-server</span>              <span class="comment">#本节点elasticsearch名称</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>             <span class="comment">#允许访问</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/opt/data/esdata</span>       <span class="comment">#数据存放目录运行elasticsearch</span></span><br><span class="line"><span class="attr">ingest.geoip.downloader.enabled:</span> <span class="literal">false</span> <span class="comment">#这里为了解决后面提示的报错。</span></span><br></pre></td></tr></table></figure>



<h3 id="启动-Elasticsearch"><a href="#启动-Elasticsearch" class="headerlink" title="启动 Elasticsearch"></a>启动 Elasticsearch</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要在普通用户下执行启动命令，在 ELK 中 Elasticsearch 需要先于 Logstash 启动</span></span><br><span class="line">su - es</span><br><span class="line">/opt/elasticsearch-8.4.1/bin/elasticsearch -d</span><br></pre></td></tr></table></figure>



<p>验证服务启动状态</p>
<p>查看端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ntlp |grep 9200</span><br></pre></td></tr></table></figure>

<p>查看页面请求</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl localhost:9200</span><br></pre></td></tr></table></figure>

<p>正确请求结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;es-server&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;test-es&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;aeWJbSOSRNeYEjqg3Nj3ow&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;8.4.1&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;tar&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;2bd229c8e56650b42e40992322a76e7914258f0c&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2022-08-26T12:11:43.232597118Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;9.3.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;7.17.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;7.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-安装配置-Kibana"><a href="#2-3-安装配置-Kibana" class="headerlink" title="2.3. 安装配置 Kibana"></a>2.3. 安装配置 Kibana</h2><h3 id="下载-tar-gz-安装包，并解压安装-1"><a href="#下载-tar-gz-安装包，并解压安装-1" class="headerlink" title="下载 .tar.gz 安装包，并解压安装"></a>下载 <code>.tar.gz</code> 安装包，并解压安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf kibana-8.4.1-linux-x86_64.tar.gz -C /opt</span><br></pre></td></tr></table></figure>



<h3 id="修改-Kibana-配置文件"><a href="#修改-Kibana-配置文件" class="headerlink" title="修改 Kibana 配置文件"></a>修改 Kibana 配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /opt/kibana-8.4.1/config/kibana.yml</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里云主机需要填写本地私有地址，不能填写 FIP，否则启动时会报错。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要远程机器访问，需要填写 non-loopback address</span> </span><br><span class="line">server.host: 10.100.5.6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">elasticsearch的地址，如果elasticsearch与kibana安装在不同服务器上，需要手动指定地址</span></span><br><span class="line">server.name: &quot;es-kibana&quot;</span><br><span class="line">elasticsearch.hosts: [&quot;http://localhost:9200&quot;]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启下面配置，日志写入指定日志文件</span></span><br><span class="line">logging.appenders.default:</span><br><span class="line">  type: file</span><br><span class="line">  fileName: /opt/kibana-8.4.1/logs/kibana.log</span><br><span class="line">  layout:</span><br><span class="line">    type: json</span><br></pre></td></tr></table></figure>

<h3 id="启动-Kibana"><a href="#启动-Kibana" class="headerlink" title="启动 Kibana"></a>启动 Kibana</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/kibana-8.4.1/bin/kibana &amp;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-安装配置-Logstash"><a href="#2-4-安装配置-Logstash" class="headerlink" title="2.4. 安装配置 Logstash"></a>2.4. 安装配置 Logstash</h2><h3 id="下载-tar-gz-安装包，并解压安装-2"><a href="#下载-tar-gz-安装包，并解压安装-2" class="headerlink" title="下载 .tar.gz 安装包，并解压安装"></a>下载 <code>.tar.gz</code> 安装包，并解压安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf logstash-8.4.1-linux-x86_64.tar.gz -C /opt</span><br></pre></td></tr></table></figure>



<h3 id="测试-Logstash-能否正常运行"><a href="#测试-Logstash-能否正常运行" class="headerlink" title="测试 Logstash 能否正常运行"></a>测试 Logstash 能否正常运行</h3><p>不修改配置前可以利用下面内容测试 Logstash 能否正常运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logstash-8.4.1/bin/logstash -e &#x27;input &#123;stdin &#123;&#125;&#125; output &#123;stdout&#123;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2022-10-02T16:58:32,007][INFO ][logstash.javapipeline    ][main] Pipeline started &#123;&quot;pipeline.id&quot;=&gt;&quot;main&quot;&#125;</span><br><span class="line">The stdin plugin is now waiting for input:</span><br><span class="line">[2022-10-02T16:58:32,060][INFO ][logstash.agent           ] Pipelines running &#123;:count=&gt;1, :running_pipelines=&gt;[:main], :non_running_pipelines=&gt;[]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>出现上面打印信息后，即可以随意输入内容，回车后，就会有内容输出。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello world.</span><br><span class="line">&#123;</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">       &quot;message&quot; =&gt; &quot;hello world.&quot;,</span><br><span class="line">          &quot;host&quot; =&gt; &#123;</span><br><span class="line">        &quot;hostname&quot; =&gt; &quot;elk1-2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2022-10-02T09:02:34.381131080Z,</span><br><span class="line">         &quot;event&quot; =&gt; &#123;</span><br><span class="line">        &quot;original&quot; =&gt; &quot;hello world.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另一种返回结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logstash-8.4.1/bin/logstash -e &#x27;input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec =&gt; rubydebug&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2022-10-02T17:09:07,932][INFO ][logstash.javapipeline    ][main] Pipeline started &#123;&quot;pipeline.id&quot;=&gt;&quot;main&quot;&#125;</span><br><span class="line">The stdin plugin is now waiting for input:</span><br><span class="line">[2022-10-02T17:09:07,966][INFO ][logstash.agent           ] Pipelines running &#123;:count=&gt;1, :running_pipelines=&gt;[:main], :non_running_pipelines=&gt;[]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入 hello world 返回结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">&#123;</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">       &quot;message&quot; =&gt; &quot;hello world&quot;,</span><br><span class="line">         &quot;event&quot; =&gt; &#123;</span><br><span class="line">        &quot;original&quot; =&gt; &quot;hello world&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">          &quot;host&quot; =&gt; &#123;</span><br><span class="line">        &quot;hostname&quot; =&gt; &quot;elk1-2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2022-10-02T09:09:37.414736483Z</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="修改-Logstash-配置文件"><a href="#修改-Logstash-配置文件" class="headerlink" title="修改 Logstash 配置文件"></a>修改 Logstash 配置文件</h3><p>创建存放自定义输入输出的配置目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/logstash-8.4.1/conf.d/*.conf</span><br></pre></td></tr></table></figure>



<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#logstash动态加载的配置文件，所有自定义的输入、输出和过滤配置都放置在这个目录中并以.conf结尾</span></span><br><span class="line"><span class="attr">path.config:</span> <span class="string">/opt/logstash-8.4.1/conf.d/*.conf</span></span><br></pre></td></tr></table></figure>



<h3 id="创建对接-filebeat-的配置文件并测试"><a href="#创建对接-filebeat-的配置文件并测试" class="headerlink" title="创建对接 filebeat 的配置文件并测试"></a>创建对接 filebeat 的配置文件并测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [&quot;http://0.0.0.0:9200&quot;]</span><br><span class="line">    index =&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用以下命令，测试配置文件是否异常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/logstash-8.4.1</span><br><span class="line">bin/logstash -f /opt/logstash-8.4.1/conf.d/filebeat.conf --config.test_and_exit</span><br></pre></td></tr></table></figure>

<p>输出如下表示配置文件正常：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2022-10-03T19:51:05,381][INFO ][logstash.javapipeline    ] Pipeline `main` is configured with `pipeline.ecs_compatibility: v8` setting. All plugins in this pipeline will default to `ecs_compatibility =&gt; v8` unless explicitly configured otherwise.</span><br><span class="line">Configuration OK</span><br><span class="line">[2022-10-03T19:51:05,382][INFO ][logstash.runner          ] Using config.test_and_exit mode. Config Validation Result: OK. Exiting Logstash</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：logstash -f &lt;文件&gt; 这里文件不能使用相对路径，最好如上命令，使用绝对路径。否则输出日志中报错如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2022-10-03T19:50:02,895][INFO ][logstash.config.source.local.configpathloader] No config files found in path &#123;:path=&gt;&quot;/opt/logstash-8.4.1/logstash-8.4.1/conf.d/filebeat.conf&quot;&#125;</span><br><span class="line">[2022-10-03T19:50:02,900][ERROR][logstash.config.sourceloader] No configuration found in the configured sources.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="使用创建的-filebeat-文件启动-Logstash"><a href="#使用创建的-filebeat-文件启动-Logstash" class="headerlink" title="使用创建的 filebeat 文件启动 Logstash"></a>使用创建的 filebeat 文件启动 Logstash</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/logstash-8.4.1/bin/logstash -f /opt/logstash-8.4.1/conf.d/filebeat.conf &amp;</span><br></pre></td></tr></table></figure>

<p>启动后，检查 5044 端口是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -nltp |grep 5044</span><br></pre></td></tr></table></figure>



<h2 id="2-5-在应用服务器上安装-filebeat-并与-Logstash-通信"><a href="#2-5-在应用服务器上安装-filebeat-并与-Logstash-通信" class="headerlink" title="2.5.  在应用服务器上安装 filebeat 并与 Logstash 通信"></a>2.5.  在应用服务器上安装 filebeat 并与 Logstash 通信</h2><h3 id="下载-tar-gz-安装包，并解压安装-3"><a href="#下载-tar-gz-安装包，并解压安装-3" class="headerlink" title="下载 .tar.gz 安装包，并解压安装"></a>下载 <code>.tar.gz</code> 安装包，并解压安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf filebeat-8.4.1-linux-x86_64.tar.gz -C /opt/</span><br></pre></td></tr></table></figure>



<h3 id="修改-filebeat-配置"><a href="#修改-filebeat-配置" class="headerlink" title="修改 filebeat 配置"></a>修改 filebeat 配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ============================== Filebeat inputs ======</span></span><br><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filestream is an input for collecting log messages from files.</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">filestream</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Unique ID among all inputs, an ID is required.</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">my-filestream-id-003</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Change to true to enable this input configuration.</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Paths that should be crawled and fetched. Glob based paths.</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/*.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================= Elasticsearch template setting =======================</span></span><br><span class="line"></span><br><span class="line"><span class="attr">setup.template.settings:</span></span><br><span class="line">  <span class="attr">index.number_of_shards:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================================== Kibana ===================================</span></span><br><span class="line"><span class="comment"># This requires a Kibana endpoint configuration.</span></span><br><span class="line"><span class="attr">setup.kibana:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Kibana Host</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">&quot;10.12.1.84:5601&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------ Logstash Output -------------------------------</span></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="comment"># The Logstash hosts</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;10.12.1.84:5044&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改以上几个部分的内容，Output 部分因为我们是使用 filebeat -&gt; Logstash 的形式，所以 Elasticsearch Output 部分的注释不打开。</p>
<blockquote>
<p>上面配置文件内容，详细信息参考 <a href="https://www.elastic.co/guide/en/beats/filebeat/current/configuring-howto-filebeat.html">Filebeat 官方文档的配置文件说明部分</a></p>
<p>其中，Inputs , Output  部分与数据搜集和输出有关。</p>
</blockquote>
<h3 id="启动-filebeat"><a href="#启动-filebeat" class="headerlink" title="启动 filebeat"></a>启动 filebeat</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/filebeat-8.4.1-linux-x86_64</span><br><span class="line">./filebeat -e -c /opt/filebeat-8.4.1-linux-x86_64/filebeat.yml &gt; logs/filebeat-2022100102.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>当日志出现如下与 Logstash 建立连接的日志内容时，表示 filebeat 搜集的内容可以发送到 Logstash 上了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filebeat 启动成功的日志，有与logstash的连接日志</span></span><br><span class="line"></span><br><span class="line">&#123;&quot;log.level&quot;:&quot;info&quot;,&quot;@timestamp&quot;:&quot;2022-10-01T21:20:27.899+0800&quot;,&quot;log.logger&quot;:&quot;publisher_pipeline_output&quot;,&quot;log.origin&quot;:&#123;&quot;file.name&quot;:&quot;pipeline/client_worker.go&quot;,&quot;file.line&quot;:139&#125;,&quot;message&quot;:&quot;Connecting to backoff(async(tcp://10.12.1.84:5044))&quot;,&quot;service.name&quot;:&quot;filebeat&quot;,&quot;ecs.version&quot;:&quot;1.6.0&quot;&#125;</span><br><span class="line">&#123;&quot;log.level&quot;:&quot;info&quot;,&quot;@timestamp&quot;:&quot;2022-10-01T21:20:27.900+0800&quot;,&quot;log.logger&quot;:&quot;publisher_pipeline_output&quot;,&quot;log.origin&quot;:&#123;&quot;file.name&quot;:&quot;pipeline/client_worker.go&quot;,&quot;file.line&quot;:147&#125;,&quot;message&quot;:&quot;Connection to backoff(async(tcp://10.12.1.84:5044)) established&quot;,&quot;service.name&quot;:&quot;filebeat&quot;,&quot;ecs.version&quot;:&quot;1.6.0&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>没有上面建立连接的信息，则 filebeat 无法将内容发到 Logstash 中。</p>
<h1 id="3-配置-Kibana-可视化"><a href="#3-配置-Kibana-可视化" class="headerlink" title="3. 配置 Kibana 可视化"></a>3. 配置 Kibana 可视化</h1><p>登录 Kibana UI，例如，<code>http://10.12.1.84:5601</code></p>
<p>创建一个 <code>Data View</code></p>
<p>添加索引</p>
<p>然后在 <code>Discover</code> 页面中查看通过 Filebeat 搜集经 Logstash 发送到 Elasticsearch 中的数据。</p>
<p>（这里需要截图，后面搞定图片存放再补充。）</p>
<h2 id="安装参考链接"><a href="#安装参考链接" class="headerlink" title="安装参考链接"></a>安装参考链接</h2><ul>
<li><a href="https://www.codeleading.com/article/7222941493/">Centos7.6 Install ELK 离线安装</a></li>
</ul>
<h1 id="4-部署中解决或未解决的问题"><a href="#4-部署中解决或未解决的问题" class="headerlink" title="4. 部署中解决或未解决的问题"></a>4. 部署中解决或未解决的问题</h1><h3 id="1-配置-Elasticsearch-并启动服务后，测试服务状态时，请求失败"><a href="#1-配置-Elasticsearch-并启动服务后，测试服务状态时，请求失败" class="headerlink" title="1. 配置 Elasticsearch 并启动服务后，测试服务状态时，请求失败"></a>1. 配置 Elasticsearch 并启动服务后，测试服务状态时，请求失败</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[es@elk1-2 elasticsearch-8.4.1]$ curl localhost:9200</span><br><span class="line">curl: (52) Empty reply from server</span><br></pre></td></tr></table></figure>

<p>查看日志，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2022-09-30T12:41:36,122][WARN ][o.e.x.s.t.n.SecurityNetty4HttpServerTransport] [es-server] received plaintext http traffic on an https channel, closing connection Netty4HttpChannel&#123;localAddress=/[0:0:0:0:0:0:0:1]:9200, remoteAddress=/[0:0:0:0:0:0:0:1]:34442&#125;</span><br><span class="line">[2022-09-30T12:49:25,975][WARN ][o.e.x.s.t.n.SecurityNetty4HttpServerTransport] [es-server] received plaintext http traffic on an https channel, closing connection Netty4HttpChannel&#123;localAddress=/127.0.0.1:9200, remoteAddress=/127.0.0.1:47816&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong></p>
<p>Elasticsearch 启动时默认配置并启用了一些安全特性。</p>
<p>从下面配置可知，自动配置以下安全配置：</p>
<ul>
<li>Authentication and authorization are enabled, and a password is generated for the <code>elastic</code> built-in superuser.</li>
<li>Certificates and keys for TLS are generated for the transport and HTTP layer, and TLS is enabled and configured with these keys and certificates.</li>
<li>An enrollment token is generated for Kibana, which is valid for 30 minutes.</li>
</ul>
<p><strong>解决方法：</strong></p>
<p>1.继续使用 http 访问</p>
<p>修改 elasticsearch.yml 配置文件，把安全认证开关从原先的 true 改为 false，实现免密登录。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Enable encryption for HTTP API client connections, such as Kibana, Logstash, and Agents</span></span><br><span class="line"><span class="attr">xpack.security.http.ssl:</span></span><br><span class="line">  <span class="comment">#enabled: true</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">keystore.path:</span> <span class="string">certs/http.p12</span></span><br></pre></td></tr></table></figure>

<p>保存并重启，重新访问就正常了。</p>
<p>2.利用本地证书，使用 https 请求</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --cacert /opt/elasticsearch-8.4.1/config/certs/http_ca.crt -u elastic https://localhost:9200</span><br><span class="line">Enter host password for user &#x27;elastic&#x27;:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入elastic 密码</p>
<p>该密码在服务初始启动时会打印在日志中，如果没有该密码，可以通过下面的命令重设密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/elasticsearch-8.4.1/bin/elasticsearch-reset-password -u elastic</span><br></pre></td></tr></table></figure>

<p>该命令会自动生成一个随机密码。</p>
<p>参考如下链接</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.4/targz.html#targz-running">Run Elasticsearch from the command line</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.4/targz.html#_check_that_elasticsearch_is_running">Check that Elasticsearch is running</a></li>
</ul>
<h3 id="2-java-net-UnknownHostException-geoip-elastic-co"><a href="#2-java-net-UnknownHostException-geoip-elastic-co" class="headerlink" title="2. java.net.UnknownHostException: geoip.elastic.co"></a>2. java.net.UnknownHostException: geoip.elastic.co</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2022-10-03T19:28:31,010][ERROR][o.e.i.g.GeoIpDownloader  ] [es-server] exception during geoip databases update</span><br><span class="line">java.net.UnknownHostException: geoip.elastic.co</span><br><span class="line">        at sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:564) ~[?:?]</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[?:?]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>修改 elasticsearch.yml  配置文件，添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ingest.geoip.downloader.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<p>参考如下链接<a href="https://discuss.elastic.co/t/how-to-disable-geoip-usage-in-7-14-0/281076">How to disable geoip usage in 7.14.0</a></p>
<h3 id="3-如何通过日志查看是否有数据在传输"><a href="#3-如何通过日志查看是否有数据在传输" class="headerlink" title="3. 如何通过日志查看是否有数据在传输"></a>3. 如何通过日志查看是否有数据在传输</h3><p>当执行 filebeat 输出到 logstash 时，查看 filebeat 日志内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filebeat 产生的日志是 json 格式：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面两条表示连接到 logstash 了。</span></span><br><span class="line">&#123;&quot;log.level&quot;:&quot;info&quot;,&quot;@timestamp&quot;:&quot;2022-10-14T17:58:08.696+0800&quot;,&quot;log.logger&quot;:&quot;publisher_pipeline_output&quot;,&quot;log.origin&quot;:&#123;&quot;file.name&quot;:&quot;pipeline/client_worker.go&quot;,&quot;file.line&quot;:139&#125;,&quot;message&quot;:&quot;Connecting to backoff(async(tcp://10.12.1.84:5044))&quot;,&quot;service.name&quot;:&quot;filebeat&quot;,&quot;ecs.version&quot;:&quot;1.6.0&quot;&#125;</span><br><span class="line">&#123;&quot;log.level&quot;:&quot;info&quot;,&quot;@timestamp&quot;:&quot;2022-10-14T17:58:08.698+0800&quot;,&quot;log.logger&quot;:&quot;publisher_pipeline_output&quot;,&quot;log.origin&quot;:&#123;&quot;file.name&quot;:&quot;pipeline/client_worker.go&quot;,&quot;file.line&quot;:147&#125;,&quot;message&quot;:&quot;Connection to backoff(async(tcp://10.12.1.84:5044)) established&quot;,&quot;service.name&quot;:&quot;filebeat&quot;,&quot;ecs.version&quot;:&quot;1.6.0&quot;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面这条日志重点关注 <span class="string">&quot;output&quot;</span> key，关注其中的 <span class="string">&quot;acked&quot;</span> key，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如下 <span class="string">&quot;acked&quot;</span>:147456，表示响应的数据条数。</span></span><br><span class="line">&#123;&quot;log.level&quot;:&quot;info&quot;,&quot;@timestamp&quot;:&quot;2022-10-14T17:58:38.564+0800&quot;,&quot;log.logger&quot;:&quot;monitoring&quot;,&quot;log.origin&quot;:&#123;&quot;file.name&quot;:&quot;log/log.go&quot;,&quot;file.line&quot;:185&#125;,&quot;message&quot;:&quot;Non-zero metrics in the last 30s&quot;,&quot;service.name&quot;:&quot;filebeat&quot;,&quot;monitoring&quot;:&#123;&quot;metrics&quot;:&#123;&quot;beat&quot;:&#123;&quot;cpu&quot;:&#123;&quot;system&quot;:&#123;&quot;ticks&quot;:470,&quot;time&quot;:&#123;&quot;ms&quot;:470&#125;&#125;,&quot;total&quot;:&#123;&quot;ticks&quot;:17010,&quot;time&quot;:&#123;&quot;ms&quot;:17010&#125;,&quot;value&quot;:17010&#125;,&quot;user&quot;:&#123;&quot;ticks&quot;:16540,&quot;time&quot;:&#123;&quot;ms&quot;:16540&#125;&#125;&#125;,&quot;handles&quot;:&#123;&quot;limit&quot;:&#123;&quot;hard&quot;:4096,&quot;soft&quot;:1024&#125;,&quot;open&quot;:20&#125;,&quot;info&quot;:&#123;&quot;ephemeral_id&quot;:&quot;b1935073-06a5-4778-8f9a-ece8512390e8&quot;,&quot;name&quot;:&quot;filebeat&quot;,&quot;uptime&quot;:&#123;&quot;ms&quot;:30459&#125;,&quot;version&quot;:&quot;8.4.1&quot;&#125;,&quot;memstats&quot;:&#123;&quot;gc_next&quot;:112098048,&quot;memory_alloc&quot;:101215976,&quot;memory_sys&quot;:138514456,&quot;memory_total&quot;:1651565976,&quot;rss&quot;:218279936&#125;,&quot;runtime&quot;:&#123;&quot;goroutines&quot;:54&#125;&#125;,&quot;filebeat&quot;:&#123;&quot;events&quot;:&#123;&quot;active&quot;:4117,&quot;added&quot;:151573,&quot;done&quot;:147456&#125;,&quot;harvester&quot;:&#123;&quot;open_files&quot;:0,&quot;running&quot;:0&#125;&#125;,&quot;libbeat&quot;:&#123;&quot;config&quot;:&#123;&quot;module&quot;:&#123;&quot;running&quot;:0&#125;,&quot;reloads&quot;:1,&quot;scans&quot;:1&#125;,&quot;output&quot;:&#123;&quot;events&quot;:&#123;&quot;acked&quot;:147456,&quot;active&quot;:4096,&quot;batches&quot;:74,&quot;total&quot;:151552&#125;,&quot;read&quot;:&#123;&quot;bytes&quot;:432&#125;,&quot;type&quot;:&quot;logstash&quot;,&quot;write&quot;:&#123;&quot;bytes&quot;:7930871&#125;&#125;,&quot;pipeline&quot;:&#123;&quot;clients&quot;:8,&quot;events&quot;:&#123;&quot;active&quot;:4117,&quot;published&quot;:151572,&quot;retry&quot;:2048,&quot;total&quot;:151573&#125;,&quot;queue&quot;:&#123;&quot;acked&quot;:147456,&quot;max_events&quot;:4096&#125;&#125;&#125;,&quot;registrar&quot;:&#123;&quot;states&quot;:&#123;&quot;current&quot;:0&#125;&#125;,&quot;system&quot;:&#123;&quot;cpu&quot;:&#123;&quot;cores&quot;:4&#125;,&quot;load&quot;:&#123;&quot;1&quot;:0.41,&quot;15&quot;:0.09,&quot;5&quot;:0.16,&quot;norm&quot;:&#123;&quot;1&quot;:0.1025,&quot;15&quot;:0.0225,&quot;5&quot;:0.04&#125;&#125;&#125;&#125;,&quot;ecs.version&quot;:&quot;1.6.0&quot;&#125;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里也同样关注 <span class="string">&quot;output&quot;</span> 的 <span class="string">&quot;acked&quot;</span> 的值，这里为 2 条。</span></span><br><span class="line">&#123;&quot;log.level&quot;:&quot;info&quot;,&quot;@timestamp&quot;:&quot;2022-10-14T18:00:08.564+0800&quot;,&quot;log.logger&quot;:&quot;monitoring&quot;,&quot;log.origin&quot;:&#123;&quot;file.name&quot;:&quot;log/log.go&quot;,&quot;file.line&quot;:185&#125;,&quot;message&quot;:&quot;Non-zero metrics in the last 30s&quot;,&quot;service.name&quot;:&quot;filebeat&quot;,&quot;monitoring&quot;:&#123;&quot;metrics&quot;:&#123;&quot;beat&quot;:&#123;&quot;cpu&quot;:&#123;&quot;system&quot;:&#123;&quot;ticks&quot;:580&#125;,&quot;total&quot;:&#123;&quot;ticks&quot;:20380,&quot;time&quot;:&#123;&quot;ms&quot;:10&#125;,&quot;value&quot;:20380&#125;,&quot;user&quot;:&#123;&quot;ticks&quot;:19800,&quot;time&quot;:&#123;&quot;ms&quot;:10&#125;&#125;&#125;,&quot;handles&quot;:&#123;&quot;limit&quot;:&#123;&quot;hard&quot;:4096,&quot;soft&quot;:1024&#125;,&quot;open&quot;:20&#125;,&quot;info&quot;:&#123;&quot;ephemeral_id&quot;:&quot;b1935073-06a5-4778-8f9a-ece8512390e8&quot;,&quot;uptime&quot;:&#123;&quot;ms&quot;:120458&#125;,&quot;version&quot;:&quot;8.4.1&quot;&#125;,&quot;memstats&quot;:&#123;&quot;gc_next&quot;:80603264,&quot;memory_alloc&quot;:58914664,&quot;memory_total&quot;:1957563536,&quot;rss&quot;:219148288&#125;,&quot;runtime&quot;:&#123;&quot;goroutines&quot;:54&#125;&#125;,&quot;filebeat&quot;:&#123;&quot;events&quot;:&#123;&quot;active&quot;:6,&quot;added&quot;:8,&quot;done&quot;:2&#125;,&quot;harvester&quot;:&#123;&quot;open_files&quot;:0,&quot;running&quot;:0&#125;&#125;,&quot;libbeat&quot;:&#123;&quot;config&quot;:&#123;&quot;module&quot;:&#123;&quot;running&quot;:0&#125;&#125;,&quot;output&quot;:&#123;&quot;events&quot;:&#123;&quot;acked&quot;:2,&quot;active&quot;:0,&quot;batches&quot;:1,&quot;total&quot;:2&#125;,&quot;read&quot;:&#123;&quot;bytes&quot;:6&#125;,&quot;write&quot;:&#123;&quot;bytes&quot;:859&#125;&#125;,&quot;pipeline&quot;:&#123;&quot;clients&quot;:8,&quot;events&quot;:&#123;&quot;active&quot;:6,&quot;published&quot;:8,&quot;total&quot;:8&#125;,&quot;queue&quot;:&#123;&quot;acked&quot;:2&#125;&#125;&#125;,&quot;registrar&quot;:&#123;&quot;states&quot;:&#123;&quot;current&quot;:0&#125;&#125;,&quot;system&quot;:&#123;&quot;load&quot;:&#123;&quot;1&quot;:0.19,&quot;15&quot;:0.1,&quot;5&quot;:0.18,&quot;norm&quot;:&#123;&quot;1&quot;:0.0475,&quot;15&quot;:0.025,&quot;5&quot;:0.045&#125;&#125;&#125;&#125;,&quot;ecs.version&quot;:&quot;1.6.0&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <strong>acked</strong> 的值持续为 0 ，filebeat 一段时间后就会断开与 logstash 的连接。直到重新检测到数据。 </p>
]]></content>
      <categories>
        <category>运维</category>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>日志分析</tag>
        <tag>logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>zabbix使用</title>
    <url>//zabbix%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="Zabbix-Web登录页面忘记Admin登录密码重置"><a href="#Zabbix-Web登录页面忘记Admin登录密码重置" class="headerlink" title="Zabbix Web登录页面忘记Admin登录密码重置"></a>Zabbix Web登录页面忘记Admin登录密码重置</h1><p>Zabbix 忘记Admin登录密码</p>
<img src="\imgs\zabbix-web" alt="image-20220910122242714" style="zoom:50%;" />

<p><strong>解决问题</strong></p>
<p>总体思路，更新mysql中user表的Admin用户的密码。</p>
<p>1 连接zabbix 的mysql数据库；</p>
<p>2 进入 zabbix 库，然后查询users表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use zabbix;</span><br><span class="line"><span class="keyword">select</span> userid,alias,passwd <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">--------+-------+--------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> userid <span class="operator">|</span> alias <span class="operator">|</span> passwd                                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+--------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span> Admin <span class="operator">|</span> $<span class="number">2</span>y$<span class="number">10</span>$NKGS97URtO2SMRCE6T4h5OuRg5B6Vrq6hv73tBu4ZGrX4wDw36qEi <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span> guest <span class="operator">|</span> $<span class="number">2</span>y$<span class="number">10</span>$<span class="number">89</span>otZrRNmde97rIyzclecuk6LwKAsHN0BcvoOKGjbT.BwMBfm7G06 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+--------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>3 为Admin生产一个新的md5密码，admin是密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@67636a2916d6:/# echo -n admin | openssl md5</span><br><span class="line">(stdin)= 21232f297a57a5a743894a0e4a801fc3</span><br><span class="line">root@67636a2916d6:/#</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4 更新userid&#x3D;1的密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> passwd<span class="operator">=</span><span class="string">&#x27;21232f297a57a5a743894a0e4a801fc3&#x27;</span> <span class="keyword">where</span> userid<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>5 重新加载权限表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>6 可用更新后的Admin&#x2F;admin 登录zabbix 的web；</p>
<blockquote>
<p>方法二，zabbix 默认用户名Admin，默认密码zabbix，</p>
<p>步骤3中使用下面语句更新userid&#x3D;1的密码为zabbix；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> passwd<span class="operator">=</span><span class="string">&#x27;5fce1b3e34b520afeffb37ce08c7cd66&#x27;</span> <span class="keyword">where</span> userid<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>解释：zabbix的md5值-为，<code>5fce1b3e34b520afeffb37ce08c7cd66</code></p>
</blockquote>
<h1 id="Zabbix-告警及解决过程"><a href="#Zabbix-告警及解决过程" class="headerlink" title="Zabbix 告警及解决过程"></a>Zabbix 告警及解决过程</h1><h2 id="1-zabbix-proxy-日志报错cannot-send-list-of-active-checks-to-“10-100-3-10”-host-10-100-3-60-not-found"><a href="#1-zabbix-proxy-日志报错cannot-send-list-of-active-checks-to-“10-100-3-10”-host-10-100-3-60-not-found" class="headerlink" title="1. zabbix proxy 日志报错cannot send list of active checks to “10.100.3.10”: host [10.100.3.60] not found"></a>1. zabbix proxy 日志报错cannot send list of active checks to “10.100.3.10”: host [10.100.3.60] not found</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">403:20221021:060755.665 cannot send list of active checks to &quot;10.100.3.10&quot;: host [10.100.3.60] not found</span><br><span class="line"> 399:20221021:060804.003 cannot send list of active checks to &quot;10.100.3.27&quot;: host [10.100.3.56] not found</span><br><span class="line"> 401:20221021:060823.654 cannot send list of active checks to &quot;10.100.3.35&quot;: host [10.100.3.61] not found</span><br></pre></td></tr></table></figure>

<p>从上面报错发现这三个节点agent的配置与实际不相符。分别登录查看其 <code>/etc/zabbix/zabbix_agentd.conf</code> 配置文件。</p>
<p>查看后发现配置文件中 <code>Hostname</code> 字段配置的确实与实际IP不一致，修改配置文件并重启服务。</p>
<h2 id="2-zabbix-proxy-日志中报错cannot-send-list-of-active-checks-to-“10-100-3-27”-host-10-100-3-27-not-found"><a href="#2-zabbix-proxy-日志中报错cannot-send-list-of-active-checks-to-“10-100-3-27”-host-10-100-3-27-not-found" class="headerlink" title="2. zabbix proxy 日志中报错cannot send list of active checks to “10.100.3.27”: host [10.100.3.27] not found"></a>2. zabbix proxy 日志中报错cannot send list of active checks to “10.100.3.27”: host [10.100.3.27] not found</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">401:20221021:064308.089 cannot send list of active checks to &quot;10.100.3.27&quot;: host [10.100.3.27] not found</span><br></pre></td></tr></table></figure>

<p>这个报错是因为该节点配置了 zabbix agent ，但是zabbix server 的 web 页面没有添加对应的主机配置。</p>
<p>登录 web ，添加该节点的主机配置即可。</p>
<h2 id="3-监控页面告警-Zabbix-agent-is-not-available-or-nodata-for-30m"><a href="#3-监控页面告警-Zabbix-agent-is-not-available-or-nodata-for-30m" class="headerlink" title="3. 监控页面告警 Zabbix agent is not available (or nodata for 30m)"></a>3. 监控页面告警 Zabbix agent is not available (or nodata for 30m)</h2><p>查看 zabbix web 页面有告警</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Zabbix agent is not available (or nodata for 30m)</span><br></pre></td></tr></table></figure>

<p>登录该节点查看 agent 日志，发现如下报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">17668:20221021:135647.898 active check configuration update from [10.100.3.62:10051] started to fail (ZBX_TCP_READ() timed out)</span><br></pre></td></tr></table></figure>

<p>检查确认其他配置没有问题后，可能是因为默认超时时间太短（默认客户端连接 proxy 的超时时间为 3秒），修改为 30 秒，然后重启 zabbix-agent 服务即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/zabbix/zabbix_agentd.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果有该参数就修改，没有改参数就添加。该参数支持的范围为：1-30，默认为3</span></span><br><span class="line">Timeout=30</span><br></pre></td></tr></table></figure>

<p>重启 zabbix-agent 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart zabbix-agent</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.zabbix.com/documentation/5.0/en/manual/appendix/config/zabbix_agentd">zabbix-agent参数</a></p>
]]></content>
      <categories>
        <category>运维</category>
        <category>监控工具</category>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>监控工具</tag>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Confluence安装</title>
    <url>//Confluence%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>运维</category>
        <category>运维工具</category>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>运维工具</tag>
        <tag>Confluence</tag>
        <tag>Wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>现场Ansible常用命令</title>
    <url>//%E7%8E%B0%E5%9C%BAAnsible%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<h1 id="ansible-常用命令"><a href="#ansible-常用命令" class="headerlink" title="ansible 常用命令"></a>ansible 常用命令</h1><ol>
<li>ansible -i hosts new_servers -m copy -a “src&#x3D;&#x2F;etc&#x2F;rc.d&#x2F;rc.local dest&#x3D;&#x2F;etc&#x2F;rc.d&#x2F;rc.local”</li>
</ol>
<h1 id="ansible-使用时的注意事项"><a href="#ansible-使用时的注意事项" class="headerlink" title="ansible 使用时的注意事项"></a>ansible 使用时的注意事项</h1><ol>
<li>ansible 是基于 ssh 的，所以部分特殊字符使用时需要添加转义符。<ul>
<li>例如，<code>$</code> -&gt; <code>\$</code>，如果使用的是shell模块，则<code>!</code>符号也需要转义；</li>
</ul>
</li>
<li>在使用账户密码登录的时候，密码部分遇到<code>!</code>符号不需要转义，但是遇到<code>#</code>符号需要转义；<ul>
<li>例如，<code>ansible_ssh_pass=XZServer2022!\#%</code></li>
</ul>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
        <category>运维工具</category>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>运维工具</tag>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡LVS+Nginx</title>
    <url>//%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1LVS+Nginx.html</url>
    <content><![CDATA[<h1 id="负载均衡LVS-x2F-Nginx-x2F-Keepalived-x2F-HAProxy"><a href="#负载均衡LVS-x2F-Nginx-x2F-Keepalived-x2F-HAProxy" class="headerlink" title="负载均衡LVS&#x2F;Nginx&#x2F;Keepalived&#x2F;HAProxy"></a>负载均衡LVS&#x2F;Nginx&#x2F;Keepalived&#x2F;HAProxy</h1><p>问题：</p>
<ol>
<li>使用负载均衡，<ul>
<li>后台web服务器是否要部署多台？</li>
<li>那么数据库如何处理？<ul>
<li>是单独的？还是统一的？</li>
<li>如果是单独的，数据如何同步？</li>
<li>如果是统一的，性能如何提升？</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h3><p>keepalived是集群管理中保证集群<code>高可用</code>的一个服务软件，用来防止单点故障。</p>
<p><code>负载均衡</code>： loadbalancing，负载均衡实现需要依赖Linux的IPVS模块（IP虚拟服务器，用于实现网络服务的负载均衡）<br><code>高可用</code>： 高可用是通过<code>VRRP协议</code>（虚拟路由冗余协议）实现多台机器之间的故障转移</p>
<pre><code>通过`heatbeat + failover`达到高可用的目的
- 在多个keepalived节点直接相关监控心跳heatbeat
- 当master出现问题时，将backup作为master继续工作，即为failover
</code></pre>
<p>keepalived架构中，两个重要的组成模块：</p>
<ul>
<li>Checkers模块：负责真实服务器的健康检查healthchecking，是keepalived最主要的功能。换言之，可以没有VRRP Stack，但健康检查healthchecking是一定要有的。</li>
<li>VRRP Stack模块：负载负载均衡器之间的失败切换FailOver，如果只用一个负载均衡器，则VRRP不是必须的。</li>
</ul>
<p>另外：</p>
<ul>
<li>Netlink Reflector：用来设定vrrp的vip地址等，<ul>
<li>常可以在日志中看到，Netlink reflector reports IP xxx added,表明已经绑定VIP xxx 了。</li>
</ul>
</li>
</ul>
<ol>
<li>安装</li>
<li><strong>配置</strong><ul>
<li>keepalived.conf，安装完成后最重要的就是在该文件中配置<code>HA</code>和<code>负载均衡</code></li>
<li>主要包含三块：全局定义块、VRRP实例定义块和虚拟服务器定义块</li>
<li>全局定义块是必须的，</li>
<li>如果keepalived只用来做ha，虚拟服务器是可选的</li>
</ul>
</li>
<li>设置服务和开机自启</li>
</ol>
<p>问题：在keepalived.conf配置文件中，这里是什么意思？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这里设置VRID，相同的VRID为一个组，他将决定多播的MAC地址</span><br><span class="line">    virtual_router_id 51</span><br></pre></td></tr></table></figure>

<p>vrrp_instance的设置注意点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置不抢占，这里只能设置在state为backup的节点上，而且这个节点的优先级必须比另外的高</span><br><span class="line">#    nopreempt</span><br></pre></td></tr></table></figure>


<p>Keepalived的一个难点，可能是双主节点时，节点权限设置，防止出现vip随便飘移故障</p>
<p>目前看到的都是用Keepalived做HA，并有利用其做负载均衡的，那么 virtual_server 目前并没有用到，怎么用？</p>
<p>问题：<br>设置了nopreempt参数，导致不抢占了怎么办？<br>    - 猜测是，当Keepalived所在机器上被监控的进程出现故障，就停止Keepalived服务，这样即使另一台Keepalived机器设置了nopreempt，也会因为主keepalived停用，而自动接管？<br>        - 明天可以测试一下</p>
<p>什么是默认路由</p>
<p>问题：linux下，如何将自己的程序做成服务模式，方便启动和关闭</p>
<ol>
<li><p>&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F; 的作用？  &#x2F;etc&#x2F;init.d 是该目录的软连接，如果需要将某命令添加到开机自启，需要确保&#x2F;etc&#x2F;rc.d&#x2F;init.d目录下有该命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig --add keepalived      #添加时必须保证/etc/init.d/keepalived存在</span><br><span class="line"></span><br><span class="line">chkconfig keepalived on</span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x2F;etc&#x2F;sysconfig&#x2F;的作用？ </p>
</li>
<li><p>&#x2F;usr&#x2F;sbin&#x2F;的作用？</p>
</li>
</ol>
<h1 id="Mysql主从复制，读写分离"><a href="#Mysql主从复制，读写分离" class="headerlink" title="Mysql主从复制，读写分离"></a>Mysql主从复制，读写分离</h1>]]></content>
      <categories>
        <category>运维</category>
        <category>运维工具</category>
        <category>LVS</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>运维工具</tag>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title>Actix使用</title>
    <url>//Actix%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p>有 bin 文件时，如何运行 bin 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo run -p webservice --bin server1</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入指定项目目录下</span></span><br><span class="line">cd webservice </span><br><span class="line">cargo run --bin server1</span><br></pre></td></tr></table></figure>



<p>当任何数据类型在 actix 中注册之后，就可以在 handler 中注入了。</p>
<p><code>web::Data&lt;数据类型&gt;</code></p>
<h1 id="Actix-Web-把错误转化为-HTTP-Response"><a href="#Actix-Web-把错误转化为-HTTP-Response" class="headerlink" title="Actix-Web 把错误转化为 HTTP Response"></a>Actix-Web 把错误转化为 HTTP Response</h1><p>Actix-Web 定义了一个通用的错误类型（struct）：</p>
<ul>
<li><code>Actix_web::error::Error</code><ul>
<li>它实现了 <code>std::error::Error</code> 这个 trait</li>
</ul>
</li>
<li>任何实现了 标准库 Error trait 的类型，都可以通过 ？ 运算符，转化为 Actix 的 Error 类型，</li>
<li>Actix 的 Error 类型会自动转化为 HTTP Response，返回给客户端。</li>
<li>ResponseError trait： 任何实现该 trait 的错误均可转化为 HTTP Response 消息。</li>
<li>内置的实现： Actix-Web 对于常见错误有内置的实现，例如：<ul>
<li>Rust 标准 I&#x2F;O 错误；</li>
<li>Serde 错误；</li>
<li>Web 错误，例如： ProtocolError，Uft8Error，ParseError 等等；</li>
</ul>
</li>
<li>其他错误类型：内置实现不可用时，需要自定义实现错误到 HTTP Response 的转换。</li>
</ul>
<h3 id="创建自定义错误处理器"><a href="#创建自定义错误处理器" class="headerlink" title="创建自定义错误处理器"></a>创建自定义错误处理器</h3><ol>
<li>创建一个自定义错误类型（struct&#x2F;enum）；</li>
<li>实现 From trait，用于把其他错误类型转化为该类型；</li>
<li>为自定义错误类型实现 ResponseError trait；</li>
<li>在 handler 里返回自定义错误类型；</li>
<li>Actix 会把错误转化为 HTTP 响应。</li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust小项目练习</category>
        <category>rust_web</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust小项目练习</tag>
        <tag>rust_web</tag>
      </tags>
  </entry>
  <entry>
    <title>REST API 相关内容</title>
    <url>//REST%20API%20%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9.html</url>
    <content><![CDATA[<h1 id="构建-REST-API"><a href="#构建-REST-API" class="headerlink" title="构建 REST API"></a>构建 REST API</h1><p> 需要使用的 crate</p>
<ul>
<li>serde<ul>
<li>序列化和反序列化</li>
</ul>
</li>
<li>chrono<ul>
<li>时间相关的处理</li>
<li>Date and time library for Rust</li>
</ul>
</li>
</ul>
<h2 id="构建内容"><a href="#构建内容" class="headerlink" title="构建内容"></a>构建内容</h2><ul>
<li>POST:  &#x2F;courses<ul>
<li>获取所有课程信息</li>
</ul>
</li>
<li>GET: &#x2F;courses&#x2F;teacher_id<ul>
<li>获取老师教的所有课程</li>
</ul>
</li>
<li>GET: &#x2F;courses&#x2F;teacher_id&#x2F;course_id<ul>
<li>或者指定课程的详细信息</li>
</ul>
</li>
</ul>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>bin&#x2F;teacher-service.rs</li>
<li>models.rs</li>
<li>state.rs<ul>
<li>应用程序的状态</li>
<li>一般情况下都存在数据库中，这里例子中放在内存中。</li>
</ul>
</li>
<li>routers.rs</li>
<li>handlers.rs</li>
</ul>
<p>Rust 代码中，部分类型构建参数时，会使用 <code>(T)</code> 的形式，看起来没有必要，同时在当前编译器中会给出警告，</p>
<ul>
<li>这里我理解就是为了利用 rust 的自动提取的特性，将包装类中的类型直接提取出来使用。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数定义中：</span></span><br><span class="line">app_state: web::Data&lt;AppState&gt;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际使用中：</span></span><br><span class="line">app_state.courses <span class="comment">// 这里直接将 app_state 当做 AppState 类型来使用。</span></span><br></pre></td></tr></table></figure>

<p>如何定义单个元素的元组？</p>
<ul>
<li>解：<code>(usize,)</code> 在单个类型后面添加一个 <code>,</code> 逗号。</li>
<li>否则，rust 编译器会认为 usize 两边的括号是多余的，会告警建议去掉括号，即不定义为元组。</li>
</ul>
<h1 id="Web-Service-中的错误处理"><a href="#Web-Service-中的错误处理" class="headerlink" title="Web Service 中的错误处理"></a>Web Service 中的错误处理</h1><p>Actix Web Servicve 中设置了统一的错误处理</p>
<p>将不同类型的错误，数据库错误，serde错误，I&#x2F;O错误，用户非法输入错误等</p>
<p>编程语言常用的两种错误处理方式：</p>
<ul>
<li>异常（Java、C#等）</li>
<li>返回值（Rust 、go 等）</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust小项目练习</category>
        <category>rust_web</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust小项目练习</tag>
        <tag>rust_web</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly</title>
    <url>//WebAssembly.html</url>
    <content><![CDATA[<h1 id="什么是-WebAssembly"><a href="#什么是-WebAssembly" class="headerlink" title="什么是 WebAssembly"></a>什么是 WebAssembly</h1><h1 id="WebAssembly-文件格式"><a href="#WebAssembly-文件格式" class="headerlink" title="WebAssembly 文件格式"></a>WebAssembly 文件格式</h1><ul>
<li>文本格式： <code>.wat</code></li>
<li>二进制格式：<code>.wasm</code></li>
</ul>
<h1 id="WebAssembly-能做什么？"><a href="#WebAssembly-能做什么？" class="headerlink" title="WebAssembly 能做什么？"></a>WebAssembly 能做什么？</h1><ul>
<li>可以把编写的 C&#x2F;C++,C#,Rust 等语言的代码编译成 WebAssembly 模块；</li>
<li>你可以在 Web 应用中加载该模块，并通过 JavaScript 调用它；</li>
<li>它并不是为了替代 JS，而是与 JS 一起工作；</li>
<li>仍然需要 HTML 和 JS ，因为 WebAssembly 无法访问平台 API，例如 DOM， WebGL …</li>
</ul>
<h1 id="WebAssembly-的优点"><a href="#WebAssembly-的优点" class="headerlink" title="WebAssembly 的优点"></a>WebAssembly 的优点</h1><ul>
<li>快速，高效，可以移植；</li>
<li>安全；</li>
<li></li>
</ul>
<p>c</p>
<h1 id="在普通闭包中执行异步操作"><a href="#在普通闭包中执行异步操作" class="headerlink" title="在普通闭包中执行异步操作"></a>在普通闭包中执行异步操作</h1><p>因为目前 Rust 中异步闭包功能不稳定，async move 这个语法不稳定，所以在 WebAssembly 中采用下面的方法来代替：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="comment">// spawn_local() 方法来自 webindgen 类库中</span></span><br><span class="line">    <span class="title function_ invoke__">spawn_local</span>(需要执行的异步方法);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust小项目练习</category>
        <category>rust_web</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust小项目练习</tag>
        <tag>rust_web</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器端web应用</title>
    <url>//%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFweb%E5%BA%94%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="传统的服务器端-web-应用"><a href="#传统的服务器端-web-应用" class="headerlink" title="传统的服务器端 web 应用"></a>传统的服务器端 web 应用</h1><p>主要技术</p>
<ul>
<li>模板引擎： <code>Tera</code><ul>
<li>主要作用：动态的渲染部分数据</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust小项目练习</category>
        <category>rust_web</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust小项目练习</tag>
        <tag>rust_web</tag>
      </tags>
  </entry>
  <entry>
    <title>http_server</title>
    <url>//http_server.html</url>
    <content><![CDATA[<h1 id="需要使用的库"><a href="#需要使用的库" class="headerlink" title="需要使用的库"></a>需要使用的库</h1><p>标准库中的网络模块</p>
<p>std::net 模块</p>
<ul>
<li>标准库的 std::net 模块，提供网络基本功能</li>
<li>支持 TCP 和 UDP 通信</li>
</ul>
<p>使用到的主要内容：</p>
<ul>
<li>TcpListener 和 TcpStream</li>
</ul>
<h3 id="TcpListener"><a href="#TcpListener" class="headerlink" title="TcpListener"></a>TcpListener</h3><p>A TCP socket server,listening for connections.</p>
<ul>
<li>TCP 服务端</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">一个TCP套接字服务器，监听连接。</span><br><span class="line">通过将TcpListener绑定到套接字地址来创建TcpListener，之后，它侦听传入的TCP连接。可以通过调用accept或遍历传入迭代器返回的传入迭代器，来接受这些对象。</span><br><span class="line">当该值被删除时，套接字将被关闭。</span><br></pre></td></tr></table></figure>



<p>TcpListener 的使用步骤：</p>
<ol>
<li>使用 <strong>TcpListener::bind</strong> 方法绑定一个 socket，创建一个 TcpListener 对象；</li>
<li>调用 TcpListener 对象的 <strong>accept</strong> 方法或者通过 <strong>incoming</strong> 方法创建迭代器来获取 TcpStream ；<ul>
<li>accept 与 incoming 方法的区别；</li>
<li><strong>accept</strong> 是一次性的，仅能获取<strong>一个新连接</strong>；</li>
<li>incoming 会返回一个迭代器，一直获取传入的连接，相当于在 loop 中调用 accept；</li>
<li>同时 incoming 的迭代器中仅有 TcpStream 没有 SocketAddr；</li>
</ul>
</li>
<li>操作创建的 TcpStream 对象进行读写数据。</li>
<li>TcpStream 端有 shutdown 方法，TcpListener 端没有。</li>
</ol>
<h3 id="TcpStream"><a href="#TcpStream" class="headerlink" title="TcpStream"></a>TcpStream</h3><p>A TCP stream between a local and a remote socket.</p>
<ul>
<li>TCP 客户端</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">通过连接到远程主机或在TcpListener上接受连接创建TcpStream后，可以对其进行读写数据传输。</span><br></pre></td></tr></table></figure>

<p>两个常用的可以创建 TcpStream 类型的方法是：</p>
<ol>
<li>TcpStream::connect<ul>
<li><code>pub fn connect&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; Result&lt;TcpStream&gt;</code></li>
<li>打开到指定主机的<strong>一个 TCP 连接</strong></li>
<li>是作为客户端去连接服务器，</li>
<li>需要远程主机的指定端口是被监听状态</li>
</ul>
</li>
<li>listener.accept()<ul>
<li>这是 TcpListener 中的方法</li>
<li><code>pub fn accept(&amp;self) -&gt; Result&lt;(TcpStream, SocketAddr)&gt;</code></li>
<li>TcpListener 通过bind的绑定socket，这个方法可以从这个监听器接收新的传入连接（incoming connection）</li>
<li>该方法会阻塞线程直到新的 TCP 连接建立。</li>
<li>会返回 TcpStream和 远端地址</li>
</ul>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::TcpStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要先启动一个监听8080端口的本地服务；</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(stream) = TcpStream::<span class="title function_ invoke__">connect</span>(<span class="string">&quot;127.0.0.1:8080&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Connected to the server!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Couldn&#x27;t connect to server...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：</p>
<ul>
<li>TcpListener 端的描述：The socket will be closed when the value is dropped.</li>
<li>TcpStream 端的描述：The connection will be closed when the value is dropped.</li>
<li>同样有表示连接的作用，<ul>
<li>服务端，称为 socket 服务，用来监听 incoming connection 传入连接；</li>
<li>客户端，称为 connection；</li>
</ul>
</li>
</ul>
<p>注意2：</p>
<p>TcpListener 和 TcpStream 函数的返回值</p>
<h3 id="TcpStream-write"><a href="#TcpStream-write" class="headerlink" title="TcpStream::write"></a><code>TcpStream::write</code></h3><p>在向 TcpStream 中写的时候，可以直接调用 <code>TcpStream::write</code> 方法，也可以调用 <code>write!()</code> 宏来操作，不过无论使用哪种调用方式，注意内容参数是要输出到 <code>write</code> 中，注意与 <code>TcpStream::read</code> 使用参数上的区别。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// response 是要输出到 stream 中的，</span></span><br><span class="line">stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// response_string 是要输出到 write_stream 中的，</span></span><br><span class="line"><span class="built_in">write!</span>(write_stream, <span class="string">&quot;&#123;&#125;&quot;</span>, response_string);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用 TcpStream::write 时，需要手动调用 TcpStream::flush 方法将数据写入到 stream 中。</p>
</blockquote>
<p>第三方序列化和反序列化库</p>
<ul>
<li><p>serde</p>
</li>
<li><p>serde_json</p>
</li>
</ul>
<h2 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h2><ol>
<li>TcpStream 的写操作如何调用？<ul>
<li>read</li>
<li>write</li>
</ul>
</li>
</ol>
<p>TCP 协议一次发送多少字节数据？</p>
<ul>
<li>一个TCP报文可以发送多少？</li>
</ul>
<p>一次网络传输可以发送多少字节？</p>
<p>程序调用 TcpStream::read&#x2F;write 的缓冲区设置多大合适？遇到很多的数据，代码怎样写&#x2F;方法怎样调用是合理的？</p>
<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><ol>
<li><p><code>into()</code> 方法在正常使用时，是需要手动声明目标类型；但是在构建 struct 实例的时候，因为指定 struct 在定义时都指定了类型，所以可以直接使用；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">http_string</span>: <span class="type">String</span> = response.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HttpResponse &#123;</span></span><br><span class="line"><span class="comment">//    body: Option(String),</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">HttpResponse &#123;</span><br><span class="line">    ...</span><br><span class="line">    body: <span class="title function_ invoke__">Some</span>(<span class="string">&quot;message&quot;</span>.into),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="构建-HTTP-Server"><a href="#构建-HTTP-Server" class="headerlink" title="构建 HTTP Server"></a>构建 HTTP Server</h1><ul>
<li>编写 HTTP Server</li>
<li>测试 HTTP Server</li>
</ul>
<h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><p>Rust 没有内置的 HTTP 支持</p>
<ul>
<li>手写</li>
<li>使用第三方库</li>
</ul>
<p>Web Server 组成</p>
<ul>
<li>Server<ul>
<li>监听进来的 TCP 字节流</li>
</ul>
</li>
<li>Router<ul>
<li>接受 HTTP 请求，并决定调用哪个 Handler</li>
</ul>
</li>
<li>Handler<ul>
<li>处理 HTTP 请求，构建 HTTP 响应</li>
</ul>
</li>
<li>HTTP Library<ul>
<li>解释字节流，把它转化为 HTTP 请求</li>
<li>把 HTTP 响应转化回字节流</li>
</ul>
</li>
</ul>
<p>1.server -&gt; 2. HTTP Library -&gt; 3. Router -&gt; 4. Handler -&gt; 5. HTTP Library -&gt; 6. Client</p>
<h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><ul>
<li>解析 HTTP 请求消息</li>
<li>构建 HTTP 响应消息</li>
<li>路由与 Handler</li>
<li>测试 Web Server</li>
</ul>
<h2 id="解析-HTTP-请求"><a href="#解析-HTTP-请求" class="headerlink" title="解析 HTTP 请求"></a>解析 HTTP 请求</h2><p>需要熟悉 HTTP 协议组成</p>
<p>需要四个数据结构</p>
<table>
<thead>
<tr>
<th>数据结构名称</th>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HttpRequest</td>
<td>struct</td>
<td>表示 HTTP 请求</td>
</tr>
<tr>
<td>Method</td>
<td>enum</td>
<td>指定所允许的 HTTP 方法</td>
</tr>
<tr>
<td>Version</td>
<td>enum</td>
<td>指定所允许的 HTTP 版本</td>
</tr>
<tr>
<td>Resource</td>
<td>enum</td>
<td>指定 HTTP 请求中的路径</td>
</tr>
</tbody></table>
<p>同时上面三个数据结构都需要实现下面三个 Trait</p>
<table>
<thead>
<tr>
<th>Trait</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>From&lt;&amp;str&gt;</td>
<td>用于把传进来的<em>字符串切片</em> 转化为 HttpRequest （提供类型转换的能力）</td>
</tr>
<tr>
<td>Debug</td>
<td>打印调试信息</td>
</tr>
<tr>
<td>PartialEq</td>
<td>用于解析和自动化测试脚本里做比较</td>
</tr>
</tbody></table>
<h2 id="构建-HTTP-响应"><a href="#构建-HTTP-响应" class="headerlink" title="构建 HTTP 响应"></a>构建 HTTP 响应</h2><p>熟悉 HTTP 响应结构体</p>
<p>为什么 httpresponse 结构体中字段类型是 &amp;str？而 httprequest 结构体中涉及到字符的是 String？</p>
<p>HttpResponse 需要实现的方法 或 Trait</p>
<ul>
<li>将 HttpResponse 转换成可以通过 TCP 传送的形式；</li>
<li>为上面的目标设计结构体和方法；</li>
</ul>
<table>
<thead>
<tr>
<th>需要实现的方法或 Trait</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Default trait</td>
<td>指定成员的默认值</td>
</tr>
<tr>
<td>new()</td>
<td>使用默认值创建一个新的结构体</td>
</tr>
<tr>
<td>send_response()</td>
<td>构建响应，将原始字节通过 TCP 传送</td>
</tr>
<tr>
<td>getter 方法</td>
<td>获得成员的值</td>
</tr>
<tr>
<td>From trait</td>
<td>能够将 HttpResponse 转化为 String</td>
</tr>
</tbody></table>
<h2 id="构建-Server"><a href="#构建-Server" class="headerlink" title="构建 Server"></a>构建 Server</h2><p>需要实现的数据结构</p>
<table>
<thead>
<tr>
<th>Server</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Server</td>
<td>监听 tcp，运行并处理请求</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>包含字段和需要实现的方法</p>
<table>
<thead>
<tr>
<th>字段和方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>socket_addr</td>
<td>监听地址</td>
</tr>
<tr>
<td>new()</td>
<td>创建对象</td>
</tr>
<tr>
<td>run()</td>
<td>运行</td>
</tr>
</tbody></table>
<h2 id="构建-Router"><a href="#构建-Router" class="headerlink" title="构建 Router"></a>构建 Router</h2><p>Router 需要实现的数据结构</p>
<ul>
<li>Router ，struct，接受 HTTP 请求，和 TcpStream，并决定调用哪个 Handler</li>
</ul>
<table>
<thead>
<tr>
<th align="center">需要实现的方法</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">route</td>
<td align="center">接受 HTTP 请求，并决定调用哪个 Handler</td>
</tr>
</tbody></table>
<h2 id="构建-Handler"><a href="#构建-Handler" class="headerlink" title="构建 Handler"></a>构建 Handler</h2><p>Handler Trait</p>
<p>一个需要实现的方法</p>
<ul>
<li>handler</li>
</ul>
<p>一个默认方法</p>
<ul>
<li>load_file  用于加载响应 handler 的配置文件；</li>
</ul>
<p>需要实现多个不同的 Handler 用以处理不同的业务情况。</p>
<ul>
<li>StaticPageHandler</li>
<li>PageNotFoundHander</li>
<li>WebServiceHandler</li>
</ul>
<h1 id="拆分项目单个文件到目录"><a href="#拆分项目单个文件到目录" class="headerlink" title="拆分项目单个文件到目录"></a>拆分项目单个文件到目录</h1>]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust小项目练习</category>
        <category>rust_web</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust小项目练习</tag>
        <tag>rust_web</tag>
      </tags>
  </entry>
  <entry>
    <title>Substrate开发学习</title>
    <url>//Substrate%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><ul>
<li>搭建 substrate 的开发环境；</li>
<li>使用 template 运行基于 substrate 的区块链；</li>
<li>使用 substrate 的前端模板和我们搭建的区块链进行交互；</li>
</ul>
<h1 id="什么是-Substrate"><a href="#什么是-Substrate" class="headerlink" title="什么是 Substrate"></a>什么是 Substrate</h1><p>从高层看，一个区块链节点包含以下几个关键组件（key components）</p>
<ul>
<li>Storage 存储<ul>
<li>key-value 存储机制</li>
</ul>
</li>
<li>P2P 网络<ul>
<li>允许客户端直接与其他网络参与者通信。</li>
</ul>
</li>
<li>共识的能力</li>
<li>外部或“外部”信息的数据处理能能力</li>
<li>一个 Runtime<ul>
<li>定义了区块的处理方式，主要是状态转换的逻辑。</li>
<li>在 Substrate 中，runtime code 被编译为 wasm 作为区块链存储状态的一部分。</li>
</ul>
</li>
</ul>
<p>因为构建上述组件比较复杂，所以目前大多数区块链项目都是从现有的区块链项目派生出来的。</p>
<p>例如，比特币仓库分叉创建:莱特币、ZCash、Namecoin和比特币现金。类似地，以太坊仓库分叉创建Quorum、POA Network、KodakCoin和Musicoin。</p>
<p>Substrate 是用于构建区块链的开源、模块化和可扩展的框架。</p>
<p>Substrate 是设计灵活，允许使用者设计和构建满足其需求的区块链网络。它提供了构建自定义区块链节点所需要的所有核心组件（core components）。</p>
<h1 id="一些基础概念"><a href="#一些基础概念" class="headerlink" title="一些基础概念"></a>一些基础概念</h1><p>pallet</p>
<ul>
<li>使用 FRAME 开发框架构建的<strong>模块</strong></li>
<li>作用：向 node template 中添加指定 pallet（即向 node 的 runtime 中添加），就是添加一个指定功能的模块。</li>
<li>是通过 crate 的形式呈现的，所以使用时需要在 <code>Cargo.toml</code> 中添加到 <code>dependencies</code> 中</li>
</ul>
<h1 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h1><p>以下命令为 Ubuntu 环境，更多环境参考<a href="https://docs.substrate.io/tutorials/v3/create-your-first-substrate-chain/#install-required-packages">官方文档</a></p>
<p>安装基础依赖软件 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install -y git clang curl libssl-dev llvm libudev-dev</span><br></pre></td></tr></table></figure>

<h3 id="安装-rust-相关"><a href="#安装-rust-相关" class="headerlink" title="安装 rust 相关"></a>安装 rust 相关</h3><p>安装 rust</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>

<p>加载 cargo 环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.cargo/env</span><br></pre></td></tr></table></figure>

<p>配置 rust 工具链默认为最新的稳定版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup default stable</span><br><span class="line">rustup update</span><br></pre></td></tr></table></figure>

<p>添加 <code>nightly</code> release和 <code>nightly</code> WebAssembly (<code>wasm</code>) 目标</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup update nightly</span><br><span class="line">rustup target add wasm32-unknown-unknown --toolchain nightly</span><br></pre></td></tr></table></figure>

<p>确定安装信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustc --version</span><br><span class="line">rustup show</span><br></pre></td></tr></table></figure>



<h3 id="使用模板搭建-Substrate-节点开发环境"><a href="#使用模板搭建-Substrate-节点开发环境" class="headerlink" title="使用模板搭建 Substrate 节点开发环境"></a>使用模板搭建 Substrate 节点开发环境</h3><h3 id="使用-node-template"><a href="#使用-node-template" class="headerlink" title="使用 node template"></a>使用 node template</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/substrate-developer-hub/substrate-node-template</span><br><span class="line"></span><br><span class="line">cd substrate-node-template</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">We want to use the `latest` tag throughout all of this tutorial</span></span><br><span class="line">git checkout latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对模板内容编译</span></span><br><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译如果出错，查看 <a href="#%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98">遇到问题</a></p>
</blockquote>
<blockquote>
<p>看到 <code>finalized</code> 的数量在增加，说明节点启动好了。</p>
</blockquote>
<h3 id="安装-front-end-template"><a href="#安装-front-end-template" class="headerlink" title="安装 front-end template"></a>安装 front-end template</h3><p>前端模板</p>
<h4 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h4><p>要求 nodejs 版本 &gt;&#x3D; v14</p>
<p>添加指定版本源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -</span><br></pre></td></tr></table></figure>

<blockquote>
<p>setup_16.x 是指 16 这个大版本，如果版本到了 17 就改成 setup_17.x 。具体版本可以的 <a href="https://nodejs.org/">https://nodejs.org</a> 查看最新版本。</p>
</blockquote>
<p>执行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure>

<p>验证版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装完 nodejs 后，npm 也会一并安全了。</p>
</blockquote>
<h4 id="验证或安装-yarn"><a href="#验证或安装-yarn" class="headerlink" title="验证或安装 yarn"></a>验证或安装 yarn</h4><p>如果有 yarn 则不需要安装，没有就安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>

<p>验证是否安装，查看版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn --version</span><br></pre></td></tr></table></figure>



<h4 id="下载前端模板"><a href="#下载前端模板" class="headerlink" title="下载前端模板"></a>下载前端模板</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/substrate-developer-hub/substrate-front-end-template</span><br><span class="line"></span><br><span class="line">cd substrate-front-end-template</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">We want to use the `latest` tag throughout all of this tutorial</span></span><br><span class="line">git checkout latest</span><br><span class="line"></span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure>



<h2 id="启动本地-Substrate-节点"><a href="#启动本地-Substrate-节点" class="headerlink" title="启动本地 Substrate 节点"></a>启动本地 Substrate 节点</h2><p>打开一个终端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd substrate-node-template</span><br><span class="line">./target/release/node-template --dev</span><br></pre></td></tr></table></figure>

<h2 id="启动前端模板"><a href="#启动前端模板" class="headerlink" title="启动前端模板"></a>启动前端模板</h2><p>再开一个终端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd substrate-front-end-template</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>

<p>启动后，打开浏览器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://localhost:8000</span><br></pre></td></tr></table></figure>





<h1 id="添加一个-Pallet-到-Runtime"><a href="#添加一个-Pallet-到-Runtime" class="headerlink" title="添加一个 Pallet 到 Runtime"></a>添加一个 Pallet 到 Runtime</h1><p>什么是 pallet ?</p>
<h3 id="添加-pallet-nicks-依赖到项目中"><a href="#添加-pallet-nicks-依赖到项目中" class="headerlink" title="添加 pallet-nicks 依赖到项目中"></a>添加 pallet-nicks 依赖到项目中</h3><p>添加 <code>pallet-nicks</code> crate 到 runtime 的 Cargo.toml 文件中 <code>[dependencies]</code> 段落中</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pallet-nicks</span> = &#123; default-features = <span class="literal">false</span>, git = <span class="string">&quot;https://github.com/paritytech/substrate.git&quot;</span>, branch = <span class="string">&quot;polkadot-v0.9.20&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>添加 <code>pallet-nicks</code> 到 <code>features</code> 段落中</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">default</span> = [<span class="string">&#x27;std&#x27;</span>]</span><br><span class="line"><span class="attr">std</span> = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;pallet-aura/std&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pallet-balances/std&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pallet-nicks/std&#x27;</span>,  <span class="comment"># 添加这行</span></span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>检查依赖是否正常</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">cargo check -p node-template-runtime</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模块名可以通过查看 Cargo.toml 中的 package name 获得</p>
</blockquote>
<h3 id="检查-Nicks-pallet-的-configuration-trait"><a href="#检查-Nicks-pallet-的-configuration-trait" class="headerlink" title="检查 Nicks pallet 的 configuration trait"></a>检查 Nicks pallet 的 configuration trait</h3><p>每个 pallet 都有一个被称为 <code>Config</code> 的Rust trait，用于配置 pallet 在运行时需要的参数和类型。</p>
<p>Runtime 要实现指定 pallet 的 <code>Config</code></p>
<p>trace the accounts that hold balances.</p>
<p>跟踪持有余额的账户。</p>
<p>balance 在金融领域，有<strong>余额</strong>的含义。</p>
<p>record an account’s balance.</p>
<p>记录一个账户的余额。</p>
<p>如何做？</p>
<p>查看 pallet_nick 的 Config 定义文档；</p>
<p>查看 Balance pallet 的 Config 的实现（implementation）；</p>
<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>按照 Substrate官网入门教程编译节点模板</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spoon@spoon-vm:~/devops/codes/substrate-node-template$ cargo build --release</span><br></pre></td></tr></table></figure>

<p>报错如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error: failed to run custom build command <span class="keyword">for</span> `tikv-jemalloc-sys v0.<span class="number">4.3</span>+<span class="number">5.2</span>.<span class="number">1</span>-patched.<span class="number">2</span>`</span><br><span class="line"></span><br><span class="line">Caused by:</span><br><span class="line">  process didn<span class="symbol">&#x27;t</span> exit successfully: `/home/spoon/devops/codes/substrate-node-template/target/release/build/tikv-jemalloc-sys-df85f4a5b8101ca7/build-script-build` (exit status: <span class="number">101</span>)</span><br><span class="line">  --- stdout</span><br></pre></td></tr></table></figure>



<p><strong>解决方法</strong></p>
<p>安装 <code>cmake</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure>

<p>然后重新编译即可。</p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust小项目练习</category>
        <category>rust_区块链</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust小项目练习</tag>
        <tag>rust_区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>rust编写简单区块链</title>
    <url>//rust%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E5%8C%BA%E5%9D%97%E9%93%BE.html</url>
    <content><![CDATA[<h1 id="区块链概念"><a href="#区块链概念" class="headerlink" title="区块链概念"></a>区块链概念</h1><p>比特币</p>
<ul>
<li>2008年，《Bitcoin: A Peer-to-Peer Electronic Cash System》</li>
<li>去中心化的，共享的，防篡改的分布式账本；<ul>
<li>分布式账本的同步策略是什么样的？</li>
<li>如何防篡改？</li>
<li>广播方式，如何保证网络传输效率？</li>
</ul>
</li>
</ul>
<p>比特币是区块链的一种应用。</p>
<p>区块链除了比特币还有哪些应用场景？</p>
<h1 id="区块链交易流程"><a href="#区块链交易流程" class="headerlink" title="区块链交易流程"></a>区块链交易流程</h1><ol>
<li>用户发起交易</li>
<li>交易广播</li>
<li>各矿工节点打包区块</li>
<li>区块广播</li>
<li>节点将区块加入到账本</li>
</ol>
<p>详细内容可以找一些其他介绍资料</p>
<h1 id="用-Rust-写区块链"><a href="#用-Rust-写区块链" class="headerlink" title="用 Rust 写区块链"></a>用 Rust 写区块链</h1><p>介绍</p>
<ul>
<li>实现简单的链式结构，能够创建区块；</li>
<li>用到序列化、反序列化、求hash等知识点；</li>
</ul>
<p>区块结构</p>
<p><strong>区块头</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">BlockHeader</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> time: <span class="type">i64</span>,  <span class="comment">// timestamp</span></span><br><span class="line">    <span class="keyword">pub</span> tx_hash: <span class="type">String</span>, <span class="comment">// transactions merkle hash</span></span><br><span class="line">    <span class="keyword">pub</span> pre_hash: <span class="type">String</span>, <span class="comment">// hash of the pre block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>区块体</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> header: BlockHeader,</span><br><span class="line">    <span class="keyword">pub</span> hash: <span class="type">String</span>,  <span class="comment">// hash of the block header</span></span><br><span class="line">    <span class="keyword">pub</span> data: <span class="type">String</span>,  <span class="comment">// transactions data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里block之间链接的方式，是通过存储前一block hash的做法达到，而不是常规 list 的存储前一block 指针的形式。</p>
<p>问题：是不是因为 rust 实现 list 比较麻烦，所以这里改用简单的形式？</p>
</blockquote>
<p>区块链结构</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">BlockChain</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> blocks: <span class="type">Vec</span>&lt;block::Block&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<ul>
<li>精通比特币</li>
<li><a href="https://github.com/rust-bitcoin/rust-bitcoin">https://github.com/rust-bitcoin/rust-bitcoin</a></li>
<li><a href="https://jeiwan.net/posts/building-blockchain-in-go-part-1/">https://jeiwan.net/posts/building-blockchain-in-go-part-1/</a></li>
</ul>
<p>其他</p>
<ul>
<li><a href="https://github.com/anonymousGiga">https://github.com/anonymousGiga</a></li>
</ul>
<h1 id="编写简单区块链代码"><a href="#编写简单区块链代码" class="headerlink" title="编写简单区块链代码"></a>编写简单区块链代码</h1><ol>
<li>定义方法时，可以参考已知库中类似的方法的签名；</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust小项目练习</category>
        <category>rust_区块链</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust小项目练习</tag>
        <tag>rust_区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链学习</title>
    <url>//%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="区块链基本概念"><a href="#区块链基本概念" class="headerlink" title="区块链基本概念"></a>区块链基本概念</h1><p>下面内容参考</p>
<p><a href="https://mp.weixin.qq.com/s/eYCbAD_tPG9PmuFE1LvCWA?utm_source=wechat_session&utm_medium=social&utm_oi=734729501476413440">比特币白皮书精读详解</a></p>
<p>去掉第三方机构</p>
<p>双重支付</p>
<p>全网唯一公认的（历史）交易序列</p>
<p>工作量证明</p>
<p><strong>电子货币</strong>：是一串数字签名</p>
<p>电子货币的交易，是通过对数字签名的核验来实现的。</p>
<ul>
<li>风险：付款人是否将款项进行了双重甚至多重支付？</li>
</ul>
<p><strong>双重支付</strong></p>
<ul>
<li>不太理解电子货币系统中为什么会出现双重支付的问题？</li>
<li>目前为止接触的都是有第三方机构来负责处理交易的，那么没有的情况下如何处理？</li>
</ul>
<p>解决方式：中本聪提出的方式是，把所有交易信息全部公开，在系统内进行全网广播，依靠系统内的参与者创建一个交易序列，即为账本。（这样就可以避免找一个第三方机构来处理）</p>
<blockquote>
<p>二重支付，指攻击者几乎同时将同一笔钱用作不同交易。</p>
<p>每当节点在把新收到的交易单加入区块之前，会顺着交易的发起方的公钥向前遍历检查，检查当前交易所用的币是否确实属于当前交易发起方，此检查可遍历到该币的最初诞生点（即产生它的那块区块源）。虽然多份交易单可以任意序的广播，但是它们最终被加入区块时必定呈现一定的顺序。区块之间以Hash值作为时间戳则区块，这决定了任意一笔交易资金来源都可以被确定的回溯。</p>
<p>原文链接：<a href="https://blog.csdn.net/csolo/article/details/52858236">https://blog.csdn.net/csolo/article/details/52858236</a></p>
</blockquote>
<p><strong>交易序列</strong></p>
<p>一连串的交易记录，这个记录的排序依据是时间，</p>
<p><strong>区块</strong></p>
<p>是存储交易数据的基本单元；</p>
<p>将交易数据进行运算处理后，形成一个加密的数列（hash），再加上<strong>时间戳</strong>，就构成了一个区块；</p>
<p>区块中可以包含多条记录，包含有交易时间。</p>
<p><strong>区块链</strong>（账本）</p>
<p>以时间为单位排列，每一个后产生的区块都记录了之前区块的信息，这样就形成了一个链条，即链条的最后一环包含了之前每一环的信息。</p>
<p>这样就形成了一个不可以篡改的交易序列。</p>
<p>第4节</p>
<p><strong>工作量证明</strong>（proof of work）机制</p>
<ul>
<li><p>谁来记账？</p>
<p>一个完全分布式网络中，每个节点都被赋予了记账权，那么一个节点如何实现记账？谁的记账结果可以被认可呢？</p>
<ul>
<li>两个机制来解决这个问题</li>
</ul>
<ol>
<li>工作量证明机制</li>
<li>CPU投票机制</li>
</ol>
</li>
<li><p>货币怎么来？</p>
</li>
<li><p>为什么允许记账？</p>
</li>
<li><p>为什么要破解随机值？</p>
</li>
<li><p>记账（挖矿）与交易的关系是什么？</p>
</li>
</ul>
<p>工作量证明机制的本质是一CPU一票。</p>
<p>“大多数”的决定表达为最长的链，因为最长的链包含了最大的工作量。</p>
<p>工作量证明的难度将采用移动平均目标的方式来确定，即令难度指向令每个小时生成区块的速度为某一个预定的平均数。</p>
<p>如果区块生成的速度过快，那么难度就会提高。</p>
<p>问题：</p>
<p>区块产生的过程，与打包交易的过程</p>
<p>问题2：</p>
<p>一个区块需要包含多少交易？</p>
<p>5.网络运行</p>
<p>全网唯一公认的交易序列</p>
<p>其步骤就是区块链的运行机制。</p>
<p>运行网络的步骤如下：</p>
<ol>
<li><p>新的交易向全网进行广播；</p>
</li>
<li><p>每一个节点都将收到的交易信息纳入一个区块中；</p>
</li>
<li><p>每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；</p>
</li>
<li><p>当一个节点找到了一个工作量证明，它就向全网进行广播；</p>
</li>
<li><p>当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性；</p>
</li>
<li><p>其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区块的随机散列值。</p>
</li>
</ol>
<p>节点始终都将最长的链条视为正确的链条，并持续工作和延长它。如果有两个节点同时广播不同版本的新区块，那么其他节点在接收到该区块的时间上将存在先后差别。当此情形，他们将在率先收到的区块基础上进行工作，但也会保留另外一个链条，以防后者变成最长的链条。</p>
<p>该僵局（tie）的打破要等到下一个工作量证明被发现，而其中的一条链条被证实为是较长的一条，那么在另一条分支链条上工作的节点将转换阵营，开始在较长的链条上工作。</p>
<blockquote>
<p><strong>分叉</strong></p>
<p>同一时间段内全网不止一个节点能计算出随机数，即会有多个节点在网络中广播它们各自打包好的临时区块（都是合法的）。</p>
<p>某一节点若收到多个针对同一前续区块的后续临时区块，则该节点会在本地区块链上建立分支，多个临时区块对应多个分支。该僵局的打破要等到下一个工作量证明被发现，而其中的一条链条被证实为是较长的一条，那么在另一条分支链条上工作的节点将转换阵营，开始在较长的链条上工作。其他分支将会被网络彻底抛弃。</p>
<p>原文链接：<a href="https://blog.csdn.net/csolo/article/details/52858236">https://blog.csdn.net/csolo/article/details/52858236</a></p>
</blockquote>
<p>广播，是一种行为动作，只要足够多的节点接收到就可以了。</p>
<p>一个交易信息只要抵达足够多的节点，就可以被整合进一个区块中。</p>
<p><strong>容错能力</strong></p>
<p>一个区块如果没有被某些节点接收到，它可以在后续被该节点请求下载。</p>
<ul>
<li>这个如何处理的？</li>
<li>那么下载该区块的节点上原本的工作量是不是就作废了？</li>
</ul>
<p>这个机制使得，整个系统同一时间只要有足够多的节点在工作就可以了，不需要所有节点都实时工作。</p>
<p><strong>激励机制</strong></p>
<p>1） 每个区块的第一笔交易进行特殊化处理，该交易产生一枚由该区块创造者拥有的新的电子货币。</p>
<p>2） 交易费（transaction fees）。如果某笔交易的输出值小于输入值，那么差额就是交易费，该交易费将被增加到该区块的激励中。</p>
<p><strong>回收硬盘空间</strong></p>
<p>区块链上的老区块只保存区块头，这样处理后，需要的存储空间变小，也就提高了区块同步的速度。这是一个提升系统运行效率、降低资源消耗的机制。</p>
<ul>
<li>有什么缺点吗？</li>
<li>只存区块头的情况下，如何回溯某次交易发生过？</li>
</ul>
<p><strong>简化的支付确认</strong></p>
<p>当发生警报，其他节点向哪里下载问题区块或完整的交易序列？</p>
<p>如何保证交易系统安全？</p>
<p>只要攻击者伪造的交易无法成为最长的链，那么交易系统就依然安全。</p>
<p><strong>交易确认</strong></p>
<p><strong>价值的组合与分割</strong></p>
<ul>
<li>比特币的交易并不是一枚比特币一次交易。</li>
<li>可以无限切割、无限组合的。</li>
<li>一比特币&#x3D;1000000 bit</li>
</ul>
<h1 id="目前区块链存在的不足"><a href="#目前区块链存在的不足" class="headerlink" title="目前区块链存在的不足"></a>目前区块链存在的不足</h1><p>交易确认比较慢</p>
]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust小项目练习</category>
        <category>rust_区块链</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust小项目练习</tag>
        <tag>rust_区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊Dapp开发学习</title>
    <url>//%E4%BB%A5%E5%A4%AA%E5%9D%8ADapp%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="Dapp-的作用"><a href="#Dapp-的作用" class="headerlink" title="Dapp 的作用"></a>Dapp 的作用</h1><h1 id="Dapp-的原理"><a href="#Dapp-的原理" class="headerlink" title="Dapp 的原理"></a>Dapp 的原理</h1><p>中心化app的数据存储在中心化服务器，dapp的数据存储在区块链上。</p>
<h1 id="Dapp-开发环境介绍"><a href="#Dapp-开发环境介绍" class="headerlink" title="Dapp 开发环境介绍"></a>Dapp 开发环境介绍</h1><ul>
<li>geth+js</li>
<li>ganache+js</li>
<li>truffle<ul>
<li>以太坊官方提供的js的框架</li>
</ul>
</li>
</ul>
<h1 id="Geth-私链环境搭建"><a href="#Geth-私链环境搭建" class="headerlink" title="Geth 私链环境搭建"></a>Geth 私链环境搭建</h1><ul>
<li>是以太坊客户端</li>
</ul>
<p>需要安装</p>
<h1 id="ganache-使用"><a href="#ganache-使用" class="headerlink" title="ganache 使用"></a>ganache 使用</h1><h1 id="使用-Web3js-和区块链进行交互"><a href="#使用-Web3js-和区块链进行交互" class="headerlink" title="使用 Web3js 和区块链进行交互"></a>使用 Web3js 和区块链进行交互</h1><h1 id="智能合约编写、部署"><a href="#智能合约编写、部署" class="headerlink" title="智能合约编写、部署"></a>智能合约编写、部署</h1><h1 id="完整-Dapp-demo"><a href="#完整-Dapp-demo" class="headerlink" title="完整 Dapp demo"></a>完整 Dapp demo</h1><h1 id="使用-truffle"><a href="#使用-truffle" class="headerlink" title="使用 truffle"></a>使用 truffle</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1>]]></content>
      <categories>
        <category>Rust</category>
        <category>Rust小项目练习</category>
        <category>以太坊Dapp</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust小项目练习</tag>
        <tag>以太坊Dapp</tag>
      </tags>
  </entry>
  <entry>
    <title>NTP配置</title>
    <url>//NTP%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<h1 id="Chrony时间同步服务"><a href="#Chrony时间同步服务" class="headerlink" title="Chrony时间同步服务"></a>Chrony时间同步服务</h1><p>chrony 与 ntp 一样，既可以做服务端，也可以做客户端。</p>
<p>使用的是 UDP 协议。</p>
<p>兼容以前的 ntp服务，所以本地会启动两个UDP端口。</p>
<p>ntp服务端口，123</p>
<p>chrony服务端口，323</p>
<h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>修改 <code>/etc/chrony.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置当前服务器向指定NTP服务器同步时间，例如这里先向11.1.36.1同步时间</span></span><br><span class="line">server 11.1.36.1 iburst</span><br><span class="line"></span><br><span class="line">服务端需要把下面的allow内容打开，并做适当配置。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Allow NTP client access from <span class="built_in">local</span> network.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">allow 192.168.0.0/16</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果上面使用server字段配置的时间服务器同步时间失败,默认情况下当前时间服务器是不会向客户端同步时间的,</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是因为担心当前节点的时间不准确(因为当前节点没有和定义中的server时间服务器进行同步),如果我们想要在</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">server指定的时间服务器同步失败的情况下依旧返回当前时间服务器的时间给客户端，需要开启该参数,这一项参</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数配置在生产环境中还是相当危险的，因此建议大家在server字段中指定互联网的网络时间,否则可能会出现整个</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">集群时间都错的的一致!</span></span><br><span class="line">local stratum 10</span><br></pre></td></tr></table></figure>





<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>修改 <code>/etc/chrony.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server 11.1.36.1 iburst</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点修改这部分，可以多行，多个NTP服务地址。</p>
<p>server NTP服务端 iburst</p>
</blockquote>
<p>启动 chronyd 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart chronyd</span><br></pre></td></tr></table></figure>

<p>查看服务状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status chronyd</span><br></pre></td></tr></table></figure>







<h2 id="查看同步"><a href="#查看同步" class="headerlink" title="查看同步"></a>查看同步</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chronyc sources -v</span><br></pre></td></tr></table></figure>

<p>样例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test-mysql5 ~]# chronyc sources -v</span><br><span class="line">210 Number of sources = 1</span><br><span class="line"></span><br><span class="line">  .-- Source mode  &#x27;^&#x27; = server, &#x27;=&#x27; = peer, &#x27;#&#x27; = local clock.</span><br><span class="line"> / .- Source state &#x27;*&#x27; = current synced, &#x27;+&#x27; = combined , &#x27;-&#x27; = not combined,</span><br><span class="line">| /   &#x27;?&#x27; = unreachable, &#x27;x&#x27; = time may be in error, &#x27;~&#x27; = time too variable.</span><br><span class="line">||                                                 .- xxxx [ yyyy ] +/- zzzz</span><br><span class="line">||      Reachability register (octal) -.           |  xxxx = adjusted offset,</span><br><span class="line">||      Log2(Polling interval) --.      |          |  yyyy = measured offset,</span><br><span class="line">||                                \     |          |  zzzz = estimated error.</span><br><span class="line">||                                 |    |           \</span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample               </span><br><span class="line">===============================================================================</span><br><span class="line">^* 11.1.36.1                     1   6   377   125  +5239ns[-1566ns] +/-  744us</span><br></pre></td></tr></table></figure>

<p>通过 <code>-v</code> 可以得知，<code>^*</code> 表示当前的时间服务器<strong>同步成功</strong>。</p>
<h2 id="手动同步"><a href="#手动同步" class="headerlink" title="手动同步"></a>手动同步</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动同步系统时间</span></span><br><span class="line">chronyc -a makestep</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看时间同步源</span></span><br><span class="line">chronyc sources -v</span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/yinzhengjie/p/12292549.html">https://www.cnblogs.com/yinzhengjie/p/12292549.html</a></p>
<hr>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>设置系统时区和时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test-mysql5 ~]# timedatectl </span><br><span class="line">      Local time: Thu 2023-07-20 17:02:41 CST</span><br><span class="line">  Universal time: Thu 2023-07-20 09:02:41 UTC</span><br><span class="line">        RTC time: Thu 2023-07-20 09:03:02</span><br><span class="line">       Time zone: n/a (CST, +0800)</span><br><span class="line">     NTP enabled: yes</span><br><span class="line">NTP synchronized: yes</span><br><span class="line"> RTC in local TZ: no</span><br><span class="line">      DST active: n/a</span><br></pre></td></tr></table></figure>

<p>查看上海时区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test-mysql5 ~]# timedatectl list-timezones |grep -E &quot;Asia/Shang*&quot;</span><br><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure>

<p>设置系统时区为上海</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test-mysql5 ~]# timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br></pre></td></tr></table></figure>

<p>帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@test-mysql5 ~]# timedatectl --help</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
        <category>NTP</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>NTP</tag>
        <tag>Chrony</tag>
      </tags>
  </entry>
  <entry>
    <title>dd命令生成文件</title>
    <url>//dd%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6.html</url>
    <content><![CDATA[<h2 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h2><h2 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/swapfile bs=1M count=1024</span><br></pre></td></tr></table></figure>

<p>通过 <code>dd</code> 命令生成文件，命令解释：</p>
<ul>
<li><p>if ，数据来源，保持不变；</p>
</li>
<li><p>of，输出文件位置，可以指定绝对路径，例如：<code>/swapfile</code>。不建议生成在当前路径下（即只有文件名，没有路径），最好使用绝对路径。</p>
</li>
<li><p>bs，块大小，默认字节，支持的单位如下（参考dd命令帮助）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N and BYTES may be followed by the following multiplicative suffixes:</span><br><span class="line">c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M</span><br><span class="line">GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.</span><br></pre></td></tr></table></figure>


</li>
<li><p>count，块的数量</p>
</li>
<li><p>生成的文件总大小&#x3D;bs x count，上面为 1M x 1024 &#x3D; 1G</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>dd</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>dd</tag>
      </tags>
  </entry>
</search>
