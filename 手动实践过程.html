<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>手动实践过程 |  听潮亭</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="听潮亭" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-学习笔记/SpringBoot/手动实践过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  手动实践过程
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/%E6%89%8B%E5%8A%A8%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B.html" class="article-date">
  <time datetime="2021-11-29T09:22:09.000Z" itemprop="datePublished">2021-11-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringBoot/">SpringBoot</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">9.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">37 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="20210723"><a href="#20210723" class="headerlink" title="20210723"></a>20210723</h1><ol>
<li>目标，常规使用<ol>
<li>搭建</li>
<li>数据库</li>
<li>常用注解说明</li>
</ol>
</li>
</ol>
<p>一共有以下简便学习步骤：</p>
<ol>
<li>运行样例，先跑起来</li>
<li>使用其开发&#x2F;写代码</li>
<li>运行，测试代码</li>
<li>打包上线</li>
<li>高级操作</li>
</ol>
<blockquote>
<p>这次主要学习 Spring 相关内容，中间遇到的一些其他知识点，先记录到另外的文件中，然后回头学习。</p>
</blockquote>
<p>首先要明白，<br>Spring Boot 是创建基于 Spring 的应用程序的工具</p>
<blockquote>
<p>下面两句话，可以说明：在 官方文档 Getting Started 章节</p>
<p>Spring Boot 帮助我们创建可独立运行的，生产级的基于 Spring 的应用程序</p>
<p>大多数 Spring Boot 应用程序只需要很少的 Spring 配置，</p>
</blockquote>
<p>Spring Boot的依赖项使用org.springframework.boot groupId。通常，你的Maven POM文件继承自spring-boot-starter-parent项目，并声明对一个或多个”Starters”的依赖。Spring Boot还提供了一个可选的Maven插件来创建可执行的jar。</p>
<h1 id="spring-io网站上-Spring-Boot-的-“入门”-指南-的作用"><a href="#spring-io网站上-Spring-Boot-的-“入门”-指南-的作用" class="headerlink" title="spring.io网站上 Spring Boot 的 “入门” 指南 的作用"></a>spring.io网站上 Spring Boot 的 “入门” 指南 的作用</h1><p>spring.io网站上有许多使用Spring Boot的 “入门” 指南。如果你需要解决一个特定的问题，请先在那里查看。</p>
<ol start="2">
<li>核心原则</li>
</ol>
<p>mvn 项目</p>
<ul>
<li>compile，所有编译（compile）后的class文件，都在target&#x2F;classes 目录下</li>
<li>package， 会执行编译，运行test，打包文件 放在 target 目录下</li>
<li>install，会执行compile，test，package，然后copy target目录下的jar&#x2F;war包到本地repo下，可供其他程序使用。</li>
</ul>
<p>问题：</p>
<p><code>&lt;dependencyManagement&gt;</code>标签在pom中的作用是什么？<br>为什么不依赖 <code>spring-boot-starter-parent</code> 就需要向 <code>&lt;dependencyManagement&gt;</code> 这个依赖管理添加内容？</p>
<p>Spring Boot Reference Document 官方参考文档</p>
<p>Using Spring Boot 	Build Systems, Structuring Your Code, Configuration, Spring Beans and Dependency Injection, DevTools, and more.</p>
<p>Spring Boot Features 	Profiles, Logging, Security, Caching, Spring Integration, Testing, and more.</p>
<p>官方文档写的特定，与自学视频中总结的不太一样，看看是不是出发点不同</p>
<p>Spring Boot 的四大特性</p>
<ul>
<li>自动配置 - Auto Configuration</li>
<li>起步依赖 - Starter Dependency</li>
<li>命令行界面 - Spring Boot CLI</li>
<li>Actuator</li>
</ul>
<p>第一个样例程序，注解说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/hello&quot;)</span>  <span class="comment">// 告诉 Spring 使用 hello() 方法响应发送到 xxx/hello 这个地址的请求</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;Hello %s!&quot;</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>  <span class="comment">// 告诉 Spring 使用 hello() 方法响应发送到 xxx/hello 这个地址的请求。</span></span><br><span class="line"><span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span>  <span class="comment">// 告诉 Spring 允许在 hello 这个请求后面添加 ?name=xxx 的参数，因为是 Get 请求，所以参数前需要使用 ? 符号将请求路径与参数分隔。</span></span><br></pre></td></tr></table></figure>



<p><code>spring-boot-starter-parent</code> 本身没有提供任何依赖</p>
<p>在我们 Sprint Boot 项目的POM文件中，The <code>spring-boot-starter-parent</code> is a special <strong>starter</strong> that provides useful Maven defaults. It also provides a <code>dependency-management</code> section so that you can omit <code>version</code> tags for “blessed” dependencies.</p>
<blockquote>
<p>总的来说就是，<code>spring-boot-starter-parent</code> 也是一个starter，只不过他本身没有提供具体的依赖包，而是提供了一个用来管理版本号的内容，依赖它的POM文件中就可以省掉 spring 相关的版本号了。</p>
</blockquote>
<p>具体的依赖都在 <code>spring-boot-starter-xxx</code> 中，例如 spring-boot-starter-web, 那么问题：如果有多个starter中依赖了相同版本的包，是自动排除多余的吗？如果依赖了同一个包的不同版本，会怎么样？还是 spring 中同一个版本的starter 中依赖的包都是同一个版本？这需要测试一下。</p>
<h1 id="常用注解说明："><a href="#常用注解说明：" class="headerlink" title="常用注解说明："></a>常用注解说明：</h1><p>被称为stereotype注解</p>
<p>它为阅读代码的人和Spring提供了提示，说明这个类扮演了一个特定的角色。</p>
<h2 id="类级注解"><a href="#类级注解" class="headerlink" title="类级注解"></a>类级注解</h2><p><strong>@SpringBootApplication</strong> 用在Main方法类上，包含三个功能，(所以当不想使用 <code>@SpringBootApplication</code> 注解时，也可以使用下面三个注解的组合代替)</p>
<ul>
<li><p>@EnableAutoConfiguration ，启用Spring Boot 的自动配置机制</p>
</li>
<li><p>@ComponentScan ，对应用程序所在的软件包启用@Component扫描，最佳实践是将主Main类放到根包下（即包的根目录下），然后即可以对该类所在的包目录，及其子目录进行 Bean 扫描。</p>
</li>
<li><p>@SpringBootConfiguration ，允许在上下文中注册额外的 bean 或导入其他配置类</p>
<blockquote>
<p>这是 Spring 标准 <code>@Configuration</code> 的替代方案，有助于在你的集成测试中进行配置检测。在 Spring Boot-2.1.1RELEASE 即之前的版本中，使用的是 <code>@Configuration</code> 。</p>
</blockquote>
</li>
</ul>
<p>样例参考 <a href="#%E4%BD%BF%E7%94%A8-SpringBootApplication-%E6%B3%A8%E8%A7%A3">使用 SpringBootApplication 注解</a></p>
<p> <strong>@Controller</strong> 告诉 Spring 这是一个 Web 的endpoint（端点），处理传入的 Web 请求时，会解析这个注解标注的类</p>
<p> <strong>@RestController</strong> 注解告诉Spring将结果字符串直接呈现给调用者。</p>
<blockquote>
<p>The <code>@RestController</code> annotation tells Spring to render the resulting string directly back to the caller.</p>
<p>render 用在前端，一般指<code>渲染</code>的意思，但是在 Spring 中翻译为 <code>呈现</code>更合适。</p>
</blockquote>
<p><strong>@ComponentScan</strong>  查找项目配置的 bean</p>
<p><strong>@Autowired</strong> 进行构造函数注入，标记你希望 Spring 使用的哪个构造函数。（没用@Autowired 标注的构造函数怎么办？）</p>
<p><strong>@Component</strong> </p>
<p>如果按照上面的建议构造代码(将应用程序类放在根包中)，则可以添加 <code>@ComponentScan</code> 而没有任何参数。您的所有应用程序组件( <code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code> 等)都会自动注册为 Spring Bean。</p>
<p><strong>@EnableAutoConfiguration</strong>  注解</p>
<ul>
<li>参考笔记中的<code>了解自动配置的实现原理</code>章节内容，知道自动配置做了哪些事情？怎么做得？如何定制化我们自己的自动配置，并让 Spring Boot 来加载</li>
</ul>
<h2 id="方法级注解"><a href="#方法级注解" class="headerlink" title="方法级注解"></a>方法级注解</h2><p><strong>@RequestMapping</strong> 注解，提供了 “路由”信息。它告诉Spring，任何带有 <code>xxx</code> 路径的HTTP请求都应该被映射到它标注的方法中。</p>
<h2 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h2><h1 id="第六章，使用-Spring-Boot"><a href="#第六章，使用-Spring-Boot" class="headerlink" title="第六章，使用 Spring Boot"></a>第六章，使用 Spring Boot</h1><p>@RequestMapping 注解，提供了 “路由”信息。它告诉Spring，任何带有 <code>xxx</code> 路径的HTTP请求都应该被映射到它标注的方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span>   <span class="comment">// 这里表示任何带有 / 路径的http请求都应该被映射到 home() 方法中</span></span><br><span class="line">String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@RestController和@RequestMapping注解是Spring MVC注解（它们不是Spring Boot特有的）。</p>
<p>为什么 main 方法中需要传入 main 方法所在的类名？</p>
<blockquote>
<p>答： We need to pass <code>MyApplication.class</code> as an argument to the <code>run</code> method to tell <code>SpringApplication</code> which is the <code>primary Spring component</code>.</p>
<p>我们需要将MyApplication.class作为参数传递给run方法，以告诉SpringApplication哪个是主要的Spring组件。</p>
</blockquote>
<h2 id="Spring-Boot-的-Dependency-Management"><a href="#Spring-Boot-的-Dependency-Management" class="headerlink" title="Spring Boot 的 Dependency Management"></a>Spring Boot 的 Dependency Management</h2><p>每个 Spring Boot 版本都提供了它支持的精选依赖列表。</p>
<blockquote>
<p>您仍然可以指定版本，并在需要时覆盖 Spring Boot 的建议。</p>
</blockquote>
<p>精选列表包含了所有可以在Spring Boot中使用的Spring模块，以及第三方库列表。该列表以标准材料清单的形式提供（<code>spring-boot-dependencies</code>），可用于Maven和Gradle。</p>
<blockquote>
<p><code>spring-boot-dependencies</code> 在 <code>spring-boot-starter-parent</code> POM 中作为 parent 部分被依赖，所以当使用 <code>spring-boot-starter-parent</code> 依赖时，这些都会被我们的项目自动继承。</p>
</blockquote>
<p>如果要修改某个依赖库的版本，直接再 pom.xml 中添加 相关依赖版本的 <properties> 属性 </p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注： 在 <code>spring-boot-dependencies</code> pom上查看受支持的属性的列表。</p>
</blockquote>
<p>关于在 Maven 中配置并使用 Spring Boot 相关内容总结：</p>
<ul>
<li>使用 <code>spring-boot-starter-parent</code> 依赖的时候</li>
<li>不适用 <code>spring-boot-starter-parent</code> 依赖的时候</li>
</ul>
<ol>
<li>一般情况，自己项目的 POM 中可以直接依赖 <code>spring-boot-starter-parent</code> 项目的 POM，这样会继承很多 Spring Boot 处理好的默认项，</li>
<li>但是如果有其他 父级 POM 需要依赖，或者不想直接依赖 <code>spring-boot-starter-parent</code>，为了保留 Spring Boot 的依赖管理的好处，可以在 项目的 POM 中添加 <dependencyManagement> ，然后将 <code>spring-boot-dependencies</code> 依赖进来，并且设置 <code>scope=import</code> 。</li>
<li>当需要修改或者覆盖 <code>spring-boot-dependencies</code> 提供的默认依赖版本时，将新版本的信息，添加到 <dependencyManagement> 中，并且放在 <code>spring-boot-dependencies</code> 依赖信息之前即可。</li>
</ol>
<p>样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;!-- Override Spring Data release train provided by Spring Boot --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;Fowler-SR2&lt;/version&gt;</span><br><span class="line">			&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">			&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.1.1.RELEASE&lt;/version&gt;</span><br><span class="line">			&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">			&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>


<h2 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h2><p>Starters 是一组方便在项目中引用的依赖描述符（ dependency descriptors），通过 starter ，我们可以方便的获取 Spring 和相关技术的一站式服务。</p>
<p>Starters 的背景，为什么会存在 Starters ？</p>
<p>传统 Maven 项目的缺点：</p>
<h2 id="构建代码-Struct-code"><a href="#构建代码-Struct-code" class="headerlink" title="构建代码 Struct code"></a>构建代码 Struct code</h2><h3 id="1-命名-Java-软件包（package）"><a href="#1-命名-Java-软件包（package）" class="headerlink" title="1. 命名 Java 软件包（package）"></a>1. 命名 Java 软件包（package）</h3><pre><code>- 使用 Java 建议的包命令约定，并使用反向域名（例如：`com.example.project`）
</code></pre>
<h3 id="2-Main-方法类的位置"><a href="#2-Main-方法类的位置" class="headerlink" title="2. Main 方法类的位置"></a>2. Main 方法类的位置</h3><pre><code>- 通常将包含 Main 方法的类，放在包的根目录下
    &gt; 通常我们会将 `@SpringBootApplication` 注解放在有 main 方法的主类上，放在根包中（包的根目录），有利于程序进行组件扫描。
</code></pre>
<p>下面列出了一个典型的布局。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- MyApplication.java   // 包含 main 方法的主类</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure>

<h3 id="3-Configuration-类"><a href="#3-Configuration-类" class="headerlink" title="3. Configuration 类"></a>3. Configuration 类</h3><p>从官方文档中暂时还不太懂这部分，这部分具体怎么使用需要看后面的文档</p>
<p>这里涉及一个 <code>@Configuration</code> 注解</p>
<p>Spring Boot 支持 Java-based 配置（基于 Java 的配置），同时也支持将 <code>SpringApplication</code> 与 XML 源一起使用，但是建议我们的主源为单个 <code>@Configuration</code> 类</p>
<p>支持导入其他配置类</p>
<blockquote>
<p>您无需将所有@Configuration都放在一个类中。 @Import注解可用于导入其他配置类。另外，您可以使用@ComponentScan自动拾取所有 Spring 组件，包括@Configuration类。</p>
</blockquote>
<p>支持导入 XML 配置</p>
<blockquote>
<p>如果绝对必须使用基于 XML 的配置，我们建议您仍然从@Configuration类开始。然后，您可以使用@ImportResource注解来加载 XML 配置文件。</p>
</blockquote>
<h3 id="4-Auto-configuration"><a href="#4-Auto-configuration" class="headerlink" title="4. Auto-configuration"></a>4. Auto-configuration</h3><blockquote>
<p>这部分内容可以参考 极客时间的视频+笔记 69,70 课</p>
</blockquote>
<p>Spring Boot自动配置试图根据你所添加的jar依赖项自动配置你的Spring应用程序。</p>
<p>例如，如果HSQLDB在你的classpath上，而且你没有手动配置任何数据库连接Bean，那么Spring Boot就会自动配置内存数据库。</p>
<h4 id="1-使用自动配置"><a href="#1-使用自动配置" class="headerlink" title="1. 使用自动配置"></a>1. 使用自动配置</h4><p>你只需要在<strong>主</strong> <code>@Configuration</code> 类中，添加 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 两个注解中的一个即可，从而选择加入自动配置。</p>
<h4 id="2-定制自己的自动配置并替换"><a href="#2-定制自己的自动配置并替换" class="headerlink" title="2. 定制自己的自动配置并替换"></a>2. 定制自己的自动配置并替换</h4><h4 id="3-禁用指定的-Auto-configuration"><a href="#3-禁用指定的-Auto-configuration" class="headerlink" title="3. 禁用指定的 Auto-configuration"></a>3. 禁用指定的 Auto-configuration</h4><p>如果发现正在应用不需要的特定自动配置类，</p>
<ol>
<li>可以通过使用 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 注解的 <code>exclude</code> 属性，指定自动配置类的类名，来禁用它</li>
<li>如果该类不在 classpath 上，你可以使用注解的 <code>excludeName</code> 属性并指定完全合格的名称来代替。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Spring-Bean-和依赖注入"><a href="#Spring-Bean-和依赖注入" class="headerlink" title="Spring Bean 和依赖注入"></a>Spring Bean 和依赖注入</h2><p>问题：依赖注入的目的是什么？与使用普通的 import 方式有什么不同？</p>
<p>我们建议使用 <code>@ComponentScan</code> (查找您的 bean)和使用 <code>@Autowired</code> (进行构造函数注入)。</p>
<p>如果按照上面的建议构造代码(将应用程序类放在根包中)，则可以添加 <code>@ComponentScan</code> 而没有任何参数。您的所有应用程序组件( <code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code> 等)都会自动注册为 Spring Bean。</p>
<p>注：</p>
<ol>
<li>如果一个 Bean 有多个构造函数，你需要用 <code>@Autowired</code> 来标记你希望 Spring 使用的哪个。如果只有一个构造函数，则可以省略 <code>@Autowired</code> 注解</li>
</ol>
<p>例如：下面的例子显示了一个 <code>@ServiceBean</code>，它使用构造函数注入来获得一个所需的 RiskAssessorBean 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAccountService</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果一个 Bean 有多个构造函数，你需要用 <code>@Autowired</code> 来标记你希望 Spring 使用的那个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAccountService</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">        <span class="built_in">this</span>.out = System.out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAccountService</span><span class="params">(RiskAssessor riskAssessor, PrintStream out)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">        <span class="built_in">this</span>.out = out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用-SpringBootApplication-注解"><a href="#使用-SpringBootApplication-注解" class="headerlink" title="使用 SpringBootApplication 注解"></a>使用 SpringBootApplication 注解</h2><p>参考 <a href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E">常用注解说明</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// same as @SpringBootConfiguration @EnableAutoConfiguration</span></span><br><span class="line">                        <span class="comment">// @ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的样例中 <code>@SpringBootApplication</code> 注解也可以用三个单一功能的注解的组合代替</p>
<p>所以具体如何使用完全自由决定，，</p>
<p>如果你不希望在你的应用程序中使用组件扫描（component scan）或配置属性扫描（configuration properties scan）。</p>
<p>也可以使用向下面例子用的组合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration(proxyBeanMethods = false)</span>  <span class="comment">// 在之前版本中这里使用 `@Configuration` ， `@ConfigurationProperties`-注解的类可以被自动检测到</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@Import(&#123; SomeConfiguration.class, AnotherConfiguration.class &#125;)</span>  <span class="comment">// 这里使用了 `@Import` 显示导入指定 Bean，代替了 `@ComponentScan` 自动检测所有` @Component`-annotated 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此示例中，Application 就像其他任何 Spring Boot 应用程序一样，除了不会自动检测到标有 <code>@Component</code>-注解的类和<code>@ConfigurationProperties</code>-注解的类，并且显式导入用户定义的 Bean (请参阅 <code>@Import</code>)。</p>
</blockquote>
<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>几种方式</p>
<ul>
<li>IDE 中导入并运行</li>
<li>打成 jar 包执行<ul>
<li>可执行 jar 包，通过 java -jar xxx&#x2F;xxx.jar<blockquote>
<p>同时执行开启远程调式功能</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> $ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=<span class="number">8000</span>,suspend=n \</span><br><span class="line">-jar target/myapplication-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>使用普通的 classpath + jar 的方式运行</li>
</ul>
</li>
<li>使用 maven 和 gradle 插件运行</li>
<li>热插拔<blockquote>
<p>由于Spring Boot应用程序是普通的Java应用程序，JVM热部署应该可以开箱即用。JVM热部署所能替换的字节码有一定的限制。要获得更完整的解决方案，可以使用 <code>JRebel</code> 。</p>
<p><code>spring-boot-devtools</code> 模块还包括对快速重启应用程序的支持。详情请见 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.hotswapping">“How-to”章节的热插拔</a>。</p>
</blockquote>
</li>
</ul>
<h2 id="Developer-Tools"><a href="#Developer-Tools" class="headerlink" title="Developer Tools"></a>Developer Tools</h2><p>这部分之后再回来重新看</p>
<p>有以下几个功能</p>
<ol>
<li>属性默认值</li>
<li>自动重启<ol>
<li>记录条件评估中的更改</li>
<li>排除资源</li>
<li>注意其他路径</li>
<li>禁用重启</li>
<li>使用触发文件</li>
<li>自定义重启类加载器</li>
<li>已知限制</li>
<li></li>
</ol>
</li>
<li>LiveReload</li>
<li>全局设置</li>
<li>远程应用程序</li>
</ol>
<h1 id="Spring-Boot-Features"><a href="#Spring-Boot-Features" class="headerlink" title="Spring Boot Features"></a>Spring Boot Features</h1><h2 id="1-1-启动失败"><a href="#1-1-启动失败" class="headerlink" title="1.1. 启动失败"></a>1.1. 启动失败</h2><p>如果你的应用程序启动失败，注册的 <code>FailureAnalyzers</code> 有机会提供专门的错误信息和具体的行动来解决这个问题。 </p>
<p>如果你通过使用java -jar运行你的应用程序，你可以启用debug属性，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar myproject-0.0.1-SNAPSHOT.jar --debug</span></span><br></pre></td></tr></table></figure>

<h2 id="1-7-应用程序事件和侦听器"><a href="#1-7-应用程序事件和侦听器" class="headerlink" title="1.7. 应用程序事件和侦听器"></a>1.7. 应用程序事件和侦听器</h2><p>在内部，Spring Boot 使用事件来处理各种任务。你通常不需要使用应用程序事件，但知道它们的存在会很方便。</p>
<p>当你的应用程序运行时，应用程序事件按以下顺序发送：</p>
<blockquote>
<p>这部分也查看官方文档</p>
</blockquote>
<p>Application events是通过使用Spring框架的事件发布机制来发送的。</p>
<h2 id="1-8-Web-环境"><a href="#1-8-Web-环境" class="headerlink" title="1.8. Web 环境"></a>1.8. Web 环境</h2><p><code>SpringApplication</code> 试图帮你创建正确类型的 <code>ApplicationContext</code> 。用于确定 <code>WebApplicationType</code> 的算法如下:</p>
<ul>
<li>如果 Spring MVC 存在，就会使用 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li>
<li>如果 Spring MVC 不存在而 Spring WebFlux 存在，则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code>。</li>
<li>否则，将使用 <code>AnnotationConfigApplicationContext</code>。</li>
</ul>
<p>这意味着，如果你在同一个应用程序中使用 Spring MVC 和 Spring WebFlux 的新 WebClient，<strong>将默认使用 Spring MVC</strong>。你可以通过调用 <code>setWebApplicationType(WebApplicationType)</code> 轻松覆盖。</p>
<p>也可以通过调用 <code>setApplicationContextClass(..)</code> 来完全控制使用的 <code>ApplicationContext</code> 类型。</p>
<blockquote>
<p>当在 JUnit 测试中使用 <code>SpringApplication</code> 时，通常需要调用 <code>setWebApplicationType(WebApplicationType.NONE)</code>。</p>
</blockquote>
<h2 id="1-9-访问-Application-参数"><a href="#1-9-访问-Application-参数" class="headerlink" title="1.9. 访问 Application 参数"></a>1.9. 访问 Application 参数</h2><p>&#x2F;&#x2F; do something…</p>
<h2 id="1-10-使用-ApplicationRunner-或者-CommandLineRunner"><a href="#1-10-使用-ApplicationRunner-或者-CommandLineRunner" class="headerlink" title="1.10. 使用 ApplicationRunner 或者 CommandLineRunner"></a>1.10. 使用 ApplicationRunner 或者 CommandLineRunner</h2><p><strong>使用场景：</strong>当你需要在 <code>SpringApplication</code> 启动后，但在其开始接受访问之前运行一些代码&#x2F;任务，可以使用下面的接口定义 Runner Bean：</p>
<ul>
<li><p>ApplicationRunner</p>
<ul>
<li><code>run(ApplicationArguments args)</code>  ，参数为 ApplicationArguments</li>
</ul>
</li>
<li><p>CommandLineRunner</p>
<ul>
<li><code>run(String... args)</code>  ，参数为 String[]</li>
</ul>
</li>
</ul>
<p><strong>异同：</strong></p>
<ul>
<li>相同点：两个接口，工作方式相同，</li>
<li>不同点：接受参数方式不同，参考上面 run 的传参</li>
</ul>
<p><strong>使用方式：</strong></p>
<ul>
<li><p>实现接口提供的 <code>run</code> 方法，并定义为 Bean (交给 Spring 管理)</p>
<blockquote>
<p>该方法会在 <code>SpringApplication.run(...)</code> 完成之前被调用。</p>
<p>注：在 SpringApplication 的 <code>public ConfigurableApplicationContext run(String... args)</code> 方法中 </p>
<p><code>callRunners(context, applicationArguments);</code> &#x2F;&#x2F; 调用 所有的 Runner 接口实现</p>
</blockquote>
</li>
<li><p>这就有两种方式，一种使用 <code>@Component</code> 作用在实现接口的类上，定义为 Bean，</p>
</li>
<li><p>另一种，使用 <code>@Bean</code> 注解，在配置类中定义返回 Bean 的方法。</p>
</li>
</ul>
<p>如果定义了多个Runner <strong>Bean</strong> （CommandLineRunner 或 ApplicationRunner），可以通过添加 @Order 注解，或者实现 <code>org.springframework.core.Ordered</code> 接口来指定运行顺序</p>
<p>样例：方法一，创建实现接口的类，并标注为 Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>样例2：使用 @Bean ，定义返回 Bean 的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">demo2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandLineRunner</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里也可以使用 lambda表达式来处理</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">demo2</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line"> <span class="comment">// do something...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="1-11-程序退出"><a href="#1-11-程序退出" class="headerlink" title="1.11. 程序退出"></a>1.11. 程序退出</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.spring-application.application-exit">https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.spring-application.application-exit</a></p>
<p>从1.8~1.11 这四个子章节的内容与 极客时间的《82 编写命令行运行的程序》内容差不多，再看时，可以考虑两个集合在一起。</p>
<h2 id="1-13-应用程序启动跟踪"><a href="#1-13-应用程序启动跟踪" class="headerlink" title="1.13. 应用程序启动跟踪"></a>1.13. 应用程序启动跟踪</h2><p>在应用启动期间，<code>SpringApplication</code> 和 <code>ApplicationContext</code> 执行许多与应用生命周期、Bean 生命周期，甚至处理应用事件有关的任务。通过 <code>ApplicationStartup</code>，Spring 框架允许你用 <code>StartupStep</code> 对象跟踪应用程序的启动顺序。这些数据可以为分析目的而收集，或者只是为了更好地了解应用程序的启动过程。</p>
<blockquote>
<p>具体使用参考官方文档 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.spring-application.startup-tracking">应用程序启动跟踪</a></p>
</blockquote>
<h2 id="2-外化配置"><a href="#2-外化配置" class="headerlink" title="2. 外化配置"></a>2. 外化配置</h2><p>极客时间的 73,74两节内容，与这部分有关联，再深入看时，可以结合在一起看。</p>
<blockquote>
<p>2.5.3 版本，这部分写的顺序更容易理解，2.1.1-RELEASE 版本中写的可能让新手容易混淆。</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.external-config">https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.external-config</a></p>
</blockquote>
<p>Spring Boot让你将配置外部化，这样你就可以在不同的环境中使用相同的应用程序代码。你可以使用各种外部配置源，包括Java properties文件、YAML文件、环境变量和命令行参数。</p>
<p>属性值可以通过使用 <code>@Value</code> 注解直接注入你的Bean，通过Spring的 <code>Environment</code> 抽象访问，或者通过 <code>@ConfigurationProperties</code> <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties">绑定到结构化对象</a>。</p>
<h3 id="PropertySource-加载和生效顺序"><a href="#PropertySource-加载和生效顺序" class="headerlink" title="PropertySource 加载和生效顺序"></a>PropertySource 加载和生效顺序</h3><p>Spring Boot 的 <code>PropertySource</code> 顺序，旨在合理的覆盖值。属性是按照以下顺序考虑。</p>
<blockquote>
<p>（后面读取的项目值会覆盖前面读取的相同项目值）</p>
</blockquote>
<ol>
<li><p>默认属性（通过设置 <code>SpringApplication.setDefaultProperties</code> 指定）。</p>
</li>
<li><p><code>@Configuration</code> 类上的 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/context/annotation/PropertySource.html">@PropertySource</a> 注解。请注意，这样的属性源直到 application context 被刷新时才会被添加到环境中。这对于配置某些属性来说已经太晚了，比如 <code>logging.*</code> 和 <code>spring.main.*</code> ，它们在刷新开始前就已经被读取了。</p>
</li>
<li><p>配置文件（如 <code>application.properties</code> 文件）。</p>
<ol>
<li>打包在你的 jar 里面(application.properties 和 YAML 变体 .yml)。</li>
<li>打包在你的jar中（application-{profile}.properties和YAML变量）。</li>
<li>在你打包的jar之外(application.properties和YAML变体)。</li>
<li>在你打包的jar之外（application-{profile}.properties和YAML变体）。<blockquote>
<p>建议你在整个应用程序中坚持使用一种格式。如果你在同一地点有 <code>.properties</code> 和<code>.yml</code>格式的配置文件，<code>.properties</code>优先。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>一个 <code>RandomValuePropertySource</code> ，它的属性只有 <code>random.*</code> 。</p>
</li>
<li><p>操作系统环境变量。</p>
</li>
<li><p>Java 系统属性（<code>System.getProperties()</code>），java -D 参数指定的属性，在命令行中可以通过 -D 参数来指定一些系统属性。</p>
</li>
<li><p>来自 <code>java:comp/env</code> 的 JNDI 属性。</p>
</li>
<li><p><code>ServletContext</code> 初始参数。</p>
</li>
<li><p><code>ServletConfig</code> 初始参数。</p>
</li>
<li><p>来自 <code>SPRING_APPLICATION_JSON</code> 的属性（嵌入环境变量或系统属性中的内联 JSON ）。</p>
</li>
<li><p>命令行参数，（例如，–server.port&#x3D;9000， <code>SpringApplication</code> 会将任何命令行选项参数转换为 propert y并将其添加到 Spring 的 <code>Environment</code> 中。）</p>
<ul>
<li>如果你不希望命令行属性被添加到 <code>Environment</code> 中，你可以通过使用 <code>SpringApplication.setAddCommandLineProperties(false)</code> 来禁用它们。</li>
</ul>
</li>
<li><p><code>properties</code> 属性在你的 <code>tests</code> 上。在 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/api/org/springframework/boot/test/context/SpringBootTest.html">@SpringBootTest</a> 和用于测试你的应用程序的特定片断的测试注释上可用。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.9/javadoc-api/org/springframework/test/context/TestPropertySource.html">@TestPropertySource</a> 对你的测试进行注解。</p>
</li>
<li><p>当 devtools 处于活动状态时，在 <code>$HOME/.config/spring-boot</code> 目录下的 Devtools 全局设置属性。</p>
</li>
</ol>
<p>以上内容需要亲自使用测试，来掌握具体内容。</p>
<p>例如：</p>
<p>在你的应用程序的classpath（例如，在你的 jar 中），你可以有一个 application.properties 文件，为 name 提供一个合理的默认属性值。当在一个新的环境中运行时，可以在 jar 之外提供一个 application.properties 文件，覆盖 name 。</p>
<p>注：</p>
<blockquote>
<p><code>env</code>和<code>configprops</code>端点在确定一个属性为什么有一个特定的值时很有用，具体可以参考  <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints">Production ready features</a> 章节</p>
</blockquote>
<blockquote>
<p>个人理解：文档中的 <code>优先</code>(takes precedence)，应该是使用的优先级，当存在a属性时，先使用a，当a不存在时，使用b。而属性加载的顺序更好相反，这样后面读取的才能更好地覆盖前面的读取的值。</p>
</blockquote>
<p>问题： </p>
<ol>
<li>lower order property sources , 这里的 lower order 是在哪里定义的？</li>
<li>The list is ordered by precedence (with values from lower items overriding earlier ones). 列表按优先级排序（较低项目的值覆盖较早项目的值）<ul>
<li>这里也是，这个 lower items 是怎么定义的？ a,b,c 这三个值，a低？还是c低？ 这是国外固有的顺序？还是哪里定义的顺序？</li>
<li>从上下文来看，a&gt;b&gt;c,但是还是对官方文档中使用 lower 这个词有疑惑。</li>
</ul>
</li>
</ol>
<h3 id="外部配置详细说明"><a href="#外部配置详细说明" class="headerlink" title="外部配置详细说明"></a>外部配置详细说明</h3><h3 id="2-1-访问命令行属性"><a href="#2-1-访问命令行属性" class="headerlink" title="2.1 访问命令行属性"></a>2.1 访问命令行属性</h3><h3 id="2-2-JSON-Application-Properties"><a href="#2-2-JSON-Application-Properties" class="headerlink" title="2.2 JSON Application Properties"></a>2.2 JSON Application Properties</h3><h3 id="2-3-External-Application-Properties-（外部-application-properties-属性配置文件）"><a href="#2-3-External-Application-Properties-（外部-application-properties-属性配置文件）" class="headerlink" title="2.3 External Application Properties  （外部 application.properties 属性配置文件）"></a>2.3 External Application Properties  （外部 application.properties 属性配置文件）</h3><h4 id="2-3-1-加载使用-application-properties-配置文件"><a href="#2-3-1-加载使用-application-properties-配置文件" class="headerlink" title="2.3.1 加载使用 application.properties 配置文件"></a><strong>2.3.1 加载使用 <code>application.properties</code> 配置文件</strong></h4><p>当你的应用程序启动时，Spring Boot 会自动从以下位置找到并加载 <code>application.properties</code> 和 <code>application.yaml</code> 文件。</p>
<ol>
<li>classpath<ol>
<li>classpath的根路径</li>
<li>classpath <code>/config</code> 包</li>
</ol>
</li>
<li>当前目录<ol>
<li>当前目录根路径</li>
<li>当前目录下的 <code>/config</code> 子目录</li>
<li><code>/config</code> 子目录的直接子目录。<blockquote>
<p>列表按优先级排序（在列表较低位置定义的属性会覆盖在较高位置定义的属性）。<br>加载的文件被作为 <code>PropertySources</code> 添加到 Spring 的 <code>Environment</code> 中。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>修改默认名字或者路径：</p>
<ul>
<li>spring.config.name</li>
<li>spring.config.location</li>
<li>spring.config.extra-location （Spring Boot 2.5.3 版本使用）<ul>
<li>spring.config.additional-location (Spring Boot 2.1.1-RELEASE 版本使用)<blockquote>
<p>通过将上述参数定义为环境属性(通常是 OS 环境变量（操作系统环境变量），系统属性或命令行参数)。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>**<code>spring.config.name</code>**， 如果您不喜欢 <code>application.properties</code> 作为配置文件名，则可以通过指定 <code>spring.config.name</code> 环境属性来切换到另一个文件名。例如：改为 myproject.properties 和 myproject.yaml 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar myproject.jar --spring.config.name=myproject</span></span><br></pre></td></tr></table></figure>

<p>**<code>spring.config.location</code>**， 您还可以使用 <code>spring.config.location</code> 环境属性(这是目录位置或文件路径的<code>逗号分隔</code>列表)来引用显式位置。下面的示例演示如何指定其他文件名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar myproject.jar --spring.config.location=\</span></span><br><span class="line"><span class="language-bash">    optional:classpath:/default.properties,\</span></span><br><span class="line"><span class="language-bash">    optional:classpath:/override.properties</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果位置是可选的并且你不介意它们不存在，请使用前缀 <code>optional:</code> 。</p>
</blockquote>
<p><strong>注：</strong> 通过使用 <code>spring.config.location</code> 配置的位置将取代默认位置。如果你想添加额外的位置，而不是替换它们，你可以使用 <code>spring.config.extra-location</code> 。从附加位置加载的属性可以覆盖默认位置的属性。</p>
<blockquote>
<p>具体样例参考官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.external-config.files">外部 application.properties</a></p>
</blockquote>
<h4 id="2-3-2-配置文件特定属性-（Profile-Specific-Files）"><a href="#2-3-2-配置文件特定属性-（Profile-Specific-Files）" class="headerlink" title="2.3.2 配置文件特定属性 （Profile Specific Files）"></a><strong>2.3.2 配置文件特定属性 （Profile Specific Files）</strong></h4><p>除了 <code>application.properties</code> 文件之外，Spring Boot 还将尝试使用命名惯例 <code>application-&#123;profile&#125;</code>加载特定配置文件(profile-specific files)。例如，如果你的应用程序激活了名为 <code>prod</code> 的配置文件并使用 YAML 文件，那么 <code>application.yml</code> 和<code>application-prod.yml</code> 都将被考虑。</p>
<p>特定配置文件与标准的<code>application.properties</code>的位置相同，特定配置文件总是优先于非特定文件。如果指定了几个配置文件，则采用最后胜出的策略。例如，如果配置文件 <code>prod,live</code> 是由<code>spring.profiles.active</code>属性指定的，<code>application-prod.properties</code>中的值可以被<code>application-live.properties</code>中的值覆盖。</p>
<p>如何设置&#x2F;激活，特定配置文件，结合 </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.profiles">Profiles 章节</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.properties-and-configuration.set-active-spring-profiles">How-to 章节中 Set the Active Spring Profiles 章节</a></li>
</ul>
<h4 id="2-3-3-属性中的占位符（Property-Placeholders）"><a href="#2-3-3-属性中的占位符（Property-Placeholders）" class="headerlink" title="2.3.3 属性中的占位符（Property Placeholders）"></a><strong>2.3.3 属性中的占位符（Property Placeholders）</strong></h4><p><code>application.properties</code>和<code>application.yml</code>中的值在使用时通过现有的 <code>Environment</code> 过滤，所以你可以参考以前定义的值（例如，从系统属性）。标准的 <code>$&#123;name&#125;</code> 属性占位符语法可以在一个值的任何地方使用。</p>
<p>例如，下面的文件将把<code>app.description</code>设置为 “MyApp is a Spring Boot application”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app:</span><br><span class="line">  name: &quot;MyApp&quot;</span><br><span class="line">  description: &quot;$&#123;app.name&#125; is a Spring Boot application&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>您还可以使用此技术来创建现有 Spring Boot 属性的“简短”变体。详细参考 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.properties-and-configuration.short-command-line-arguments">How-to章节的使用短命令行参数章节</a></p>
</blockquote>
<h3 id="2-4-加密配置属性"><a href="#2-4-加密配置属性" class="headerlink" title="2.4 加密配置属性"></a>2.4 加密配置属性</h3><h3 id="2-5-使用YAML-（使用-yaml-代替-properties-配置文件）"><a href="#2-5-使用YAML-（使用-yaml-代替-properties-配置文件）" class="headerlink" title="2.5 使用YAML （使用 yaml 代替 properties 配置文件）"></a>2.5 使用YAML （使用 yaml 代替 properties 配置文件）</h3><p>具体参考官方文档</p>
<p><code>YAML</code>是 JSON 的超集，因此是一种用于指定<em>层次结构</em>配置数据的便捷格式。</p>
<ol>
<li><p>使用条件，</p>
<ul>
<li>只要在 Classpath 上具有 <code>SnakeYAML</code>库，<code>SpringApplication</code> 类就会自动支持 YAML 作为属性的替代方法。<blockquote>
<p>如果您使用“Starter”，则 <code>spring-boot-starter</code>自动提供 SnakeYAML。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>如何加载 YAML ？</p>
</li>
<li><p>YAML 缺点</p>
<ul>
<li>YAML文件不能通过使用 <code>@PropertySource</code> 或 <code>@TestPropertySource</code> 注解来加载。所以，在你需要以这种方式加载值的情况下，你需要使用一个properties文件。</li>
</ul>
</li>
</ol>
<h3 id="2-6-配置随机值-（Ramdom）"><a href="#2-6-配置随机值-（Ramdom）" class="headerlink" title="2.6 配置随机值 （Ramdom）"></a>2.6 配置随机值 （Ramdom）</h3><h3 id="2-7-配置系统环境属性-（Configuring-System-Environment-Properties）"><a href="#2-7-配置系统环境属性-（Configuring-System-Environment-Properties）" class="headerlink" title="2.7 配置系统环境属性 （Configuring System Environment Properties）"></a>2.7 配置系统环境属性 （Configuring System Environment Properties）</h3><h3 id="2-8-类型安全的配置属性-（-Type-safe-Configuration-Properties）"><a href="#2-8-类型安全的配置属性-（-Type-safe-Configuration-Properties）" class="headerlink" title="2.8 类型安全的配置属性 （ Type-safe Configuration Properties）"></a>2.8 类型安全的配置属性 （ Type-safe Configuration Properties）</h3><p>该章节主要介绍 <code>@ConfigurationProperties</code> 注解相关内容，具体参考官方文档，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.external-config.typesafe-configuration-properties">Type-safe Configuration Properties</a>。</p>
<p>背景：</p>
<p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 注解来注入配置属性有时会很麻烦，特别是当你要处理多个属性或你的数据是分层的。Spring Boot提供了一种处理属性的替代方法，让强类型的 Bean 管理和验证你的应用程序的配置。</p>
<p>Spring Boot提供了绑定 <code>@ConfigurationProperties</code> 类型并将其注册为Bean的基础设施。</p>
<p>另请参见 <a href="#2.8.10-@ConfigurationProperties-vs.-@Value">@Value和类型安全配置属性的区别</a>。</p>
<h4 id="2-8-1-JavaBean-属性绑定"><a href="#2-8-1-JavaBean-属性绑定" class="headerlink" title="2.8.1 JavaBean 属性绑定"></a>2.8.1 JavaBean 属性绑定</h4><h4 id="2-8-2-构造函数绑定"><a href="#2-8-2-构造函数绑定" class="headerlink" title="2.8.2 构造函数绑定"></a>2.8.2 构造函数绑定</h4><h4 id="2-8-3-启用-Enabling-ConfigurationProperties-annotated-类型"><a href="#2-8-3-启用-Enabling-ConfigurationProperties-annotated-类型" class="headerlink" title="2.8.3 启用(Enabling) @ConfigurationProperties-annotated 类型"></a>2.8.3 启用(Enabling) @ConfigurationProperties-annotated 类型</h4><h4 id="2-8-4-使用-Using-ConfigurationProperties-annotated-类型"><a href="#2-8-4-使用-Using-ConfigurationProperties-annotated-类型" class="headerlink" title="2.8.4 使用(Using) @ConfigurationProperties-annotated 类型"></a>2.8.4 使用(Using) @ConfigurationProperties-annotated 类型</h4><h4 id="2-8-5-第三方配置"><a href="#2-8-5-第三方配置" class="headerlink" title="2.8.5 第三方配置"></a>2.8.5 第三方配置</h4><h4 id="2-8-6-宽松绑定"><a href="#2-8-6-宽松绑定" class="headerlink" title="2.8.6 宽松绑定"></a>2.8.6 宽松绑定</h4><h4 id="2-8-7-合并复杂类型"><a href="#2-8-7-合并复杂类型" class="headerlink" title="2.8.7 合并复杂类型"></a>2.8.7 合并复杂类型</h4><h4 id="2-8-8-属性转换"><a href="#2-8-8-属性转换" class="headerlink" title="2.8.8 属性转换"></a>2.8.8 属性转换</h4><h4 id="2-8-9-ConfigurationProperties-验证"><a href="#2-8-9-ConfigurationProperties-验证" class="headerlink" title="2.8.9 @ConfigurationProperties 验证"></a>2.8.9 @ConfigurationProperties 验证</h4><h4 id="2-8-10-ConfigurationProperties-vs-Value"><a href="#2-8-10-ConfigurationProperties-vs-Value" class="headerlink" title="2.8.10 @ConfigurationProperties vs. @Value"></a>2.8.10 @ConfigurationProperties vs. @Value</h4><p><code>@Value</code> 注解是一个核心的容器功能，它不提供与 <em>类型安全的配置属性(<code>@ConfigurationProperties</code>)</em> 相同的功能。下表总结了 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 所支持的功能。</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>@ConfigurationProperties</th>
<th>@Value f</th>
</tr>
</thead>
<tbody><tr>
<td>Relaxed binding</td>
<td>Yes</td>
<td>Limited (see note below)</td>
</tr>
<tr>
<td>Meta-data support</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>SpEL evaluation</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<h2 id="3-Profiles"><a href="#3-Profiles" class="headerlink" title="3. Profiles"></a>3. Profiles</h2><p>具体参考 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.profiles">官方文档</a></p>
<p>我个人理解，它的功能就是根据配置的参数，支持在不同的环境中使用参数指定的配置文件。</p>
<h3 id="3-1-利用-Profile-指定应用程序配置何时被加载"><a href="#3-1-利用-Profile-指定应用程序配置何时被加载" class="headerlink" title="3.1 利用 @Profile 指定应用程序配置何时被加载"></a>3.1 利用 <code>@Profile</code> 指定应用程序配置何时被加载</h3><p>Spring Profiles提供了一种方法来隔离你的应用程序配置的一部分，使其只在某些环境下可用。任何 <code>@Component</code>、<code>@Configuration</code> 或 <code>@ConfigurationProperties</code> 都可以用 <code>@Profile</code> 来标记，以限制它何时被加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 <code>@ConfigurationProperties</code> Bean 是通过 <code>@EnableConfigurationProperties</code> 注册的，而不是<code>自动扫描</code>，则需要在具有 <code>@EnableConfigurationProperties</code> 注解的 <code>@Configuration</code> 类上指定 <code>@Profile</code> 注解。在 <code>@ConfigurationProperties</code> 被扫描的情况下，<code>@Profile</code> 可以在 <code>@ConfigurationProperties</code> 类本身指定。</p>
</blockquote>
<h3 id="3-2-如何-启用-x2F-激活-不同的配置文件"><a href="#3-2-如何-启用-x2F-激活-不同的配置文件" class="headerlink" title="3.2 如何 启用&#x2F;激活 不同的配置文件"></a>3.2 如何 启用&#x2F;激活 不同的配置文件</h3><p>使用 <code>spring.profiles.active</code> 这个<code>Environment</code>属性来指定哪些配置文件是活动的。可以将这个属性添加到配置文件中，同样也可以使用命令行参数的形式替换。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev,hsqldb</span><br></pre></td></tr></table></figure>
<p>或者使用命令行的形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--spring.profiles.active=dev,hsqldb</span><br></pre></td></tr></table></figure>

<p>注：如果没有配置 active 状态的配置文件(profile)，Spring 就会启用一个默认的配置文件，例如：<code>application-default.properties</code>。<br>当然我们也可以通过 <code>spring.profiles.default</code> 这个 <code>Environment</code> 属性，来做调整， 例如： <code>spring.profiles.default=none</code></p>
<p><code>spring.profiles.active</code> 属性的生效覆盖方式，与其他普通属性一样，加载生效顺序，参考 <a href="#PropertySource-%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%94%9F%E6%95%88%E9%A1%BA%E5%BA%8F">外化配置</a></p>
<p>例如：可以在application.properties中指定活动配置文件，然后通过使用命令行开关替换它们。</p>
<p>有时，有一些属性可以添加到活动配置文件中，而不是替换它们。参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/api/org/springframework/boot/SpringApplication.html">SpringApplication API</a>中的setAdditionalProfiles()方法。</p>
<h2 id="4-Logging"><a href="#4-Logging" class="headerlink" title="4. Logging"></a>4. Logging</h2><p>详细内容参考 官方文档<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.logging">logging</a></p>
<p>一般来说，你不需要改变你的日志依赖，Spring Boot的默认值就很好用。</p>
<blockquote>
<p>如果你使用 “Starter”，Logback被用来做日志记录</p>
</blockquote>
<h3 id="4-1-日志格式"><a href="#4-1-日志格式" class="headerlink" title="4.1. 日志格式"></a>4.1. 日志格式</h3><p>日志级别: ERROR, WARN, INFO, DEBUG, 或TRACE.</p>
<blockquote>
<p>Logback没有FATAL级别。它被映射到 ERROR。</p>
</blockquote>
<h3 id="4-3-输出到文件"><a href="#4-3-输出到文件" class="headerlink" title="4.3. 输出到文件"></a>4.3. 输出到文件</h3><p>默认情况下，Spring Boot只向控制台记录日志，不写日志文件。</p>
<p>如果你想在控制台输出之外写日志文件，你需要设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性（例如，在你的 <code>application.properties</code>）。</p>
<p>下表显示了 <code>logging.*</code> 属性如何被一起使用。</p>
<table>
<thead>
<tr>
<th>logging.file.name</th>
<th>logging.file.path</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>(none)</td>
<td>(none)</td>
<td></td>
<td>只在控制台进行记录。</td>
</tr>
<tr>
<td>指定文件</td>
<td>(none)</td>
<td>my.log</td>
<td>写到指定的日志文件。名称可以是准确的位置，也可以是与当前目录的相对位置。</td>
</tr>
<tr>
<td>(none)</td>
<td>指定目录</td>
<td>&#x2F;var&#x2F;log</td>
<td>将spring.log写到指定目录。名称可以是准确的位置，也可以是与当前目录的相对位置。</td>
</tr>
</tbody></table>
<blockquote>
<p>日志文件在达到 10MB 时就会轮换，与控制台输出一样，默认情况下会记录 ERROR-级、WARN-级和 INFO-级的信息。</p>
</blockquote>
<p>其他的如，日志文件轮询策略等参考官方文档。</p>
<h3 id="4-8-自定义日志配置"><a href="#4-8-自定义日志配置" class="headerlink" title="4.8. 自定义日志配置"></a>4.8. 自定义日志配置</h3><p>根据你的日志系统，会加载以下文件。</p>
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody><tr>
<td>Logback</td>
<td>logback-spring.xml , logback-spring.groovy , logback.xml , or logback.groovy</td>
</tr>
<tr>
<td>Log4j2</td>
<td>log4j2-spring.xml or log4j2.xml</td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td>logging.properties</td>
</tr>
</tbody></table>
<h2 id="7-开发-Web-Applications"><a href="#7-开发-Web-Applications" class="headerlink" title="7. 开发 Web Applications"></a>7. 开发 Web Applications</h2><p>大多数Web应用程序使用 <code>spring-boot-starter-web</code> 模块来快速启动和运行。</p>
<p>使用 <code>spring-boot-starter-webflux</code> 模块来构建 reactive Web 应用。</p>
<h3 id="7-1-Spring-Web-MVC-框架"><a href="#7-1-Spring-Web-MVC-框架" class="headerlink" title="7.1. Spring Web MVC 框架"></a>7.1. Spring Web MVC 框架</h3><p>创建特殊的 <code>@Controller</code> 或 <code>@RestController</code> bean 来处理 HTTP 请求。</p>
<p>控制器中的方法通过使用 <code>@RequestMapping</code> 注解被映射到 HTTP。</p>
<p>Spring MVC是Spring框架核心的一部分，详细的信息可以在 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.9/reference/html/web.html#mvc">参考文档</a> 中找到</p>
<h4 id="7-1-1-Spring-MVC自动配置"><a href="#7-1-1-Spring-MVC自动配置" class="headerlink" title="7.1.1. Spring MVC自动配置"></a>7.1.1. Spring MVC自动配置</h4><h4 id="7-1-2-HttpMessageConverters"><a href="#7-1-2-HttpMessageConverters" class="headerlink" title="7.1.2. HttpMessageConverters"></a>7.1.2. HttpMessageConverters</h4><p>Spring MVC 使用 <code>HttpMessageConverter</code> 接口来转换 HTTP 请求和响应。</p>
<p>它支持一些开箱即用的默认值，<br>例如：</p>
<ol>
<li><p>对象可以自动转换为 JSON（通过使用 Jackson 库）或 XML（通过使用 Jackson XML 扩展，如果可用的话，或通过使用 JAXB，如果 Jackson XML扩展不可用）。</p>
</li>
<li><p>默认情况下，字符串是以 UTF-8 编码的。</p>
</li>
</ol>
<p>你可以使用 Spring Boo t的 <code>HttpMessageConverters</code> 类，添加或定制转换器。</p>
<p>任何存在于上下文中的 <code>HttpMessageConverter</code> bean都会被添加到转换器的列表中。</p>
<h4 id="7-1-3-自定义-JSON-Serializers-和-Deserializers"><a href="#7-1-3-自定义-JSON-Serializers-和-Deserializers" class="headerlink" title="7.1.3. 自定义 JSON Serializers 和 Deserializers"></a><strong>7.1.3. 自定义 JSON Serializers 和 Deserializers</strong></h4><p>如果你使用 Jackson 来序列化和反序列化 JSON 数据，你可能想编写自己的 JsonSerializer 和 JsonDeserializer 类。</p>
<p>自定义序列化器通常是<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers">通过模块与Jackson注册</a>，但 Spring Boot 提供了一个替代性的 <code>@JsonComponent</code> 注解，使直接注册 Spring Beans 更容易。</p>
<p>关于 <code>@JsonComponent</code> 注解使用场景</p>
<ol>
<li>你可以直接在 <code>JsonSerializer</code> 、<code>JsonDeserializer</code> 或 <code>KeyDeserializer</code> 实现上使用 <code>@JsonComponent</code> 注解。</li>
<li>也可以在那些包含序列化器&#x2F;反序列化器作为内部类(inner classes)的类上使用它。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.ObjectCodec;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.DeserializationContext;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.jackson.JsonComponent;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJsonComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Serializer</span> <span class="keyword">extends</span> <span class="title class_">JsonSerializer</span>&lt;MyObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(MyObject value, JsonGenerator jgen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            jgen.writeStringField(<span class="string">&quot;name&quot;</span>, value.getName());</span><br><span class="line">            jgen.writeNumberField(<span class="string">&quot;age&quot;</span>, value.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Deserializer</span> <span class="keyword">extends</span> <span class="title class_">JsonDeserializer</span>&lt;MyObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MyObject <span class="title function_">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext ctxt)</span></span><br><span class="line">                <span class="keyword">throws</span> IOException, JsonProcessingException &#123;</span><br><span class="line">            <span class="type">ObjectCodec</span> <span class="variable">codec</span> <span class="operator">=</span> jsonParser.getCodec();</span><br><span class="line">            <span class="type">JsonNode</span> <span class="variable">tree</span> <span class="operator">=</span> codec.readTree(jsonParser);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> tree.get(<span class="string">&quot;name&quot;</span>).textValue();</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> tree.get(<span class="string">&quot;age&quot;</span>).intValue();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(name, age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ApplicationContext</code> 中的所有 <code>@JsonComponent</code> Bean 都会自动向 Jackson 注册。因为 <code>@JsonComponent</code> 是用 <code>@Component</code> 元注释的，所以通常的组件扫描规则适用。</p>
</blockquote>
<p>Spring Boot还提供了 <code>JsonObjectSerializer</code> 和 <code>JsonObjectDeserializer</code> 基类，在序列化对象时提供了标准 Jackson 版本的有用替代品。详情见 Javadoc 中的 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/api/org/springframework/boot/jackson/JsonObjectSerializer.html">JsonObjectSerializer</a> 和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/api/org/springframework/boot/jackson/JsonObjectDeserializer.html">JsonObjectDeserializer</a>。</p>
<h4 id="7-1-5-静态内容"><a href="#7-1-5-静态内容" class="headerlink" title="7.1.5. 静态内容"></a>7.1.5. 静态内容</h4><p>默认情况下，Spring Boot从 classpath 中的 <code>/static</code> （或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/resources</code> ）目录或 <code>ServletContext</code> 的根中提供静态内容。它使用了 Spring MVC 中的 <code>ResourceHttpRequestHandler</code> ，因此你可以通过添加你自己的 <code>WebMvcConfigurer</code> 并重写 <code>addResourceHandlers</code> 方法来修改该行为。</p>
<p>具体参考<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.spring-mvc.static-content">官方文档</a></p>
<h4 id="7-1-7-路径匹配和内容协商"><a href="#7-1-7-路径匹配和内容协商" class="headerlink" title="7.1.7. 路径匹配和内容协商"></a><strong>7.1.7. 路径匹配和内容协商</strong></h4><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.spring-mvc.content-negotiation">https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.spring-mvc.content-negotiation</a></p>
<p>Spring MVC 可以通过查看请求路径并将其与应用程序中定义的映射（例如，控制器方法上的 <code>@GetMapping</code> 注解）相匹配，将传入的 HTTP 请求映射到处理程序。</p>
<p>Spring Boot 默认选择禁用后缀模式匹配，这被认为是一个 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.9/reference/html/web.html#mvc-ann-requestmapping-suffix-pattern-match">Spring MVC应用的最佳实践</a>。</p>
<p>这意味着诸如 <code>&quot;GET /projects/spring-boot.json&quot;</code> 之类的请求将不会与 <code>@GetMapping(&quot;/projects/spring-boot&quot;)</code> 映射相匹配。</p>
<ul>
<li>为什么？不用后缀模式匹配不是反而能匹配到吗？</li>
</ul>
<p>背景：</p>
<p>过去，此功能主要用于未发送正确的“ Accept”请求 Headers 的 HTTP Client 端。我们需要确保将正确的 <code>Content Type</code> 发送给 Client 端。如今，内容协商(Content Negotiation)已变得更加可靠。</p>
<p><strong>注：</strong> 后缀模式匹配已被废弃，并将在未来的版本中被删除。如果你了解这些注意事项，并且仍然希望你的应用程序使用后缀模式匹配，则需要进行以下配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-path-extension=true</span><br><span class="line">spring.mvc.pathmatch.use-suffix-pattern=true</span><br></pre></td></tr></table></figure>


<h4 id="7-1-8-ConfigurableWebBindingInitializer"><a href="#7-1-8-ConfigurableWebBindingInitializer" class="headerlink" title="7.1.8. ConfigurableWebBindingInitializer"></a>7.1.8. ConfigurableWebBindingInitializer</h4><h4 id="7-1-9-模板引擎"><a href="#7-1-9-模板引擎" class="headerlink" title="7.1.9. 模板引擎"></a>7.1.9. 模板引擎</h4><p>作用：</p>
<ul>
<li>提供动态 HTML 内容</li>
</ul>
<p>Spring Boot包括对以下模板引擎的自动配置支持。</p>
<ul>
<li>FreeMarker</li>
<li>Groovy</li>
<li><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/">Thymeleaf</a></li>
<li>Mustache</li>
</ul>
<blockquote>
<p>当你使用这些默认配置的模板引擎之一时，你的模板会自动从 <code>src/main/resources/templates</code> 中获取。</p>
</blockquote>
<p>模板引擎具体该怎么用，请参考各个模板引擎的官网</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据您运行应用程序的方式，IntelliJ IDEA 对 Classpath 的排序方式不同。与使用 Maven 或 Gradle 或从打包的 jar 运行应用程序时，从 IDE 的 Main 方法运行应用程序的顺序会有所不同。这可能会导致 Spring Boot 无法在 Classpath 上找到模板。如果遇到此问题，则可以在 IDE 中重新排序 Classpath，以首先放置模块的类和资源。另外，您可以配置模板前缀以搜索 Classpath 上的每个templates目录，如下所示：classpath*:/templates/。</span><br></pre></td></tr></table></figure>


<h4 id="7-1-12-跨域支持-（CORS-支持）"><a href="#7-1-12-跨域支持-（CORS-支持）" class="headerlink" title="7.1.12. 跨域支持 （CORS 支持）"></a>7.1.12. 跨域支持 （CORS 支持）</h4><p>Cross-origin resource sharing (CORS) 是一个由大多数浏览器实现的 W3C 规范，它让你以灵活的方式指定什么样的跨域请求是被授权的。而不是使用一些不太安全、不太强大的方法，如 IFRAME 或 JSONP。</p>
<p>从 4.2 版本开始，Spring MVC 支持 CORS。</p>
<h3 id="7-2-Spring-WebFlux框架"><a href="#7-2-Spring-WebFlux框架" class="headerlink" title="7.2 Spring WebFlux框架"></a>7.2 Spring WebFlux框架</h3><p>详细内容，参考官方文档 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.spring-webflux">The “Spring WebFlux Framework”</a></p>
<p>Spring WebFlux 是 Spring Framework 5.0 中引入的新的响应式 Web 框架。</p>
<p>与 Spring MVC 不同，它不需要 Servlet API，是完全异步和非阻塞的，并通过 Reactor 项目实现了 Reactive Streams 规范。</p>
<p>在你的应用程序中同时添加 <code>spring-boot-starter-web</code> 和 <code>spring-boot-starter-webflux</code> 模块，Spring Boot 会自动配置 <code>Spring MVC</code>，而不是 WebFlux。</p>
<h3 id="7-4-嵌入式-Servlet-容器支持"><a href="#7-4-嵌入式-Servlet-容器支持" class="headerlink" title="7.4. 嵌入式 Servlet 容器支持"></a>7.4. 嵌入式 Servlet 容器支持</h3><p>更多内容参考官方文档 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.developing-web-applications.embedded-container">Embedded Servlet Container Support</a></p>
<p>Spring Boot 包含对嵌入式 Tomcat，Jetty 和 Undertow 服务器的支持。</p>
<p>使用适当的 “Starter”来获得一个完全配置的实例。</p>
<p>默认情况下，嵌入式服务器在端口 <code>8080</code> 上监听 HTTP 请求。</p>
<h3 id="7-5-嵌入式Reactive务器支持"><a href="#7-5-嵌入式Reactive务器支持" class="headerlink" title="7.5. 嵌入式Reactive务器支持"></a>7.5. 嵌入式Reactive务器支持</h3><p>Spring Boot 对以下嵌入式反应式Web服务器的支持。</p>
<ul>
<li>Reactor Netty</li>
<li>Tomcat</li>
<li>Jetty</li>
<li>Undertow</li>
</ul>
<h2 id="11-使用SQL数据库"><a href="#11-使用SQL数据库" class="headerlink" title="11. 使用SQL数据库"></a>11. 使用SQL数据库</h2><h3 id="11-1-配置数据源"><a href="#11-1-配置数据源" class="headerlink" title="11.1. 配置数据源"></a>11.1. 配置数据源</h3><p>详细内容，参考官方文档 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.3/reference/html/features.html#features.sql.datasource">Configure a DataSource</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-access">Data Access</a><br><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-data-access.html#howto-configure-a-datasource">2.1.1.RELEASE 有汉化版本</a></p>
<h3 id="11-2-使用JdbcTemplate"><a href="#11-2-使用JdbcTemplate" class="headerlink" title="11.2. 使用JdbcTemplate"></a>11.2. 使用JdbcTemplate</h3><h3 id="11-3-JPA-和-Spring-Data-JPA"><a href="#11-3-JPA-和-Spring-Data-JPA" class="headerlink" title="11.3. JPA 和 Spring Data JPA"></a>11.3. JPA 和 Spring Data JPA</h3><h3 id="11-4-Spring-Data-JDBC"><a href="#11-4-Spring-Data-JDBC" class="headerlink" title="11.4. Spring Data JDBC"></a>11.4. Spring Data JDBC</h3><h3 id="11-5-使用H2的Web-Console"><a href="#11-5-使用H2的Web-Console" class="headerlink" title="11.5. 使用H2的Web Console"></a>11.5. 使用H2的Web Console</h3><h3 id="11-6-使用-jOOQ"><a href="#11-6-使用-jOOQ" class="headerlink" title="11.6. 使用 jOOQ"></a>11.6. 使用 jOOQ</h3><h3 id="11-7-使用-R2DBC"><a href="#11-7-使用-R2DBC" class="headerlink" title="11.7. 使用 R2DBC"></a>11.7. 使用 R2DBC</h3> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://ligongzhao.github.io/%E6%89%8B%E5%8A%A8%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B.html" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95.html" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            学习过程中额外知识点记录
          
        </div>
      </a>
    
    
      <a href="/WindowsServer%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98.html" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">WindowsServer使用遇到问题</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> ligongzhao
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="听潮亭"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>